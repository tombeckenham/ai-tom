import type { ResolvedProviderConfig, ModelInfo } from '../types'

/** Default OpenAI OpenAPI spec URL (official, from Stainless) */
const OPENAI_SPEC_URL =
  'https://app.stainless.com/api/spec/documented/openai/openapi.documented.yml'

/** Default OpenAI models endpoint */
const OPENAI_MODELS_ENDPOINT = 'https://api.openai.com/v1/models'

export function resolveOpenAIConfig(
  overrides?: Partial<ResolvedProviderConfig>,
): ResolvedProviderConfig {
  return {
    name: 'openai',
    specUrl: overrides?.specUrl ?? OPENAI_SPEC_URL,
    modelsEndpoint: overrides?.modelsEndpoint ?? OPENAI_MODELS_ENDPOINT,
    apiKeyEnvVar: overrides?.apiKeyEnvVar ?? 'OPENAI_API_KEY',
    apiKey: overrides?.apiKey,
  }
}

/**
 * Fetch model list from OpenAI /v1/models endpoint.
 * Returns the model IDs sorted alphabetically.
 */
export async function fetchOpenAIModels(
  config: ResolvedProviderConfig,
): Promise<Array<ModelInfo>> {
  const apiKey =
    config.apiKey ?? process.env[config.apiKeyEnvVar]

  if (!apiKey) {
    console.warn(
      `[ai-vite] No API key found for OpenAI (checked env: ${config.apiKeyEnvVar}). Skipping model fetch.`,
    )
    return []
  }

  if (!config.modelsEndpoint) {
    return []
  }

  const response = await fetch(config.modelsEndpoint, {
    headers: {
      Authorization: `Bearer ${apiKey}`,
    },
  })

  if (!response.ok) {
    throw new Error(
      `Failed to fetch OpenAI models: ${response.status} ${response.statusText}`,
    )
  }

  const data = (await response.json()) as { data: Array<ModelInfo> }
  return data.data.sort((a, b) => a.id.localeCompare(b.id))
}

/**
 * Filter models to only include chat-capable models.
 * OpenAI's /v1/models endpoint returns ALL models (embeddings, tts, whisper, etc.)
 * We filter to only those relevant for chat/text generation.
 */
export function filterChatModels(models: Array<ModelInfo>): Array<ModelInfo> {
  const chatPrefixes = [
    'gpt-',
    'chatgpt-',
    'o1',
    'o3',
    'o4',
    'codex-',
  ]

  const excludePrefixes = [
    'gpt-4o-realtime',
    'gpt-4o-mini-realtime',
    'gpt-4o-transcribe',
    'gpt-4o-mini-transcribe',
    'gpt-4o-tts',
    'gpt-4o-mini-tts',
    'gpt-image-',
  ]

  return models.filter((m) => {
    const id = m.id.toLowerCase()
    const isChatModel = chatPrefixes.some((prefix) => id.startsWith(prefix))
    const isExcluded = excludePrefixes.some((prefix) => id.startsWith(prefix))
    return isChatModel && !isExcluded
  })
}

/**
 * Filter models to image generation models.
 */
export function filterImageModels(models: Array<ModelInfo>): Array<ModelInfo> {
  const imagePrefixes = ['gpt-image-', 'dall-e-']
  return models.filter((m) =>
    imagePrefixes.some((prefix) => m.id.toLowerCase().startsWith(prefix)),
  )
}

/**
 * Generate TypeScript source for model name union types from the model list.
 */
export function generateModelUnionSource(
  chatModels: Array<ModelInfo>,
  imageModels: Array<ModelInfo>,
): string {
  const lines: Array<string> = []

  lines.push('// Auto-generated by @tanstack/ai-vite')
  lines.push('// Do not edit manually')
  lines.push('')
  lines.push('/**')
  lines.push(' * All available OpenAI chat/text model IDs.')
  lines.push(` * Generated from /v1/models endpoint at ${new Date().toISOString().split('T')[0]}`)
  lines.push(' */')

  if (chatModels.length > 0) {
    lines.push('export const OPENAI_CHAT_MODELS = [')
    for (const model of chatModels) {
      lines.push(`  '${model.id}',`)
    }
    lines.push('] as const')
    lines.push('')
    lines.push('export type OpenAIChatModel = (typeof OPENAI_CHAT_MODELS)[number]')
  } else {
    lines.push('export const OPENAI_CHAT_MODELS = [] as const')
    lines.push('export type OpenAIChatModel = string')
  }

  lines.push('')

  if (imageModels.length > 0) {
    lines.push('/**')
    lines.push(' * All available OpenAI image generation model IDs.')
    lines.push(' */')
    lines.push('export const OPENAI_IMAGE_MODELS = [')
    for (const model of imageModels) {
      lines.push(`  '${model.id}',`)
    }
    lines.push('] as const')
    lines.push('')
    lines.push(
      'export type OpenAIImageModel = (typeof OPENAI_IMAGE_MODELS)[number]',
    )
  }

  lines.push('')

  return lines.join('\n')
}
