import * as path from 'node:path'
import { downloadSpec, runHeyApiCodegen, writeGeneratedFile } from './codegen'
import {
  fetchOpenAIModels,
  filterChatModels,
  filterImageModels,
  generateModelUnionSource,
  resolveOpenAIConfig,
} from './providers/openai'
import type { Plugin } from 'vite'
import type {
  ProviderEntry,
  ProviderName,
  ResolvedProviderConfig,
  TanStackAIPluginOptions,
} from './types'

export type {
  TanStackAIPluginOptions,
  ProviderConfig,
  ProviderName,
  ProviderEntry,
} from './types'

/**
 * Resolve a provider name or entry into a full config.
 */
function resolveProvider(
  provider: ProviderName | ProviderEntry,
): ResolvedProviderConfig {
  const name = typeof provider === 'string' ? provider : provider.name
  const overrides = typeof provider === 'string' ? undefined : provider.config

  switch (name) {
    case 'openai':
      return resolveOpenAIConfig(overrides as any)
    default:
      throw new Error(
        `[ai-vite] Unsupported provider: "${name}". Currently supported: openai`,
      )
  }
}

/**
 * Run the full codegen pipeline for a single provider.
 */
async function generateForProvider(
  config: ResolvedProviderConfig,
  outputDir: string,
  cacheDir: string,
): Promise<void> {
  const providerOutputDir = path.join(outputDir, config.name)

  // Step 1: Download/cache the OpenAPI spec
  const specPath = await downloadSpec(config, cacheDir)

  // Step 2: Run hey-api codegen (generates types.gen.ts, zod.gen.ts, etc.)
  await runHeyApiCodegen({
    specPath,
    outputDir: providerOutputDir,
    providerName: config.name,
  })

  // Step 3: Fetch models from API and generate model unions
  if (config.name === 'openai') {
    const allModels = await fetchOpenAIModels(config)
    if (allModels.length > 0) {
      const chatModels = filterChatModels(allModels)
      const imageModels = filterImageModels(allModels)
      const modelSource = generateModelUnionSource(chatModels, imageModels)
      writeGeneratedFile(
        path.join(providerOutputDir, 'models.gen.ts'),
        modelSource,
      )
      console.log(
        `[ai-vite] Generated model unions: ${chatModels.length} chat models, ${imageModels.length} image models`,
      )
    }
  }
}

/**
 * Run codegen for all configured providers.
 */
export async function generate(
  options: TanStackAIPluginOptions,
  projectRoot?: string,
): Promise<void> {
  const root = projectRoot ?? process.cwd()
  const outputDir = path.resolve(root, options.outputDir ?? 'src/generated')
  const cacheDir = path.resolve(root, options.cacheDir ?? 'node_modules/.cache/ai-vite')

  console.log(`[ai-vite] Starting codegen...`)
  console.log(`[ai-vite] Output: ${outputDir}`)

  for (const provider of options.providers) {
    const config = resolveProvider(provider)
    await generateForProvider(config, outputDir, cacheDir)
  }

  // Generate index.ts re-exports
  const indexLines = [
    '// Auto-generated by @tanstack/ai-vite',
    '// Do not edit manually',
    '',
  ]

  for (const provider of options.providers) {
    const name = typeof provider === 'string' ? provider : provider.name
    indexLines.push(`export * from './${name}/models.gen'`)
  }

  indexLines.push('')
  writeGeneratedFile(path.join(outputDir, 'index.ts'), indexLines.join('\n'))

  console.log(`[ai-vite] Codegen complete!`)
}

/**
 * Vite plugin for generating AI model types from OpenAPI specs.
 *
 * @example
 * ```ts
 * import { tanstackAI } from '@tanstack/ai-vite'
 *
 * export default defineConfig({
 *   plugins: [
 *     tanstackAI({
 *       providers: ['openai'],
 *     })
 *   ]
 * })
 * ```
 */
export function tanstackAI(options: TanStackAIPluginOptions): Plugin {
  let projectRoot: string

  return {
    name: 'tanstack-ai',
    configResolved(config) {
      projectRoot = config.root
    },
    async buildStart() {
      if (options.runOnDevStart !== false) {
        try {
          await generate(options, projectRoot)
        } catch (err) {
          console.error('[ai-vite] Codegen failed:', err)
          // Don't fail the build - types may already be generated
        }
      }
    },
  }
}
