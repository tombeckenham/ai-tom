// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: `${string}://${string}` | (string & {});
};

export type File = {
    url: string;
    content_type?: string;
    file_name?: string;
    file_size?: number;
};

export type QueueStatus = {
    status: 'IN_PROGRESS' | 'COMPLETED' | 'FAILED';
    response_url?: string;
};

/**
 * VoiceChangerRequest
 */
export type ElevenlabsVoiceChangerInput = {
    /**
     * Voice
     *
     * The voice to use for speech generation
     */
    voice?: string;
    /**
     * Audio Url
     *
     * The input audio file
     */
    audio_url: string;
    /**
     * Seed
     *
     * Random seed for reproducibility.
     */
    seed?: number;
    /**
     * Output Format
     *
     * Output format of the generated audio. Formatted as codec_sample_rate_bitrate.
     */
    output_format?: 'mp3_22050_32' | 'mp3_44100_32' | 'mp3_44100_64' | 'mp3_44100_96' | 'mp3_44100_128' | 'mp3_44100_192' | 'pcm_8000' | 'pcm_16000' | 'pcm_22050' | 'pcm_24000' | 'pcm_44100' | 'pcm_48000' | 'ulaw_8000' | 'alaw_8000' | 'opus_48000_32' | 'opus_48000_64' | 'opus_48000_96' | 'opus_48000_128' | 'opus_48000_192';
    /**
     * Remove Background Noise
     *
     * If set, will remove the background noise from your audio input using our audio isolation model.
     */
    remove_background_noise?: boolean;
};

/**
 * VoiceChangerOutput
 */
export type ElevenlabsVoiceChangerOutput = {
    /**
     * Seed
     *
     * Random seed for reproducibility.
     */
    seed: number;
    audio: FalAiElevenlabsVoiceChangerFile;
};

/**
 * File
 */
export type FalAiElevenlabsVoiceChangerFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
};

/**
 * NovaSRInput
 */
export type NovaSrInput = {
    /**
     * Sync Mode
     *
     * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
     */
    sync_mode?: boolean;
    /**
     * Bitrate
     *
     * The bitrate of the output audio.
     */
    bitrate?: string;
    /**
     * Audio URL
     *
     * The URL of the audio file to enhance.
     */
    audio_url: string;
    /**
     * Audio Format
     *
     * The format for the output audio.
     */
    audio_format?: 'mp3' | 'aac' | 'm4a' | 'ogg' | 'opus' | 'flac' | 'wav';
};

/**
 * NovaSROutput
 */
export type NovaSrOutput = {
    /**
     * Timings
     *
     * Timings for each step in the pipeline.
     */
    timings: NovaSrTimings;
    /**
     * Audio
     *
     * The enhanced audio file.
     */
    audio: AudioFile;
};

/**
 * NovaSRTimings
 */
export type NovaSrTimings = {
    /**
     * Postprocess
     *
     * Time taken to postprocess the audio in seconds.
     */
    postprocess: number;
    /**
     * Inference
     *
     * Time taken to run the inference in seconds.
     */
    inference: number;
    /**
     * Preprocess
     *
     * Time taken to preprocess the audio in seconds.
     */
    preprocess: number;
};

/**
 * AudioFile
 */
export type AudioFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * Duration
     *
     * The duration of the audio
     */
    duration?: number;
    /**
     * Bitrate
     *
     * The bitrate of the audio
     */
    bitrate?: string;
    /**
     * Channels
     *
     * The number of channels in the audio
     */
    channels?: number;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Sample Rate
     *
     * The sample rate of the audio
     */
    sample_rate?: number;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * DeepFilterNet3Input
 */
export type Deepfilternet3Input = {
    /**
     * Sync Mode
     *
     * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
     */
    sync_mode?: boolean;
    /**
     * Audio Format
     *
     * The format for the output audio.
     */
    audio_format?: 'mp3' | 'aac' | 'm4a' | 'ogg' | 'opus' | 'flac' | 'wav';
    /**
     * Audio URL
     *
     * The URL of the audio to enhance.
     */
    audio_url: string;
    /**
     * Bitrate
     *
     * The bitrate of the output audio.
     */
    bitrate?: string;
};

/**
 * DeepFilterNet3Output
 */
export type Deepfilternet3Output = {
    /**
     * Timings
     *
     * Timings for each step in the pipeline.
     */
    timings: DeepFilterNetTimings;
    /**
     * Audio File
     *
     * The audio file that was enhanced.
     */
    audio_file: FalAiDeepfilternet3AudioFile;
};

/**
 * DeepFilterNetTimings
 */
export type DeepFilterNetTimings = {
    /**
     * Postprocess
     *
     * Postprocessing time.
     */
    postprocess: number;
    /**
     * Inference
     *
     * Inference time.
     */
    inference: number;
    /**
     * Preprocess
     *
     * Preprocessing time.
     */
    preprocess: number;
};

/**
 * AudioFile
 */
export type FalAiDeepfilternet3AudioFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * Duration
     *
     * The duration of the audio
     */
    duration?: number;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
    /**
     * Bitrate
     *
     * The bitrate of the audio
     */
    bitrate?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Sample Rate
     *
     * The sample rate of the audio
     */
    sample_rate?: number;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Channels
     *
     * The number of channels in the audio
     */
    channels?: number;
};

/**
 * SAMAudioInput
 *
 * Input for text-based audio separation.
 */
export type SamAudioSeparateInput = {
    /**
     * Prompt
     *
     * Text prompt describing the sound to isolate.
     */
    prompt: string;
    /**
     * Acceleration
     *
     * The acceleration level to use.
     */
    acceleration?: 'fast' | 'balanced' | 'quality';
    /**
     * Audio Url
     *
     * URL of the audio file to process (WAV, MP3, FLAC supported)
     */
    audio_url: string;
    /**
     * Predict Spans
     *
     * Automatically predict temporal spans where the target sound occurs.
     */
    predict_spans?: boolean;
    /**
     * Output Format
     *
     * Output audio format.
     */
    output_format?: 'wav' | 'mp3';
    /**
     * Reranking Candidates
     *
     * Number of candidates to generate and rank. Higher improves quality but increases latency and cost.
     */
    reranking_candidates?: number;
};

/**
 * SAMAudioSeparateOutput
 *
 * Output for text-based audio separation.
 */
export type SamAudioSeparateOutput = {
    /**
     * Target
     *
     * The isolated target sound.
     */
    target: FalAiSamAudioSeparateFile;
    /**
     * Duration
     *
     * Duration of the output audio in seconds.
     */
    duration: number;
    /**
     * Sample Rate
     *
     * Sample rate of the output audio in Hz.
     */
    sample_rate?: number;
    /**
     * Residual
     *
     * Everything else in the audio.
     */
    residual: FalAiSamAudioSeparateFile;
};

/**
 * File
 */
export type FalAiSamAudioSeparateFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * SAMAudioSpanInput
 *
 * Input for temporal span-based audio separation.
 */
export type SamAudioSpanSeparateInput = {
    /**
     * Prompt
     *
     * Text prompt describing the sound to isolate. Optional but recommended - helps the model identify what type of sound to extract from the span.
     */
    prompt?: string;
    /**
     * Acceleration
     *
     * The acceleration level to use.
     */
    acceleration?: 'fast' | 'balanced' | 'quality';
    /**
     * Spans
     *
     * Time spans where the target sound occurs which should be isolated.
     */
    spans: Array<AudioTimeSpan>;
    /**
     * Output Format
     *
     * Output audio format.
     */
    output_format?: 'wav' | 'mp3';
    /**
     * Trim To Span
     *
     * Trim output audio to only include the specified span time range. If False, returns the full audio length with the target sound isolated throughout.
     */
    trim_to_span?: boolean;
    /**
     * Audio Url
     *
     * URL of the audio file to process.
     */
    audio_url: string;
    /**
     * Reranking Candidates
     *
     * Number of candidates to generate and rank. Higher improves quality but increases latency and cost. Requires text prompt; ignored for span-only separation.
     */
    reranking_candidates?: number;
};

/**
 * SAMAudioSpanSeparateOutput
 *
 * Output for span-based audio separation.
 */
export type SamAudioSpanSeparateOutput = {
    /**
     * Target
     *
     * The isolated target sound.
     */
    target: FalAiSamAudioSpanSeparateFile;
    /**
     * Duration
     *
     * Duration of the output audio in seconds.
     */
    duration: number;
    /**
     * Sample Rate
     *
     * Sample rate of the output audio in Hz.
     */
    sample_rate?: number;
    /**
     * Residual
     *
     * Everything else in the audio.
     */
    residual: FalAiSamAudioSpanSeparateFile;
};

/**
 * AudioTimeSpan
 *
 * A time span indicating where the target sound occurs.
 */
export type AudioTimeSpan = {
    /**
     * End
     *
     * End time of the span in seconds
     */
    end: number;
    /**
     * Start
     *
     * Start time of the span in seconds
     */
    start: number;
    /**
     * Include
     *
     * Whether to include (True) or exclude (False) sounds in this span
     */
    include?: boolean;
};

/**
 * File
 */
export type FalAiSamAudioSpanSeparateFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * MergeAudiosInput
 */
export type FfmpegApiMergeAudiosInput = {
    /**
     * Audio Urls
     *
     * List of audio URLs to merge in order. The 0th stream of the audio will be considered as the merge candidate.
     */
    audio_urls: Array<string>;
    /**
     * Output Format
     *
     * Output format of the combined audio. If not used, will be determined automatically using FFMPEG. Formatted as codec_sample_rate_bitrate.
     */
    output_format?: 'mp3_22050_32' | 'mp3_44100_32' | 'mp3_44100_64' | 'mp3_44100_96' | 'mp3_44100_128' | 'mp3_44100_192' | 'pcm_8000' | 'pcm_16000' | 'pcm_22050' | 'pcm_24000' | 'pcm_44100' | 'pcm_48000' | 'ulaw_8000' | 'alaw_8000' | 'opus_48000_32' | 'opus_48000_64' | 'opus_48000_96' | 'opus_48000_128' | 'opus_48000_192' | unknown;
};

/**
 * MergeAudiosOutput
 */
export type FfmpegApiMergeAudiosOutput = {
    audio: FalAiFfmpegApiMergeAudiosFile;
};

/**
 * File
 */
export type FalAiFfmpegApiMergeAudiosFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
};

/**
 * CreateVoiceInput
 *
 * Request model for creating a custom voice.
 */
export type KlingVideoCreateVoiceInput = {
    /**
     * Voice Url
     *
     * URL of the voice audio file. Supports .mp3/.wav audio or .mp4/.mov video. Duration must be 5-30 seconds with clean, single-voice audio.
     */
    voice_url: string;
};

/**
 * CreateVoiceOutput
 *
 * Response model for creating a custom voice.
 */
export type KlingVideoCreateVoiceOutput = {
    /**
     * Voice Id
     *
     * Unique identifier for the created voice
     */
    voice_id: string;
};

/**
 * DemucsInput
 */
export type DemucsInput = {
    /**
     * Segment Length
     *
     * Length in seconds of each segment for processing. Smaller values use less memory but may reduce quality. Default is model-specific.
     */
    segment_length?: number | unknown;
    /**
     * Output Format
     *
     * Output audio format for the separated stems
     */
    output_format?: 'wav' | 'mp3';
    /**
     * Stems
     *
     * Specific stems to extract. If None, extracts all available stems. Available stems depend on model: vocals, drums, bass, other, guitar, piano (for 6s model)
     */
    stems?: Array<'vocals' | 'drums' | 'bass' | 'other' | 'guitar' | 'piano'> | unknown;
    /**
     * Overlap
     *
     * Overlap between segments (0.0 to 1.0). Higher values may improve quality but increase processing time.
     */
    overlap?: number;
    /**
     * Model
     *
     * Demucs model to use for separation
     */
    model?: 'htdemucs' | 'htdemucs_ft' | 'htdemucs_6s' | 'hdemucs_mmi' | 'mdx' | 'mdx_extra' | 'mdx_q' | 'mdx_extra_q';
    /**
     * Audio Url
     *
     * URL of the audio file to separate into stems
     */
    audio_url: string;
    /**
     * Shifts
     *
     * Number of random shifts for equivariant stabilization. Higher values improve quality but increase processing time.
     */
    shifts?: number;
};

/**
 * DemucsOutput
 */
export type DemucsOutput = {
    /**
     * Separated vocals audio file
     */
    vocals?: FalAiDemucsFile | unknown;
    /**
     * Separated guitar audio file (only available for 6s models)
     */
    guitar?: FalAiDemucsFile | unknown;
    /**
     * Separated bass audio file
     */
    bass?: FalAiDemucsFile | unknown;
    /**
     * Separated piano audio file (only available for 6s models)
     */
    piano?: FalAiDemucsFile | unknown;
    /**
     * Separated other instruments audio file
     */
    other?: FalAiDemucsFile | unknown;
    /**
     * Separated drums audio file
     */
    drums?: FalAiDemucsFile | unknown;
};

/**
 * File
 */
export type FalAiDemucsFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
};

/**
 * AudioUnderstandingInput
 */
export type AudioUnderstandingInput = {
    /**
     * Prompt
     *
     * The question or prompt about the audio content.
     */
    prompt: string;
    /**
     * Detailed Analysis
     *
     * Whether to request a more detailed analysis of the audio
     */
    detailed_analysis?: boolean;
    /**
     * Audio Url
     *
     * URL of the audio file to analyze
     */
    audio_url: string;
};

/**
 * AudioUnderstandingOutput
 */
export type AudioUnderstandingOutput = {
    /**
     * Output
     *
     * The analysis of the audio content based on the prompt
     */
    output: string;
};

/**
 * AudioToAudioInput
 */
export type StableAudio25AudioToAudioInput = {
    /**
     * Prompt
     *
     * The prompt to guide the audio generation
     */
    prompt: string;
    /**
     * Strength
     *
     * Sometimes referred to as denoising, this parameter controls how much influence the `audio_url` parameter has on the generated audio. A value of 0 would yield audio that is identical to the input. A value of 1 would be as if you passed in no audio at all.
     */
    strength?: number;
    /**
     * Sync Mode
     *
     * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
     */
    sync_mode?: boolean;
    /**
     * Audio Url
     *
     * The audio clip to transform
     */
    audio_url: string;
    /**
     * Num Inference Steps
     *
     * The number of steps to denoise the audio for
     */
    num_inference_steps?: number;
    /**
     * Guidance Scale
     *
     * How strictly the diffusion process adheres to the prompt text (higher values make your audio closer to your prompt).
     */
    guidance_scale?: number;
    /**
     * Seed
     */
    seed?: number;
    /**
     * Total Seconds
     *
     * The duration of the audio clip to generate. If not provided, it will be set to the duration of the input audio.
     */
    total_seconds?: number;
};

/**
 * AudioToAudioOutput
 */
export type StableAudio25AudioToAudioOutput = {
    /**
     * Seed
     *
     * The random seed used for generation
     */
    seed: number;
    /**
     * Audio
     *
     * The generated audio clip
     */
    audio: FalAiStableAudio25AudioToAudioFile;
};

/**
 * File
 */
export type FalAiStableAudio25AudioToAudioFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * InpaintInput
 */
export type StableAudio25InpaintInput = {
    /**
     * Prompt
     *
     * The prompt to guide the audio generation
     */
    prompt: string;
    /**
     * Guidance Scale
     *
     * How strictly the diffusion process adheres to the prompt text (higher values make your audio closer to your prompt).
     */
    guidance_scale?: number;
    /**
     * Mask End
     *
     * The end point of the audio mask
     */
    mask_end?: number;
    /**
     * Sync Mode
     *
     * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
     */
    sync_mode?: boolean;
    /**
     * Audio Url
     *
     * The audio clip to inpaint
     */
    audio_url: string;
    /**
     * Seed
     */
    seed?: number;
    /**
     * Seconds Total
     *
     * The duration of the audio clip to generate. If not provided, it will be set to the duration of the input audio.
     */
    seconds_total?: number;
    /**
     * Num Inference Steps
     *
     * The number of steps to denoise the audio for
     */
    num_inference_steps?: number;
    /**
     * Mask Start
     *
     * The start point of the audio mask
     */
    mask_start?: number;
};

/**
 * InpaintOutput
 */
export type StableAudio25InpaintOutput = {
    /**
     * Seed
     *
     * The random seed used for generation
     */
    seed: number;
    /**
     * Audio
     *
     * The generated audio clip
     */
    audio: FalAiStableAudio25InpaintFile;
};

/**
 * File
 */
export type FalAiStableAudio25InpaintFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * ExtendInput
 */
export type V2ExtendInput = {
    /**
     * Prompt
     *
     * A description of the track you want to generate. This prompt will be used to automatically generate the tags and lyrics unless you manually set them. For example, if you set prompt and tags, then the prompt will be used to generate only the lyrics.
     */
    prompt?: string | unknown;
    /**
     * Lyrics Prompt
     *
     * The lyrics sung in the generated song. An empty string will generate an instrumental track.
     */
    lyrics_prompt?: string | unknown;
    /**
     * Tags
     *
     * Tags/styles of the music to generate. You can view a list of all available tags at https://sonauto.ai/tag-explorer.
     */
    tags?: Array<string> | unknown;
    /**
     * Prompt Strength
     *
     * Controls how strongly your prompt influences the output. Greater values adhere more to the prompt but sound less natural. (This is CFG.)
     */
    prompt_strength?: number;
    /**
     * Output Bit Rate
     *
     * The bit rate to use for mp3 and m4a formats. Not available for other formats.
     */
    output_bit_rate?: 128 | 192 | 256 | 320 | unknown;
    /**
     * Num Songs
     *
     * Generating 2 songs costs 1.5x the price of generating 1 song. Also, note that using the same seed may not result in identical songs if the number of songs generated is changed.
     */
    num_songs?: number;
    /**
     * Output Format
     */
    output_format?: 'flac' | 'mp3' | 'wav' | 'ogg' | 'm4a';
    /**
     * Side
     *
     * Add more to the beginning (left) or end (right) of the song
     */
    side: 'left' | 'right';
    /**
     * Balance Strength
     *
     * Greater means more natural vocals. Lower means sharper instrumentals. We recommend 0.7.
     */
    balance_strength?: number;
    /**
     * Crop Duration
     *
     * Duration in seconds to crop from the selected side before extending from that side.
     */
    crop_duration?: number;
    /**
     * Audio Url
     *
     * The URL of the audio file to alter. Must be a valid publicly accessible URL.
     */
    audio_url: string;
    /**
     * Seed
     *
     * The seed to use for generation. Will pick a random seed if not provided. Repeating a request with identical parameters (must use lyrics and tags, not prompt) and the same seed will generate the same song.
     */
    seed?: number | unknown;
    /**
     * Extend Duration
     *
     * Duration in seconds to extend the song. If not provided, will attempt to automatically determine.
     */
    extend_duration?: number | unknown;
};

/**
 * ExtendOutput
 */
export type V2ExtendOutput = {
    /**
     * Tags
     *
     * The style tags used for generation.
     */
    tags?: Array<string> | unknown;
    /**
     * Seed
     *
     * The seed used for generation. This can be used to generate an identical song by passing the same parameters with this seed in a future request.
     */
    seed: number;
    /**
     * Extend Duration
     *
     * The duration in seconds that the song was extended by.
     */
    extend_duration: number;
    /**
     * Audio
     *
     * The generated audio files.
     */
    audio: Array<SonautoV2ExtendFile>;
    /**
     * Lyrics
     *
     * The lyrics used for generation.
     */
    lyrics?: string | unknown;
};

/**
 * File
 */
export type SonautoV2ExtendFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
};

/**
 * ACEStepAudioOutpaintRequest
 */
export type AceStepAudioOutpaintInput = {
    /**
     * Number Of Steps
     *
     * Number of steps to generate the audio.
     */
    number_of_steps?: number;
    /**
     * Tags
     *
     * Comma-separated list of genre tags to control the style of the generated audio.
     */
    tags: string;
    /**
     * Minimum Guidance Scale
     *
     * Minimum guidance scale for the generation after the decay.
     */
    minimum_guidance_scale?: number;
    /**
     * Extend After Duration
     *
     * Duration in seconds to extend the audio from the end.
     */
    extend_after_duration?: number;
    /**
     * Lyrics
     *
     * Lyrics to be sung in the audio. If not provided or if [inst] or [instrumental] is the content of this field, no lyrics will be sung. Use control structures like [verse], [chorus] and [bridge] to control the structure of the song.
     */
    lyrics?: string;
    /**
     * Tag Guidance Scale
     *
     * Tag guidance scale for the generation.
     */
    tag_guidance_scale?: number;
    /**
     * Scheduler
     *
     * Scheduler to use for the generation process.
     */
    scheduler?: 'euler' | 'heun';
    /**
     * Extend Before Duration
     *
     * Duration in seconds to extend the audio from the start.
     */
    extend_before_duration?: number;
    /**
     * Guidance Type
     *
     * Type of CFG to use for the generation process.
     */
    guidance_type?: 'cfg' | 'apg' | 'cfg_star';
    /**
     * Guidance Scale
     *
     * Guidance scale for the generation.
     */
    guidance_scale?: number;
    /**
     * Lyric Guidance Scale
     *
     * Lyric guidance scale for the generation.
     */
    lyric_guidance_scale?: number;
    /**
     * Guidance Interval
     *
     * Guidance interval for the generation. 0.5 means only apply guidance in the middle steps (0.25 * infer_steps to 0.75 * infer_steps)
     */
    guidance_interval?: number;
    /**
     * Guidance Interval Decay
     *
     * Guidance interval decay for the generation. Guidance scale will decay from guidance_scale to min_guidance_scale in the interval. 0.0 means no decay.
     */
    guidance_interval_decay?: number;
    /**
     * Audio Url
     *
     * URL of the audio file to be outpainted.
     */
    audio_url: string;
    /**
     * Seed
     *
     * Random seed for reproducibility. If not provided, a random seed will be used.
     */
    seed?: number;
    /**
     * Granularity Scale
     *
     * Granularity scale for the generation process. Higher values can reduce artifacts.
     */
    granularity_scale?: number;
};

/**
 * ACEStepResponse
 */
export type AceStepAudioOutpaintOutput = {
    /**
     * Tags
     *
     * The genre tags used in the generation process.
     */
    tags: string;
    /**
     * Lyrics
     *
     * The lyrics used in the generation process.
     */
    lyrics: string;
    /**
     * Seed
     *
     * The random seed used for the generation process.
     */
    seed: number;
    /**
     * Audio
     *
     * The generated audio file.
     */
    audio: FalAiAceStepAudioOutpaintFile;
};

/**
 * File
 */
export type FalAiAceStepAudioOutpaintFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * ACEStepAudioInpaintRequest
 */
export type AceStepAudioInpaintInput = {
    /**
     * Number Of Steps
     *
     * Number of steps to generate the audio.
     */
    number_of_steps?: number;
    /**
     * Start Time
     *
     * start time in seconds for the inpainting process.
     */
    start_time?: number;
    /**
     * Tags
     *
     * Comma-separated list of genre tags to control the style of the generated audio.
     */
    tags: string;
    /**
     * Minimum Guidance Scale
     *
     * Minimum guidance scale for the generation after the decay.
     */
    minimum_guidance_scale?: number;
    /**
     * Lyrics
     *
     * Lyrics to be sung in the audio. If not provided or if [inst] or [instrumental] is the content of this field, no lyrics will be sung. Use control structures like [verse], [chorus] and [bridge] to control the structure of the song.
     */
    lyrics?: string;
    /**
     * End Time Relative To
     *
     * Whether the end time is relative to the start or end of the audio.
     */
    end_time_relative_to?: 'start' | 'end';
    /**
     * Tag Guidance Scale
     *
     * Tag guidance scale for the generation.
     */
    tag_guidance_scale?: number;
    /**
     * Scheduler
     *
     * Scheduler to use for the generation process.
     */
    scheduler?: 'euler' | 'heun';
    /**
     * End Time
     *
     * end time in seconds for the inpainting process.
     */
    end_time?: number;
    /**
     * Guidance Type
     *
     * Type of CFG to use for the generation process.
     */
    guidance_type?: 'cfg' | 'apg' | 'cfg_star';
    /**
     * Guidance Scale
     *
     * Guidance scale for the generation.
     */
    guidance_scale?: number;
    /**
     * Lyric Guidance Scale
     *
     * Lyric guidance scale for the generation.
     */
    lyric_guidance_scale?: number;
    /**
     * Guidance Interval
     *
     * Guidance interval for the generation. 0.5 means only apply guidance in the middle steps (0.25 * infer_steps to 0.75 * infer_steps)
     */
    guidance_interval?: number;
    /**
     * Variance
     *
     * Variance for the inpainting process. Higher values can lead to more diverse results.
     */
    variance?: number;
    /**
     * Guidance Interval Decay
     *
     * Guidance interval decay for the generation. Guidance scale will decay from guidance_scale to min_guidance_scale in the interval. 0.0 means no decay.
     */
    guidance_interval_decay?: number;
    /**
     * Start Time Relative To
     *
     * Whether the start time is relative to the start or end of the audio.
     */
    start_time_relative_to?: 'start' | 'end';
    /**
     * Audio Url
     *
     * URL of the audio file to be inpainted.
     */
    audio_url: string;
    /**
     * Seed
     *
     * Random seed for reproducibility. If not provided, a random seed will be used.
     */
    seed?: number;
    /**
     * Granularity Scale
     *
     * Granularity scale for the generation process. Higher values can reduce artifacts.
     */
    granularity_scale?: number;
};

/**
 * ACEStepAudioInpaintResponse
 */
export type AceStepAudioInpaintOutput = {
    /**
     * Tags
     *
     * The genre tags used in the generation process.
     */
    tags: string;
    /**
     * Lyrics
     *
     * The lyrics used in the generation process.
     */
    lyrics: string;
    /**
     * Seed
     *
     * The random seed used for the generation process.
     */
    seed: number;
    /**
     * Audio
     *
     * The generated audio file.
     */
    audio: FalAiAceStepAudioInpaintFile;
};

/**
 * File
 */
export type FalAiAceStepAudioInpaintFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * ACEStepAudioToAudioRequest
 */
export type AceStepAudioToAudioInput = {
    /**
     * Number Of Steps
     *
     * Number of steps to generate the audio.
     */
    number_of_steps?: number;
    /**
     * Tags
     *
     * Comma-separated list of genre tags to control the style of the generated audio.
     */
    tags: string;
    /**
     * Minimum Guidance Scale
     *
     * Minimum guidance scale for the generation after the decay.
     */
    minimum_guidance_scale?: number;
    /**
     * Lyrics
     *
     * Lyrics to be sung in the audio. If not provided or if [inst] or [instrumental] is the content of this field, no lyrics will be sung. Use control structures like [verse], [chorus] and [bridge] to control the structure of the song.
     */
    lyrics?: string;
    /**
     * Tag Guidance Scale
     *
     * Tag guidance scale for the generation.
     */
    tag_guidance_scale?: number;
    /**
     * Original Lyrics
     *
     * Original lyrics of the audio file.
     */
    original_lyrics?: string;
    /**
     * Scheduler
     *
     * Scheduler to use for the generation process.
     */
    scheduler?: 'euler' | 'heun';
    /**
     * Guidance Scale
     *
     * Guidance scale for the generation.
     */
    guidance_scale?: number;
    /**
     * Guidance Type
     *
     * Type of CFG to use for the generation process.
     */
    guidance_type?: 'cfg' | 'apg' | 'cfg_star';
    /**
     * Lyric Guidance Scale
     *
     * Lyric guidance scale for the generation.
     */
    lyric_guidance_scale?: number;
    /**
     * Guidance Interval
     *
     * Guidance interval for the generation. 0.5 means only apply guidance in the middle steps (0.25 * infer_steps to 0.75 * infer_steps)
     */
    guidance_interval?: number;
    /**
     * Edit Mode
     *
     * Whether to edit the lyrics only or remix the audio.
     */
    edit_mode?: 'lyrics' | 'remix';
    /**
     * Guidance Interval Decay
     *
     * Guidance interval decay for the generation. Guidance scale will decay from guidance_scale to min_guidance_scale in the interval. 0.0 means no decay.
     */
    guidance_interval_decay?: number;
    /**
     * Audio Url
     *
     * URL of the audio file to be outpainted.
     */
    audio_url: string;
    /**
     * Seed
     *
     * Random seed for reproducibility. If not provided, a random seed will be used.
     */
    seed?: number;
    /**
     * Granularity Scale
     *
     * Granularity scale for the generation process. Higher values can reduce artifacts.
     */
    granularity_scale?: number;
    /**
     * Original Tags
     *
     * Original tags of the audio file.
     */
    original_tags: string;
    /**
     * Original Seed
     *
     * Original seed of the audio file.
     */
    original_seed?: number;
};

/**
 * ACEStepAudioToAudioResponse
 */
export type AceStepAudioToAudioOutput = {
    /**
     * Tags
     *
     * The genre tags used in the generation process.
     */
    tags: string;
    /**
     * Lyrics
     *
     * The lyrics used in the generation process.
     */
    lyrics: string;
    /**
     * Seed
     *
     * The random seed used for the generation process.
     */
    seed: number;
    /**
     * Audio
     *
     * The generated audio file.
     */
    audio: FalAiAceStepAudioToAudioFile;
};

/**
 * File
 */
export type FalAiAceStepAudioToAudioFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * CloneRequest
 */
export type DiaTtsVoiceCloneInput = {
    /**
     * Text
     *
     * The text to be converted to speech.
     */
    text: string;
    /**
     * Reference Text for the Reference Audio
     *
     * The reference text to be used for TTS.
     */
    ref_text: string;
    /**
     * Reference Audio URL
     *
     * The URL of the reference audio file.
     */
    ref_audio_url: string;
};

/**
 * DiaCloneOutput
 */
export type DiaTtsVoiceCloneOutput = {
    /**
     * The generated speech audio
     */
    audio: FalAiDiaTtsVoiceCloneFile;
};

/**
 * File
 */
export type FalAiDiaTtsVoiceCloneFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
};

/**
 * AudioIsolationRequest
 */
export type ElevenlabsAudioIsolationInput = {
    /**
     * Video Url
     *
     * Video file to use for audio isolation. Either `audio_url` or `video_url` must be provided.
     */
    video_url?: string | unknown;
    /**
     * Audio Url
     *
     * URL of the audio file to isolate voice from
     */
    audio_url?: string | unknown;
};

/**
 * TTSOutput
 */
export type ElevenlabsAudioIsolationOutput = {
    audio: FalAiElevenlabsAudioIsolationFile;
    /**
     * Timestamps
     *
     * Timestamps for each word in the generated speech. Only returned if `timestamps` is set to True in the request.
     */
    timestamps?: Array<unknown> | unknown;
};

/**
 * File
 */
export type FalAiElevenlabsAudioIsolationFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
};
