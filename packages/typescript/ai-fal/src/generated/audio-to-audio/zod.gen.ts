// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

export const zFile = z.object({
    url: z.url(),
    content_type: z.optional(z.string()),
    file_name: z.optional(z.string()),
    file_size: z.optional(z.int())
});

export const zQueueStatus = z.object({
    status: z.enum([
        'IN_PROGRESS',
        'COMPLETED',
        'FAILED'
    ]),
    response_url: z.optional(z.url())
});

/**
 * VoiceChangerRequest
 */
export const zElevenlabsVoiceChangerInput = z.object({
    voice: z.optional(z.string()).default('Rachel'),
    audio_url: z.string(),
    seed: z.optional(z.int()),
    output_format: z.optional(z.enum([
        'mp3_22050_32',
        'mp3_44100_32',
        'mp3_44100_64',
        'mp3_44100_96',
        'mp3_44100_128',
        'mp3_44100_192',
        'pcm_8000',
        'pcm_16000',
        'pcm_22050',
        'pcm_24000',
        'pcm_44100',
        'pcm_48000',
        'ulaw_8000',
        'alaw_8000',
        'opus_48000_32',
        'opus_48000_64',
        'opus_48000_96',
        'opus_48000_128',
        'opus_48000_192'
    ])),
    remove_background_noise: z.optional(z.boolean()).default(false)
});

/**
 * File
 */
export const zFalAiElevenlabsVoiceChangerFile = z.object({
    file_size: z.optional(z.union([
        z.int(),
        z.unknown()
    ])),
    file_name: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    content_type: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    url: z.string()
});

/**
 * VoiceChangerOutput
 */
export const zElevenlabsVoiceChangerOutput = z.object({
    seed: z.int(),
    audio: zFalAiElevenlabsVoiceChangerFile
});

/**
 * NovaSRInput
 */
export const zNovaSrInput = z.object({
    sync_mode: z.optional(z.boolean()).default(false),
    bitrate: z.optional(z.string()).default('192k'),
    audio_url: z.string(),
    audio_format: z.optional(z.enum([
        'mp3',
        'aac',
        'm4a',
        'ogg',
        'opus',
        'flac',
        'wav'
    ]))
});

/**
 * NovaSRTimings
 */
export const zNovaSrTimings = z.object({
    postprocess: z.number(),
    inference: z.number(),
    preprocess: z.number()
});

/**
 * AudioFile
 */
export const zAudioFile = z.object({
    file_size: z.optional(z.int()),
    duration: z.optional(z.number()),
    bitrate: z.optional(z.string()),
    channels: z.optional(z.int()),
    url: z.string(),
    file_name: z.optional(z.string()),
    sample_rate: z.optional(z.int()),
    content_type: z.optional(z.string()),
    file_data: z.optional(z.string())
});

/**
 * NovaSROutput
 */
export const zNovaSrOutput = z.object({
    timings: zNovaSrTimings,
    audio: zAudioFile
});

/**
 * DeepFilterNet3Input
 */
export const zDeepfilternet3Input = z.object({
    sync_mode: z.optional(z.boolean()).default(false),
    audio_format: z.optional(z.enum([
        'mp3',
        'aac',
        'm4a',
        'ogg',
        'opus',
        'flac',
        'wav'
    ])),
    audio_url: z.string(),
    bitrate: z.optional(z.string()).default('192k')
});

/**
 * DeepFilterNetTimings
 */
export const zDeepFilterNetTimings = z.object({
    postprocess: z.number(),
    inference: z.number(),
    preprocess: z.number()
});

/**
 * AudioFile
 */
export const zFalAiDeepfilternet3AudioFile = z.object({
    file_size: z.optional(z.int()),
    duration: z.optional(z.number()),
    file_data: z.optional(z.string()),
    bitrate: z.optional(z.string()),
    url: z.string(),
    file_name: z.optional(z.string()),
    sample_rate: z.optional(z.int()),
    content_type: z.optional(z.string()),
    channels: z.optional(z.int())
});

/**
 * DeepFilterNet3Output
 */
export const zDeepfilternet3Output = z.object({
    timings: zDeepFilterNetTimings,
    audio_file: zFalAiDeepfilternet3AudioFile
});

/**
 * SAMAudioInput
 *
 * Input for text-based audio separation.
 */
export const zSamAudioSeparateInput = z.object({
    prompt: z.string(),
    acceleration: z.optional(z.enum([
        'fast',
        'balanced',
        'quality'
    ])),
    audio_url: z.string(),
    predict_spans: z.optional(z.boolean()).default(false),
    output_format: z.optional(z.enum(['wav', 'mp3'])),
    reranking_candidates: z.optional(z.int().gte(1).lte(4)).default(1)
});

/**
 * File
 */
export const zFalAiSamAudioSeparateFile = z.object({
    file_size: z.optional(z.int()),
    file_name: z.optional(z.string()),
    content_type: z.optional(z.string()),
    url: z.string(),
    file_data: z.optional(z.string())
});

/**
 * SAMAudioSeparateOutput
 *
 * Output for text-based audio separation.
 */
export const zSamAudioSeparateOutput = z.object({
    target: zFalAiSamAudioSeparateFile,
    duration: z.number(),
    sample_rate: z.optional(z.int()).default(48000),
    residual: zFalAiSamAudioSeparateFile
});

/**
 * AudioTimeSpan
 *
 * A time span indicating where the target sound occurs.
 */
export const zAudioTimeSpan = z.object({
    end: z.number().gte(0),
    start: z.number().gte(0),
    include: z.optional(z.boolean()).default(true)
});

/**
 * SAMAudioSpanInput
 *
 * Input for temporal span-based audio separation.
 */
export const zSamAudioSpanSeparateInput = z.object({
    prompt: z.optional(z.string()),
    acceleration: z.optional(z.enum([
        'fast',
        'balanced',
        'quality'
    ])),
    spans: z.array(zAudioTimeSpan),
    output_format: z.optional(z.enum(['wav', 'mp3'])),
    trim_to_span: z.optional(z.boolean()).default(false),
    audio_url: z.string(),
    reranking_candidates: z.optional(z.int().gte(1).lte(4)).default(1)
});

/**
 * File
 */
export const zFalAiSamAudioSpanSeparateFile = z.object({
    file_size: z.optional(z.int()),
    file_name: z.optional(z.string()),
    content_type: z.optional(z.string()),
    url: z.string(),
    file_data: z.optional(z.string())
});

/**
 * SAMAudioSpanSeparateOutput
 *
 * Output for span-based audio separation.
 */
export const zSamAudioSpanSeparateOutput = z.object({
    target: zFalAiSamAudioSpanSeparateFile,
    duration: z.number(),
    sample_rate: z.optional(z.int()).default(48000),
    residual: zFalAiSamAudioSpanSeparateFile
});

/**
 * MergeAudiosInput
 */
export const zFfmpegApiMergeAudiosInput = z.object({
    audio_urls: z.array(z.string()).min(2).max(5),
    output_format: z.optional(z.union([
        z.enum([
            'mp3_22050_32',
            'mp3_44100_32',
            'mp3_44100_64',
            'mp3_44100_96',
            'mp3_44100_128',
            'mp3_44100_192',
            'pcm_8000',
            'pcm_16000',
            'pcm_22050',
            'pcm_24000',
            'pcm_44100',
            'pcm_48000',
            'ulaw_8000',
            'alaw_8000',
            'opus_48000_32',
            'opus_48000_64',
            'opus_48000_96',
            'opus_48000_128',
            'opus_48000_192'
        ]),
        z.unknown()
    ]))
});

/**
 * File
 */
export const zFalAiFfmpegApiMergeAudiosFile = z.object({
    file_size: z.optional(z.union([
        z.int(),
        z.unknown()
    ])),
    file_name: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    content_type: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    url: z.string()
});

/**
 * MergeAudiosOutput
 */
export const zFfmpegApiMergeAudiosOutput = z.object({
    audio: zFalAiFfmpegApiMergeAudiosFile
});

/**
 * CreateVoiceInput
 *
 * Request model for creating a custom voice.
 */
export const zKlingVideoCreateVoiceInput = z.object({
    voice_url: z.string()
});

/**
 * CreateVoiceOutput
 *
 * Response model for creating a custom voice.
 */
export const zKlingVideoCreateVoiceOutput = z.object({
    voice_id: z.string()
});

/**
 * DemucsInput
 */
export const zDemucsInput = z.object({
    segment_length: z.optional(z.union([
        z.int(),
        z.unknown()
    ])),
    output_format: z.optional(z.enum(['wav', 'mp3'])),
    stems: z.optional(z.union([
        z.array(z.enum([
            'vocals',
            'drums',
            'bass',
            'other',
            'guitar',
            'piano'
        ])),
        z.unknown()
    ])),
    overlap: z.optional(z.number().gte(0).lte(1)).default(0.25),
    model: z.optional(z.enum([
        'htdemucs',
        'htdemucs_ft',
        'htdemucs_6s',
        'hdemucs_mmi',
        'mdx',
        'mdx_extra',
        'mdx_q',
        'mdx_extra_q'
    ])),
    audio_url: z.string(),
    shifts: z.optional(z.int().gte(1).lte(10)).default(1)
});

/**
 * File
 */
export const zFalAiDemucsFile = z.object({
    file_size: z.optional(z.union([
        z.int(),
        z.unknown()
    ])),
    file_name: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    content_type: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    url: z.string()
});

/**
 * DemucsOutput
 */
export const zDemucsOutput = z.object({
    vocals: z.optional(z.union([
        zFalAiDemucsFile,
        z.unknown()
    ])),
    guitar: z.optional(z.union([
        zFalAiDemucsFile,
        z.unknown()
    ])),
    bass: z.optional(z.union([
        zFalAiDemucsFile,
        z.unknown()
    ])),
    piano: z.optional(z.union([
        zFalAiDemucsFile,
        z.unknown()
    ])),
    other: z.optional(z.union([
        zFalAiDemucsFile,
        z.unknown()
    ])),
    drums: z.optional(z.union([
        zFalAiDemucsFile,
        z.unknown()
    ]))
});

/**
 * AudioUnderstandingInput
 */
export const zAudioUnderstandingInput = z.object({
    prompt: z.string().min(1).max(10000),
    detailed_analysis: z.optional(z.boolean()).default(false),
    audio_url: z.string()
});

/**
 * AudioUnderstandingOutput
 */
export const zAudioUnderstandingOutput = z.object({
    output: z.string()
});

/**
 * AudioToAudioInput
 */
export const zStableAudio25AudioToAudioInput = z.object({
    prompt: z.string(),
    strength: z.optional(z.number().gte(0.01).lte(1)).default(0.8),
    sync_mode: z.optional(z.boolean()).default(false),
    audio_url: z.string(),
    num_inference_steps: z.optional(z.int().gte(4).lte(8)).default(8),
    guidance_scale: z.optional(z.int().gte(1).lte(25)).default(1),
    seed: z.optional(z.int()),
    total_seconds: z.optional(z.int().gte(1).lte(190))
});

/**
 * File
 */
export const zFalAiStableAudio25AudioToAudioFile = z.object({
    file_size: z.optional(z.int()),
    file_name: z.optional(z.string()),
    content_type: z.optional(z.string()),
    url: z.string(),
    file_data: z.optional(z.string())
});

/**
 * AudioToAudioOutput
 */
export const zStableAudio25AudioToAudioOutput = z.object({
    seed: z.int(),
    audio: zFalAiStableAudio25AudioToAudioFile
});

/**
 * InpaintInput
 */
export const zStableAudio25InpaintInput = z.object({
    prompt: z.string(),
    guidance_scale: z.optional(z.int().gte(1).lte(25)).default(1),
    mask_end: z.optional(z.int().gte(0).lte(190)).default(190),
    sync_mode: z.optional(z.boolean()).default(false),
    audio_url: z.string(),
    seed: z.optional(z.int()),
    seconds_total: z.optional(z.int().gte(1).lte(190)).default(190),
    num_inference_steps: z.optional(z.int().gte(4).lte(8)).default(8),
    mask_start: z.optional(z.int().gte(0).lte(190)).default(30)
});

/**
 * File
 */
export const zFalAiStableAudio25InpaintFile = z.object({
    file_size: z.optional(z.int()),
    file_name: z.optional(z.string()),
    content_type: z.optional(z.string()),
    url: z.string(),
    file_data: z.optional(z.string())
});

/**
 * InpaintOutput
 */
export const zStableAudio25InpaintOutput = z.object({
    seed: z.int(),
    audio: zFalAiStableAudio25InpaintFile
});

/**
 * ExtendInput
 */
export const zV2ExtendInput = z.object({
    prompt: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    lyrics_prompt: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    tags: z.optional(z.union([
        z.array(z.string()),
        z.unknown()
    ])),
    prompt_strength: z.optional(z.number().gte(1.4).lte(3.1)).default(1.8),
    output_bit_rate: z.optional(z.union([
        z.union([
            z.literal(128),
            z.literal(192),
            z.literal(256),
            z.literal(320)
        ]),
        z.unknown()
    ])),
    num_songs: z.optional(z.int().gte(1).lte(2)).default(1),
    output_format: z.optional(z.enum([
        'flac',
        'mp3',
        'wav',
        'ogg',
        'm4a'
    ])),
    side: z.enum(['left', 'right']),
    balance_strength: z.optional(z.number().gte(0).lte(1)).default(0.7),
    crop_duration: z.optional(z.number()).default(0),
    audio_url: z.url().min(1).max(2083),
    seed: z.optional(z.union([
        z.int().gte(-9223372036854776000).lte(9223372036854776000),
        z.unknown()
    ])),
    extend_duration: z.optional(z.union([
        z.number().lte(85),
        z.unknown()
    ]))
});

/**
 * File
 */
export const zSonautoV2ExtendFile = z.object({
    file_size: z.optional(z.union([
        z.int(),
        z.unknown()
    ])),
    file_name: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    content_type: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    url: z.string()
});

/**
 * ExtendOutput
 */
export const zV2ExtendOutput = z.object({
    tags: z.optional(z.union([
        z.array(z.string()),
        z.unknown()
    ])),
    seed: z.int(),
    extend_duration: z.number(),
    audio: z.array(zSonautoV2ExtendFile),
    lyrics: z.optional(z.union([
        z.string(),
        z.unknown()
    ]))
});

/**
 * ACEStepAudioOutpaintRequest
 */
export const zAceStepAudioOutpaintInput = z.object({
    number_of_steps: z.optional(z.int().gte(3).lte(60)).default(27),
    tags: z.string(),
    minimum_guidance_scale: z.optional(z.number().gte(0).lte(200)).default(3),
    extend_after_duration: z.optional(z.number().gte(0).lte(240)).default(30),
    lyrics: z.optional(z.string()).default(''),
    tag_guidance_scale: z.optional(z.number().gte(0).lte(10)).default(5),
    scheduler: z.optional(z.enum(['euler', 'heun'])),
    extend_before_duration: z.optional(z.number().gte(0).lte(240)).default(0),
    guidance_type: z.optional(z.enum([
        'cfg',
        'apg',
        'cfg_star'
    ])),
    guidance_scale: z.optional(z.number().gte(0).lte(200)).default(15),
    lyric_guidance_scale: z.optional(z.number().gte(0).lte(10)).default(1.5),
    guidance_interval: z.optional(z.number().gte(0).lte(1)).default(0.5),
    guidance_interval_decay: z.optional(z.number().gte(0).lte(1)).default(0),
    audio_url: z.string(),
    seed: z.optional(z.int()),
    granularity_scale: z.optional(z.int().gte(-100).lte(100)).default(10)
});

/**
 * File
 */
export const zFalAiAceStepAudioOutpaintFile = z.object({
    file_size: z.optional(z.int()),
    file_name: z.optional(z.string()),
    content_type: z.optional(z.string()),
    url: z.string(),
    file_data: z.optional(z.string())
});

/**
 * ACEStepResponse
 */
export const zAceStepAudioOutpaintOutput = z.object({
    tags: z.string(),
    lyrics: z.string(),
    seed: z.int(),
    audio: zFalAiAceStepAudioOutpaintFile
});

/**
 * ACEStepAudioInpaintRequest
 */
export const zAceStepAudioInpaintInput = z.object({
    number_of_steps: z.optional(z.int().gte(3).lte(60)).default(27),
    start_time: z.optional(z.number().gte(0).lte(240)).default(0),
    tags: z.string(),
    minimum_guidance_scale: z.optional(z.number().gte(0).lte(200)).default(3),
    lyrics: z.optional(z.string()).default(''),
    end_time_relative_to: z.optional(z.enum(['start', 'end'])),
    tag_guidance_scale: z.optional(z.number().gte(0).lte(10)).default(5),
    scheduler: z.optional(z.enum(['euler', 'heun'])),
    end_time: z.optional(z.number().gte(0).lte(240)).default(30),
    guidance_type: z.optional(z.enum([
        'cfg',
        'apg',
        'cfg_star'
    ])),
    guidance_scale: z.optional(z.number().gte(0).lte(200)).default(15),
    lyric_guidance_scale: z.optional(z.number().gte(0).lte(10)).default(1.5),
    guidance_interval: z.optional(z.number().gte(0).lte(1)).default(0.5),
    variance: z.optional(z.number().gte(0).lte(1)).default(0.5),
    guidance_interval_decay: z.optional(z.number().gte(0).lte(1)).default(0),
    start_time_relative_to: z.optional(z.enum(['start', 'end'])),
    audio_url: z.string(),
    seed: z.optional(z.int()),
    granularity_scale: z.optional(z.int().gte(-100).lte(100)).default(10)
});

/**
 * File
 */
export const zFalAiAceStepAudioInpaintFile = z.object({
    file_size: z.optional(z.int()),
    file_name: z.optional(z.string()),
    content_type: z.optional(z.string()),
    url: z.string(),
    file_data: z.optional(z.string())
});

/**
 * ACEStepAudioInpaintResponse
 */
export const zAceStepAudioInpaintOutput = z.object({
    tags: z.string(),
    lyrics: z.string(),
    seed: z.int(),
    audio: zFalAiAceStepAudioInpaintFile
});

/**
 * ACEStepAudioToAudioRequest
 */
export const zAceStepAudioToAudioInput = z.object({
    number_of_steps: z.optional(z.int().gte(3).lte(60)).default(27),
    tags: z.string(),
    minimum_guidance_scale: z.optional(z.number().gte(0).lte(200)).default(3),
    lyrics: z.optional(z.string()).default(''),
    tag_guidance_scale: z.optional(z.number().gte(0).lte(10)).default(5),
    original_lyrics: z.optional(z.string()).default(''),
    scheduler: z.optional(z.enum(['euler', 'heun'])),
    guidance_scale: z.optional(z.number().gte(0).lte(200)).default(15),
    guidance_type: z.optional(z.enum([
        'cfg',
        'apg',
        'cfg_star'
    ])),
    lyric_guidance_scale: z.optional(z.number().gte(0).lte(10)).default(1.5),
    guidance_interval: z.optional(z.number().gte(0).lte(1)).default(0.5),
    edit_mode: z.optional(z.enum(['lyrics', 'remix'])),
    guidance_interval_decay: z.optional(z.number().gte(0).lte(1)).default(0),
    audio_url: z.string(),
    seed: z.optional(z.int()),
    granularity_scale: z.optional(z.int().gte(-100).lte(100)).default(10),
    original_tags: z.string(),
    original_seed: z.optional(z.int())
});

/**
 * File
 */
export const zFalAiAceStepAudioToAudioFile = z.object({
    file_size: z.optional(z.int()),
    file_name: z.optional(z.string()),
    content_type: z.optional(z.string()),
    url: z.string(),
    file_data: z.optional(z.string())
});

/**
 * ACEStepAudioToAudioResponse
 */
export const zAceStepAudioToAudioOutput = z.object({
    tags: z.string(),
    lyrics: z.string(),
    seed: z.int(),
    audio: zFalAiAceStepAudioToAudioFile
});

/**
 * CloneRequest
 */
export const zDiaTtsVoiceCloneInput = z.object({
    text: z.string(),
    ref_text: z.string(),
    ref_audio_url: z.string()
});

/**
 * File
 */
export const zFalAiDiaTtsVoiceCloneFile = z.object({
    file_size: z.optional(z.union([
        z.int(),
        z.unknown()
    ])),
    file_name: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    content_type: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    url: z.string()
});

/**
 * DiaCloneOutput
 */
export const zDiaTtsVoiceCloneOutput = z.object({
    audio: zFalAiDiaTtsVoiceCloneFile
});

/**
 * AudioIsolationRequest
 */
export const zElevenlabsAudioIsolationInput = z.object({
    video_url: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    audio_url: z.optional(z.union([
        z.string(),
        z.unknown()
    ]))
});

/**
 * File
 */
export const zFalAiElevenlabsAudioIsolationFile = z.object({
    file_size: z.optional(z.union([
        z.int(),
        z.unknown()
    ])),
    file_name: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    content_type: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    url: z.string()
});

/**
 * TTSOutput
 */
export const zElevenlabsAudioIsolationOutput = z.object({
    audio: zFalAiElevenlabsAudioIsolationFile,
    timestamps: z.optional(z.union([
        z.array(z.unknown()),
        z.unknown()
    ]))
});
