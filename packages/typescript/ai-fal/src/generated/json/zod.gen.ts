// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

export const zFile = z.object({
    url: z.url(),
    content_type: z.optional(z.string()),
    file_name: z.optional(z.string()),
    file_size: z.optional(z.int())
});

export const zQueueStatus = z.object({
    status: z.enum([
        'IN_PROGRESS',
        'COMPLETED',
        'FAILED'
    ]),
    response_url: z.optional(z.url())
});

/**
 * LoudnormInput
 */
export const zFfmpegApiLoudnormInput = z.object({
    measured_tp: z.optional(z.union([
        z.number().gte(-99).lte(99),
        z.unknown()
    ])),
    linear: z.optional(z.boolean()).default(false),
    offset: z.optional(z.number().gte(-99).lte(99)).default(0),
    measured_i: z.optional(z.union([
        z.number().gte(-99).lte(0),
        z.unknown()
    ])),
    print_summary: z.optional(z.boolean()).default(false),
    measured_lra: z.optional(z.union([
        z.number().gte(0).lte(99),
        z.unknown()
    ])),
    measured_thresh: z.optional(z.union([
        z.number().gte(-99).lte(0),
        z.unknown()
    ])),
    dual_mono: z.optional(z.boolean()).default(false),
    true_peak: z.optional(z.number().gte(-9).lte(0)).default(-0.1),
    audio_url: z.string(),
    integrated_loudness: z.optional(z.number().gte(-70).lte(-5)).default(-18),
    loudness_range: z.optional(z.number().gte(1).lte(20)).default(7)
});

/**
 * LoudnormSummary
 */
export const zLoudnormSummary = z.object({
    output_integrated: z.optional(z.union([
        z.number(),
        z.unknown()
    ])),
    output_true_peak: z.optional(z.union([
        z.number(),
        z.unknown()
    ])),
    input_lra: z.optional(z.union([
        z.number(),
        z.unknown()
    ])),
    normalization_type: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    output_lra: z.optional(z.union([
        z.number(),
        z.unknown()
    ])),
    output_threshold: z.optional(z.union([
        z.number(),
        z.unknown()
    ])),
    input_integrated: z.optional(z.union([
        z.number(),
        z.unknown()
    ])),
    input_true_peak: z.optional(z.union([
        z.number(),
        z.unknown()
    ])),
    target_offset: z.optional(z.union([
        z.number(),
        z.unknown()
    ])),
    input_threshold: z.optional(z.union([
        z.number(),
        z.unknown()
    ]))
});

/**
 * File
 */
export const zFalAiFfmpegApiLoudnormFile = z.object({
    file_size: z.optional(z.union([
        z.int(),
        z.unknown()
    ])),
    file_name: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    content_type: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    url: z.string()
});

/**
 * LoudnormOutput
 */
export const zFfmpegApiLoudnormOutput = z.object({
    summary: z.optional(z.union([
        zLoudnormSummary,
        z.unknown()
    ])),
    audio: zFalAiFfmpegApiLoudnormFile
});

/**
 * WaveformInput
 */
export const zFfmpegApiWaveformInput = z.object({
    precision: z.optional(z.int().gte(1).lte(6)).default(2),
    smoothing_window: z.optional(z.int().gte(1).lte(21)).default(3),
    media_url: z.string(),
    points_per_second: z.optional(z.number().gte(1).lte(10)).default(4)
});

/**
 * WaveformOutput
 */
export const zFfmpegApiWaveformOutput = z.object({
    precision: z.int(),
    duration: z.number(),
    points: z.int(),
    waveform: z.array(z.number())
});

/**
 * MetadataInput
 */
export const zFfmpegApiMetadataInput = z.object({
    extract_frames: z.optional(z.boolean()).default(false),
    media_url: z.string()
});

/**
 * Audio
 */
export const zAudio = z.object({
    file_size: z.int(),
    duration: z.number(),
    bitrate: z.int(),
    url: z.string(),
    media_type: z.optional(z.string()).default('audio'),
    codec: z.string(),
    file_name: z.string(),
    sample_rate: z.int(),
    content_type: z.string(),
    container: z.string(),
    channels: z.int()
});

/**
 * VideoFormat
 */
export const zVideoFormat = z.object({
    container: z.string(),
    level: z.number(),
    pixel_format: z.string(),
    video_codec: z.string(),
    profile: z.string(),
    bitrate: z.int()
});

/**
 * Resolution
 */
export const zResolution = z.object({
    height: z.int(),
    aspect_ratio: z.string(),
    width: z.int()
});

/**
 * AudioTrack
 */
export const zAudioTrack = z.object({
    codec: z.string(),
    channels: z.int(),
    sample_rate: z.int(),
    bitrate: z.int()
});

/**
 * Video
 */
export const zVideo = z.object({
    file_size: z.int(),
    timebase: z.string(),
    start_frame_url: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    duration: z.number(),
    url: z.string(),
    fps: z.int(),
    codec: z.string(),
    media_type: z.optional(z.string()).default('video'),
    end_frame_url: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    content_type: z.string(),
    container: z.string(),
    bitrate: z.int(),
    format: zVideoFormat,
    resolution: zResolution,
    frame_count: z.int(),
    file_name: z.string(),
    audio: z.optional(z.union([
        zAudioTrack,
        z.unknown()
    ]))
});

/**
 * MetadataOutput
 */
export const zFfmpegApiMetadataOutput = z.object({
    media: z.union([
        zVideo,
        zAudio
    ])
});
