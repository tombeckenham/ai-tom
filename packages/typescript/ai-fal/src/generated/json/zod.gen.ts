// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod'

export const zSchemaFiboGenerateStructuredPromptOutput = z.unknown()

/**
 * Lighting
 */
export const zSchemaLighting = z.object({
  shadows: z.optional(z.union([z.string(), z.unknown()])),
  conditions: z.optional(z.union([z.string(), z.unknown()])),
  direction: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * PhotographicCharacteristics
 */
export const zSchemaPhotographicCharacteristics = z.object({
  focus: z.optional(z.union([z.string(), z.unknown()])),
  lens_focal_length: z.optional(z.union([z.string(), z.unknown()])),
  camera_angle: z.optional(z.union([z.string(), z.unknown()])),
  depth_of_field: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * PromptObject
 */
export const zSchemaPromptObject = z.object({
  clothing: z.optional(z.union([z.string(), z.unknown()])),
  description: z.optional(z.union([z.string(), z.unknown()])),
  skin_tone_and_texture: z.optional(z.union([z.string(), z.unknown()])),
  appearance_details: z.optional(z.union([z.string(), z.unknown()])),
  number_of_objects: z.optional(z.union([z.int(), z.unknown()])),
  expression: z.optional(z.union([z.string(), z.unknown()])),
  pose: z.optional(z.union([z.string(), z.unknown()])),
  shape_and_color: z.optional(z.union([z.string(), z.unknown()])),
  relationship: z.string().register(z.globalRegistry, {
    description:
      'The relationship of the object to other objects in the image.',
  }),
  texture: z.optional(z.union([z.string(), z.unknown()])),
  gender: z.optional(z.union([z.string(), z.unknown()])),
  relative_size: z.optional(z.union([z.string(), z.unknown()])),
  location: z.optional(z.union([z.string(), z.unknown()])),
  orientation: z.optional(z.union([z.string(), z.unknown()])),
  action: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * Aesthetics
 */
export const zSchemaAesthetics = z.object({
  composition: z.optional(z.union([z.string(), z.unknown()])),
  mood_atmosphere: z.optional(z.union([z.string(), z.unknown()])),
  color_scheme: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * StructuredPrompt
 */
export const zSchemaStructuredPrompt = z.object({
  background_setting: z.optional(z.union([z.string(), z.unknown()])),
  artistic_style: z.optional(z.union([z.string(), z.unknown()])),
  aesthetics: z.optional(z.union([zSchemaAesthetics, z.unknown()])),
  text_render: z.optional(z.union([z.array(z.unknown()), z.unknown()])),
  objects: z.optional(z.union([z.array(zSchemaPromptObject), z.unknown()])),
  style_medium: z.optional(z.union([z.string(), z.unknown()])),
  photographic_characteristics: z.optional(
    z.union([zSchemaPhotographicCharacteristics, z.unknown()]),
  ),
  context: z.optional(z.union([z.string(), z.unknown()])),
  lighting: z.optional(z.union([zSchemaLighting, z.unknown()])),
  short_description: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * StructuredPromptModel
 */
export const zSchemaFiboGenerateStructuredPromptInput = z.object({
  prompt: z.optional(z.union([z.string(), z.unknown()])),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Random seed for reproducibility.',
      }),
    )
    .default(5555),
  structured_prompt: z.optional(
    z.union([zSchemaStructuredPrompt, z.unknown()]),
  ),
  image_url: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * Aesthetics
 */
export const zSchemaBriaFiboVlmAesthetics = z.object({
  preference_score: z.string().register(z.globalRegistry, {
    description: 'The preference score of the image.',
  }),
  composition: z.optional(z.union([z.string(), z.unknown()])),
  mood_atmosphere: z.optional(z.union([z.string(), z.unknown()])),
  aesthetic_score: z.string().register(z.globalRegistry, {
    description: 'The aesthetic score of the image.',
  }),
  color_scheme: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * StructuredPrompt
 */
export const zSchemaBriaFiboVlmStructuredPrompt = z.object({
  background_setting: z.optional(z.union([z.string(), z.unknown()])),
  artistic_style: z.optional(z.union([z.string(), z.unknown()])),
  style_medium: z.optional(z.union([z.string(), z.unknown()])),
  text_render: z.optional(z.union([z.array(z.unknown()), z.unknown()])),
  objects: z.optional(z.union([z.array(zSchemaPromptObject), z.unknown()])),
  context: z.optional(z.union([z.string(), z.unknown()])),
  photographic_characteristics: z.optional(
    z.union([zSchemaPhotographicCharacteristics, z.unknown()]),
  ),
  aesthetics: z.optional(z.union([zSchemaBriaFiboVlmAesthetics, z.unknown()])),
  lighting: z.optional(z.union([zSchemaLighting, z.unknown()])),
  short_description: z.optional(z.union([z.string(), z.unknown()])),
})

export const zSchemaFiboLiteGenerateStructuredPromptLiteOutput = z.unknown()

/**
 * StructuredPromptModel
 */
export const zSchemaFiboLiteGenerateStructuredPromptLiteInput = z.object({
  prompt: z.optional(z.union([z.string(), z.unknown()])),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Random seed for reproducibility.',
      }),
    )
    .default(5555),
  structured_prompt: z.optional(
    z.union([zSchemaBriaFiboVlmStructuredPrompt, z.unknown()]),
  ),
  image_url: z.optional(z.union([z.string(), z.unknown()])),
})

export const zSchemaFiboLiteGenerateStructuredPromptOutput = z.unknown()

/**
 * StructuredPromptModel
 */
export const zSchemaFiboLiteGenerateStructuredPromptInput = z.object({
  prompt: z.optional(z.union([z.string(), z.unknown()])),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Random seed for reproducibility.',
      }),
    )
    .default(5555),
  structured_prompt: z.optional(
    z.union([zSchemaStructuredPrompt, z.unknown()]),
  ),
  image_url: z.optional(z.union([z.string(), z.unknown()])),
})

export const zSchemaFiboEditEditStructuredInstructionOutput = z.unknown()

/**
 * StructuredInstructionInputModel
 */
export const zSchemaFiboEditEditStructuredInstructionInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If true, returns the image directly in the response (increases latency).',
      }),
    )
    .default(false),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Random seed for reproducibility.',
      }),
    )
    .default(5555),
  mask_url: z.optional(z.union([z.string(), z.unknown()])),
  instruction: z.optional(z.union([z.string(), z.unknown()])),
  image_url: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * AudioTrack
 */
export const zSchemaAudioTrack = z.object({
  codec: z.string().register(z.globalRegistry, {
    description: "Audio codec used (e.g., 'aac', 'mp3')",
  }),
  channels: z.int().register(z.globalRegistry, {
    description: 'Number of audio channels',
  }),
  sample_rate: z.int().register(z.globalRegistry, {
    description: 'Audio sample rate in Hz',
  }),
  bitrate: z.int().register(z.globalRegistry, {
    description: 'Audio bitrate in bits per second',
  }),
})

/**
 * Resolution
 */
export const zSchemaResolution = z.object({
  height: z.int().register(z.globalRegistry, {
    description: 'Height of the video in pixels',
  }),
  aspect_ratio: z.string().register(z.globalRegistry, {
    description: "Display aspect ratio (e.g., '16:9')",
  }),
  width: z.int().register(z.globalRegistry, {
    description: 'Width of the video in pixels',
  }),
})

/**
 * VideoFormat
 */
export const zSchemaVideoFormat = z.object({
  container: z.string().register(z.globalRegistry, {
    description: 'Container format of the video',
  }),
  level: z.number().register(z.globalRegistry, {
    description: 'Codec level (e.g., 4.1)',
  }),
  pixel_format: z.string().register(z.globalRegistry, {
    description: "Pixel format used (e.g., 'yuv420p')",
  }),
  video_codec: z.string().register(z.globalRegistry, {
    description: "Video codec used (e.g., 'h264')",
  }),
  profile: z.string().register(z.globalRegistry, {
    description: "Codec profile (e.g., 'main', 'high')",
  }),
  bitrate: z.int().register(z.globalRegistry, {
    description: 'Video bitrate in bits per second',
  }),
})

/**
 * Audio
 */
export const zSchemaAudio = z.object({
  file_size: z.int().register(z.globalRegistry, {
    description: 'Size of the file in bytes',
  }),
  duration: z.number().register(z.globalRegistry, {
    description: 'Duration of the media in seconds',
  }),
  bitrate: z.int().register(z.globalRegistry, {
    description: 'Overall bitrate of the media in bits per second',
  }),
  url: z.string().register(z.globalRegistry, {
    description: 'URL where the media file can be accessed',
  }),
  media_type: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Type of media (always 'audio')",
      }),
    )
    .default('audio'),
  codec: z.string().register(z.globalRegistry, {
    description: 'Codec used to encode the media',
  }),
  file_name: z.string().register(z.globalRegistry, {
    description: 'Original filename of the media',
  }),
  sample_rate: z.int().register(z.globalRegistry, {
    description: 'Audio sample rate in Hz',
  }),
  content_type: z.string().register(z.globalRegistry, {
    description: 'MIME type of the media file',
  }),
  container: z.string().register(z.globalRegistry, {
    description: "Container format of the media file (e.g., 'mp4', 'mov')",
  }),
  channels: z.int().register(z.globalRegistry, {
    description: 'Number of audio channels',
  }),
})

/**
 * Video
 */
export const zSchemaVideo = z.object({
  file_size: z.int().register(z.globalRegistry, {
    description: 'Size of the file in bytes',
  }),
  timebase: z.string().register(z.globalRegistry, {
    description: 'Time base used for frame timestamps',
  }),
  start_frame_url: z.optional(z.union([z.string(), z.unknown()])),
  duration: z.number().register(z.globalRegistry, {
    description: 'Duration of the media in seconds',
  }),
  url: z.string().register(z.globalRegistry, {
    description: 'URL where the media file can be accessed',
  }),
  fps: z.int().register(z.globalRegistry, {
    description: 'Frames per second',
  }),
  codec: z.string().register(z.globalRegistry, {
    description: 'Codec used to encode the media',
  }),
  media_type: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: "Type of media (always 'video')",
      }),
    )
    .default('video'),
  end_frame_url: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.string().register(z.globalRegistry, {
    description: 'MIME type of the media file',
  }),
  container: z.string().register(z.globalRegistry, {
    description: "Container format of the media file (e.g., 'mp4', 'mov')",
  }),
  bitrate: z.int().register(z.globalRegistry, {
    description: 'Overall bitrate of the media in bits per second',
  }),
  format: zSchemaVideoFormat,
  resolution: zSchemaResolution,
  frame_count: z.int().register(z.globalRegistry, {
    description: 'Total number of frames in the video',
  }),
  file_name: z.string().register(z.globalRegistry, {
    description: 'Original filename of the media',
  }),
  audio: z.optional(z.union([zSchemaAudioTrack, z.unknown()])),
})

/**
 * MetadataOutput
 */
export const zSchemaFfmpegApiMetadataOutput = z.object({
  media: z.union([zSchemaVideo, zSchemaAudio]),
})

/**
 * MetadataInput
 */
export const zSchemaFfmpegApiMetadataInput = z.object({
  extract_frames: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to extract the start and end frames for videos. Note that when true the request will be slower.',
      }),
    )
    .default(false),
  media_url: z.union([z.string(), z.string()]),
})

/**
 * WaveformOutput
 */
export const zSchemaFfmpegApiWaveformOutput = z.object({
  precision: z.int().register(z.globalRegistry, {
    description: 'Number of decimal places used in the waveform values',
  }),
  duration: z.number().register(z.globalRegistry, {
    description: 'Duration of the audio in seconds',
  }),
  points: z.int().register(z.globalRegistry, {
    description: 'Number of points in the waveform data',
  }),
  waveform: z.array(z.number()).register(z.globalRegistry, {
    description:
      'Normalized waveform data as an array of values between -1 and 1. The number of points is determined by audio duration Ã— points_per_second.',
  }),
})

/**
 * WaveformInput
 */
export const zSchemaFfmpegApiWaveformInput = z.object({
  precision: z
    .optional(
      z.int().gte(1).lte(6).register(z.globalRegistry, {
        description:
          'Number of decimal places for the waveform values. Higher values provide more precision but increase payload size.',
      }),
    )
    .default(2),
  smoothing_window: z
    .optional(
      z.int().gte(1).lte(21).register(z.globalRegistry, {
        description:
          'Size of the smoothing window. Higher values create a smoother waveform. Must be an odd number.',
      }),
    )
    .default(3),
  media_url: z.union([z.string(), z.string()]),
  points_per_second: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Controls how many points are sampled per second of audio. Lower values (e.g. 1-2) create a coarser waveform, higher values (e.g. 4-10) create a more detailed one.',
      }),
    )
    .default(4),
})

/**
 * File
 */
export const zSchemaFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * LoudnormSummary
 */
export const zSchemaLoudnormSummary = z.object({
  output_integrated: z.optional(z.union([z.number(), z.unknown()])),
  output_true_peak: z.optional(z.union([z.number(), z.unknown()])),
  input_lra: z.optional(z.union([z.number(), z.unknown()])),
  normalization_type: z.optional(z.union([z.string(), z.unknown()])),
  output_lra: z.optional(z.union([z.number(), z.unknown()])),
  output_threshold: z.optional(z.union([z.number(), z.unknown()])),
  input_integrated: z.optional(z.union([z.number(), z.unknown()])),
  input_true_peak: z.optional(z.union([z.number(), z.unknown()])),
  target_offset: z.optional(z.union([z.number(), z.unknown()])),
  input_threshold: z.optional(z.union([z.number(), z.unknown()])),
})

/**
 * LoudnormOutput
 */
export const zSchemaFfmpegApiLoudnormOutput = z.object({
  summary: z.optional(z.union([zSchemaLoudnormSummary, z.unknown()])),
  audio: zSchemaFile,
})

/**
 * LoudnormInput
 */
export const zSchemaFfmpegApiLoudnormInput = z.object({
  measured_tp: z.optional(z.union([z.number().gte(-99).lte(99), z.unknown()])),
  linear: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Use linear normalization mode (single-pass). If false, uses dynamic mode (two-pass for better quality).',
      }),
    )
    .default(false),
  offset: z
    .optional(
      z.number().gte(-99).lte(99).register(z.globalRegistry, {
        description: 'Offset gain in dB applied before the true-peak limiter',
      }),
    )
    .default(0),
  measured_i: z.optional(z.union([z.number().gte(-99).lte(0), z.unknown()])),
  print_summary: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Return loudness measurement summary with the normalized audio',
      }),
    )
    .default(false),
  measured_lra: z.optional(z.union([z.number().gte(0).lte(99), z.unknown()])),
  measured_thresh: z.optional(
    z.union([z.number().gte(-99).lte(0), z.unknown()]),
  ),
  dual_mono: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Treat mono input files as dual-mono for correct EBU R128 measurement on stereo systems',
      }),
    )
    .default(false),
  true_peak: z
    .optional(
      z.number().gte(-9).lte(0).register(z.globalRegistry, {
        description: 'Maximum true peak in dBTP.',
      }),
    )
    .default(-0.1),
  audio_url: z.union([z.string(), z.string()]),
  integrated_loudness: z
    .optional(
      z.number().gte(-70).lte(-5).register(z.globalRegistry, {
        description: 'Integrated loudness target in LUFS.',
      }),
    )
    .default(-18),
  loudness_range: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: 'Loudness range target in LU',
      }),
    )
    .default(7),
})

/**
 * TextOutput
 */
export const zSchemaBagelUnderstandOutput = z.object({
  text: z.string().register(z.globalRegistry, {
    description: 'The answer to the query.',
  }),
  prompt: z.string().register(z.globalRegistry, {
    description: 'The query used for the generation.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for the generation.',
  }),
  timings: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: 'The timings of the generation.',
  }),
})

/**
 * ImageUnderstandingInput
 */
export const zSchemaBagelUnderstandInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to query the image with.',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed to use for the generation.',
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
})

export const zSchemaQueueStatus = z.object({
  status: z.enum(['IN_QUEUE', 'IN_PROGRESS', 'COMPLETED']),
  request_id: z.string().register(z.globalRegistry, {
    description: 'The request id.',
  }),
  response_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The response url.',
    }),
  ),
  status_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The status url.',
    }),
  ),
  cancel_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The cancel url.',
    }),
  ),
  logs: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The logs.',
    }),
  ),
  metrics: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The metrics.',
    }),
  ),
  queue_position: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The queue position.',
    }),
  ),
})

export const zGetFalAiBagelUnderstandRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiBagelUnderstandRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBagelUnderstandRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiBagelUnderstandRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiBagelUnderstandData = z.object({
  body: zSchemaBagelUnderstandInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBagelUnderstandResponse = zSchemaQueueStatus

export const zGetFalAiBagelUnderstandRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiBagelUnderstandRequestsByRequestIdResponse =
  zSchemaBagelUnderstandOutput

export const zGetFalAiFfmpegApiLoudnormRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiFfmpegApiLoudnormRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFfmpegApiLoudnormRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiFfmpegApiLoudnormRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFfmpegApiLoudnormData = z.object({
  body: zSchemaFfmpegApiLoudnormInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFfmpegApiLoudnormResponse = zSchemaQueueStatus

export const zGetFalAiFfmpegApiLoudnormRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFfmpegApiLoudnormRequestsByRequestIdResponse =
  zSchemaFfmpegApiLoudnormOutput

export const zGetFalAiFfmpegApiWaveformRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiFfmpegApiWaveformRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFfmpegApiWaveformRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiFfmpegApiWaveformRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFfmpegApiWaveformData = z.object({
  body: zSchemaFfmpegApiWaveformInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFfmpegApiWaveformResponse = zSchemaQueueStatus

export const zGetFalAiFfmpegApiWaveformRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFfmpegApiWaveformRequestsByRequestIdResponse =
  zSchemaFfmpegApiWaveformOutput

export const zGetFalAiFfmpegApiMetadataRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiFfmpegApiMetadataRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFfmpegApiMetadataRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiFfmpegApiMetadataRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFfmpegApiMetadataData = z.object({
  body: zSchemaFfmpegApiMetadataInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFfmpegApiMetadataResponse = zSchemaQueueStatus

export const zGetFalAiFfmpegApiMetadataRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFfmpegApiMetadataRequestsByRequestIdResponse =
  zSchemaFfmpegApiMetadataOutput

export const zGetBriaFiboEditEditStructuredInstructionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetBriaFiboEditEditStructuredInstructionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaFiboEditEditStructuredInstructionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditEditStructuredInstructionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostBriaFiboEditEditStructuredInstructionData = z.object({
  body: zSchemaFiboEditEditStructuredInstructionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaFiboEditEditStructuredInstructionResponse =
  zSchemaQueueStatus

export const zGetBriaFiboEditEditStructuredInstructionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetBriaFiboEditEditStructuredInstructionRequestsByRequestIdResponse =
  zSchemaFiboEditEditStructuredInstructionOutput

export const zGetBriaFiboLiteGenerateStructuredPromptRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetBriaFiboLiteGenerateStructuredPromptRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaFiboLiteGenerateStructuredPromptRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutBriaFiboLiteGenerateStructuredPromptRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostBriaFiboLiteGenerateStructuredPromptData = z.object({
  body: zSchemaFiboLiteGenerateStructuredPromptInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaFiboLiteGenerateStructuredPromptResponse =
  zSchemaQueueStatus

export const zGetBriaFiboLiteGenerateStructuredPromptRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetBriaFiboLiteGenerateStructuredPromptRequestsByRequestIdResponse =
  zSchemaFiboLiteGenerateStructuredPromptOutput

export const zGetBriaFiboLiteGenerateStructuredPromptLiteRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetBriaFiboLiteGenerateStructuredPromptLiteRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaFiboLiteGenerateStructuredPromptLiteRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutBriaFiboLiteGenerateStructuredPromptLiteRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostBriaFiboLiteGenerateStructuredPromptLiteData = z.object({
  body: zSchemaFiboLiteGenerateStructuredPromptLiteInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaFiboLiteGenerateStructuredPromptLiteResponse =
  zSchemaQueueStatus

export const zGetBriaFiboLiteGenerateStructuredPromptLiteRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetBriaFiboLiteGenerateStructuredPromptLiteRequestsByRequestIdResponse =
  zSchemaFiboLiteGenerateStructuredPromptLiteOutput

export const zGetBriaFiboGenerateStructuredPromptRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetBriaFiboGenerateStructuredPromptRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaFiboGenerateStructuredPromptRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutBriaFiboGenerateStructuredPromptRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostBriaFiboGenerateStructuredPromptData = z.object({
  body: zSchemaFiboGenerateStructuredPromptInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaFiboGenerateStructuredPromptResponse = zSchemaQueueStatus

export const zGetBriaFiboGenerateStructuredPromptRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetBriaFiboGenerateStructuredPromptRequestsByRequestIdResponse =
  zSchemaFiboGenerateStructuredPromptOutput
