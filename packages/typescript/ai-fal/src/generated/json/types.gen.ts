// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
  baseUrl: `${string}://${string}` | (string & {})
}

export type File = {
  url: string
  content_type?: string
  file_name?: string
  file_size?: number
}

export type QueueStatus = {
  status: 'IN_PROGRESS' | 'COMPLETED' | 'FAILED'
  response_url?: string
}

/**
 * LoudnormInput
 */
export type FfmpegApiLoudnormInput = {
  /**
   * Measured Tp
   *
   * Measured true peak of input file in dBTP. Required for linear mode.
   */
  measured_tp?: number | unknown
  /**
   * Linear
   *
   * Use linear normalization mode (single-pass). If false, uses dynamic mode (two-pass for better quality).
   */
  linear?: boolean
  /**
   * Offset
   *
   * Offset gain in dB applied before the true-peak limiter
   */
  offset?: number
  /**
   * Measured I
   *
   * Measured integrated loudness of input file in LUFS. Required for linear mode.
   */
  measured_i?: number | unknown
  /**
   * Print Summary
   *
   * Return loudness measurement summary with the normalized audio
   */
  print_summary?: boolean
  /**
   * Measured Lra
   *
   * Measured loudness range of input file in LU. Required for linear mode.
   */
  measured_lra?: number | unknown
  /**
   * Measured Thresh
   *
   * Measured threshold of input file in LUFS. Required for linear mode.
   */
  measured_thresh?: number | unknown
  /**
   * Dual Mono
   *
   * Treat mono input files as dual-mono for correct EBU R128 measurement on stereo systems
   */
  dual_mono?: boolean
  /**
   * True Peak
   *
   * Maximum true peak in dBTP.
   */
  true_peak?: number
  /**
   * Audio Url
   *
   * URL of the audio file to normalize
   */
  audio_url: string
  /**
   * Integrated Loudness
   *
   * Integrated loudness target in LUFS.
   */
  integrated_loudness?: number
  /**
   * Loudness Range
   *
   * Loudness range target in LU
   */
  loudness_range?: number
}

/**
 * LoudnormOutput
 */
export type FfmpegApiLoudnormOutput = {
  /**
   * Structured loudness measurement summary (if requested)
   */
  summary?: LoudnormSummary | unknown
  audio: FalAiFfmpegApiLoudnormFile
}

/**
 * LoudnormSummary
 */
export type LoudnormSummary = {
  /**
   * Output Integrated
   *
   * Output integrated loudness in LUFS
   */
  output_integrated?: number | unknown
  /**
   * Output True Peak
   *
   * Output true peak in dBTP
   */
  output_true_peak?: number | unknown
  /**
   * Input Lra
   *
   * Input loudness range in LU
   */
  input_lra?: number | unknown
  /**
   * Normalization Type
   *
   * Type of normalization applied (Dynamic/Linear)
   */
  normalization_type?: string | unknown
  /**
   * Output Lra
   *
   * Output loudness range in LU
   */
  output_lra?: number | unknown
  /**
   * Output Threshold
   *
   * Output threshold in LUFS
   */
  output_threshold?: number | unknown
  /**
   * Input Integrated
   *
   * Input integrated loudness in LUFS
   */
  input_integrated?: number | unknown
  /**
   * Input True Peak
   *
   * Input true peak in dBTP
   */
  input_true_peak?: number | unknown
  /**
   * Target Offset
   *
   * Target offset in LU
   */
  target_offset?: number | unknown
  /**
   * Input Threshold
   *
   * Input threshold in LUFS
   */
  input_threshold?: number | unknown
}

/**
 * File
 */
export type FalAiFfmpegApiLoudnormFile = {
  /**
   * File Size
   *
   * The size of the file in bytes.
   */
  file_size?: number | unknown
  /**
   * File Name
   *
   * The name of the file. It will be auto-generated if not provided.
   */
  file_name?: string | unknown
  /**
   * Content Type
   *
   * The mime type of the file.
   */
  content_type?: string | unknown
  /**
   * Url
   *
   * The URL where the file can be downloaded from.
   */
  url: string
}

/**
 * WaveformInput
 */
export type FfmpegApiWaveformInput = {
  /**
   * Precision
   *
   * Number of decimal places for the waveform values. Higher values provide more precision but increase payload size.
   */
  precision?: number
  /**
   * Smoothing Window
   *
   * Size of the smoothing window. Higher values create a smoother waveform. Must be an odd number.
   */
  smoothing_window?: number
  /**
   * Media Url
   *
   * URL of the audio file to analyze
   */
  media_url: string
  /**
   * Points Per Second
   *
   * Controls how many points are sampled per second of audio. Lower values (e.g. 1-2) create a coarser waveform, higher values (e.g. 4-10) create a more detailed one.
   */
  points_per_second?: number
}

/**
 * WaveformOutput
 */
export type FfmpegApiWaveformOutput = {
  /**
   * Precision
   *
   * Number of decimal places used in the waveform values
   */
  precision: number
  /**
   * Duration
   *
   * Duration of the audio in seconds
   */
  duration: number
  /**
   * Points
   *
   * Number of points in the waveform data
   */
  points: number
  /**
   * Waveform
   *
   * Normalized waveform data as an array of values between -1 and 1. The number of points is determined by audio duration Ã— points_per_second.
   */
  waveform: Array<number>
}

/**
 * MetadataInput
 */
export type FfmpegApiMetadataInput = {
  /**
   * Extract Frames
   *
   * Whether to extract the start and end frames for videos. Note that when true the request will be slower.
   */
  extract_frames?: boolean
  /**
   * Media Url
   *
   * URL of the media file (video or audio) to analyze
   */
  media_url: string
}

/**
 * MetadataOutput
 */
export type FfmpegApiMetadataOutput = {
  /**
   * Media
   *
   * Metadata for the analyzed media file (either Video or Audio)
   */
  media: Video | Audio
}

/**
 * Video
 */
export type Video = {
  /**
   * File Size
   *
   * Size of the file in bytes
   */
  file_size: number
  /**
   * Timebase
   *
   * Time base used for frame timestamps
   */
  timebase: string
  /**
   * Start Frame Url
   *
   * URL of the extracted first frame
   */
  start_frame_url?: string | unknown
  /**
   * Duration
   *
   * Duration of the media in seconds
   */
  duration: number
  /**
   * Url
   *
   * URL where the media file can be accessed
   */
  url: string
  /**
   * Fps
   *
   * Frames per second
   */
  fps: number
  /**
   * Codec
   *
   * Codec used to encode the media
   */
  codec: string
  /**
   * Media Type
   *
   * Type of media (always 'video')
   */
  media_type?: string
  /**
   * End Frame Url
   *
   * URL of the extracted last frame
   */
  end_frame_url?: string | unknown
  /**
   * Content Type
   *
   * MIME type of the media file
   */
  content_type: string
  /**
   * Container
   *
   * Container format of the media file (e.g., 'mp4', 'mov')
   */
  container: string
  /**
   * Bitrate
   *
   * Overall bitrate of the media in bits per second
   */
  bitrate: number
  format: VideoFormat
  resolution: Resolution
  /**
   * Frame Count
   *
   * Total number of frames in the video
   */
  frame_count: number
  /**
   * File Name
   *
   * Original filename of the media
   */
  file_name: string
  /**
   * Audio track information if video has audio
   */
  audio?: AudioTrack | unknown
}

/**
 * VideoFormat
 */
export type VideoFormat = {
  /**
   * Container
   *
   * Container format of the video
   */
  container: string
  /**
   * Level
   *
   * Codec level (e.g., 4.1)
   */
  level: number
  /**
   * Pixel Format
   *
   * Pixel format used (e.g., 'yuv420p')
   */
  pixel_format: string
  /**
   * Video Codec
   *
   * Video codec used (e.g., 'h264')
   */
  video_codec: string
  /**
   * Profile
   *
   * Codec profile (e.g., 'main', 'high')
   */
  profile: string
  /**
   * Bitrate
   *
   * Video bitrate in bits per second
   */
  bitrate: number
}

/**
 * Resolution
 */
export type Resolution = {
  /**
   * Height
   *
   * Height of the video in pixels
   */
  height: number
  /**
   * Aspect Ratio
   *
   * Display aspect ratio (e.g., '16:9')
   */
  aspect_ratio: string
  /**
   * Width
   *
   * Width of the video in pixels
   */
  width: number
}

/**
 * AudioTrack
 */
export type AudioTrack = {
  /**
   * Codec
   *
   * Audio codec used (e.g., 'aac', 'mp3')
   */
  codec: string
  /**
   * Channels
   *
   * Number of audio channels
   */
  channels: number
  /**
   * Sample Rate
   *
   * Audio sample rate in Hz
   */
  sample_rate: number
  /**
   * Bitrate
   *
   * Audio bitrate in bits per second
   */
  bitrate: number
}

/**
 * Audio
 */
export type Audio = {
  /**
   * File Size
   *
   * Size of the file in bytes
   */
  file_size: number
  /**
   * Duration
   *
   * Duration of the media in seconds
   */
  duration: number
  /**
   * Bitrate
   *
   * Overall bitrate of the media in bits per second
   */
  bitrate: number
  /**
   * Url
   *
   * URL where the media file can be accessed
   */
  url: string
  /**
   * Media Type
   *
   * Type of media (always 'audio')
   */
  media_type?: string
  /**
   * Codec
   *
   * Codec used to encode the media
   */
  codec: string
  /**
   * File Name
   *
   * Original filename of the media
   */
  file_name: string
  /**
   * Sample Rate
   *
   * Audio sample rate in Hz
   */
  sample_rate: number
  /**
   * Content Type
   *
   * MIME type of the media file
   */
  content_type: string
  /**
   * Container
   *
   * Container format of the media file (e.g., 'mp4', 'mov')
   */
  container: string
  /**
   * Channels
   *
   * Number of audio channels
   */
  channels: number
}
