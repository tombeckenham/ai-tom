// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
  baseUrl: 'https://queue.fal.run' | (string & {})
}

/**
 * AudioTrack
 */
export type SchemaAudioTrack = {
  /**
   * Codec
   *
   * Audio codec used (e.g., 'aac', 'mp3')
   */
  codec: string
  /**
   * Channels
   *
   * Number of audio channels
   */
  channels: number
  /**
   * Sample Rate
   *
   * Audio sample rate in Hz
   */
  sample_rate: number
  /**
   * Bitrate
   *
   * Audio bitrate in bits per second
   */
  bitrate: number
}

/**
 * Resolution
 */
export type SchemaResolution = {
  /**
   * Height
   *
   * Height of the video in pixels
   */
  height: number
  /**
   * Aspect Ratio
   *
   * Display aspect ratio (e.g., '16:9')
   */
  aspect_ratio: string
  /**
   * Width
   *
   * Width of the video in pixels
   */
  width: number
}

/**
 * VideoFormat
 */
export type SchemaVideoFormat = {
  /**
   * Container
   *
   * Container format of the video
   */
  container: string
  /**
   * Level
   *
   * Codec level (e.g., 4.1)
   */
  level: number
  /**
   * Pixel Format
   *
   * Pixel format used (e.g., 'yuv420p')
   */
  pixel_format: string
  /**
   * Video Codec
   *
   * Video codec used (e.g., 'h264')
   */
  video_codec: string
  /**
   * Profile
   *
   * Codec profile (e.g., 'main', 'high')
   */
  profile: string
  /**
   * Bitrate
   *
   * Video bitrate in bits per second
   */
  bitrate: number
}

/**
 * Audio
 */
export type SchemaAudio = {
  /**
   * File Size
   *
   * Size of the file in bytes
   */
  file_size: number
  /**
   * Duration
   *
   * Duration of the media in seconds
   */
  duration: number
  /**
   * Bitrate
   *
   * Overall bitrate of the media in bits per second
   */
  bitrate: number
  /**
   * Url
   *
   * URL where the media file can be accessed
   */
  url: string
  /**
   * Media Type
   *
   * Type of media (always 'audio')
   */
  media_type?: string
  /**
   * Codec
   *
   * Codec used to encode the media
   */
  codec: string
  /**
   * File Name
   *
   * Original filename of the media
   */
  file_name: string
  /**
   * Sample Rate
   *
   * Audio sample rate in Hz
   */
  sample_rate: number
  /**
   * Content Type
   *
   * MIME type of the media file
   */
  content_type: string
  /**
   * Container
   *
   * Container format of the media file (e.g., 'mp4', 'mov')
   */
  container: string
  /**
   * Channels
   *
   * Number of audio channels
   */
  channels: number
}

/**
 * Video
 */
export type SchemaVideo = {
  /**
   * File Size
   *
   * Size of the file in bytes
   */
  file_size: number
  /**
   * Timebase
   *
   * Time base used for frame timestamps
   */
  timebase: string
  /**
   * Start Frame Url
   *
   * URL of the extracted first frame
   */
  start_frame_url?: string | unknown
  /**
   * Duration
   *
   * Duration of the media in seconds
   */
  duration: number
  /**
   * Url
   *
   * URL where the media file can be accessed
   */
  url: string
  /**
   * Fps
   *
   * Frames per second
   */
  fps: number
  /**
   * Codec
   *
   * Codec used to encode the media
   */
  codec: string
  /**
   * Media Type
   *
   * Type of media (always 'video')
   */
  media_type?: string
  /**
   * End Frame Url
   *
   * URL of the extracted last frame
   */
  end_frame_url?: string | unknown
  /**
   * Content Type
   *
   * MIME type of the media file
   */
  content_type: string
  /**
   * Container
   *
   * Container format of the media file (e.g., 'mp4', 'mov')
   */
  container: string
  /**
   * Bitrate
   *
   * Overall bitrate of the media in bits per second
   */
  bitrate: number
  format: SchemaVideoFormat
  resolution: SchemaResolution
  /**
   * Frame Count
   *
   * Total number of frames in the video
   */
  frame_count: number
  /**
   * File Name
   *
   * Original filename of the media
   */
  file_name: string
  /**
   * Audio track information if video has audio
   */
  audio?: SchemaAudioTrack | unknown
}

/**
 * MetadataOutput
 */
export type SchemaFfmpegApiMetadataOutput = {
  /**
   * Media
   *
   * Metadata for the analyzed media file (either Video or Audio)
   */
  media: SchemaVideo | SchemaAudio
}

/**
 * MetadataInput
 */
export type SchemaFfmpegApiMetadataInput = {
  /**
   * Extract Frames
   *
   * Whether to extract the start and end frames for videos. Note that when true the request will be slower.
   */
  extract_frames?: boolean
  /**
   * Media Url
   *
   * URL of the media file (video or audio) to analyze
   */
  media_url: string
}

/**
 * WaveformOutput
 */
export type SchemaFfmpegApiWaveformOutput = {
  /**
   * Precision
   *
   * Number of decimal places used in the waveform values
   */
  precision: number
  /**
   * Duration
   *
   * Duration of the audio in seconds
   */
  duration: number
  /**
   * Points
   *
   * Number of points in the waveform data
   */
  points: number
  /**
   * Waveform
   *
   * Normalized waveform data as an array of values between -1 and 1. The number of points is determined by audio duration Ã— points_per_second.
   */
  waveform: Array<number>
}

/**
 * WaveformInput
 */
export type SchemaFfmpegApiWaveformInput = {
  /**
   * Precision
   *
   * Number of decimal places for the waveform values. Higher values provide more precision but increase payload size.
   */
  precision?: number
  /**
   * Smoothing Window
   *
   * Size of the smoothing window. Higher values create a smoother waveform. Must be an odd number.
   */
  smoothing_window?: number
  /**
   * Media Url
   *
   * URL of the audio file to analyze
   */
  media_url: string
  /**
   * Points Per Second
   *
   * Controls how many points are sampled per second of audio. Lower values (e.g. 1-2) create a coarser waveform, higher values (e.g. 4-10) create a more detailed one.
   */
  points_per_second?: number
}

/**
 * File
 */
export type SchemaFile = {
  /**
   * File Size
   *
   * The size of the file in bytes.
   */
  file_size?: number | unknown
  /**
   * File Name
   *
   * The name of the file. It will be auto-generated if not provided.
   */
  file_name?: string | unknown
  /**
   * Content Type
   *
   * The mime type of the file.
   */
  content_type?: string | unknown
  /**
   * Url
   *
   * The URL where the file can be downloaded from.
   */
  url: string
}

/**
 * LoudnormSummary
 */
export type SchemaLoudnormSummary = {
  /**
   * Output Integrated
   *
   * Output integrated loudness in LUFS
   */
  output_integrated?: number | unknown
  /**
   * Output True Peak
   *
   * Output true peak in dBTP
   */
  output_true_peak?: number | unknown
  /**
   * Input Lra
   *
   * Input loudness range in LU
   */
  input_lra?: number | unknown
  /**
   * Normalization Type
   *
   * Type of normalization applied (Dynamic/Linear)
   */
  normalization_type?: string | unknown
  /**
   * Output Lra
   *
   * Output loudness range in LU
   */
  output_lra?: number | unknown
  /**
   * Output Threshold
   *
   * Output threshold in LUFS
   */
  output_threshold?: number | unknown
  /**
   * Input Integrated
   *
   * Input integrated loudness in LUFS
   */
  input_integrated?: number | unknown
  /**
   * Input True Peak
   *
   * Input true peak in dBTP
   */
  input_true_peak?: number | unknown
  /**
   * Target Offset
   *
   * Target offset in LU
   */
  target_offset?: number | unknown
  /**
   * Input Threshold
   *
   * Input threshold in LUFS
   */
  input_threshold?: number | unknown
}

/**
 * LoudnormOutput
 */
export type SchemaFfmpegApiLoudnormOutput = {
  /**
   * Structured loudness measurement summary (if requested)
   */
  summary?: SchemaLoudnormSummary | unknown
  audio: SchemaFile
}

/**
 * LoudnormInput
 */
export type SchemaFfmpegApiLoudnormInput = {
  /**
   * Measured Tp
   *
   * Measured true peak of input file in dBTP. Required for linear mode.
   */
  measured_tp?: number | unknown
  /**
   * Linear
   *
   * Use linear normalization mode (single-pass). If false, uses dynamic mode (two-pass for better quality).
   */
  linear?: boolean
  /**
   * Offset
   *
   * Offset gain in dB applied before the true-peak limiter
   */
  offset?: number
  /**
   * Measured I
   *
   * Measured integrated loudness of input file in LUFS. Required for linear mode.
   */
  measured_i?: number | unknown
  /**
   * Print Summary
   *
   * Return loudness measurement summary with the normalized audio
   */
  print_summary?: boolean
  /**
   * Measured Lra
   *
   * Measured loudness range of input file in LU. Required for linear mode.
   */
  measured_lra?: number | unknown
  /**
   * Measured Thresh
   *
   * Measured threshold of input file in LUFS. Required for linear mode.
   */
  measured_thresh?: number | unknown
  /**
   * Dual Mono
   *
   * Treat mono input files as dual-mono for correct EBU R128 measurement on stereo systems
   */
  dual_mono?: boolean
  /**
   * True Peak
   *
   * Maximum true peak in dBTP.
   */
  true_peak?: number
  /**
   * Audio Url
   *
   * URL of the audio file to normalize
   */
  audio_url: string
  /**
   * Integrated Loudness
   *
   * Integrated loudness target in LUFS.
   */
  integrated_loudness?: number
  /**
   * Loudness Range
   *
   * Loudness range target in LU
   */
  loudness_range?: number
}

export type SchemaQueueStatus = {
  status: 'IN_QUEUE' | 'IN_PROGRESS' | 'COMPLETED'
  /**
   * The request id.
   */
  request_id: string
  /**
   * The response url.
   */
  response_url?: string
  /**
   * The status url.
   */
  status_url?: string
  /**
   * The cancel url.
   */
  cancel_url?: string
  /**
   * The logs.
   */
  logs?: {
    [key: string]: unknown
  }
  /**
   * The metrics.
   */
  metrics?: {
    [key: string]: unknown
  }
  /**
   * The queue position.
   */
  queue_position?: number
}

export type GetFalAiFfmpegApiLoudnormRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ffmpeg-api/loudnorm/requests/{request_id}/status'
}

export type GetFalAiFfmpegApiLoudnormRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFfmpegApiLoudnormRequestsByRequestIdStatusResponse =
  GetFalAiFfmpegApiLoudnormRequestsByRequestIdStatusResponses[keyof GetFalAiFfmpegApiLoudnormRequestsByRequestIdStatusResponses]

export type PutFalAiFfmpegApiLoudnormRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ffmpeg-api/loudnorm/requests/{request_id}/cancel'
}

export type PutFalAiFfmpegApiLoudnormRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFfmpegApiLoudnormRequestsByRequestIdCancelResponse =
  PutFalAiFfmpegApiLoudnormRequestsByRequestIdCancelResponses[keyof PutFalAiFfmpegApiLoudnormRequestsByRequestIdCancelResponses]

export type PostFalAiFfmpegApiLoudnormData = {
  body: SchemaFfmpegApiLoudnormInput
  path?: never
  query?: never
  url: '/fal-ai/ffmpeg-api/loudnorm'
}

export type PostFalAiFfmpegApiLoudnormResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFfmpegApiLoudnormResponse =
  PostFalAiFfmpegApiLoudnormResponses[keyof PostFalAiFfmpegApiLoudnormResponses]

export type GetFalAiFfmpegApiLoudnormRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ffmpeg-api/loudnorm/requests/{request_id}'
}

export type GetFalAiFfmpegApiLoudnormRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFfmpegApiLoudnormOutput
}

export type GetFalAiFfmpegApiLoudnormRequestsByRequestIdResponse =
  GetFalAiFfmpegApiLoudnormRequestsByRequestIdResponses[keyof GetFalAiFfmpegApiLoudnormRequestsByRequestIdResponses]

export type GetFalAiFfmpegApiWaveformRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ffmpeg-api/waveform/requests/{request_id}/status'
}

export type GetFalAiFfmpegApiWaveformRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFfmpegApiWaveformRequestsByRequestIdStatusResponse =
  GetFalAiFfmpegApiWaveformRequestsByRequestIdStatusResponses[keyof GetFalAiFfmpegApiWaveformRequestsByRequestIdStatusResponses]

export type PutFalAiFfmpegApiWaveformRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ffmpeg-api/waveform/requests/{request_id}/cancel'
}

export type PutFalAiFfmpegApiWaveformRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFfmpegApiWaveformRequestsByRequestIdCancelResponse =
  PutFalAiFfmpegApiWaveformRequestsByRequestIdCancelResponses[keyof PutFalAiFfmpegApiWaveformRequestsByRequestIdCancelResponses]

export type PostFalAiFfmpegApiWaveformData = {
  body: SchemaFfmpegApiWaveformInput
  path?: never
  query?: never
  url: '/fal-ai/ffmpeg-api/waveform'
}

export type PostFalAiFfmpegApiWaveformResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFfmpegApiWaveformResponse =
  PostFalAiFfmpegApiWaveformResponses[keyof PostFalAiFfmpegApiWaveformResponses]

export type GetFalAiFfmpegApiWaveformRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ffmpeg-api/waveform/requests/{request_id}'
}

export type GetFalAiFfmpegApiWaveformRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFfmpegApiWaveformOutput
}

export type GetFalAiFfmpegApiWaveformRequestsByRequestIdResponse =
  GetFalAiFfmpegApiWaveformRequestsByRequestIdResponses[keyof GetFalAiFfmpegApiWaveformRequestsByRequestIdResponses]

export type GetFalAiFfmpegApiMetadataRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ffmpeg-api/metadata/requests/{request_id}/status'
}

export type GetFalAiFfmpegApiMetadataRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFfmpegApiMetadataRequestsByRequestIdStatusResponse =
  GetFalAiFfmpegApiMetadataRequestsByRequestIdStatusResponses[keyof GetFalAiFfmpegApiMetadataRequestsByRequestIdStatusResponses]

export type PutFalAiFfmpegApiMetadataRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ffmpeg-api/metadata/requests/{request_id}/cancel'
}

export type PutFalAiFfmpegApiMetadataRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFfmpegApiMetadataRequestsByRequestIdCancelResponse =
  PutFalAiFfmpegApiMetadataRequestsByRequestIdCancelResponses[keyof PutFalAiFfmpegApiMetadataRequestsByRequestIdCancelResponses]

export type PostFalAiFfmpegApiMetadataData = {
  body: SchemaFfmpegApiMetadataInput
  path?: never
  query?: never
  url: '/fal-ai/ffmpeg-api/metadata'
}

export type PostFalAiFfmpegApiMetadataResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFfmpegApiMetadataResponse =
  PostFalAiFfmpegApiMetadataResponses[keyof PostFalAiFfmpegApiMetadataResponses]

export type GetFalAiFfmpegApiMetadataRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ffmpeg-api/metadata/requests/{request_id}'
}

export type GetFalAiFfmpegApiMetadataRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFfmpegApiMetadataOutput
}

export type GetFalAiFfmpegApiMetadataRequestsByRequestIdResponse =
  GetFalAiFfmpegApiMetadataRequestsByRequestIdResponses[keyof GetFalAiFfmpegApiMetadataRequestsByRequestIdResponses]
