// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
  baseUrl: 'https://queue.fal.run' | (string & {})
}

/**
 * HunyuanPartOutput
 */
export type SchemaHunyuanPartOutput = {
  /**
   * Iou Scores
   *
   * IoU scores for each of the three masks.
   */
  iou_scores: Array<number>
  /**
   * Best Mask Index
   *
   * Index of the best mask (1, 2, or 3) based on IoU score.
   */
  best_mask_index: number
  /**
   * Mask 2 Mesh
   *
   * Mesh showing segmentation mask 2.
   */
  mask_2_mesh: SchemaFile
  /**
   * Mask 1 Mesh
   *
   * Mesh showing segmentation mask 1.
   */
  mask_1_mesh: SchemaFile
  /**
   * Segmented Mesh
   *
   * Segmented 3D mesh with mask applied.
   */
  segmented_mesh: SchemaFile
  /**
   * Seed
   *
   * Seed value used for generation.
   */
  seed: number
  /**
   * Mask 3 Mesh
   *
   * Mesh showing segmentation mask 3.
   */
  mask_3_mesh: SchemaFile
}

/**
 * File
 */
export type SchemaFile = {
  /**
   * File Size
   *
   * The size of the file in bytes.
   */
  file_size?: number
  /**
   * File Name
   *
   * The name of the file. It will be auto-generated if not provided.
   */
  file_name?: string
  /**
   * Content Type
   *
   * The mime type of the file.
   */
  content_type?: string
  /**
   * Url
   *
   * The URL where the file can be downloaded from.
   */
  url: string
  /**
   * File Data
   *
   * File data
   */
  file_data?: Blob | File
}

/**
 * HunyuanPartInput
 */
export type SchemaHunyuanPartInput = {
  /**
   * Point Prompt X
   *
   * X coordinate of the point prompt for segmentation (normalized space -1 to 1).
   */
  point_prompt_x?: number
  /**
   * Point Prompt Z
   *
   * Z coordinate of the point prompt for segmentation (normalized space -1 to 1).
   */
  point_prompt_z?: number
  /**
   * Use Normal
   *
   * Whether to use normal information for segmentation.
   */
  use_normal?: boolean
  /**
   * Noise Std
   *
   * Standard deviation of noise to add to sampled points.
   */
  noise_std?: number
  /**
   * Point Num
   *
   * Number of points to sample from the mesh.
   */
  point_num?: number
  /**
   * Model File Url
   *
   * URL of the 3D model file (.glb or .obj) to process for segmentation.
   */
  model_file_url: string
  /**
   * Point Prompt Y
   *
   * Y coordinate of the point prompt for segmentation (normalized space -1 to 1).
   */
  point_prompt_y?: number
  /**
   * Seed
   *
   *
   * The same seed and input will produce the same segmentation results.
   *
   */
  seed?: number
}

/**
 * RemeshOutput
 *
 * Output for 3D Model Remeshing
 */
export type SchemaMeshyV5RemeshOutput = {
  /**
   * Model Urls
   *
   * URLs for different 3D model formats
   */
  model_urls: SchemaModelUrls
  /**
   * Model Glb
   *
   * Remeshed 3D object in GLB format (if GLB was requested).
   */
  model_glb?: SchemaFile
}

/**
 * ModelUrls
 *
 * 3D model files in various formats
 */
export type SchemaModelUrls = {
  /**
   * Usdz
   *
   * USDZ format 3D model
   */
  usdz?: SchemaFile
  /**
   * Fbx
   *
   * FBX format 3D model
   */
  fbx?: SchemaFile
  /**
   * Blend
   *
   * Blender format 3D model
   */
  blend?: SchemaFile
  /**
   * Stl
   *
   * STL format 3D model
   */
  stl?: SchemaFile
  /**
   * Glb
   *
   * GLB format 3D model
   */
  glb?: SchemaFile
  /**
   * Obj
   *
   * OBJ format 3D model
   */
  obj?: SchemaFile
}

/**
 * RemeshInput
 *
 * Input for 3D Model Remeshing
 */
export type SchemaMeshyV5RemeshInput = {
  /**
   * Resize Height
   *
   * Resize the model to a certain height measured in meters. Set to 0 for no resizing.
   */
  resize_height?: number
  /**
   * Topology
   *
   * Specify the topology of the generated model. Quad for smooth surfaces, Triangle for detailed geometry.
   */
  topology?: 'quad' | 'triangle'
  /**
   * Target Polycount
   *
   * Target number of polygons in the generated model. Actual count may vary based on geometry complexity.
   */
  target_polycount?: number
  /**
   * Model Url
   *
   * URL or base64 data URI of a 3D model to remesh. Supports .glb, .gltf, .obj, .fbx, .stl formats. Can be a publicly accessible URL or data URI with MIME type application/octet-stream.
   */
  model_url: string
  /**
   * Origin At
   *
   * Position of the origin. None means no effect.
   */
  origin_at?: 'bottom' | 'center'
  /**
   * Target Formats
   *
   * List of target formats for the remeshed model.
   */
  target_formats?: Array<'glb' | 'fbx' | 'obj' | 'usdz' | 'blend' | 'stl'>
}

/**
 * TextureFiles
 *
 * Texture files downloaded and uploaded to CDN
 */
export type SchemaTextureFiles = {
  /**
   * Base Color
   *
   * Base color texture
   */
  base_color: SchemaFile
  /**
   * Normal
   *
   * Normal texture (PBR)
   */
  normal?: SchemaFile
  /**
   * Roughness
   *
   * Roughness texture (PBR)
   */
  roughness?: SchemaFile
  /**
   * Metallic
   *
   * Metallic texture (PBR)
   */
  metallic?: SchemaFile
}

/**
 * RetextureOutput
 *
 * Output for 3D Model Retexturing
 */
export type SchemaMeshyV5RetextureOutput = {
  /**
   * Model Urls
   *
   * URLs for different 3D model formats
   */
  model_urls: SchemaModelUrls
  /**
   * Text Style Prompt
   *
   * The text prompt used for texturing (if provided)
   */
  text_style_prompt?: string
  /**
   * Texture Urls
   *
   * Array of texture file objects
   */
  texture_urls?: Array<SchemaTextureFiles>
  /**
   * Thumbnail
   *
   * Preview thumbnail of the retextured model
   */
  thumbnail?: SchemaFile
  /**
   * Image Style Url
   *
   * The image URL used for texturing (if provided)
   */
  image_style_url?: string
  /**
   * Model Glb
   *
   * Retextured 3D object in GLB format.
   */
  model_glb: SchemaFile
}

/**
 * RetextureInput
 *
 * Input for 3D Model Retexturing
 */
export type SchemaMeshyV5RetextureInput = {
  /**
   * Enable Pbr
   *
   * Generate PBR Maps (metallic, roughness, normal) in addition to base color.
   */
  enable_pbr?: boolean
  /**
   * Text Style Prompt
   *
   * Describe your desired texture style using text. Maximum 600 characters. Required if image_style_url is not provided.
   */
  text_style_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, input data will be checked for safety before processing.
   */
  enable_safety_checker?: boolean
  /**
   * Enable Original Uv
   *
   * Use the original UV mapping of the model instead of generating new UVs. If the model has no original UV, output quality may be reduced.
   */
  enable_original_uv?: boolean
  /**
   * Model Url
   *
   * URL or base64 data URI of a 3D model to texture. Supports .glb, .gltf, .obj, .fbx, .stl formats. Can be a publicly accessible URL or data URI with MIME type application/octet-stream.
   */
  model_url: string
  /**
   * Image Style Url
   *
   * 2D image to guide the texturing process. Supports .jpg, .jpeg, and .png formats. Required if text_style_prompt is not provided. If both are provided, image_style_url takes precedence.
   */
  image_style_url?: string
}

/**
 * SAM3DBodyAlignmentInfo
 *
 * Per-person alignment metadata.
 */
export type SchemaSam3dBodyAlignmentInfo = {
  /**
   * Translation
   *
   * Translation [tx, ty, tz]
   */
  translation: Array<number>
  /**
   * Cropped Vertices Count
   *
   * Number of cropped vertices
   */
  cropped_vertices_count: number
  /**
   * Person Id
   *
   * Index of the person
   */
  person_id: number
  /**
   * Target Points Count
   *
   * Number of target points for alignment
   */
  target_points_count: number
  /**
   * Scale Factor
   *
   * Scale factor applied for alignment
   */
  scale_factor: number
  /**
   * Focal Length
   *
   * Focal length used
   */
  focal_length: number
}

/**
 * SAM3DAlignmentOutput
 */
export type SchemaSam33dAlignOutput = {
  /**
   * Scene Glb
   *
   * Combined scene with body + object meshes in GLB format (only when object_mesh_url provided)
   */
  scene_glb?: SchemaFile
  /**
   * Visualization
   *
   * Visualization of aligned mesh overlaid on input image
   */
  visualization: SchemaFile
  /**
   * Metadata
   *
   * Alignment info (scale, translation, etc.)
   */
  metadata: SchemaSam3dBodyAlignmentInfo
  /**
   * Body Mesh Ply
   *
   * Aligned body mesh in PLY format
   */
  body_mesh_ply: SchemaFile
  /**
   * Model Glb
   *
   * Aligned body mesh in GLB format (for 3D preview)
   */
  model_glb: SchemaFile
}

/**
 * SAM3DAlignmentInput
 */
export type SchemaSam33dAlignInput = {
  /**
   * Image Url
   *
   * URL of the original image used for MoGe depth estimation
   */
  image_url: string
  /**
   * Body Mesh Url
   *
   * URL of the SAM-3D Body mesh file (.ply or .glb) to align
   */
  body_mesh_url: string
  /**
   * Object Mesh Url
   *
   * Optional URL of SAM-3D Object mesh (.glb) to create combined scene
   */
  object_mesh_url?: string
  /**
   * Focal Length
   *
   * Focal length from SAM-3D Body metadata. If not provided, estimated from MoGe.
   */
  focal_length?: number
  /**
   * Body Mask Url
   *
   * URL of the human mask image. If not provided, uses full image.
   */
  body_mask_url?: string
}

/**
 * UltraShapeResponse
 */
export type SchemaUltrashapeOutput = {
  /**
   * Model Glb
   *
   * Generated 3D object.
   */
  model_glb: SchemaFile
}

/**
 * UltraShapeRequest
 */
export type SchemaUltrashapeInput = {
  /**
   * Octree Resolution
   *
   * Marching cubes resolution.
   */
  octree_resolution?: number
  /**
   * Remove Background
   *
   * Remove image background.
   */
  remove_background?: boolean
  /**
   * Num Inference Steps
   *
   * Diffusion steps.
   */
  num_inference_steps?: number
  /**
   * Model Url
   *
   * URL of the coarse mesh (.glb or .obj) to refine.
   */
  model_url: string
  /**
   * Seed
   *
   * Random seed.
   */
  seed?: number
  /**
   * Image Url
   *
   * URL of the reference image for mesh refinement.
   */
  image_url: string
}

export type SchemaQueueStatus = {
  status: 'IN_QUEUE' | 'IN_PROGRESS' | 'COMPLETED'
  /**
   * The request id.
   */
  request_id: string
  /**
   * The response url.
   */
  response_url?: string
  /**
   * The status url.
   */
  status_url?: string
  /**
   * The cancel url.
   */
  cancel_url?: string
  /**
   * The logs.
   */
  logs?: {
    [key: string]: unknown
  }
  /**
   * The metrics.
   */
  metrics?: {
    [key: string]: unknown
  }
  /**
   * The queue position.
   */
  queue_position?: number
}

export type GetFalAiUltrashapeRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ultrashape/requests/{request_id}/status'
}

export type GetFalAiUltrashapeRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiUltrashapeRequestsByRequestIdStatusResponse =
  GetFalAiUltrashapeRequestsByRequestIdStatusResponses[keyof GetFalAiUltrashapeRequestsByRequestIdStatusResponses]

export type PutFalAiUltrashapeRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ultrashape/requests/{request_id}/cancel'
}

export type PutFalAiUltrashapeRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiUltrashapeRequestsByRequestIdCancelResponse =
  PutFalAiUltrashapeRequestsByRequestIdCancelResponses[keyof PutFalAiUltrashapeRequestsByRequestIdCancelResponses]

export type PostFalAiUltrashapeData = {
  body: SchemaUltrashapeInput
  path?: never
  query?: never
  url: '/fal-ai/ultrashape'
}

export type PostFalAiUltrashapeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiUltrashapeResponse =
  PostFalAiUltrashapeResponses[keyof PostFalAiUltrashapeResponses]

export type GetFalAiUltrashapeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ultrashape/requests/{request_id}'
}

export type GetFalAiUltrashapeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaUltrashapeOutput
}

export type GetFalAiUltrashapeRequestsByRequestIdResponse =
  GetFalAiUltrashapeRequestsByRequestIdResponses[keyof GetFalAiUltrashapeRequestsByRequestIdResponses]

export type GetFalAiSam33dAlignRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/sam-3/3d-align/requests/{request_id}/status'
}

export type GetFalAiSam33dAlignRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiSam33dAlignRequestsByRequestIdStatusResponse =
  GetFalAiSam33dAlignRequestsByRequestIdStatusResponses[keyof GetFalAiSam33dAlignRequestsByRequestIdStatusResponses]

export type PutFalAiSam33dAlignRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sam-3/3d-align/requests/{request_id}/cancel'
}

export type PutFalAiSam33dAlignRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiSam33dAlignRequestsByRequestIdCancelResponse =
  PutFalAiSam33dAlignRequestsByRequestIdCancelResponses[keyof PutFalAiSam33dAlignRequestsByRequestIdCancelResponses]

export type PostFalAiSam33dAlignData = {
  body: SchemaSam33dAlignInput
  path?: never
  query?: never
  url: '/fal-ai/sam-3/3d-align'
}

export type PostFalAiSam33dAlignResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiSam33dAlignResponse =
  PostFalAiSam33dAlignResponses[keyof PostFalAiSam33dAlignResponses]

export type GetFalAiSam33dAlignRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sam-3/3d-align/requests/{request_id}'
}

export type GetFalAiSam33dAlignRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaSam33dAlignOutput
}

export type GetFalAiSam33dAlignRequestsByRequestIdResponse =
  GetFalAiSam33dAlignRequestsByRequestIdResponses[keyof GetFalAiSam33dAlignRequestsByRequestIdResponses]

export type GetFalAiMeshyV5RetextureRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/meshy/v5/retexture/requests/{request_id}/status'
}

export type GetFalAiMeshyV5RetextureRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiMeshyV5RetextureRequestsByRequestIdStatusResponse =
  GetFalAiMeshyV5RetextureRequestsByRequestIdStatusResponses[keyof GetFalAiMeshyV5RetextureRequestsByRequestIdStatusResponses]

export type PutFalAiMeshyV5RetextureRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/meshy/v5/retexture/requests/{request_id}/cancel'
}

export type PutFalAiMeshyV5RetextureRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiMeshyV5RetextureRequestsByRequestIdCancelResponse =
  PutFalAiMeshyV5RetextureRequestsByRequestIdCancelResponses[keyof PutFalAiMeshyV5RetextureRequestsByRequestIdCancelResponses]

export type PostFalAiMeshyV5RetextureData = {
  body: SchemaMeshyV5RetextureInput
  path?: never
  query?: never
  url: '/fal-ai/meshy/v5/retexture'
}

export type PostFalAiMeshyV5RetextureResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiMeshyV5RetextureResponse =
  PostFalAiMeshyV5RetextureResponses[keyof PostFalAiMeshyV5RetextureResponses]

export type GetFalAiMeshyV5RetextureRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/meshy/v5/retexture/requests/{request_id}'
}

export type GetFalAiMeshyV5RetextureRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaMeshyV5RetextureOutput
}

export type GetFalAiMeshyV5RetextureRequestsByRequestIdResponse =
  GetFalAiMeshyV5RetextureRequestsByRequestIdResponses[keyof GetFalAiMeshyV5RetextureRequestsByRequestIdResponses]

export type GetFalAiMeshyV5RemeshRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/meshy/v5/remesh/requests/{request_id}/status'
}

export type GetFalAiMeshyV5RemeshRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiMeshyV5RemeshRequestsByRequestIdStatusResponse =
  GetFalAiMeshyV5RemeshRequestsByRequestIdStatusResponses[keyof GetFalAiMeshyV5RemeshRequestsByRequestIdStatusResponses]

export type PutFalAiMeshyV5RemeshRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/meshy/v5/remesh/requests/{request_id}/cancel'
}

export type PutFalAiMeshyV5RemeshRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiMeshyV5RemeshRequestsByRequestIdCancelResponse =
  PutFalAiMeshyV5RemeshRequestsByRequestIdCancelResponses[keyof PutFalAiMeshyV5RemeshRequestsByRequestIdCancelResponses]

export type PostFalAiMeshyV5RemeshData = {
  body: SchemaMeshyV5RemeshInput
  path?: never
  query?: never
  url: '/fal-ai/meshy/v5/remesh'
}

export type PostFalAiMeshyV5RemeshResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiMeshyV5RemeshResponse =
  PostFalAiMeshyV5RemeshResponses[keyof PostFalAiMeshyV5RemeshResponses]

export type GetFalAiMeshyV5RemeshRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/meshy/v5/remesh/requests/{request_id}'
}

export type GetFalAiMeshyV5RemeshRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaMeshyV5RemeshOutput
}

export type GetFalAiMeshyV5RemeshRequestsByRequestIdResponse =
  GetFalAiMeshyV5RemeshRequestsByRequestIdResponses[keyof GetFalAiMeshyV5RemeshRequestsByRequestIdResponses]

export type GetFalAiHunyuanPartRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/hunyuan-part/requests/{request_id}/status'
}

export type GetFalAiHunyuanPartRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiHunyuanPartRequestsByRequestIdStatusResponse =
  GetFalAiHunyuanPartRequestsByRequestIdStatusResponses[keyof GetFalAiHunyuanPartRequestsByRequestIdStatusResponses]

export type PutFalAiHunyuanPartRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/hunyuan-part/requests/{request_id}/cancel'
}

export type PutFalAiHunyuanPartRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiHunyuanPartRequestsByRequestIdCancelResponse =
  PutFalAiHunyuanPartRequestsByRequestIdCancelResponses[keyof PutFalAiHunyuanPartRequestsByRequestIdCancelResponses]

export type PostFalAiHunyuanPartData = {
  body: SchemaHunyuanPartInput
  path?: never
  query?: never
  url: '/fal-ai/hunyuan-part'
}

export type PostFalAiHunyuanPartResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiHunyuanPartResponse =
  PostFalAiHunyuanPartResponses[keyof PostFalAiHunyuanPartResponses]

export type GetFalAiHunyuanPartRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/hunyuan-part/requests/{request_id}'
}

export type GetFalAiHunyuanPartRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaHunyuanPartOutput
}

export type GetFalAiHunyuanPartRequestsByRequestIdResponse =
  GetFalAiHunyuanPartRequestsByRequestIdResponses[keyof GetFalAiHunyuanPartRequestsByRequestIdResponses]
