// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: `${string}://${string}` | (string & {});
};

export type File = {
    url: string;
    content_type?: string;
    file_name?: string;
    file_size?: number;
};

export type QueueStatus = {
    status: 'IN_PROGRESS' | 'COMPLETED' | 'FAILED';
    response_url?: string;
};

/**
 * UltraShapeRequest
 */
export type UltrashapeInput = {
    /**
     * Octree Resolution
     *
     * Marching cubes resolution.
     */
    octree_resolution?: number;
    /**
     * Remove Background
     *
     * Remove image background.
     */
    remove_background?: boolean;
    /**
     * Num Inference Steps
     *
     * Diffusion steps.
     */
    num_inference_steps?: number;
    /**
     * Model Url
     *
     * URL of the coarse mesh (.glb or .obj) to refine.
     */
    model_url: string;
    /**
     * Seed
     *
     * Random seed.
     */
    seed?: number;
    /**
     * Image Url
     *
     * URL of the reference image for mesh refinement.
     */
    image_url: string;
};

/**
 * UltraShapeResponse
 */
export type UltrashapeOutput = {
    /**
     * Model Glb
     *
     * Generated 3D object.
     */
    model_glb: FalAiUltrashapeFile;
};

/**
 * File
 */
export type FalAiUltrashapeFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * SAM3DAlignmentInput
 */
export type Sam33dAlignInput = {
    /**
     * Image Url
     *
     * URL of the original image used for MoGe depth estimation
     */
    image_url: string;
    /**
     * Body Mesh Url
     *
     * URL of the SAM-3D Body mesh file (.ply or .glb) to align
     */
    body_mesh_url: string;
    /**
     * Object Mesh Url
     *
     * Optional URL of SAM-3D Object mesh (.glb) to create combined scene
     */
    object_mesh_url?: string;
    /**
     * Focal Length
     *
     * Focal length from SAM-3D Body metadata. If not provided, estimated from MoGe.
     */
    focal_length?: number;
    /**
     * Body Mask Url
     *
     * URL of the human mask image. If not provided, uses full image.
     */
    body_mask_url?: string;
};

/**
 * SAM3DAlignmentOutput
 */
export type Sam33dAlignOutput = {
    /**
     * Scene Glb
     *
     * Combined scene with body + object meshes in GLB format (only when object_mesh_url provided)
     */
    scene_glb?: FalAiSam33dAlignFile;
    /**
     * Visualization
     *
     * Visualization of aligned mesh overlaid on input image
     */
    visualization: FalAiSam33dAlignFile;
    /**
     * Metadata
     *
     * Alignment info (scale, translation, etc.)
     */
    metadata: Sam3dBodyAlignmentInfo;
    /**
     * Body Mesh Ply
     *
     * Aligned body mesh in PLY format
     */
    body_mesh_ply: FalAiSam33dAlignFile;
    /**
     * Model Glb
     *
     * Aligned body mesh in GLB format (for 3D preview)
     */
    model_glb: FalAiSam33dAlignFile;
};

/**
 * File
 */
export type FalAiSam33dAlignFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * SAM3DBodyAlignmentInfo
 *
 * Per-person alignment metadata.
 */
export type Sam3dBodyAlignmentInfo = {
    /**
     * Translation
     *
     * Translation [tx, ty, tz]
     */
    translation: Array<number>;
    /**
     * Cropped Vertices Count
     *
     * Number of cropped vertices
     */
    cropped_vertices_count: number;
    /**
     * Person Id
     *
     * Index of the person
     */
    person_id: number;
    /**
     * Target Points Count
     *
     * Number of target points for alignment
     */
    target_points_count: number;
    /**
     * Scale Factor
     *
     * Scale factor applied for alignment
     */
    scale_factor: number;
    /**
     * Focal Length
     *
     * Focal length used
     */
    focal_length: number;
};

/**
 * RetextureInput
 *
 * Input for 3D Model Retexturing
 */
export type MeshyV5RetextureInput = {
    /**
     * Enable Pbr
     *
     * Generate PBR Maps (metallic, roughness, normal) in addition to base color.
     */
    enable_pbr?: boolean;
    /**
     * Text Style Prompt
     *
     * Describe your desired texture style using text. Maximum 600 characters. Required if image_style_url is not provided.
     */
    text_style_prompt?: string;
    /**
     * Enable Safety Checker
     *
     * If set to true, input data will be checked for safety before processing.
     */
    enable_safety_checker?: boolean;
    /**
     * Enable Original Uv
     *
     * Use the original UV mapping of the model instead of generating new UVs. If the model has no original UV, output quality may be reduced.
     */
    enable_original_uv?: boolean;
    /**
     * Model Url
     *
     * URL or base64 data URI of a 3D model to texture. Supports .glb, .gltf, .obj, .fbx, .stl formats. Can be a publicly accessible URL or data URI with MIME type application/octet-stream.
     */
    model_url: string;
    /**
     * Image Style Url
     *
     * 2D image to guide the texturing process. Supports .jpg, .jpeg, and .png formats. Required if text_style_prompt is not provided. If both are provided, image_style_url takes precedence.
     */
    image_style_url?: string;
};

/**
 * RetextureOutput
 *
 * Output for 3D Model Retexturing
 */
export type MeshyV5RetextureOutput = {
    /**
     * Model Urls
     *
     * URLs for different 3D model formats
     */
    model_urls: ModelUrls;
    /**
     * Text Style Prompt
     *
     * The text prompt used for texturing (if provided)
     */
    text_style_prompt?: string;
    /**
     * Texture Urls
     *
     * Array of texture file objects
     */
    texture_urls?: Array<TextureFiles>;
    /**
     * Thumbnail
     *
     * Preview thumbnail of the retextured model
     */
    thumbnail?: FalAiMeshyV5RetextureFile;
    /**
     * Image Style Url
     *
     * The image URL used for texturing (if provided)
     */
    image_style_url?: string;
    /**
     * Model Glb
     *
     * Retextured 3D object in GLB format.
     */
    model_glb: FalAiMeshyV5RetextureFile;
};

/**
 * ModelUrls
 *
 * 3D model files in various formats
 */
export type ModelUrls = {
    /**
     * Usdz
     *
     * USDZ format 3D model
     */
    usdz?: FalAiMeshyV5RetextureFile;
    /**
     * Fbx
     *
     * FBX format 3D model
     */
    fbx?: FalAiMeshyV5RetextureFile;
    /**
     * Blend
     *
     * Blender format 3D model
     */
    blend?: FalAiMeshyV5RetextureFile;
    /**
     * Stl
     *
     * STL format 3D model
     */
    stl?: FalAiMeshyV5RetextureFile;
    /**
     * Glb
     *
     * GLB format 3D model
     */
    glb?: FalAiMeshyV5RetextureFile;
    /**
     * Obj
     *
     * OBJ format 3D model
     */
    obj?: FalAiMeshyV5RetextureFile;
};

/**
 * TextureFiles
 *
 * Texture files downloaded and uploaded to CDN
 */
export type TextureFiles = {
    /**
     * Base Color
     *
     * Base color texture
     */
    base_color: FalAiMeshyV5RetextureFile;
    /**
     * Normal
     *
     * Normal texture (PBR)
     */
    normal?: FalAiMeshyV5RetextureFile;
    /**
     * Roughness
     *
     * Roughness texture (PBR)
     */
    roughness?: FalAiMeshyV5RetextureFile;
    /**
     * Metallic
     *
     * Metallic texture (PBR)
     */
    metallic?: FalAiMeshyV5RetextureFile;
};

/**
 * File
 */
export type FalAiMeshyV5RetextureFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * RemeshInput
 *
 * Input for 3D Model Remeshing
 */
export type MeshyV5RemeshInput = {
    /**
     * Resize Height
     *
     * Resize the model to a certain height measured in meters. Set to 0 for no resizing.
     */
    resize_height?: number;
    /**
     * Topology
     *
     * Specify the topology of the generated model. Quad for smooth surfaces, Triangle for detailed geometry.
     */
    topology?: 'quad' | 'triangle';
    /**
     * Target Polycount
     *
     * Target number of polygons in the generated model. Actual count may vary based on geometry complexity.
     */
    target_polycount?: number;
    /**
     * Model Url
     *
     * URL or base64 data URI of a 3D model to remesh. Supports .glb, .gltf, .obj, .fbx, .stl formats. Can be a publicly accessible URL or data URI with MIME type application/octet-stream.
     */
    model_url: string;
    /**
     * Origin At
     *
     * Position of the origin. None means no effect.
     */
    origin_at?: 'bottom' | 'center';
    /**
     * Target Formats
     *
     * List of target formats for the remeshed model.
     */
    target_formats?: Array<'glb' | 'fbx' | 'obj' | 'usdz' | 'blend' | 'stl'>;
};

/**
 * RemeshOutput
 *
 * Output for 3D Model Remeshing
 */
export type MeshyV5RemeshOutput = {
    /**
     * Model Urls
     *
     * URLs for different 3D model formats
     */
    model_urls: FalAiMeshyV5RemeshModelUrls;
    /**
     * Model Glb
     *
     * Remeshed 3D object in GLB format (if GLB was requested).
     */
    model_glb?: FalAiMeshyV5RemeshFile;
};

/**
 * ModelUrls
 *
 * 3D model files in various formats
 */
export type FalAiMeshyV5RemeshModelUrls = {
    /**
     * Usdz
     *
     * USDZ format 3D model
     */
    usdz?: FalAiMeshyV5RemeshFile;
    /**
     * Fbx
     *
     * FBX format 3D model
     */
    fbx?: FalAiMeshyV5RemeshFile;
    /**
     * Blend
     *
     * Blender format 3D model
     */
    blend?: FalAiMeshyV5RemeshFile;
    /**
     * Stl
     *
     * STL format 3D model
     */
    stl?: FalAiMeshyV5RemeshFile;
    /**
     * Glb
     *
     * GLB format 3D model
     */
    glb?: FalAiMeshyV5RemeshFile;
    /**
     * Obj
     *
     * OBJ format 3D model
     */
    obj?: FalAiMeshyV5RemeshFile;
};

/**
 * File
 */
export type FalAiMeshyV5RemeshFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * HunyuanPartInput
 */
export type HunyuanPartInput = {
    /**
     * Point Prompt X
     *
     * X coordinate of the point prompt for segmentation (normalized space -1 to 1).
     */
    point_prompt_x?: number;
    /**
     * Point Prompt Z
     *
     * Z coordinate of the point prompt for segmentation (normalized space -1 to 1).
     */
    point_prompt_z?: number;
    /**
     * Use Normal
     *
     * Whether to use normal information for segmentation.
     */
    use_normal?: boolean;
    /**
     * Noise Std
     *
     * Standard deviation of noise to add to sampled points.
     */
    noise_std?: number;
    /**
     * Point Num
     *
     * Number of points to sample from the mesh.
     */
    point_num?: number;
    /**
     * Model File Url
     *
     * URL of the 3D model file (.glb or .obj) to process for segmentation.
     */
    model_file_url: string;
    /**
     * Point Prompt Y
     *
     * Y coordinate of the point prompt for segmentation (normalized space -1 to 1).
     */
    point_prompt_y?: number;
    /**
     * Seed
     *
     *
     * The same seed and input will produce the same segmentation results.
     *
     */
    seed?: number;
};

/**
 * HunyuanPartOutput
 */
export type HunyuanPartOutput = {
    /**
     * Iou Scores
     *
     * IoU scores for each of the three masks.
     */
    iou_scores: Array<number>;
    /**
     * Best Mask Index
     *
     * Index of the best mask (1, 2, or 3) based on IoU score.
     */
    best_mask_index: number;
    /**
     * Mask 2 Mesh
     *
     * Mesh showing segmentation mask 2.
     */
    mask_2_mesh: FalAiHunyuanPartFile;
    /**
     * Mask 1 Mesh
     *
     * Mesh showing segmentation mask 1.
     */
    mask_1_mesh: FalAiHunyuanPartFile;
    /**
     * Segmented Mesh
     *
     * Segmented 3D mesh with mask applied.
     */
    segmented_mesh: FalAiHunyuanPartFile;
    /**
     * Seed
     *
     * Seed value used for generation.
     */
    seed: number;
    /**
     * Mask 3 Mesh
     *
     * Mesh showing segmentation mask 3.
     */
    mask_3_mesh: FalAiHunyuanPartFile;
};

/**
 * File
 */
export type FalAiHunyuanPartFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};
