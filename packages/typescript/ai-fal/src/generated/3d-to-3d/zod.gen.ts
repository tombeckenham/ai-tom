// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod'

export const zFile = z.object({
  url: z.url(),
  content_type: z.optional(z.string()),
  file_name: z.optional(z.string()),
  file_size: z.optional(z.int()),
})

export const zQueueStatus = z.object({
  status: z.enum(['IN_PROGRESS', 'COMPLETED', 'FAILED']),
  response_url: z.optional(z.url()),
})

/**
 * UltraShapeRequest
 */
export const zUltrashapeInput = z.object({
  octree_resolution: z
    .optional(
      z.int().gte(128).lte(1024).register(z.globalRegistry, {
        description: 'Marching cubes resolution.',
      }),
    )
    .default(1024),
  remove_background: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Remove image background.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Diffusion steps.',
      }),
    )
    .default(50),
  model_url: z.string().register(z.globalRegistry, {
    description: 'URL of the coarse mesh (.glb or .obj) to refine.',
  }),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Random seed.',
      }),
    )
    .default(42),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the reference image for mesh refinement.',
  }),
})

/**
 * File
 */
export const zFalAiUltrashapeFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * UltraShapeResponse
 */
export const zUltrashapeOutput = z.object({
  model_glb: zFalAiUltrashapeFile,
})

/**
 * SAM3DAlignmentInput
 */
export const zSam33dAlignInput = z.object({
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the original image used for MoGe depth estimation',
  }),
  body_mesh_url: z.string().register(z.globalRegistry, {
    description: 'URL of the SAM-3D Body mesh file (.ply or .glb) to align',
  }),
  object_mesh_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Optional URL of SAM-3D Object mesh (.glb) to create combined scene',
    }),
  ),
  focal_length: z.optional(
    z.number().register(z.globalRegistry, {
      description:
        'Focal length from SAM-3D Body metadata. If not provided, estimated from MoGe.',
    }),
  ),
  body_mask_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'URL of the human mask image. If not provided, uses full image.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiSam33dAlignFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * SAM3DBodyAlignmentInfo
 *
 * Per-person alignment metadata.
 */
export const zSam3dBodyAlignmentInfo = z
  .object({
    translation: z.array(z.number()).register(z.globalRegistry, {
      description: 'Translation [tx, ty, tz]',
    }),
    cropped_vertices_count: z.int().register(z.globalRegistry, {
      description: 'Number of cropped vertices',
    }),
    person_id: z.int().register(z.globalRegistry, {
      description: 'Index of the person',
    }),
    target_points_count: z.int().register(z.globalRegistry, {
      description: 'Number of target points for alignment',
    }),
    scale_factor: z.number().register(z.globalRegistry, {
      description: 'Scale factor applied for alignment',
    }),
    focal_length: z.number().register(z.globalRegistry, {
      description: 'Focal length used',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Per-person alignment metadata.',
  })

/**
 * SAM3DAlignmentOutput
 */
export const zSam33dAlignOutput = z.object({
  scene_glb: z.optional(zFalAiSam33dAlignFile),
  visualization: zFalAiSam33dAlignFile,
  metadata: zSam3dBodyAlignmentInfo,
  body_mesh_ply: zFalAiSam33dAlignFile,
  model_glb: zFalAiSam33dAlignFile,
})

/**
 * RetextureInput
 *
 * Input for 3D Model Retexturing
 */
export const zMeshyV5RetextureInput = z
  .object({
    enable_pbr: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Generate PBR Maps (metallic, roughness, normal) in addition to base color.',
        }),
      )
      .default(false),
    text_style_prompt: z.optional(
      z.string().max(600).register(z.globalRegistry, {
        description:
          'Describe your desired texture style using text. Maximum 600 characters. Required if image_style_url is not provided.',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If set to true, input data will be checked for safety before processing.',
        }),
      )
      .default(true),
    enable_original_uv: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Use the original UV mapping of the model instead of generating new UVs. If the model has no original UV, output quality may be reduced.',
        }),
      )
      .default(true),
    model_url: z.string().register(z.globalRegistry, {
      description:
        'URL or base64 data URI of a 3D model to texture. Supports .glb, .gltf, .obj, .fbx, .stl formats. Can be a publicly accessible URL or data URI with MIME type application/octet-stream.',
    }),
    image_style_url: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          '2D image to guide the texturing process. Supports .jpg, .jpeg, and .png formats. Required if text_style_prompt is not provided. If both are provided, image_style_url takes precedence.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Input for 3D Model Retexturing',
  })

/**
 * File
 */
export const zFalAiMeshyV5RetextureFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ModelUrls
 *
 * 3D model files in various formats
 */
export const zModelUrls = z
  .object({
    usdz: z.optional(zFalAiMeshyV5RetextureFile),
    fbx: z.optional(zFalAiMeshyV5RetextureFile),
    blend: z.optional(zFalAiMeshyV5RetextureFile),
    stl: z.optional(zFalAiMeshyV5RetextureFile),
    glb: z.optional(zFalAiMeshyV5RetextureFile),
    obj: z.optional(zFalAiMeshyV5RetextureFile),
  })
  .register(z.globalRegistry, {
    description: '3D model files in various formats',
  })

/**
 * TextureFiles
 *
 * Texture files downloaded and uploaded to CDN
 */
export const zTextureFiles = z
  .object({
    base_color: zFalAiMeshyV5RetextureFile,
    normal: z.optional(zFalAiMeshyV5RetextureFile),
    roughness: z.optional(zFalAiMeshyV5RetextureFile),
    metallic: z.optional(zFalAiMeshyV5RetextureFile),
  })
  .register(z.globalRegistry, {
    description: 'Texture files downloaded and uploaded to CDN',
  })

/**
 * RetextureOutput
 *
 * Output for 3D Model Retexturing
 */
export const zMeshyV5RetextureOutput = z
  .object({
    model_urls: zModelUrls,
    text_style_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The text prompt used for texturing (if provided)',
      }),
    ),
    texture_urls: z.optional(
      z.array(zTextureFiles).register(z.globalRegistry, {
        description: 'Array of texture file objects',
      }),
    ),
    thumbnail: z.optional(zFalAiMeshyV5RetextureFile),
    image_style_url: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The image URL used for texturing (if provided)',
      }),
    ),
    model_glb: zFalAiMeshyV5RetextureFile,
  })
  .register(z.globalRegistry, {
    description: 'Output for 3D Model Retexturing',
  })

/**
 * RemeshInput
 *
 * Input for 3D Model Remeshing
 */
export const zMeshyV5RemeshInput = z
  .object({
    resize_height: z
      .optional(
        z.number().gte(0).register(z.globalRegistry, {
          description:
            'Resize the model to a certain height measured in meters. Set to 0 for no resizing.',
        }),
      )
      .default(0),
    topology: z.optional(
      z.enum(['quad', 'triangle']).register(z.globalRegistry, {
        description:
          'Specify the topology of the generated model. Quad for smooth surfaces, Triangle for detailed geometry.',
      }),
    ),
    target_polycount: z
      .optional(
        z.int().gte(100).lte(300000).register(z.globalRegistry, {
          description:
            'Target number of polygons in the generated model. Actual count may vary based on geometry complexity.',
        }),
      )
      .default(30000),
    model_url: z.string().register(z.globalRegistry, {
      description:
        'URL or base64 data URI of a 3D model to remesh. Supports .glb, .gltf, .obj, .fbx, .stl formats. Can be a publicly accessible URL or data URI with MIME type application/octet-stream.',
    }),
    origin_at: z.optional(
      z.enum(['bottom', 'center']).register(z.globalRegistry, {
        description: 'Position of the origin. None means no effect.',
      }),
    ),
    target_formats: z
      .optional(
        z
          .array(z.enum(['glb', 'fbx', 'obj', 'usdz', 'blend', 'stl']))
          .register(z.globalRegistry, {
            description: 'List of target formats for the remeshed model.',
          }),
      )
      .default(['glb']),
  })
  .register(z.globalRegistry, {
    description: 'Input for 3D Model Remeshing',
  })

/**
 * File
 */
export const zFalAiMeshyV5RemeshFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ModelUrls
 *
 * 3D model files in various formats
 */
export const zFalAiMeshyV5RemeshModelUrls = z
  .object({
    usdz: z.optional(zFalAiMeshyV5RemeshFile),
    fbx: z.optional(zFalAiMeshyV5RemeshFile),
    blend: z.optional(zFalAiMeshyV5RemeshFile),
    stl: z.optional(zFalAiMeshyV5RemeshFile),
    glb: z.optional(zFalAiMeshyV5RemeshFile),
    obj: z.optional(zFalAiMeshyV5RemeshFile),
  })
  .register(z.globalRegistry, {
    description: '3D model files in various formats',
  })

/**
 * RemeshOutput
 *
 * Output for 3D Model Remeshing
 */
export const zMeshyV5RemeshOutput = z
  .object({
    model_urls: zFalAiMeshyV5RemeshModelUrls,
    model_glb: z.optional(zFalAiMeshyV5RemeshFile),
  })
  .register(z.globalRegistry, {
    description: 'Output for 3D Model Remeshing',
  })

/**
 * HunyuanPartInput
 */
export const zHunyuanPartInput = z.object({
  point_prompt_x: z
    .optional(
      z.number().gte(-1).lte(1).register(z.globalRegistry, {
        description:
          'X coordinate of the point prompt for segmentation (normalized space -1 to 1).',
      }),
    )
    .default(0),
  point_prompt_z: z
    .optional(
      z.number().gte(-1).lte(1).register(z.globalRegistry, {
        description:
          'Z coordinate of the point prompt for segmentation (normalized space -1 to 1).',
      }),
    )
    .default(0),
  use_normal: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to use normal information for segmentation.',
      }),
    )
    .default(true),
  noise_std: z
    .optional(
      z.number().gte(0).lte(0.02).register(z.globalRegistry, {
        description: 'Standard deviation of noise to add to sampled points.',
      }),
    )
    .default(0),
  point_num: z
    .optional(
      z.int().gte(10000).lte(500000).register(z.globalRegistry, {
        description: 'Number of points to sample from the mesh.',
      }),
    )
    .default(100000),
  model_file_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the 3D model file (.glb or .obj) to process for segmentation.',
  }),
  point_prompt_y: z
    .optional(
      z.number().gte(-1).lte(1).register(z.globalRegistry, {
        description:
          'Y coordinate of the point prompt for segmentation (normalized space -1 to 1).',
      }),
    )
    .default(0),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and input will produce the same segmentation results.\n        ',
    }),
  ),
})

/**
 * File
 */
export const zFalAiHunyuanPartFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * HunyuanPartOutput
 */
export const zHunyuanPartOutput = z.object({
  iou_scores: z.array(z.number()).register(z.globalRegistry, {
    description: 'IoU scores for each of the three masks.',
  }),
  best_mask_index: z.int().register(z.globalRegistry, {
    description: 'Index of the best mask (1, 2, or 3) based on IoU score.',
  }),
  mask_2_mesh: zFalAiHunyuanPartFile,
  mask_1_mesh: zFalAiHunyuanPartFile,
  segmented_mesh: zFalAiHunyuanPartFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
  mask_3_mesh: zFalAiHunyuanPartFile,
})
