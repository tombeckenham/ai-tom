// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod'

/**
 * Audio
 */
export const zSchemaAudio = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * AudioOutput
 */
export const zSchemaSfxV1VideoToAudioOutput = z.object({
  audio: z.array(zSchemaAudio).register(z.globalRegistry, {
    description: 'The generated sound effects audio',
  }),
})

/**
 * Input
 */
export const zSchemaSfxV1VideoToAudioInput = z.object({
  num_samples: z.optional(z.union([z.int().gte(2).lte(8), z.unknown()])),
  video_url: z.union([z.string(), z.string()]),
  duration: z.optional(z.union([z.number().gte(1).lte(10), z.unknown()])),
  seed: z.optional(z.union([z.int().gte(1), z.unknown()])),
  text_prompt: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * File
 */
export const zSchemaFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * VideoToAudioOutput
 */
export const zSchemaKlingVideoVideoToAudioOutput = z.object({
  audio: zSchemaFile,
  video: zSchemaFile,
})

/**
 * VideoToAudioInput
 */
export const zSchemaKlingVideoVideoToAudioInput = z.object({
  video_url: z.union([z.string(), z.string()]),
  asmr_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Enable ASMR mode. This mode enhances detailed sound effects and is suitable for highly immersive content scenarios.',
      }),
    )
    .default(false),
  background_music_prompt: z
    .optional(
      z.string().max(200).register(z.globalRegistry, {
        description: 'Background music prompt. Cannot exceed 200 characters.',
      }),
    )
    .default('intense car race'),
  sound_effect_prompt: z
    .optional(
      z.string().max(200).register(z.globalRegistry, {
        description: 'Sound effect prompt. Cannot exceed 200 characters.',
      }),
    )
    .default('Car tires screech as they accelerate in a drag race'),
})

/**
 * Audio
 */
export const zSchemaAudioOutput = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * AudioOutput
 */
export const zSchemaSfxV15VideoToAudioOutput = z.object({
  audio: z.array(zSchemaAudioOutput).register(z.globalRegistry, {
    description: 'The generated sound effects audio',
  }),
})

/**
 * Input
 */
export const zSchemaSfxV15VideoToAudioInput = z.object({
  num_samples: z.optional(z.union([z.int().gte(2).lte(8), z.unknown()])),
  duration: z.optional(z.union([z.number().gte(1).lte(10), z.unknown()])),
  start_offset: z.optional(z.union([z.number().gte(0), z.unknown()])),
  video_url: z.union([z.string(), z.string()]),
  seed: z.optional(z.union([z.int().gte(1), z.unknown()])),
  text_prompt: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * SAMAudioVisualSeparateOutput
 *
 * Output for visual-prompted audio separation.
 */
export const zSchemaSamAudioVisualSeparateOutput = z
  .object({
    target: zSchemaFile,
    duration: z.number().register(z.globalRegistry, {
      description: 'Duration of the output audio in seconds.',
    }),
    sample_rate: z
      .optional(
        z.int().register(z.globalRegistry, {
          description: 'Sample rate of the output audio in Hz.',
        }),
      )
      .default(48000),
    residual: zSchemaFile,
  })
  .register(z.globalRegistry, {
    description: 'Output for visual-prompted audio separation.',
  })

/**
 * SAMAudioVisualInput
 *
 * Input for visual-prompted audio separation.
 */
export const zSchemaSamAudioVisualSeparateInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'Text prompt to assist with separation. Use natural language to describe the target sound.',
        }),
      )
      .default(''),
    video_url: z.union([z.string(), z.string()]),
    acceleration: z.optional(
      z.enum(['fast', 'balanced', 'quality']).register(z.globalRegistry, {
        description: 'The acceleration level to use.',
      }),
    ),
    mask_video_url: z.optional(z.union([z.string(), z.string()])),
    output_format: z.optional(
      z.enum(['wav', 'mp3']).register(z.globalRegistry, {
        description: 'Output audio format.',
      }),
    ),
    reranking_candidates: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description:
            'Number of candidates to generate and rank. Higher improves quality but increases latency and cost.',
        }),
      )
      .default(1),
  })
  .register(z.globalRegistry, {
    description: 'Input for visual-prompted audio separation.',
  })

/**
 * Output
 */
export const zSchemaStableAudioOutput = z.object({
  audio_file: zSchemaFile,
})

/**
 * Input
 */
export const zSchemaStableAudioInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate audio from',
  }),
  steps: z
    .optional(
      z.int().gte(1).lte(1000).register(z.globalRegistry, {
        description: 'The number of steps to denoise the audio for',
      }),
    )
    .default(100),
  seconds_total: z
    .optional(
      z.int().gte(0).lte(47).register(z.globalRegistry, {
        description: 'The duration of the audio clip to generate',
      }),
    )
    .default(30),
  seconds_start: z
    .optional(
      z.int().gte(0).lte(47).register(z.globalRegistry, {
        description: 'The start point of the audio clip to generate',
      }),
    )
    .default(0),
})

/**
 * AudioFile
 */
export const zSchemaAudioFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z
    .optional(z.string())
    .default('8535dd59e911496a947daa35c07e67a3_tmplkcy6tut.wav'),
  content_type: z.optional(z.string()).default('audio/wav'),
  url: z.string(),
})

/**
 * TTSOutput
 */
export const zSchemaF5TtsOutput = z.object({
  audio_url: zSchemaAudioFile,
})

/**
 * TTSInput
 */
export const zSchemaF5TtsInput = z.object({
  ref_text: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The reference text to be used for TTS. If not provided, an ASR (Automatic Speech Recognition) model will be used to generate the reference text.',
      }),
    )
    .default(''),
  remove_silence: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to remove the silence from the audio file.',
      }),
    )
    .default(true),
  gen_text: z.string().register(z.globalRegistry, {
    description: 'The text to be converted to speech.',
  }),
  model_type: z.enum(['F5-TTS', 'E2-TTS']).register(z.globalRegistry, {
    description: 'The name of the model to be used for TTS.',
  }),
  ref_audio_url: z.union([z.string(), z.string()]),
})

/**
 * MusicOutput
 */
export const zSchemaMinimaxMusicOutput = z.object({
  audio: zSchemaFile,
})

/**
 * TextToMusicRequest
 */
export const zSchemaMinimaxMusicInput = z.object({
  prompt: z.string().min(1).max(600).register(z.globalRegistry, {
    description:
      'Lyrics with optional formatting. You can use a newline to separate each line of lyrics. You can use two newlines to add a pause between lines. You can use double hash marks (##) at the beginning and end of the lyrics to add accompaniment. Maximum 600 characters.',
  }),
  reference_audio_url: z.union([z.string(), z.string()]),
})

/**
 * AudioOutput
 */
export const zSchemaMmaudioV2TextToAudioOutput = z.object({
  audio: zSchemaFile,
})

/**
 * AudioInput
 */
export const zSchemaMmaudioV2TextToAudioInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the audio for.',
  }),
  num_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: 'The number of steps to generate the audio for.',
      }),
    )
    .default(25),
  duration: z
    .optional(
      z.number().gte(1).lte(30).register(z.globalRegistry, {
        description: 'The duration of the audio to generate.',
      }),
    )
    .default(8),
  cfg_strength: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'The strength of Classifier Free Guidance.',
      }),
    )
    .default(4.5),
  seed: z.optional(
    z.int().gte(0).lte(65535).register(z.globalRegistry, {
      description: 'The seed for the random number generator',
    }),
  ),
  mask_away_clip: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to mask away the clip.',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to generate the audio for.',
      }),
    )
    .default(''),
})

/**
 * Output
 */
export const zSchemaYueOutput = z.object({
  audio: zSchemaFile,
})

/**
 * TextToMusicInput
 */
export const zSchemaYueInput = z.object({
  lyrics: z.string().register(z.globalRegistry, {
    description:
      'The prompt to generate an image from. Must have two sections. Sections start with either [chorus] or a [verse].',
  }),
  genres: z.string().register(z.globalRegistry, {
    description:
      "The genres (separated by a space ' ') to guide the music generation.",
  }),
})

/**
 * ItalianOutput
 */
export const zSchemaKokoroItalianOutput = z.object({
  audio: zSchemaFile,
})

/**
 * ItalianRequest
 */
export const zSchemaKokoroItalianInput = z.object({
  prompt: z.string(),
  voice: z.enum(['if_sara', 'im_nicola']).register(z.globalRegistry, {
    description: 'Voice ID for the desired voice.',
  }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * ZonosOutput
 */
export const zSchemaZonosOutput = z.object({
  audio: zSchemaFile,
})

/**
 * ZonosInput
 */
export const zSchemaZonosInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The content generated using cloned voice.',
  }),
  reference_audio_url: z.union([z.string(), z.string()]),
})

/**
 * AmEngOutput
 */
export const zSchemaKokoroAmericanEnglishOutput = z.object({
  audio: zSchemaFile,
})

/**
 * AmEnglishRequest
 */
export const zSchemaKokoroAmericanEnglishInput = z.object({
  prompt: z.optional(z.string()).default(''),
  voice: z.optional(
    z
      .enum([
        'af_heart',
        'af_alloy',
        'af_aoede',
        'af_bella',
        'af_jessica',
        'af_kore',
        'af_nicole',
        'af_nova',
        'af_river',
        'af_sarah',
        'af_sky',
        'am_adam',
        'am_echo',
        'am_eric',
        'am_fenrir',
        'am_liam',
        'am_michael',
        'am_onyx',
        'am_puck',
        'am_santa',
      ])
      .register(z.globalRegistry, {
        description: 'Voice ID for the desired voice.',
      }),
  ),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * JapaneseOutput
 */
export const zSchemaKokoroJapaneseOutput = z.object({
  audio: zSchemaFile,
})

/**
 * JapaneseRequest
 */
export const zSchemaKokoroJapaneseInput = z.object({
  prompt: z.string(),
  voice: z
    .enum(['jf_alpha', 'jf_gongitsune', 'jf_nezumi', 'jf_tebukuro', 'jm_kumo'])
    .register(z.globalRegistry, {
      description: 'Voice ID for the desired voice.',
    }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * FrenchOutput
 */
export const zSchemaKokoroFrenchOutput = z.object({
  audio: zSchemaFile,
})

/**
 * FrenchRequest
 */
export const zSchemaKokoroFrenchInput = z.object({
  prompt: z.string(),
  voice: z.enum(['ff_siwis']).register(z.globalRegistry, {
    description: 'Voice ID for the desired voice.',
  }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * BrEngOutput
 */
export const zSchemaKokoroBritishEnglishOutput = z.object({
  audio: zSchemaFile,
})

/**
 * BrEnglishRequest
 */
export const zSchemaKokoroBritishEnglishInput = z.object({
  prompt: z.string(),
  voice: z
    .enum([
      'bf_alice',
      'bf_emma',
      'bf_isabella',
      'bf_lily',
      'bm_daniel',
      'bm_fable',
      'bm_george',
      'bm_lewis',
    ])
    .register(z.globalRegistry, {
      description: 'Voice ID for the desired voice.',
    }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * BrPortugeseOutput
 */
export const zSchemaKokoroBrazilianPortugueseOutput = z.object({
  audio: zSchemaFile,
})

/**
 * BrPortugueseRequest
 */
export const zSchemaKokoroBrazilianPortugueseInput = z.object({
  prompt: z.string(),
  voice: z.enum(['pf_dora', 'pm_alex', 'pm_santa']).register(z.globalRegistry, {
    description: 'Voice ID for the desired voice.',
  }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * SpanishOutput
 */
export const zSchemaKokoroSpanishOutput = z.object({
  audio: zSchemaFile,
})

/**
 * SpanishRequest
 */
export const zSchemaKokoroSpanishInput = z.object({
  prompt: z.string(),
  voice: z.enum(['ef_dora', 'em_alex', 'em_santa']).register(z.globalRegistry, {
    description: 'Voice ID for the desired voice.',
  }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * MandarinOutput
 */
export const zSchemaKokoroMandarinChineseOutput = z.object({
  audio: zSchemaFile,
})

/**
 * MandarinRequest
 */
export const zSchemaKokoroMandarinChineseInput = z.object({
  prompt: z.string(),
  voice: z
    .enum([
      'zf_xiaobei',
      'zf_xiaoni',
      'zf_xiaoxiao',
      'zf_xiaoyi',
      'zm_yunjian',
      'zm_yunxi',
      'zm_yunxia',
      'zm_yunyang',
    ])
    .register(z.globalRegistry, {
      description: 'Voice ID for the desired voice.',
    }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * HindiOutput
 */
export const zSchemaKokoroHindiOutput = z.object({
  audio: zSchemaFile,
})

/**
 * HindiRequest
 */
export const zSchemaKokoroHindiInput = z.object({
  prompt: z.string(),
  voice: z
    .enum(['hf_alpha', 'hf_beta', 'hm_omega', 'hm_psi'])
    .register(z.globalRegistry, {
      description: 'Voice ID for the desired voice.',
    }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * TTSOutput
 */
export const zSchemaElevenlabsTtsMultilingualV2Output = z.object({
  audio: zSchemaFile,
  timestamps: z.optional(z.union([z.array(z.unknown()), z.unknown()])),
})

/**
 * TextToSpeechRequest
 */
export const zSchemaElevenlabsTtsMultilingualV2Input = z.object({
  stability: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Voice stability (0-1)',
      }),
    )
    .default(0.5),
  next_text: z.optional(z.union([z.string(), z.unknown()])),
  speed: z
    .optional(
      z.number().gte(0.7).lte(1.2).register(z.globalRegistry, {
        description:
          'Speech speed (0.7-1.2). Values below 1.0 slow down the speech, above 1.0 speed it up. Extreme values may affect quality.',
      }),
    )
    .default(1),
  style: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Style exaggeration (0-1)',
      }),
    )
    .default(0),
  text: z.string().min(1).register(z.globalRegistry, {
    description: 'The text to convert to speech',
  }),
  timestamps: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to return timestamps for each word in the generated speech',
      }),
    )
    .default(false),
  similarity_boost: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Similarity boost (0-1)',
      }),
    )
    .default(0.75),
  voice: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The voice to use for speech generation',
      }),
    )
    .default('Rachel'),
  language_code: z.optional(z.union([z.string(), z.unknown()])),
  previous_text: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * Output
 */
export const zSchemaDiffrhythmOutput = z.object({
  audio: zSchemaFile,
})

/**
 * TextToMusicInput
 */
export const zSchemaDiffrhythmInput = z.object({
  lyrics: z.string().register(z.globalRegistry, {
    description:
      'The prompt to generate the song from. Must have two sections. Sections start with either [chorus] or a [verse].',
  }),
  cfg_strength: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: 'The CFG strength to use for the music generation.',
      }),
    )
    .default(4),
  reference_audio_url: z.optional(z.union([z.string(), z.string()])),
  music_duration: z.optional(
    z.enum(['95s', '285s']).register(z.globalRegistry, {
      description: 'The duration of the music to generate.',
    }),
  ),
  scheduler: z.optional(
    z
      .enum(['euler', 'midpoint', 'rk4', 'implicit_adams'])
      .register(z.globalRegistry, {
        description: 'The scheduler to use for the music generation.',
      }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(100).register(z.globalRegistry, {
        description:
          'The number of inference steps to use for the music generation.',
      }),
    )
    .default(32),
  style_prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The style prompt to use for the music generation.',
    }),
  ),
})

/**
 * Speaker
 */
export const zSchemaSpeaker = z.object({
  prompt: z.string(),
  audio_url: z.string(),
  speaker_id: z.int(),
})

/**
 * Turn
 */
export const zSchemaTurn = z.object({
  text: z.string(),
  speaker_id: z.int(),
})

/**
 * Output
 */
export const zSchemaCsm1bOutput = z.object({
  audio: z.union([zSchemaFile, z.string()]),
})

/**
 * Input
 */
export const zSchemaCsm1bInput = z.object({
  scene: z.array(zSchemaTurn).register(z.globalRegistry, {
    description: 'The text to generate an audio from.',
  }),
  context: z.optional(
    z.array(zSchemaSpeaker).register(z.globalRegistry, {
      description: 'The context to generate an audio from.',
    }),
  ),
})

/**
 * AudioOutput
 *
 * Example Pydantic model showing how to include a File in the output.
 */
export const zSchemaMusicGeneratorOutput = z
  .object({
    audio_file: zSchemaFile,
  })
  .register(z.globalRegistry, {
    description:
      'Example Pydantic model showing how to include a File in the output.',
  })

/**
 * Input
 */
export const zSchemaMusicGeneratorInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate music from.',
  }),
  duration: z.int().gte(10).lte(180).register(z.globalRegistry, {
    description: 'The duration of the generated music in seconds.',
  }),
})

/**
 * AudioOutput
 *
 * Example Pydantic model showing how to include a File in the output.
 */
export const zSchemaSoundEffectsGeneratorOutput = z
  .object({
    audio_file: zSchemaFile,
  })
  .register(z.globalRegistry, {
    description:
      'Example Pydantic model showing how to include a File in the output.',
  })

/**
 * Input
 */
export const zSchemaSoundEffectsGeneratorInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate SFX.',
  }),
  duration: z.int().gte(1).lte(30).register(z.globalRegistry, {
    description: 'The duration of the generated SFX in seconds.',
  }),
})

/**
 * ACEStepResponse
 */
export const zSchemaAceStepOutput = z.object({
  tags: z.string().register(z.globalRegistry, {
    description: 'The genre tags used in the generation process.',
  }),
  lyrics: z.string().register(z.globalRegistry, {
    description: 'The lyrics used in the generation process.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The random seed used for the generation process.',
  }),
  audio: zSchemaFile,
})

/**
 * ACEStepTextToAudioRequest
 */
export const zSchemaAceStepInput = z.object({
  number_of_steps: z
    .optional(
      z.int().gte(3).lte(60).register(z.globalRegistry, {
        description: 'Number of steps to generate the audio.',
      }),
    )
    .default(27),
  duration: z
    .optional(
      z.number().gte(5).lte(240).register(z.globalRegistry, {
        description: 'The duration of the generated audio in seconds.',
      }),
    )
    .default(60),
  tags: z.string().register(z.globalRegistry, {
    description:
      'Comma-separated list of genre tags to control the style of the generated audio.',
  }),
  minimum_guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description:
          'Minimum guidance scale for the generation after the decay.',
      }),
    )
    .default(3),
  lyrics: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Lyrics to be sung in the audio. If not provided or if [inst] or [instrumental] is the content of this field, no lyrics will be sung. Use control structures like [verse], [chorus] and [bridge] to control the structure of the song.',
      }),
    )
    .default(''),
  tag_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Tag guidance scale for the generation.',
      }),
    )
    .default(5),
  scheduler: z.optional(
    z.enum(['euler', 'heun']).register(z.globalRegistry, {
      description: 'Scheduler to use for the generation process.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description: 'Guidance scale for the generation.',
      }),
    )
    .default(15),
  guidance_type: z.optional(
    z.enum(['cfg', 'apg', 'cfg_star']).register(z.globalRegistry, {
      description: 'Type of CFG to use for the generation process.',
    }),
  ),
  lyric_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Lyric guidance scale for the generation.',
      }),
    )
    .default(1.5),
  guidance_interval: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Guidance interval for the generation. 0.5 means only apply guidance in the middle steps (0.25 * infer_steps to 0.75 * infer_steps)',
      }),
    )
    .default(0.5),
  guidance_interval_decay: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Guidance interval decay for the generation. Guidance scale will decay from guidance_scale to min_guidance_scale in the interval. 0.0 means no decay.',
      }),
    )
    .default(0),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If not provided, a random seed will be used.',
    }),
  ),
  granularity_scale: z
    .optional(
      z.int().gte(-100).lte(100).register(z.globalRegistry, {
        description:
          'Granularity scale for the generation process. Higher values can reduce artifacts.',
      }),
    )
    .default(10),
})

/**
 * ACEStepResponse
 */
export const zSchemaAceStepPromptToAudioOutput = z.object({
  tags: z.string().register(z.globalRegistry, {
    description: 'The genre tags used in the generation process.',
  }),
  lyrics: z.string().register(z.globalRegistry, {
    description: 'The lyrics used in the generation process.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The random seed used for the generation process.',
  }),
  audio: zSchemaFile,
})

/**
 * ACEStepPromptToAudioRequest
 */
export const zSchemaAceStepPromptToAudioInput = z.object({
  number_of_steps: z
    .optional(
      z.int().gte(3).lte(60).register(z.globalRegistry, {
        description: 'Number of steps to generate the audio.',
      }),
    )
    .default(27),
  duration: z
    .optional(
      z.number().gte(5).lte(240).register(z.globalRegistry, {
        description: 'The duration of the generated audio in seconds.',
      }),
    )
    .default(60),
  prompt: z.string().register(z.globalRegistry, {
    description:
      'Prompt to control the style of the generated audio. This will be used to generate tags and lyrics.',
  }),
  minimum_guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description:
          'Minimum guidance scale for the generation after the decay.',
      }),
    )
    .default(3),
  tag_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Tag guidance scale for the generation.',
      }),
    )
    .default(5),
  scheduler: z.optional(
    z.enum(['euler', 'heun']).register(z.globalRegistry, {
      description: 'Scheduler to use for the generation process.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description: 'Guidance scale for the generation.',
      }),
    )
    .default(15),
  guidance_type: z.optional(
    z.enum(['cfg', 'apg', 'cfg_star']).register(z.globalRegistry, {
      description: 'Type of CFG to use for the generation process.',
    }),
  ),
  instrumental: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to generate an instrumental version of the audio.',
      }),
    )
    .default(false),
  lyric_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Lyric guidance scale for the generation.',
      }),
    )
    .default(1.5),
  guidance_interval: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Guidance interval for the generation. 0.5 means only apply guidance in the middle steps (0.25 * infer_steps to 0.75 * infer_steps)',
      }),
    )
    .default(0.5),
  guidance_interval_decay: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Guidance interval decay for the generation. Guidance scale will decay from guidance_scale to min_guidance_scale in the interval. 0.0 means no decay.',
      }),
    )
    .default(0),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If not provided, a random seed will be used.',
    }),
  ),
  granularity_scale: z
    .optional(
      z.int().gte(-100).lte(100).register(z.globalRegistry, {
        description:
          'Granularity scale for the generation process. Higher values can reduce artifacts.',
      }),
    )
    .default(10),
})

/**
 * TextToMusicOutput
 */
export const zSchemaLyria2Output = z.object({
  audio: zSchemaFile,
})

/**
 * TextToMusicInput
 */
export const zSchemaLyria2Input = z.object({
  prompt: z.string().min(1).max(2000).register(z.globalRegistry, {
    description: 'The text prompt describing the music you want to generate',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'A seed for deterministic generation. If provided, the model will attempt to produce the same audio given the same prompt and other parameters.',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'A description of what to exclude from the generated audio',
      }),
    )
    .default('low quality'),
})

/**
 * TTSOutput
 */
export const zSchemaElevenlabsTtsElevenV3Output = z.object({
  audio: zSchemaFile,
  timestamps: z.optional(z.union([z.array(z.unknown()), z.unknown()])),
})

/**
 * TextToSpeechRequestV3
 *
 * Request model for eleven_v3 which doesn't support previous_text/next_text
 */
export const zSchemaElevenlabsTtsElevenV3Input = z
  .object({
    stability: z
      .optional(
        z.number().gte(0).lte(1).register(z.globalRegistry, {
          description: 'Voice stability (0-1)',
        }),
      )
      .default(0.5),
    speed: z
      .optional(
        z.number().gte(0.7).lte(1.2).register(z.globalRegistry, {
          description:
            'Speech speed (0.7-1.2). Values below 1.0 slow down the speech, above 1.0 speed it up. Extreme values may affect quality.',
        }),
      )
      .default(1),
    text: z.string().min(1).max(5000).register(z.globalRegistry, {
      description: 'The text to convert to speech',
    }),
    style: z
      .optional(
        z.number().gte(0).lte(1).register(z.globalRegistry, {
          description: 'Style exaggeration (0-1)',
        }),
      )
      .default(0),
    timestamps: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to return timestamps for each word in the generated speech',
        }),
      )
      .default(false),
    similarity_boost: z
      .optional(
        z.number().gte(0).lte(1).register(z.globalRegistry, {
          description: 'Similarity boost (0-1)',
        }),
      )
      .default(0.75),
    voice: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The voice to use for speech generation',
        }),
      )
      .default('Rachel'),
    language_code: z.optional(z.union([z.string(), z.unknown()])),
  })
  .register(z.globalRegistry, {
    description:
      "Request model for eleven_v3 which doesn't support previous_text/next_text",
  })

/**
 * GenerateOutput
 */
export const zSchemaV2TextToMusicOutput = z.object({
  tags: z.optional(z.union([z.array(z.string()), z.unknown()])),
  seed: z.int().register(z.globalRegistry, {
    description:
      'The seed used for generation. This can be used to generate an identical song by passing the same parameters with this seed in a future request.',
  }),
  lyrics: z.optional(z.union([z.string(), z.unknown()])),
  audio: z.array(zSchemaFile).register(z.globalRegistry, {
    description: 'The generated audio files.',
  }),
})

/**
 * GenerateInput
 */
export const zSchemaV2TextToMusicInput = z.object({
  prompt: z.optional(z.union([z.string(), z.unknown()])),
  lyrics_prompt: z.optional(z.union([z.string(), z.unknown()])),
  tags: z.optional(z.union([z.array(z.string()), z.unknown()])),
  prompt_strength: z
    .optional(
      z.number().gte(1.4).lte(3.1).register(z.globalRegistry, {
        description:
          'Controls how strongly your prompt influences the output. Greater values adhere more to the prompt but sound less natural. (This is CFG.)',
      }),
    )
    .default(2),
  output_bit_rate: z.optional(
    z.union([
      z.union([z.literal(128), z.literal(192), z.literal(256), z.literal(320)]),
      z.unknown(),
    ]),
  ),
  num_songs: z
    .optional(
      z.int().gte(1).lte(2).register(z.globalRegistry, {
        description:
          'Generating 2 songs costs 1.5x the price of generating 1 song. Also, note that using the same seed may not result in identical songs if the number of songs generated is changed.',
      }),
    )
    .default(1),
  output_format: z.optional(z.enum(['flac', 'mp3', 'wav', 'ogg', 'm4a'])),
  bpm: z.optional(z.union([z.int(), z.string(), z.unknown()])),
  balance_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Greater means more natural vocals. Lower means sharper instrumentals. We recommend 0.7.',
      }),
    )
    .default(0.7),
  seed: z.optional(
    z.union([
      z.int().gte(-9223372036854776000).lte(9223372036854776000),
      z.unknown(),
    ]),
  ),
})

/**
 * InpaintSection
 */
export const zSchemaInpaintSection = z.object({
  end: z.number().register(z.globalRegistry, {
    description: 'End time in seconds of the section to inpaint.',
  }),
  start: z.number().gte(0).register(z.globalRegistry, {
    description: 'Start time in seconds of the section to inpaint.',
  }),
})

/**
 * InpaintOutput
 */
export const zSchemaV2InpaintOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description:
      'The seed used for generation. This can be used to generate an identical song by passing the same parameters with this seed in a future request.',
  }),
  audio: z.array(zSchemaFile).register(z.globalRegistry, {
    description: 'The generated audio files.',
  }),
})

/**
 * InpaintInput
 */
export const zSchemaV2InpaintInput = z.object({
  lyrics_prompt: z.string().register(z.globalRegistry, {
    description:
      'The lyrics sung in the generated song. An empty string will generate an instrumental track.',
  }),
  tags: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'Tags/styles of the music to generate. You can view a list of all available tags at https://sonauto.ai/tag-explorer.',
    }),
  ),
  prompt_strength: z
    .optional(
      z.number().gte(1.4).lte(3.1).register(z.globalRegistry, {
        description:
          'Controls how strongly your prompt influences the output. Greater values adhere more to the prompt but sound less natural. (This is CFG.)',
      }),
    )
    .default(2),
  output_bit_rate: z.optional(
    z.union([
      z.union([z.literal(128), z.literal(192), z.literal(256), z.literal(320)]),
      z.unknown(),
    ]),
  ),
  num_songs: z
    .optional(
      z.int().gte(1).lte(2).register(z.globalRegistry, {
        description:
          'Generating 2 songs costs 1.5x the price of generating 1 song. Also, note that using the same seed may not result in identical songs if the number of songs generated is changed.',
      }),
    )
    .default(1),
  output_format: z.optional(z.enum(['flac', 'mp3', 'wav', 'ogg', 'm4a'])),
  selection_crop: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Crop to the selected region',
      }),
    )
    .default(false),
  sections: z.array(zSchemaInpaintSection).register(z.globalRegistry, {
    description:
      'List of sections to inpaint. Currently, only one section is supported so the list length must be 1.',
  }),
  balance_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Greater means more natural vocals. Lower means sharper instrumentals. We recommend 0.7.',
      }),
    )
    .default(0.7),
  audio_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.union([
      z.int().gte(-9223372036854776000).lte(9223372036854776000),
      z.unknown(),
    ]),
  ),
})

/**
 * SoundEffectOutput
 *
 * Output format for generated sound effects
 */
export const zSchemaElevenlabsSoundEffectsV2Output = z
  .object({
    audio: zSchemaFile,
  })
  .register(z.globalRegistry, {
    description: 'Output format for generated sound effects',
  })

/**
 * SoundEffectRequestV2
 */
export const zSchemaElevenlabsSoundEffectsV2Input = z.object({
  text: z.string().register(z.globalRegistry, {
    description: 'The text describing the sound effect to generate',
  }),
  loop: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to create a sound effect that loops smoothly.',
      }),
    )
    .default(false),
  prompt_influence: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'How closely to follow the prompt (0-1). Higher values mean less variation.',
      }),
    )
    .default(0.3),
  output_format: z.optional(
    z
      .enum([
        'mp3_22050_32',
        'mp3_44100_32',
        'mp3_44100_64',
        'mp3_44100_96',
        'mp3_44100_128',
        'mp3_44100_192',
        'pcm_8000',
        'pcm_16000',
        'pcm_22050',
        'pcm_24000',
        'pcm_44100',
        'pcm_48000',
        'ulaw_8000',
        'alaw_8000',
        'opus_48000_32',
        'opus_48000_64',
        'opus_48000_96',
        'opus_48000_128',
        'opus_48000_192',
      ])
      .register(z.globalRegistry, {
        description:
          'Output format of the generated audio. Formatted as codec_sample_rate_bitrate.',
      }),
  ),
  duration_seconds: z.optional(
    z.union([z.number().gte(0.5).lte(22), z.unknown()]),
  ),
})

/**
 * PronunciationDictionaryLocator
 */
export const zSchemaPronunciationDictionaryLocator = z.object({
  version_id: z.optional(z.union([z.string(), z.unknown()])),
  pronunciation_dictionary_id: z.union([z.string(), z.unknown()]),
})

/**
 * DialogueBlock
 */
export const zSchemaDialogueBlock = z.object({
  text: z.string().register(z.globalRegistry, {
    description: 'The dialogue text',
  }),
  voice: z.string().register(z.globalRegistry, {
    description:
      'The name or the ID of the voice to be used for the generation.',
  }),
})

/**
 * TextToDialogueOutput
 */
export const zSchemaElevenlabsTextToDialogueElevenV3Output = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'Random seed for reproducibility.',
  }),
  audio: zSchemaFile,
})

/**
 * TextToDialogueRequest
 */
export const zSchemaElevenlabsTextToDialogueElevenV3Input = z.object({
  stability: z.optional(z.union([z.number().gte(0).lte(1), z.unknown()])),
  inputs: z.array(zSchemaDialogueBlock).register(z.globalRegistry, {
    description:
      'A list of dialogue inputs, each containing text and a voice ID which will be converted into speech.',
  }),
  language_code: z.optional(z.union([z.string(), z.unknown()])),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  use_speaker_boost: z.optional(z.union([z.boolean(), z.unknown()])),
  pronunciation_dictionary_locators: z
    .optional(
      z
        .array(zSchemaPronunciationDictionaryLocator)
        .register(z.globalRegistry, {
          description:
            'A list of pronunciation dictionary locators (id, version_id) to be applied to the text. They will be applied in order. You may have up to 3 locators per request',
        }),
    )
    .default([]),
})

/**
 * TextToAudioOutput
 */
export const zSchemaStableAudio25TextToAudioOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The random seed used for generation',
  }),
  audio: zSchemaFile,
})

/**
 * TextToAudioInput
 */
export const zSchemaStableAudio25TextToAudioInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate audio from',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seconds_total: z
    .optional(
      z.int().gte(1).lte(190).register(z.globalRegistry, {
        description: 'The duration of the audio clip to generate',
      }),
    )
    .default(190),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(8).register(z.globalRegistry, {
        description: 'The number of steps to denoise the audio for',
      }),
    )
    .default(8),
  guidance_scale: z
    .optional(
      z.int().gte(1).lte(25).register(z.globalRegistry, {
        description:
          'How strictly the diffusion process adheres to the prompt text (higher values make your audio closer to your prompt).',
      }),
    )
    .default(1),
  seed: z.optional(z.int()),
})

/**
 * MusicV15Output
 */
export const zSchemaMinimaxMusicV15Output = z.object({
  audio: zSchemaFile,
})

/**
 * AudioSetting
 */
export const zSchemaAudioSetting = z.object({
  format: z.optional(
    z.enum(['mp3', 'pcm', 'flac']).register(z.globalRegistry, {
      description: 'Audio format',
    }),
  ),
  sample_rate: z.optional(
    z
      .union([
        z.literal(8000),
        z.literal(16000),
        z.literal(22050),
        z.literal(24000),
        z.literal(32000),
        z.literal(44100),
      ])
      .register(z.globalRegistry, {
        description: 'Sample rate of generated audio',
      }),
  ),
  bitrate: z.optional(
    z
      .union([
        z.literal(32000),
        z.literal(64000),
        z.literal(128000),
        z.literal(256000),
      ])
      .register(z.globalRegistry, {
        description: 'Bitrate of generated audio',
      }),
  ),
})

/**
 * TextToMusic15Request
 */
export const zSchemaMinimaxMusicV15Input = z.object({
  prompt: z.string().min(10).max(600).register(z.globalRegistry, {
    description:
      'Lyrics, supports [intro][verse][chorus][bridge][outro] sections. 10-600 characters.',
  }),
  lyrics_prompt: z.string().min(10).max(3000).register(z.globalRegistry, {
    description: 'Control music generation. 10-3000 characters.',
  }),
  audio_setting: z.optional(zSchemaAudioSetting),
})

/**
 * MusicGenerationOutput
 *
 * Output schema for music generation.
 */
export const zSchemaMusicGenerationOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'The processed prompt used for generation',
    }),
    metadata: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description:
        'Generation metadata including duration, sample rate, and parameters',
    }),
    audio: zSchemaFile,
  })
  .register(z.globalRegistry, {
    description: 'Output schema for music generation.',
  })

/**
 * MusicGenerationInput
 *
 * Input schema for music generation with form controls for the playground.
 */
export const zSchemaMusicGenerationInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'Describe the music you want to generate',
    }),
    duration: z
      .optional(
        z.number().gte(5).lte(150).register(z.globalRegistry, {
          description: 'Length of the generated music in seconds',
        }),
      )
      .default(90),
    refinement: z
      .optional(
        z.int().gte(10).lte(200).register(z.globalRegistry, {
          description:
            'Refinement level - higher values may improve quality but take longer',
        }),
      )
      .default(100),
    seed: z.optional(z.union([z.int().gte(0).lte(2147483647), z.unknown()])),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'Describe what you want to avoid in the music (instruments, styles, moods). Leave blank for none.',
        }),
      )
      .default(''),
    creativity: z
      .optional(
        z.number().gte(1).lte(20).register(z.globalRegistry, {
          description:
            'Creativity level - higher values allow more creative interpretation of the prompt',
        }),
      )
      .default(16),
  })
  .register(z.globalRegistry, {
    description:
      'Input schema for music generation with form controls for the playground.',
  })

/**
 * SoundEffectGenerationOutput
 *
 * Output schema for sound effect generation.
 */
export const zSchemaSoundEffectGenerationOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'The processed prompt used for generation',
    }),
    metadata: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description:
        'Generation metadata including duration, sample rate, and parameters',
    }),
    audio: zSchemaFile,
  })
  .register(z.globalRegistry, {
    description: 'Output schema for sound effect generation.',
  })

/**
 * SoundEffectGenerationInput
 *
 * Input schema for sound effect generation with form controls for the playground.
 */
export const zSchemaSoundEffectGenerationInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'Describe the sound effect you want to generate',
    }),
    duration: z
      .optional(
        z.number().gte(1).lte(35).register(z.globalRegistry, {
          description: 'Length of the generated sound effect in seconds',
        }),
      )
      .default(5),
    refinement: z
      .optional(
        z.int().gte(10).lte(200).register(z.globalRegistry, {
          description:
            'Refinement level - Higher values may improve quality but take longer',
        }),
      )
      .default(40),
    seed: z.optional(z.union([z.int().gte(0).lte(2147483647), z.unknown()])),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe the types of sounds you don't want to generate in the output, avoid double-negatives, compare with positive prompts",
        }),
      )
      .default(''),
    creativity: z
      .optional(
        z.number().gte(1).lte(20).register(z.globalRegistry, {
          description:
            'Creativity level - higher values allow more creative interpretation of the prompt',
        }),
      )
      .default(16),
  })
  .register(z.globalRegistry, {
    description:
      'Input schema for sound effect generation with form controls for the playground.',
  })

/**
 * MusicV15Output
 */
export const zSchemaMinimaxMusicV2Output = z.object({
  audio: zSchemaFile,
})

/**
 * TextToMusic20Request
 */
export const zSchemaMinimaxMusicV2Input = z.object({
  prompt: z.string().min(10).max(2000).register(z.globalRegistry, {
    description:
      'A description of the music, specifying style, mood, and scenario. 10-300 characters.',
  }),
  lyrics_prompt: z.string().min(10).max(3000).register(z.globalRegistry, {
    description:
      'Lyrics of the song. Use n to separate lines. You may add structure tags like [Intro], [Verse], [Chorus], [Bridge], [Outro] to enhance the arrangement. 10-3000 characters.',
  }),
  audio_setting: z.optional(zSchemaAudioSetting),
})

/**
 * MusicSection
 */
export const zSchemaMusicSection = z.object({
  positive_local_styles: z.array(z.string()).register(z.globalRegistry, {
    description: 'The styles that should be present in this section.',
  }),
  lines: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The lyrics of the section. Each line must be at most 200 characters long.',
  }),
  negative_local_styles: z.array(z.string()).register(z.globalRegistry, {
    description: 'The styles that should not be present in this section.',
  }),
  duration_ms: z.int().gte(3000).lte(120000).register(z.globalRegistry, {
    description:
      'The duration of the section in milliseconds. Must be between 3000ms and 120000ms.',
  }),
  section_name: z.string().min(1).max(100).register(z.globalRegistry, {
    description:
      'The name of the section. Must be between 1 and 100 characters.',
  }),
})

/**
 * MusicCompositionPlan
 */
export const zSchemaMusicCompositionPlan = z.object({
  negative_global_styles: z.array(z.string()).register(z.globalRegistry, {
    description: 'The styles that should not be present in the entire song.',
  }),
  sections: z.array(zSchemaMusicSection).register(z.globalRegistry, {
    description: 'The sections of the song.',
  }),
  positive_global_styles: z.array(z.string()).register(z.globalRegistry, {
    description: 'The styles that should be present in the entire song.',
  }),
})

/**
 * MusicOutput
 */
export const zSchemaElevenlabsMusicOutput = z.object({
  audio: zSchemaFile,
})

/**
 * MusicRequest
 *
 * Request format for Elevenlabs Music API
 */
export const zSchemaElevenlabsMusicInput = z
  .object({
    prompt: z.optional(z.union([z.string(), z.unknown()])),
    composition_plan: z.optional(
      z.union([zSchemaMusicCompositionPlan, z.unknown()]),
    ),
    music_length_ms: z.optional(
      z.union([z.int().gte(3000).lte(600000), z.unknown()]),
    ),
    output_format: z.optional(
      z
        .enum([
          'mp3_22050_32',
          'mp3_44100_32',
          'mp3_44100_64',
          'mp3_44100_96',
          'mp3_44100_128',
          'mp3_44100_192',
          'pcm_8000',
          'pcm_16000',
          'pcm_22050',
          'pcm_24000',
          'pcm_44100',
          'pcm_48000',
          'ulaw_8000',
          'alaw_8000',
          'opus_48000_32',
          'opus_48000_64',
          'opus_48000_96',
          'opus_48000_128',
          'opus_48000_192',
        ])
        .register(z.globalRegistry, {
          description:
            'Output format of the generated audio. Formatted as codec_sample_rate_bitrate. So an mp3 with 22.05kHz sample rate at 32kbs is represented as mp3_22050_32. MP3 with 192kbps bitrate requires you to be subscribed to Creator tier or above. PCM with 44.1kHz sample rate requires you to be subscribed to Pro tier or above. Note that the -law format (sometimes written mu-law, often approximated as u-law) is commonly used for Twilio audio inputs.',
        }),
    ),
    respect_sections_durations: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Controls how strictly section durations in the composition_plan are enforced. It will only have an effect if it is used with composition_plan. When set to true, the model will precisely respect each section's duration_ms from the plan. When set to false, the model may adjust individual section durations which will generally lead to better generation quality and improved latency, while always preserving the total song duration from the plan.",
        }),
      )
      .default(true),
    force_instrumental: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If true, guarantees that the generated song will be instrumental. If false, the song may or may not be instrumental depending on the prompt. Can only be used with prompt.',
        }),
      )
      .default(false),
  })
  .register(z.globalRegistry, {
    description: 'Request format for Elevenlabs Music API',
  })

/**
 * TTSOutput
 */
export const zSchemaElevenlabsAudioIsolationOutput = z.object({
  audio: zSchemaFile,
  timestamps: z.optional(z.union([z.array(z.unknown()), z.unknown()])),
})

/**
 * AudioIsolationRequest
 */
export const zSchemaElevenlabsAudioIsolationInput = z.object({
  video_url: z.optional(z.union([z.string(), z.unknown()])),
  audio_url: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * DiaCloneOutput
 */
export const zSchemaDiaTtsVoiceCloneOutput = z.object({
  audio: zSchemaFile,
})

/**
 * CloneRequest
 */
export const zSchemaDiaTtsVoiceCloneInput = z.object({
  text: z.string().register(z.globalRegistry, {
    description: 'The text to be converted to speech.',
  }),
  ref_text: z.string().register(z.globalRegistry, {
    description: 'The reference text to be used for TTS.',
  }),
  ref_audio_url: z.union([z.string(), z.string()]),
})

/**
 * ACEStepAudioToAudioResponse
 */
export const zSchemaAceStepAudioToAudioOutput = z.object({
  tags: z.string().register(z.globalRegistry, {
    description: 'The genre tags used in the generation process.',
  }),
  lyrics: z.string().register(z.globalRegistry, {
    description: 'The lyrics used in the generation process.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The random seed used for the generation process.',
  }),
  audio: zSchemaFile,
})

/**
 * ACEStepAudioToAudioRequest
 */
export const zSchemaAceStepAudioToAudioInput = z.object({
  number_of_steps: z
    .optional(
      z.int().gte(3).lte(60).register(z.globalRegistry, {
        description: 'Number of steps to generate the audio.',
      }),
    )
    .default(27),
  tags: z.string().register(z.globalRegistry, {
    description:
      'Comma-separated list of genre tags to control the style of the generated audio.',
  }),
  minimum_guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description:
          'Minimum guidance scale for the generation after the decay.',
      }),
    )
    .default(3),
  lyrics: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Lyrics to be sung in the audio. If not provided or if [inst] or [instrumental] is the content of this field, no lyrics will be sung. Use control structures like [verse], [chorus] and [bridge] to control the structure of the song.',
      }),
    )
    .default(''),
  tag_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Tag guidance scale for the generation.',
      }),
    )
    .default(5),
  original_lyrics: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Original lyrics of the audio file.',
      }),
    )
    .default(''),
  scheduler: z.optional(
    z.enum(['euler', 'heun']).register(z.globalRegistry, {
      description: 'Scheduler to use for the generation process.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description: 'Guidance scale for the generation.',
      }),
    )
    .default(15),
  guidance_type: z.optional(
    z.enum(['cfg', 'apg', 'cfg_star']).register(z.globalRegistry, {
      description: 'Type of CFG to use for the generation process.',
    }),
  ),
  lyric_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Lyric guidance scale for the generation.',
      }),
    )
    .default(1.5),
  guidance_interval: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Guidance interval for the generation. 0.5 means only apply guidance in the middle steps (0.25 * infer_steps to 0.75 * infer_steps)',
      }),
    )
    .default(0.5),
  edit_mode: z.optional(
    z.enum(['lyrics', 'remix']).register(z.globalRegistry, {
      description: 'Whether to edit the lyrics only or remix the audio.',
    }),
  ),
  guidance_interval_decay: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Guidance interval decay for the generation. Guidance scale will decay from guidance_scale to min_guidance_scale in the interval. 0.0 means no decay.',
      }),
    )
    .default(0),
  audio_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If not provided, a random seed will be used.',
    }),
  ),
  granularity_scale: z
    .optional(
      z.int().gte(-100).lte(100).register(z.globalRegistry, {
        description:
          'Granularity scale for the generation process. Higher values can reduce artifacts.',
      }),
    )
    .default(10),
  original_tags: z.string().register(z.globalRegistry, {
    description: 'Original tags of the audio file.',
  }),
  original_seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Original seed of the audio file.',
    }),
  ),
})

/**
 * ACEStepAudioInpaintResponse
 */
export const zSchemaAceStepAudioInpaintOutput = z.object({
  tags: z.string().register(z.globalRegistry, {
    description: 'The genre tags used in the generation process.',
  }),
  lyrics: z.string().register(z.globalRegistry, {
    description: 'The lyrics used in the generation process.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The random seed used for the generation process.',
  }),
  audio: zSchemaFile,
})

/**
 * ACEStepAudioInpaintRequest
 */
export const zSchemaAceStepAudioInpaintInput = z.object({
  number_of_steps: z
    .optional(
      z.int().gte(3).lte(60).register(z.globalRegistry, {
        description: 'Number of steps to generate the audio.',
      }),
    )
    .default(27),
  start_time: z
    .optional(
      z.number().gte(0).lte(240).register(z.globalRegistry, {
        description: 'start time in seconds for the inpainting process.',
      }),
    )
    .default(0),
  tags: z.string().register(z.globalRegistry, {
    description:
      'Comma-separated list of genre tags to control the style of the generated audio.',
  }),
  minimum_guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description:
          'Minimum guidance scale for the generation after the decay.',
      }),
    )
    .default(3),
  lyrics: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Lyrics to be sung in the audio. If not provided or if [inst] or [instrumental] is the content of this field, no lyrics will be sung. Use control structures like [verse], [chorus] and [bridge] to control the structure of the song.',
      }),
    )
    .default(''),
  end_time_relative_to: z.optional(
    z.enum(['start', 'end']).register(z.globalRegistry, {
      description:
        'Whether the end time is relative to the start or end of the audio.',
    }),
  ),
  tag_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Tag guidance scale for the generation.',
      }),
    )
    .default(5),
  scheduler: z.optional(
    z.enum(['euler', 'heun']).register(z.globalRegistry, {
      description: 'Scheduler to use for the generation process.',
    }),
  ),
  end_time: z
    .optional(
      z.number().gte(0).lte(240).register(z.globalRegistry, {
        description: 'end time in seconds for the inpainting process.',
      }),
    )
    .default(30),
  guidance_type: z.optional(
    z.enum(['cfg', 'apg', 'cfg_star']).register(z.globalRegistry, {
      description: 'Type of CFG to use for the generation process.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description: 'Guidance scale for the generation.',
      }),
    )
    .default(15),
  lyric_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Lyric guidance scale for the generation.',
      }),
    )
    .default(1.5),
  guidance_interval: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Guidance interval for the generation. 0.5 means only apply guidance in the middle steps (0.25 * infer_steps to 0.75 * infer_steps)',
      }),
    )
    .default(0.5),
  variance: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Variance for the inpainting process. Higher values can lead to more diverse results.',
      }),
    )
    .default(0.5),
  guidance_interval_decay: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Guidance interval decay for the generation. Guidance scale will decay from guidance_scale to min_guidance_scale in the interval. 0.0 means no decay.',
      }),
    )
    .default(0),
  start_time_relative_to: z.optional(
    z.enum(['start', 'end']).register(z.globalRegistry, {
      description:
        'Whether the start time is relative to the start or end of the audio.',
    }),
  ),
  audio_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If not provided, a random seed will be used.',
    }),
  ),
  granularity_scale: z
    .optional(
      z.int().gte(-100).lte(100).register(z.globalRegistry, {
        description:
          'Granularity scale for the generation process. Higher values can reduce artifacts.',
      }),
    )
    .default(10),
})

/**
 * ACEStepResponse
 */
export const zSchemaAceStepAudioOutpaintOutput = z.object({
  tags: z.string().register(z.globalRegistry, {
    description: 'The genre tags used in the generation process.',
  }),
  lyrics: z.string().register(z.globalRegistry, {
    description: 'The lyrics used in the generation process.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The random seed used for the generation process.',
  }),
  audio: zSchemaFile,
})

/**
 * ACEStepAudioOutpaintRequest
 */
export const zSchemaAceStepAudioOutpaintInput = z.object({
  number_of_steps: z
    .optional(
      z.int().gte(3).lte(60).register(z.globalRegistry, {
        description: 'Number of steps to generate the audio.',
      }),
    )
    .default(27),
  tags: z.string().register(z.globalRegistry, {
    description:
      'Comma-separated list of genre tags to control the style of the generated audio.',
  }),
  minimum_guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description:
          'Minimum guidance scale for the generation after the decay.',
      }),
    )
    .default(3),
  extend_after_duration: z
    .optional(
      z.number().gte(0).lte(240).register(z.globalRegistry, {
        description: 'Duration in seconds to extend the audio from the end.',
      }),
    )
    .default(30),
  lyrics: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Lyrics to be sung in the audio. If not provided or if [inst] or [instrumental] is the content of this field, no lyrics will be sung. Use control structures like [verse], [chorus] and [bridge] to control the structure of the song.',
      }),
    )
    .default(''),
  tag_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Tag guidance scale for the generation.',
      }),
    )
    .default(5),
  scheduler: z.optional(
    z.enum(['euler', 'heun']).register(z.globalRegistry, {
      description: 'Scheduler to use for the generation process.',
    }),
  ),
  extend_before_duration: z
    .optional(
      z.number().gte(0).lte(240).register(z.globalRegistry, {
        description: 'Duration in seconds to extend the audio from the start.',
      }),
    )
    .default(0),
  guidance_type: z.optional(
    z.enum(['cfg', 'apg', 'cfg_star']).register(z.globalRegistry, {
      description: 'Type of CFG to use for the generation process.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description: 'Guidance scale for the generation.',
      }),
    )
    .default(15),
  lyric_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Lyric guidance scale for the generation.',
      }),
    )
    .default(1.5),
  guidance_interval: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Guidance interval for the generation. 0.5 means only apply guidance in the middle steps (0.25 * infer_steps to 0.75 * infer_steps)',
      }),
    )
    .default(0.5),
  guidance_interval_decay: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Guidance interval decay for the generation. Guidance scale will decay from guidance_scale to min_guidance_scale in the interval. 0.0 means no decay.',
      }),
    )
    .default(0),
  audio_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If not provided, a random seed will be used.',
    }),
  ),
  granularity_scale: z
    .optional(
      z.int().gte(-100).lte(100).register(z.globalRegistry, {
        description:
          'Granularity scale for the generation process. Higher values can reduce artifacts.',
      }),
    )
    .default(10),
})

/**
 * ExtendOutput
 */
export const zSchemaV2ExtendOutput = z.object({
  tags: z.optional(z.union([z.array(z.string()), z.unknown()])),
  seed: z.int().register(z.globalRegistry, {
    description:
      'The seed used for generation. This can be used to generate an identical song by passing the same parameters with this seed in a future request.',
  }),
  extend_duration: z.number().register(z.globalRegistry, {
    description: 'The duration in seconds that the song was extended by.',
  }),
  audio: z.array(zSchemaFile).register(z.globalRegistry, {
    description: 'The generated audio files.',
  }),
  lyrics: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * ExtendInput
 */
export const zSchemaV2ExtendInput = z.object({
  prompt: z.optional(z.union([z.string(), z.unknown()])),
  lyrics_prompt: z.optional(z.union([z.string(), z.unknown()])),
  tags: z.optional(z.union([z.array(z.string()), z.unknown()])),
  prompt_strength: z
    .optional(
      z.number().gte(1.4).lte(3.1).register(z.globalRegistry, {
        description:
          'Controls how strongly your prompt influences the output. Greater values adhere more to the prompt but sound less natural. (This is CFG.)',
      }),
    )
    .default(1.8),
  output_bit_rate: z.optional(
    z.union([
      z.union([z.literal(128), z.literal(192), z.literal(256), z.literal(320)]),
      z.unknown(),
    ]),
  ),
  num_songs: z
    .optional(
      z.int().gte(1).lte(2).register(z.globalRegistry, {
        description:
          'Generating 2 songs costs 1.5x the price of generating 1 song. Also, note that using the same seed may not result in identical songs if the number of songs generated is changed.',
      }),
    )
    .default(1),
  output_format: z.optional(z.enum(['flac', 'mp3', 'wav', 'ogg', 'm4a'])),
  side: z.enum(['left', 'right']).register(z.globalRegistry, {
    description: 'Add more to the beginning (left) or end (right) of the song',
  }),
  balance_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Greater means more natural vocals. Lower means sharper instrumentals. We recommend 0.7.',
      }),
    )
    .default(0.7),
  crop_duration: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          'Duration in seconds to crop from the selected side before extending from that side.',
      }),
    )
    .default(0),
  audio_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.union([
      z.int().gte(-9223372036854776000).lte(9223372036854776000),
      z.unknown(),
    ]),
  ),
  extend_duration: z.optional(z.union([z.number().lte(85), z.unknown()])),
})

/**
 * InpaintOutput
 */
export const zSchemaStableAudio25InpaintOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The random seed used for generation',
  }),
  audio: zSchemaFile,
})

/**
 * InpaintInput
 */
export const zSchemaStableAudio25InpaintInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to guide the audio generation',
  }),
  guidance_scale: z
    .optional(
      z.int().gte(1).lte(25).register(z.globalRegistry, {
        description:
          'How strictly the diffusion process adheres to the prompt text (higher values make your audio closer to your prompt). ',
      }),
    )
    .default(1),
  mask_end: z
    .optional(
      z.int().gte(0).lte(190).register(z.globalRegistry, {
        description: 'The end point of the audio mask',
      }),
    )
    .default(190),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  audio_url: z.union([z.string(), z.string()]),
  seed: z.optional(z.int()),
  seconds_total: z
    .optional(
      z.int().gte(1).lte(190).register(z.globalRegistry, {
        description:
          'The duration of the audio clip to generate. If not provided, it will be set to the duration of the input audio.',
      }),
    )
    .default(190),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(8).register(z.globalRegistry, {
        description: 'The number of steps to denoise the audio for',
      }),
    )
    .default(8),
  mask_start: z
    .optional(
      z.int().gte(0).lte(190).register(z.globalRegistry, {
        description: 'The start point of the audio mask',
      }),
    )
    .default(30),
})

/**
 * AudioToAudioOutput
 */
export const zSchemaStableAudio25AudioToAudioOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The random seed used for generation',
  }),
  audio: zSchemaFile,
})

/**
 * AudioToAudioInput
 */
export const zSchemaStableAudio25AudioToAudioInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to guide the audio generation',
  }),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'Sometimes referred to as denoising, this parameter controls how much influence the `audio_url` parameter has on the generated audio. A value of 0 would yield audio that is identical to the input. A value of 1 would be as if you passed in no audio at all.',
      }),
    )
    .default(0.8),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  audio_url: z.union([z.string(), z.string()]),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(8).register(z.globalRegistry, {
        description: 'The number of steps to denoise the audio for',
      }),
    )
    .default(8),
  guidance_scale: z
    .optional(
      z.int().gte(1).lte(25).register(z.globalRegistry, {
        description:
          'How strictly the diffusion process adheres to the prompt text (higher values make your audio closer to your prompt). ',
      }),
    )
    .default(1),
  seed: z.optional(z.int()),
  total_seconds: z.optional(
    z.int().gte(1).lte(190).register(z.globalRegistry, {
      description:
        'The duration of the audio clip to generate. If not provided, it will be set to the duration of the input audio.',
    }),
  ),
})

/**
 * AudioUnderstandingOutput
 */
export const zSchemaAudioUnderstandingOutput = z.object({
  output: z.string().register(z.globalRegistry, {
    description: 'The analysis of the audio content based on the prompt',
  }),
})

/**
 * AudioUnderstandingInput
 */
export const zSchemaAudioUnderstandingInput = z.object({
  prompt: z.string().min(1).max(10000).register(z.globalRegistry, {
    description: 'The question or prompt about the audio content.',
  }),
  detailed_analysis: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to request a more detailed analysis of the audio',
      }),
    )
    .default(false),
  audio_url: z.union([z.string(), z.string()]),
})

/**
 * DemucsOutput
 */
export const zSchemaDemucsOutput = z.object({
  vocals: z.optional(z.union([zSchemaFile, z.unknown()])),
  guitar: z.optional(z.union([zSchemaFile, z.unknown()])),
  bass: z.optional(z.union([zSchemaFile, z.unknown()])),
  piano: z.optional(z.union([zSchemaFile, z.unknown()])),
  other: z.optional(z.union([zSchemaFile, z.unknown()])),
  drums: z.optional(z.union([zSchemaFile, z.unknown()])),
})

/**
 * DemucsInput
 */
export const zSchemaDemucsInput = z.object({
  segment_length: z.optional(z.union([z.int(), z.unknown()])),
  output_format: z.optional(
    z.enum(['wav', 'mp3']).register(z.globalRegistry, {
      description: 'Output audio format for the separated stems',
    }),
  ),
  stems: z.optional(
    z.union([
      z.array(z.enum(['vocals', 'drums', 'bass', 'other', 'guitar', 'piano'])),
      z.unknown(),
    ]),
  ),
  overlap: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Overlap between segments (0.0 to 1.0). Higher values may improve quality but increase processing time.',
      }),
    )
    .default(0.25),
  model: z.optional(
    z
      .enum([
        'htdemucs',
        'htdemucs_ft',
        'htdemucs_6s',
        'hdemucs_mmi',
        'mdx',
        'mdx_extra',
        'mdx_q',
        'mdx_extra_q',
      ])
      .register(z.globalRegistry, {
        description: 'Demucs model to use for separation',
      }),
  ),
  audio_url: z.union([z.string(), z.string()]),
  shifts: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Number of random shifts for equivariant stabilization. Higher values improve quality but increase processing time.',
      }),
    )
    .default(1),
})

/**
 * CreateVoiceOutput
 *
 * Response model for creating a custom voice.
 */
export const zSchemaKlingVideoCreateVoiceOutput = z
  .object({
    voice_id: z.string().register(z.globalRegistry, {
      description: 'Unique identifier for the created voice',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Response model for creating a custom voice.',
  })

/**
 * CreateVoiceInput
 *
 * Request model for creating a custom voice.
 */
export const zSchemaKlingVideoCreateVoiceInput = z
  .object({
    voice_url: z.union([z.string(), z.string()]),
  })
  .register(z.globalRegistry, {
    description: 'Request model for creating a custom voice.',
  })

/**
 * MergeAudiosOutput
 */
export const zSchemaFfmpegApiMergeAudiosOutput = z.object({
  audio: zSchemaFile,
})

/**
 * MergeAudiosInput
 */
export const zSchemaFfmpegApiMergeAudiosInput = z.object({
  audio_urls: z.array(z.string()).min(2).max(5).register(z.globalRegistry, {
    description:
      'List of audio URLs to merge in order. The 0th stream of the audio will be considered as the merge candidate.',
  }),
  output_format: z.optional(
    z.union([
      z.enum([
        'mp3_22050_32',
        'mp3_44100_32',
        'mp3_44100_64',
        'mp3_44100_96',
        'mp3_44100_128',
        'mp3_44100_192',
        'pcm_8000',
        'pcm_16000',
        'pcm_22050',
        'pcm_24000',
        'pcm_44100',
        'pcm_48000',
        'ulaw_8000',
        'alaw_8000',
        'opus_48000_32',
        'opus_48000_64',
        'opus_48000_96',
        'opus_48000_128',
        'opus_48000_192',
      ]),
      z.unknown(),
    ]),
  ),
})

/**
 * AudioTimeSpan
 *
 * A time span indicating where the target sound occurs.
 */
export const zSchemaAudioTimeSpan = z
  .object({
    end: z.number().gte(0).register(z.globalRegistry, {
      description: 'End time of the span in seconds',
    }),
    start: z.number().gte(0).register(z.globalRegistry, {
      description: 'Start time of the span in seconds',
    }),
    include: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to include (True) or exclude (False) sounds in this span',
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: 'A time span indicating where the target sound occurs.',
  })

/**
 * SAMAudioSpanSeparateOutput
 *
 * Output for span-based audio separation.
 */
export const zSchemaSamAudioSpanSeparateOutput = z
  .object({
    target: zSchemaFile,
    duration: z.number().register(z.globalRegistry, {
      description: 'Duration of the output audio in seconds.',
    }),
    sample_rate: z
      .optional(
        z.int().register(z.globalRegistry, {
          description: 'Sample rate of the output audio in Hz.',
        }),
      )
      .default(48000),
    residual: zSchemaFile,
  })
  .register(z.globalRegistry, {
    description: 'Output for span-based audio separation.',
  })

/**
 * SAMAudioSpanInput
 *
 * Input for temporal span-based audio separation.
 */
export const zSchemaSamAudioSpanSeparateInput = z
  .object({
    prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'Text prompt describing the sound to isolate. Optional but recommended - helps the model identify what type of sound to extract from the span.',
      }),
    ),
    acceleration: z.optional(
      z.enum(['fast', 'balanced', 'quality']).register(z.globalRegistry, {
        description: 'The acceleration level to use.',
      }),
    ),
    spans: z.array(zSchemaAudioTimeSpan).register(z.globalRegistry, {
      description:
        'Time spans where the target sound occurs which should be isolated.',
    }),
    output_format: z.optional(
      z.enum(['wav', 'mp3']).register(z.globalRegistry, {
        description: 'Output audio format.',
      }),
    ),
    trim_to_span: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Trim output audio to only include the specified span time range. If False, returns the full audio length with the target sound isolated throughout.',
        }),
      )
      .default(false),
    audio_url: z.union([z.string(), z.string()]),
    reranking_candidates: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description:
            'Number of candidates to generate and rank. Higher improves quality but increases latency and cost. Requires text prompt; ignored for span-only separation.',
        }),
      )
      .default(1),
  })
  .register(z.globalRegistry, {
    description: 'Input for temporal span-based audio separation.',
  })

/**
 * SAMAudioSeparateOutput
 *
 * Output for text-based audio separation.
 */
export const zSchemaSamAudioSeparateOutput = z
  .object({
    target: zSchemaFile,
    duration: z.number().register(z.globalRegistry, {
      description: 'Duration of the output audio in seconds.',
    }),
    sample_rate: z
      .optional(
        z.int().register(z.globalRegistry, {
          description: 'Sample rate of the output audio in Hz.',
        }),
      )
      .default(48000),
    residual: zSchemaFile,
  })
  .register(z.globalRegistry, {
    description: 'Output for text-based audio separation.',
  })

/**
 * SAMAudioInput
 *
 * Input for text-based audio separation.
 */
export const zSchemaSamAudioSeparateInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'Text prompt describing the sound to isolate.',
    }),
    acceleration: z.optional(
      z.enum(['fast', 'balanced', 'quality']).register(z.globalRegistry, {
        description: 'The acceleration level to use.',
      }),
    ),
    audio_url: z.union([z.string(), z.string()]),
    predict_spans: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Automatically predict temporal spans where the target sound occurs.',
        }),
      )
      .default(false),
    output_format: z.optional(
      z.enum(['wav', 'mp3']).register(z.globalRegistry, {
        description: 'Output audio format.',
      }),
    ),
    reranking_candidates: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description:
            'Number of candidates to generate and rank. Higher improves quality but increases latency and cost.',
        }),
      )
      .default(1),
  })
  .register(z.globalRegistry, {
    description: 'Input for text-based audio separation.',
  })

/**
 * DeepFilterNetTimings
 */
export const zSchemaDeepFilterNetTimings = z.object({
  postprocess: z.number().register(z.globalRegistry, {
    description: 'Postprocessing time.',
  }),
  inference: z.number().register(z.globalRegistry, {
    description: 'Inference time.',
  }),
  preprocess: z.number().register(z.globalRegistry, {
    description: 'Preprocessing time.',
  }),
})

/**
 * DeepFilterNet3Output
 */
export const zSchemaDeepfilternet3Output = z.object({
  timings: zSchemaDeepFilterNetTimings,
  audio_file: zSchemaAudioFile,
})

/**
 * DeepFilterNet3Input
 */
export const zSchemaDeepfilternet3Input = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  audio_format: z.optional(
    z
      .enum(['mp3', 'aac', 'm4a', 'ogg', 'opus', 'flac', 'wav'])
      .register(z.globalRegistry, {
        description: 'The format for the output audio.',
      }),
  ),
  audio_url: z.union([z.string(), z.string()]),
  bitrate: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The bitrate of the output audio.',
      }),
    )
    .default('192k'),
})

/**
 * NovaSRTimings
 */
export const zSchemaNovaSrTimings = z.object({
  postprocess: z.number().register(z.globalRegistry, {
    description: 'Time taken to postprocess the audio in seconds.',
  }),
  inference: z.number().register(z.globalRegistry, {
    description: 'Time taken to run the inference in seconds.',
  }),
  preprocess: z.number().register(z.globalRegistry, {
    description: 'Time taken to preprocess the audio in seconds.',
  }),
})

/**
 * NovaSROutput
 */
export const zSchemaNovaSrOutput = z.object({
  timings: zSchemaNovaSrTimings,
  audio: zSchemaAudioFile,
})

/**
 * NovaSRInput
 */
export const zSchemaNovaSrInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  bitrate: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The bitrate of the output audio.',
      }),
    )
    .default('192k'),
  audio_url: z.union([z.string(), z.string()]),
  audio_format: z.optional(
    z
      .enum(['mp3', 'aac', 'm4a', 'ogg', 'opus', 'flac', 'wav'])
      .register(z.globalRegistry, {
        description: 'The format for the output audio.',
      }),
  ),
})

/**
 * VoiceChangerOutput
 */
export const zSchemaElevenlabsVoiceChangerOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'Random seed for reproducibility.',
  }),
  audio: zSchemaFile,
})

/**
 * VoiceChangerRequest
 */
export const zSchemaElevenlabsVoiceChangerInput = z.object({
  voice: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The voice to use for speech generation',
      }),
    )
    .default('Rachel'),
  audio_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducibility.',
    }),
  ),
  output_format: z.optional(
    z
      .enum([
        'mp3_22050_32',
        'mp3_44100_32',
        'mp3_44100_64',
        'mp3_44100_96',
        'mp3_44100_128',
        'mp3_44100_192',
        'pcm_8000',
        'pcm_16000',
        'pcm_22050',
        'pcm_24000',
        'pcm_44100',
        'pcm_48000',
        'ulaw_8000',
        'alaw_8000',
        'opus_48000_32',
        'opus_48000_64',
        'opus_48000_96',
        'opus_48000_128',
        'opus_48000_192',
      ])
      .register(z.globalRegistry, {
        description:
          'Output format of the generated audio. Formatted as codec_sample_rate_bitrate.',
      }),
  ),
  remove_background_noise: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set, will remove the background noise from your audio input using our audio isolation model.',
      }),
    )
    .default(false),
})

export const zSchemaQueueStatus = z.object({
  status: z.enum(['IN_QUEUE', 'IN_PROGRESS', 'COMPLETED']),
  request_id: z.string().register(z.globalRegistry, {
    description: 'The request id.',
  }),
  response_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The response url.',
    }),
  ),
  status_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The status url.',
    }),
  ),
  cancel_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The cancel url.',
    }),
  ),
  logs: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The logs.',
    }),
  ),
  metrics: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The metrics.',
    }),
  ),
  queue_position: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The queue position.',
    }),
  ),
})

export const zGetFalAiElevenlabsVoiceChangerRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiElevenlabsVoiceChangerRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiElevenlabsVoiceChangerRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiElevenlabsVoiceChangerRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiElevenlabsVoiceChangerData = z.object({
  body: zSchemaElevenlabsVoiceChangerInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiElevenlabsVoiceChangerResponse = zSchemaQueueStatus

export const zGetFalAiElevenlabsVoiceChangerRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiElevenlabsVoiceChangerRequestsByRequestIdResponse =
  zSchemaElevenlabsVoiceChangerOutput

export const zGetFalAiNovaSrRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiNovaSrRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiNovaSrRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiNovaSrRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiNovaSrData = z.object({
  body: zSchemaNovaSrInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiNovaSrResponse = zSchemaQueueStatus

export const zGetFalAiNovaSrRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiNovaSrRequestsByRequestIdResponse = zSchemaNovaSrOutput

export const zGetFalAiDeepfilternet3RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiDeepfilternet3RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiDeepfilternet3RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiDeepfilternet3RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiDeepfilternet3Data = z.object({
  body: zSchemaDeepfilternet3Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiDeepfilternet3Response = zSchemaQueueStatus

export const zGetFalAiDeepfilternet3RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiDeepfilternet3RequestsByRequestIdResponse =
  zSchemaDeepfilternet3Output

export const zGetFalAiSamAudioSeparateRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiSamAudioSeparateRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSamAudioSeparateRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiSamAudioSeparateRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSamAudioSeparateData = z.object({
  body: zSchemaSamAudioSeparateInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSamAudioSeparateResponse = zSchemaQueueStatus

export const zGetFalAiSamAudioSeparateRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSamAudioSeparateRequestsByRequestIdResponse =
  zSchemaSamAudioSeparateOutput

export const zGetFalAiSamAudioSpanSeparateRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiSamAudioSpanSeparateRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSamAudioSpanSeparateRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiSamAudioSpanSeparateRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSamAudioSpanSeparateData = z.object({
  body: zSchemaSamAudioSpanSeparateInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSamAudioSpanSeparateResponse = zSchemaQueueStatus

export const zGetFalAiSamAudioSpanSeparateRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSamAudioSpanSeparateRequestsByRequestIdResponse =
  zSchemaSamAudioSpanSeparateOutput

export const zGetFalAiFfmpegApiMergeAudiosRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFfmpegApiMergeAudiosRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFfmpegApiMergeAudiosRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFfmpegApiMergeAudiosRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFfmpegApiMergeAudiosData = z.object({
  body: zSchemaFfmpegApiMergeAudiosInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFfmpegApiMergeAudiosResponse = zSchemaQueueStatus

export const zGetFalAiFfmpegApiMergeAudiosRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFfmpegApiMergeAudiosRequestsByRequestIdResponse =
  zSchemaFfmpegApiMergeAudiosOutput

export const zGetFalAiKlingVideoCreateVoiceRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiKlingVideoCreateVoiceRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKlingVideoCreateVoiceRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiKlingVideoCreateVoiceRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKlingVideoCreateVoiceData = z.object({
  body: zSchemaKlingVideoCreateVoiceInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKlingVideoCreateVoiceResponse = zSchemaQueueStatus

export const zGetFalAiKlingVideoCreateVoiceRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKlingVideoCreateVoiceRequestsByRequestIdResponse =
  zSchemaKlingVideoCreateVoiceOutput

export const zGetFalAiDemucsRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiDemucsRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiDemucsRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiDemucsRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiDemucsData = z.object({
  body: zSchemaDemucsInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiDemucsResponse = zSchemaQueueStatus

export const zGetFalAiDemucsRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiDemucsRequestsByRequestIdResponse = zSchemaDemucsOutput

export const zGetFalAiAudioUnderstandingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiAudioUnderstandingRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiAudioUnderstandingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiAudioUnderstandingRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiAudioUnderstandingData = z.object({
  body: zSchemaAudioUnderstandingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiAudioUnderstandingResponse = zSchemaQueueStatus

export const zGetFalAiAudioUnderstandingRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiAudioUnderstandingRequestsByRequestIdResponse =
  zSchemaAudioUnderstandingOutput

export const zGetFalAiStableAudio25AudioToAudioRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiStableAudio25AudioToAudioRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiStableAudio25AudioToAudioRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiStableAudio25AudioToAudioRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiStableAudio25AudioToAudioData = z.object({
  body: zSchemaStableAudio25AudioToAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiStableAudio25AudioToAudioResponse = zSchemaQueueStatus

export const zGetFalAiStableAudio25AudioToAudioRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiStableAudio25AudioToAudioRequestsByRequestIdResponse =
  zSchemaStableAudio25AudioToAudioOutput

export const zGetFalAiStableAudio25InpaintRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiStableAudio25InpaintRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiStableAudio25InpaintRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiStableAudio25InpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiStableAudio25InpaintData = z.object({
  body: zSchemaStableAudio25InpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiStableAudio25InpaintResponse = zSchemaQueueStatus

export const zGetFalAiStableAudio25InpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiStableAudio25InpaintRequestsByRequestIdResponse =
  zSchemaStableAudio25InpaintOutput

export const zGetSonautoV2ExtendRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetSonautoV2ExtendRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutSonautoV2ExtendRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutSonautoV2ExtendRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostSonautoV2ExtendData = z.object({
  body: zSchemaV2ExtendInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostSonautoV2ExtendResponse = zSchemaQueueStatus

export const zGetSonautoV2ExtendRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetSonautoV2ExtendRequestsByRequestIdResponse =
  zSchemaV2ExtendOutput

export const zGetFalAiAceStepAudioOutpaintRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiAceStepAudioOutpaintRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiAceStepAudioOutpaintRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiAceStepAudioOutpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiAceStepAudioOutpaintData = z.object({
  body: zSchemaAceStepAudioOutpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiAceStepAudioOutpaintResponse = zSchemaQueueStatus

export const zGetFalAiAceStepAudioOutpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiAceStepAudioOutpaintRequestsByRequestIdResponse =
  zSchemaAceStepAudioOutpaintOutput

export const zGetFalAiAceStepAudioInpaintRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiAceStepAudioInpaintRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiAceStepAudioInpaintRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiAceStepAudioInpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiAceStepAudioInpaintData = z.object({
  body: zSchemaAceStepAudioInpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiAceStepAudioInpaintResponse = zSchemaQueueStatus

export const zGetFalAiAceStepAudioInpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiAceStepAudioInpaintRequestsByRequestIdResponse =
  zSchemaAceStepAudioInpaintOutput

export const zGetFalAiAceStepAudioToAudioRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiAceStepAudioToAudioRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiAceStepAudioToAudioRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiAceStepAudioToAudioRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiAceStepAudioToAudioData = z.object({
  body: zSchemaAceStepAudioToAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiAceStepAudioToAudioResponse = zSchemaQueueStatus

export const zGetFalAiAceStepAudioToAudioRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiAceStepAudioToAudioRequestsByRequestIdResponse =
  zSchemaAceStepAudioToAudioOutput

export const zGetFalAiDiaTtsVoiceCloneRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiDiaTtsVoiceCloneRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiDiaTtsVoiceCloneRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiDiaTtsVoiceCloneRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiDiaTtsVoiceCloneData = z.object({
  body: zSchemaDiaTtsVoiceCloneInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiDiaTtsVoiceCloneResponse = zSchemaQueueStatus

export const zGetFalAiDiaTtsVoiceCloneRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiDiaTtsVoiceCloneRequestsByRequestIdResponse =
  zSchemaDiaTtsVoiceCloneOutput

export const zGetFalAiElevenlabsAudioIsolationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiElevenlabsAudioIsolationRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiElevenlabsAudioIsolationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiElevenlabsAudioIsolationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiElevenlabsAudioIsolationData = z.object({
  body: zSchemaElevenlabsAudioIsolationInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiElevenlabsAudioIsolationResponse = zSchemaQueueStatus

export const zGetFalAiElevenlabsAudioIsolationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiElevenlabsAudioIsolationRequestsByRequestIdResponse =
  zSchemaElevenlabsAudioIsolationOutput

export const zGetFalAiElevenlabsMusicRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiElevenlabsMusicRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiElevenlabsMusicRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiElevenlabsMusicRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiElevenlabsMusicData = z.object({
  body: zSchemaElevenlabsMusicInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiElevenlabsMusicResponse = zSchemaQueueStatus

export const zGetFalAiElevenlabsMusicRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiElevenlabsMusicRequestsByRequestIdResponse =
  zSchemaElevenlabsMusicOutput

export const zGetFalAiMinimaxMusicV2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiMinimaxMusicV2RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiMinimaxMusicV2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiMinimaxMusicV2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiMinimaxMusicV2Data = z.object({
  body: zSchemaMinimaxMusicV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiMinimaxMusicV2Response = zSchemaQueueStatus

export const zGetFalAiMinimaxMusicV2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiMinimaxMusicV2RequestsByRequestIdResponse =
  zSchemaMinimaxMusicV2Output

export const zGetBeatovenSoundEffectGenerationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetBeatovenSoundEffectGenerationRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBeatovenSoundEffectGenerationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutBeatovenSoundEffectGenerationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostBeatovenSoundEffectGenerationData = z.object({
  body: zSchemaSoundEffectGenerationInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBeatovenSoundEffectGenerationResponse = zSchemaQueueStatus

export const zGetBeatovenSoundEffectGenerationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetBeatovenSoundEffectGenerationRequestsByRequestIdResponse =
  zSchemaSoundEffectGenerationOutput

export const zGetBeatovenMusicGenerationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetBeatovenMusicGenerationRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBeatovenMusicGenerationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutBeatovenMusicGenerationRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostBeatovenMusicGenerationData = z.object({
  body: zSchemaMusicGenerationInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBeatovenMusicGenerationResponse = zSchemaQueueStatus

export const zGetBeatovenMusicGenerationRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetBeatovenMusicGenerationRequestsByRequestIdResponse =
  zSchemaMusicGenerationOutput

export const zGetFalAiMinimaxMusicV15RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiMinimaxMusicV15RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiMinimaxMusicV15RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiMinimaxMusicV15RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiMinimaxMusicV15Data = z.object({
  body: zSchemaMinimaxMusicV15Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiMinimaxMusicV15Response = zSchemaQueueStatus

export const zGetFalAiMinimaxMusicV15RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiMinimaxMusicV15RequestsByRequestIdResponse =
  zSchemaMinimaxMusicV15Output

export const zGetFalAiStableAudio25TextToAudioRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiStableAudio25TextToAudioRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiStableAudio25TextToAudioRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiStableAudio25TextToAudioRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiStableAudio25TextToAudioData = z.object({
  body: zSchemaStableAudio25TextToAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiStableAudio25TextToAudioResponse = zSchemaQueueStatus

export const zGetFalAiStableAudio25TextToAudioRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiStableAudio25TextToAudioRequestsByRequestIdResponse =
  zSchemaStableAudio25TextToAudioOutput

export const zGetFalAiElevenlabsTextToDialogueElevenV3RequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiElevenlabsTextToDialogueElevenV3RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiElevenlabsTextToDialogueElevenV3RequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiElevenlabsTextToDialogueElevenV3RequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiElevenlabsTextToDialogueElevenV3Data = z.object({
  body: zSchemaElevenlabsTextToDialogueElevenV3Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiElevenlabsTextToDialogueElevenV3Response =
  zSchemaQueueStatus

export const zGetFalAiElevenlabsTextToDialogueElevenV3RequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiElevenlabsTextToDialogueElevenV3RequestsByRequestIdResponse =
  zSchemaElevenlabsTextToDialogueElevenV3Output

export const zGetFalAiElevenlabsSoundEffectsV2RequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiElevenlabsSoundEffectsV2RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiElevenlabsSoundEffectsV2RequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiElevenlabsSoundEffectsV2RequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiElevenlabsSoundEffectsV2Data = z.object({
  body: zSchemaElevenlabsSoundEffectsV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiElevenlabsSoundEffectsV2Response = zSchemaQueueStatus

export const zGetFalAiElevenlabsSoundEffectsV2RequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiElevenlabsSoundEffectsV2RequestsByRequestIdResponse =
  zSchemaElevenlabsSoundEffectsV2Output

export const zGetSonautoV2InpaintRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetSonautoV2InpaintRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutSonautoV2InpaintRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutSonautoV2InpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostSonautoV2InpaintData = z.object({
  body: zSchemaV2InpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostSonautoV2InpaintResponse = zSchemaQueueStatus

export const zGetSonautoV2InpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetSonautoV2InpaintRequestsByRequestIdResponse =
  zSchemaV2InpaintOutput

export const zGetSonautoV2TextToMusicRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetSonautoV2TextToMusicRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutSonautoV2TextToMusicRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutSonautoV2TextToMusicRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostSonautoV2TextToMusicData = z.object({
  body: zSchemaV2TextToMusicInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostSonautoV2TextToMusicResponse = zSchemaQueueStatus

export const zGetSonautoV2TextToMusicRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetSonautoV2TextToMusicRequestsByRequestIdResponse =
  zSchemaV2TextToMusicOutput

export const zGetFalAiElevenlabsTtsElevenV3RequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiElevenlabsTtsElevenV3RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiElevenlabsTtsElevenV3RequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiElevenlabsTtsElevenV3RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiElevenlabsTtsElevenV3Data = z.object({
  body: zSchemaElevenlabsTtsElevenV3Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiElevenlabsTtsElevenV3Response = zSchemaQueueStatus

export const zGetFalAiElevenlabsTtsElevenV3RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiElevenlabsTtsElevenV3RequestsByRequestIdResponse =
  zSchemaElevenlabsTtsElevenV3Output

export const zGetFalAiLyria2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiLyria2RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLyria2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiLyria2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLyria2Data = z.object({
  body: zSchemaLyria2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLyria2Response = zSchemaQueueStatus

export const zGetFalAiLyria2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLyria2RequestsByRequestIdResponse = zSchemaLyria2Output

export const zGetFalAiAceStepPromptToAudioRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiAceStepPromptToAudioRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiAceStepPromptToAudioRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiAceStepPromptToAudioRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiAceStepPromptToAudioData = z.object({
  body: zSchemaAceStepPromptToAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiAceStepPromptToAudioResponse = zSchemaQueueStatus

export const zGetFalAiAceStepPromptToAudioRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiAceStepPromptToAudioRequestsByRequestIdResponse =
  zSchemaAceStepPromptToAudioOutput

export const zGetFalAiAceStepRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiAceStepRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiAceStepRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiAceStepRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiAceStepData = z.object({
  body: zSchemaAceStepInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiAceStepResponse = zSchemaQueueStatus

export const zGetFalAiAceStepRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiAceStepRequestsByRequestIdResponse = zSchemaAceStepOutput

export const zGetCassetteaiSoundEffectsGeneratorRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetCassetteaiSoundEffectsGeneratorRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutCassetteaiSoundEffectsGeneratorRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutCassetteaiSoundEffectsGeneratorRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostCassetteaiSoundEffectsGeneratorData = z.object({
  body: zSchemaSoundEffectsGeneratorInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostCassetteaiSoundEffectsGeneratorResponse = zSchemaQueueStatus

export const zGetCassetteaiSoundEffectsGeneratorRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetCassetteaiSoundEffectsGeneratorRequestsByRequestIdResponse =
  zSchemaSoundEffectsGeneratorOutput

export const zGetCassetteaiMusicGeneratorRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetCassetteaiMusicGeneratorRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutCassetteaiMusicGeneratorRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutCassetteaiMusicGeneratorRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostCassetteaiMusicGeneratorData = z.object({
  body: zSchemaMusicGeneratorInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostCassetteaiMusicGeneratorResponse = zSchemaQueueStatus

export const zGetCassetteaiMusicGeneratorRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetCassetteaiMusicGeneratorRequestsByRequestIdResponse =
  zSchemaMusicGeneratorOutput

export const zGetFalAiCsm1bRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiCsm1bRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiCsm1bRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiCsm1bRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiCsm1bData = z.object({
  body: zSchemaCsm1bInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiCsm1bResponse = zSchemaQueueStatus

export const zGetFalAiCsm1bRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiCsm1bRequestsByRequestIdResponse = zSchemaCsm1bOutput

export const zGetFalAiDiffrhythmRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiDiffrhythmRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiDiffrhythmRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiDiffrhythmRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiDiffrhythmData = z.object({
  body: zSchemaDiffrhythmInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiDiffrhythmResponse = zSchemaQueueStatus

export const zGetFalAiDiffrhythmRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiDiffrhythmRequestsByRequestIdResponse =
  zSchemaDiffrhythmOutput

export const zGetFalAiElevenlabsTtsMultilingualV2RequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiElevenlabsTtsMultilingualV2RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiElevenlabsTtsMultilingualV2RequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiElevenlabsTtsMultilingualV2RequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiElevenlabsTtsMultilingualV2Data = z.object({
  body: zSchemaElevenlabsTtsMultilingualV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiElevenlabsTtsMultilingualV2Response = zSchemaQueueStatus

export const zGetFalAiElevenlabsTtsMultilingualV2RequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiElevenlabsTtsMultilingualV2RequestsByRequestIdResponse =
  zSchemaElevenlabsTtsMultilingualV2Output

export const zGetFalAiKokoroHindiRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiKokoroHindiRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKokoroHindiRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroHindiRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKokoroHindiData = z.object({
  body: zSchemaKokoroHindiInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKokoroHindiResponse = zSchemaQueueStatus

export const zGetFalAiKokoroHindiRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKokoroHindiRequestsByRequestIdResponse =
  zSchemaKokoroHindiOutput

export const zGetFalAiKokoroMandarinChineseRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiKokoroMandarinChineseRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKokoroMandarinChineseRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroMandarinChineseRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKokoroMandarinChineseData = z.object({
  body: zSchemaKokoroMandarinChineseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKokoroMandarinChineseResponse = zSchemaQueueStatus

export const zGetFalAiKokoroMandarinChineseRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKokoroMandarinChineseRequestsByRequestIdResponse =
  zSchemaKokoroMandarinChineseOutput

export const zGetFalAiKokoroSpanishRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiKokoroSpanishRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKokoroSpanishRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroSpanishRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKokoroSpanishData = z.object({
  body: zSchemaKokoroSpanishInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKokoroSpanishResponse = zSchemaQueueStatus

export const zGetFalAiKokoroSpanishRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKokoroSpanishRequestsByRequestIdResponse =
  zSchemaKokoroSpanishOutput

export const zGetFalAiKokoroBrazilianPortugueseRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiKokoroBrazilianPortugueseRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKokoroBrazilianPortugueseRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroBrazilianPortugueseRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiKokoroBrazilianPortugueseData = z.object({
  body: zSchemaKokoroBrazilianPortugueseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKokoroBrazilianPortugueseResponse = zSchemaQueueStatus

export const zGetFalAiKokoroBrazilianPortugueseRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiKokoroBrazilianPortugueseRequestsByRequestIdResponse =
  zSchemaKokoroBrazilianPortugueseOutput

export const zGetFalAiKokoroBritishEnglishRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiKokoroBritishEnglishRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKokoroBritishEnglishRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroBritishEnglishRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKokoroBritishEnglishData = z.object({
  body: zSchemaKokoroBritishEnglishInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKokoroBritishEnglishResponse = zSchemaQueueStatus

export const zGetFalAiKokoroBritishEnglishRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKokoroBritishEnglishRequestsByRequestIdResponse =
  zSchemaKokoroBritishEnglishOutput

export const zGetFalAiKokoroFrenchRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiKokoroFrenchRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKokoroFrenchRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroFrenchRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKokoroFrenchData = z.object({
  body: zSchemaKokoroFrenchInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKokoroFrenchResponse = zSchemaQueueStatus

export const zGetFalAiKokoroFrenchRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKokoroFrenchRequestsByRequestIdResponse =
  zSchemaKokoroFrenchOutput

export const zGetFalAiKokoroJapaneseRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiKokoroJapaneseRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKokoroJapaneseRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroJapaneseRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKokoroJapaneseData = z.object({
  body: zSchemaKokoroJapaneseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKokoroJapaneseResponse = zSchemaQueueStatus

export const zGetFalAiKokoroJapaneseRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKokoroJapaneseRequestsByRequestIdResponse =
  zSchemaKokoroJapaneseOutput

export const zGetFalAiKokoroAmericanEnglishRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiKokoroAmericanEnglishRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKokoroAmericanEnglishRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroAmericanEnglishRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKokoroAmericanEnglishData = z.object({
  body: zSchemaKokoroAmericanEnglishInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKokoroAmericanEnglishResponse = zSchemaQueueStatus

export const zGetFalAiKokoroAmericanEnglishRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKokoroAmericanEnglishRequestsByRequestIdResponse =
  zSchemaKokoroAmericanEnglishOutput

export const zGetFalAiZonosRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiZonosRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiZonosRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiZonosRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiZonosData = z.object({
  body: zSchemaZonosInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiZonosResponse = zSchemaQueueStatus

export const zGetFalAiZonosRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiZonosRequestsByRequestIdResponse = zSchemaZonosOutput

export const zGetFalAiKokoroItalianRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiKokoroItalianRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKokoroItalianRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroItalianRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKokoroItalianData = z.object({
  body: zSchemaKokoroItalianInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKokoroItalianResponse = zSchemaQueueStatus

export const zGetFalAiKokoroItalianRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKokoroItalianRequestsByRequestIdResponse =
  zSchemaKokoroItalianOutput

export const zGetFalAiYueRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiYueRequestsByRequestIdStatusResponse = zSchemaQueueStatus

export const zPutFalAiYueRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiYueRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiYueData = z.object({
  body: zSchemaYueInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiYueResponse = zSchemaQueueStatus

export const zGetFalAiYueRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiYueRequestsByRequestIdResponse = zSchemaYueOutput

export const zGetFalAiMmaudioV2TextToAudioRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiMmaudioV2TextToAudioRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiMmaudioV2TextToAudioRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiMmaudioV2TextToAudioRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiMmaudioV2TextToAudioData = z.object({
  body: zSchemaMmaudioV2TextToAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiMmaudioV2TextToAudioResponse = zSchemaQueueStatus

export const zGetFalAiMmaudioV2TextToAudioRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiMmaudioV2TextToAudioRequestsByRequestIdResponse =
  zSchemaMmaudioV2TextToAudioOutput

export const zGetFalAiMinimaxMusicRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiMinimaxMusicRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiMinimaxMusicRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiMinimaxMusicRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiMinimaxMusicData = z.object({
  body: zSchemaMinimaxMusicInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiMinimaxMusicResponse = zSchemaQueueStatus

export const zGetFalAiMinimaxMusicRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiMinimaxMusicRequestsByRequestIdResponse =
  zSchemaMinimaxMusicOutput

export const zGetFalAiF5TtsRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiF5TtsRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiF5TtsRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiF5TtsRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiF5TtsData = z.object({
  body: zSchemaF5TtsInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiF5TtsResponse = zSchemaQueueStatus

export const zGetFalAiF5TtsRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiF5TtsRequestsByRequestIdResponse = zSchemaF5TtsOutput

export const zGetFalAiStableAudioRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiStableAudioRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiStableAudioRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiStableAudioRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiStableAudioData = z.object({
  body: zSchemaStableAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiStableAudioResponse = zSchemaQueueStatus

export const zGetFalAiStableAudioRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiStableAudioRequestsByRequestIdResponse =
  zSchemaStableAudioOutput

export const zGetFalAiSamAudioVisualSeparateRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiSamAudioVisualSeparateRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSamAudioVisualSeparateRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiSamAudioVisualSeparateRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiSamAudioVisualSeparateData = z.object({
  body: zSchemaSamAudioVisualSeparateInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSamAudioVisualSeparateResponse = zSchemaQueueStatus

export const zGetFalAiSamAudioVisualSeparateRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSamAudioVisualSeparateRequestsByRequestIdResponse =
  zSchemaSamAudioVisualSeparateOutput

export const zGetMireloAiSfxV15VideoToAudioRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetMireloAiSfxV15VideoToAudioRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutMireloAiSfxV15VideoToAudioRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutMireloAiSfxV15VideoToAudioRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostMireloAiSfxV15VideoToAudioData = z.object({
  body: zSchemaSfxV15VideoToAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostMireloAiSfxV15VideoToAudioResponse = zSchemaQueueStatus

export const zGetMireloAiSfxV15VideoToAudioRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetMireloAiSfxV15VideoToAudioRequestsByRequestIdResponse =
  zSchemaSfxV15VideoToAudioOutput

export const zGetFalAiKlingVideoVideoToAudioRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiKlingVideoVideoToAudioRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKlingVideoVideoToAudioRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiKlingVideoVideoToAudioRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiKlingVideoVideoToAudioData = z.object({
  body: zSchemaKlingVideoVideoToAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKlingVideoVideoToAudioResponse = zSchemaQueueStatus

export const zGetFalAiKlingVideoVideoToAudioRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKlingVideoVideoToAudioRequestsByRequestIdResponse =
  zSchemaKlingVideoVideoToAudioOutput

export const zGetMireloAiSfxV1VideoToAudioRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetMireloAiSfxV1VideoToAudioRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutMireloAiSfxV1VideoToAudioRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutMireloAiSfxV1VideoToAudioRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostMireloAiSfxV1VideoToAudioData = z.object({
  body: zSchemaSfxV1VideoToAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostMireloAiSfxV1VideoToAudioResponse = zSchemaQueueStatus

export const zGetMireloAiSfxV1VideoToAudioRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetMireloAiSfxV1VideoToAudioRequestsByRequestIdResponse =
  zSchemaSfxV1VideoToAudioOutput
