// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod'

export const zFile = z.object({
  url: z.url(),
  content_type: z.optional(z.string()),
  file_name: z.optional(z.string()),
  file_size: z.optional(z.int()),
})

export const zQueueStatus = z.object({
  status: z.enum(['IN_PROGRESS', 'COMPLETED', 'FAILED']),
  response_url: z.optional(z.url()),
})

/**
 * SingleImageInputModel
 */
export const zTrellis2Input = z.object({
  remesh_band: z.optional(z.number().gte(0).lte(4)).default(1),
  ss_guidance_rescale: z.optional(z.number().gte(0).lte(1)).default(0.7),
  ss_rescale_t: z.optional(z.number().gte(1).lte(6)).default(5),
  shape_slat_sampling_steps: z.optional(z.int().gte(1).lte(50)).default(12),
  tex_slat_rescale_t: z.optional(z.number().gte(1).lte(6)).default(3),
  ss_guidance_strength: z.optional(z.number().gte(0).lte(10)).default(7.5),
  ss_sampling_steps: z.optional(z.int().gte(1).lte(50)).default(12),
  tex_slat_sampling_steps: z.optional(z.int().gte(1).lte(50)).default(12),
  remesh_project: z.optional(z.number().gte(0).lte(1)).default(0),
  texture_size: z.optional(
    z
      .union([z.literal(1024), z.literal(2048), z.literal(4096)])
      .register(z.globalRegistry, {
        description: 'Texture resolution',
      }),
  ),
  shape_slat_rescale_t: z.optional(z.number().gte(1).lte(6)).default(3),
  resolution: z.optional(
    z
      .union([z.literal(512), z.literal(1024), z.literal(1536)])
      .register(z.globalRegistry, {
        description: 'Output resolution; higher is slower but more detailed',
      }),
  ),
  remesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Run remeshing (slower; often improves topology)',
      }),
    )
    .default(true),
  tex_slat_guidance_rescale: z.optional(z.number().gte(0).lte(1)).default(0),
  shape_slat_guidance_rescale: z
    .optional(z.number().gte(0).lte(1))
    .default(0.5),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the input image to convert to 3D',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducibility',
    }),
  ),
  shape_slat_guidance_strength: z
    .optional(z.number().gte(0).lte(10))
    .default(7.5),
  tex_slat_guidance_strength: z.optional(z.number().gte(0).lte(10)).default(1),
  decimation_target: z
    .optional(
      z.int().gte(100000).lte(2000000).register(z.globalRegistry, {
        description:
          'Target vertex count for mesh simplification during export',
      }),
    )
    .default(500000),
})

/**
 * File
 */
export const zFalAiTrellis2File = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ObjectOutput
 */
export const zTrellis2Output = z.object({
  model_glb: zFalAiTrellis2File,
})

/**
 * SketchTo3DInput
 */
export const zHunyuan3dV3SketchTo3dInput = z.object({
  input_image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of sketch or line art image to transform into a 3D model. Image resolution must be between 128x128 and 5000x5000 pixels.',
  }),
  prompt: z.string().max(1024).register(z.globalRegistry, {
    description:
      'Text prompt describing the 3D content attributes such as color, category, and material.',
  }),
  face_count: z
    .optional(
      z.int().gte(40000).lte(1500000).register(z.globalRegistry, {
        description: 'Target face count. Range: 40000-1500000',
      }),
    )
    .default(500000),
  enable_pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable PBR material generation.',
      }),
    )
    .default(false),
})

/**
 * File
 */
export const zFalAiHunyuan3dV3SketchTo3dFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ModelUrls
 */
export const zModelUrls = z.object({
  fbx: z.optional(zFalAiHunyuan3dV3SketchTo3dFile),
  usdz: z.optional(zFalAiHunyuan3dV3SketchTo3dFile),
  glb: z.optional(zFalAiHunyuan3dV3SketchTo3dFile),
  obj: z.optional(zFalAiHunyuan3dV3SketchTo3dFile),
})

/**
 * SketchTo3DOutput
 */
export const zHunyuan3dV3SketchTo3dOutput = z.object({
  model_urls: zModelUrls,
  thumbnail: z.optional(zFalAiHunyuan3dV3SketchTo3dFile),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
  ),
  model_glb: zFalAiHunyuan3dV3SketchTo3dFile,
})

/**
 * ImageTo3DInput
 */
export const zHunyuan3dV3ImageTo3dInput = z.object({
  input_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use while generating the 3D model.',
  }),
  polygon_type: z.optional(
    z.enum(['triangle', 'quadrilateral']).register(z.globalRegistry, {
      description:
        'Polygon type. Only takes effect when GenerateType is LowPoly.',
    }),
  ),
  face_count: z
    .optional(
      z.int().gte(40000).lte(1500000).register(z.globalRegistry, {
        description: 'Target face count. Range: 40000-1500000',
      }),
    )
    .default(500000),
  right_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Optional right view image URL for better 3D reconstruction.',
    }),
  ),
  back_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Optional back view image URL for better 3D reconstruction.',
    }),
  ),
  enable_pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to enable PBR material generation. Does not take effect when generate_type is Geometry.',
      }),
    )
    .default(false),
  generate_type: z.optional(
    z.enum(['Normal', 'LowPoly', 'Geometry']).register(z.globalRegistry, {
      description:
        'Generation type. Normal: textured model. LowPoly: polygon reduction. Geometry: white model without texture.',
    }),
  ),
  left_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Optional left view image URL for better 3D reconstruction.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiHunyuan3dV3ImageTo3dFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ModelUrls
 */
export const zFalAiHunyuan3dV3ImageTo3dModelUrls = z.object({
  fbx: z.optional(zFalAiHunyuan3dV3ImageTo3dFile),
  usdz: z.optional(zFalAiHunyuan3dV3ImageTo3dFile),
  glb: z.optional(zFalAiHunyuan3dV3ImageTo3dFile),
  obj: z.optional(zFalAiHunyuan3dV3ImageTo3dFile),
})

/**
 * ImageTo3DOutput
 */
export const zHunyuan3dV3ImageTo3dOutput = z.object({
  model_urls: zFalAiHunyuan3dV3ImageTo3dModelUrls,
  thumbnail: z.optional(zFalAiHunyuan3dV3ImageTo3dFile),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
  ),
  model_glb: zFalAiHunyuan3dV3ImageTo3dFile,
})

/**
 * SAM3DBodyInput
 */
export const zSam33dBodyInput = z.object({
  include_3d_keypoints: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Include 3D keypoint markers (spheres) in the GLB mesh for visualization',
      }),
    )
    .default(true),
  export_meshes: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Export individual mesh files (.ply) per person',
      }),
    )
    .default(true),
  mask_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Optional URL of a binary mask image (white=person, black=background). When provided, skips auto human detection and uses this mask instead. Bbox is auto-computed from the mask.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image containing humans',
  }),
})

/**
 * File
 */
export const zFalAiSam33dBodyFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * SAM3DBodyPersonMetadata
 *
 * Per-person metadata for body reconstruction.
 */
export const zSam3dBodyPersonMetadata = z
  .object({
    pred_cam_t: z.array(z.number()).register(z.globalRegistry, {
      description: 'Predicted camera translation [tx, ty, tz]',
    }),
    person_id: z.int().register(z.globalRegistry, {
      description: 'Index of the person in the scene',
    }),
    focal_length: z.number().register(z.globalRegistry, {
      description: 'Estimated focal length',
    }),
    keypoints_3d: z.optional(
      z.array(z.array(z.number())).register(z.globalRegistry, {
        description:
          '3D keypoints [[x, y, z], ...] - 70 body keypoints in camera space',
      }),
    ),
    keypoints_2d: z.array(z.array(z.number())).register(z.globalRegistry, {
      description: '2D keypoints [[x, y], ...] - 70 body keypoints',
    }),
    bbox: z.array(z.number()).register(z.globalRegistry, {
      description: 'Bounding box [x_min, y_min, x_max, y_max]',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Per-person metadata for body reconstruction.',
  })

/**
 * SAM3DBodyMetadata
 *
 * Metadata for body reconstruction output.
 */
export const zSam3dBodyMetadata = z
  .object({
    people: z.array(zSam3dBodyPersonMetadata).register(z.globalRegistry, {
      description: 'Per-person metadata',
    }),
    num_people: z.int().register(z.globalRegistry, {
      description: 'Number of people detected',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Metadata for body reconstruction output.',
  })

/**
 * SAM3DBodyOutput
 */
export const zSam33dBodyOutput = z.object({
  visualization: zFalAiSam33dBodyFile,
  metadata: zSam3dBodyMetadata,
  meshes: z.optional(
    z.array(zFalAiSam33dBodyFile).register(z.globalRegistry, {
      description:
        'Individual mesh files (.ply), one per detected person (when export_meshes=True)',
    }),
  ),
  model_glb: zFalAiSam33dBodyFile,
})

/**
 * BoxPromptBase
 */
export const zBoxPromptBase = z.object({
  y_min: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Y Min Coordinate of the box',
    }),
  ),
  object_id: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Optional object identifier. Boxes sharing an object id refine the same object.',
    }),
  ),
  x_max: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'X Max Coordinate of the box',
    }),
  ),
  x_min: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'X Min Coordinate of the box',
    }),
  ),
  y_max: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Y Max Coordinate of the box',
    }),
  ),
})

/**
 * PointPromptBase
 */
export const zPointPromptBase = z.object({
  y: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Y Coordinate of the prompt',
    }),
  ),
  x: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'X Coordinate of the prompt',
    }),
  ),
  object_id: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Optional object identifier. Prompts sharing an object id refine the same object.',
    }),
  ),
  label: z.optional(
    z.union([z.literal(0), z.literal(1)]).register(z.globalRegistry, {
      description: '1 for foreground, 0 for background',
    }),
  ),
})

/**
 * SAM3DObjectInput
 */
export const zSam33dObjectsInput = z.object({
  pointmap_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Optional URL to external pointmap/depth data (NPY or NPZ format) for improved 3D reconstruction depth estimation',
    }),
  ),
  export_textured_glb: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If True, exports GLB with baked texture and UVs instead of vertex colors.',
      }),
    )
    .default(false),
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Text prompt for auto-segmentation when no masks provided (e.g., 'chair', 'lamp')",
      }),
    )
    .default('car'),
  box_prompts: z
    .optional(
      z.array(zBoxPromptBase).register(z.globalRegistry, {
        description:
          'Box prompts for auto-segmentation when no masks provided. Multiple boxes supported - each produces a separate object mask for 3D reconstruction.',
      }),
    )
    .default([]),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to reconstruct in 3D',
  }),
  mask_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'Optional list of mask URLs (one per object). If not provided, use prompt/point_prompts/box_prompts to auto-segment, or entire image will be used.',
    }),
  ),
  point_prompts: z
    .optional(
      z.array(zPointPromptBase).register(z.globalRegistry, {
        description:
          'Point prompts for auto-segmentation when no masks provided',
      }),
    )
    .default([]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducibility',
    }),
  ),
})

/**
 * File
 */
export const zFalAiSam33dObjectsFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * SAM3DObjectMetadata
 *
 * Per-object metadata for 3D reconstruction.
 */
export const zSam3dObjectMetadata = z
  .object({
    rotation: z.optional(
      z.array(z.array(z.number())).register(z.globalRegistry, {
        description: 'Rotation quaternion [x, y, z, w]',
      }),
    ),
    translation: z.optional(
      z.array(z.array(z.number())).register(z.globalRegistry, {
        description: 'Translation [tx, ty, tz]',
      }),
    ),
    object_index: z.int().register(z.globalRegistry, {
      description: 'Index of the object in the scene',
    }),
    scale: z.optional(
      z.array(z.array(z.number())).register(z.globalRegistry, {
        description: 'Scale factors [sx, sy, sz]',
      }),
    ),
    camera_pose: z.optional(
      z.array(z.array(z.number())).register(z.globalRegistry, {
        description: 'Camera pose matrix',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Per-object metadata for 3D reconstruction.',
  })

/**
 * SAM3DObjectOutput
 */
export const zSam33dObjectsOutput = z.object({
  model_glb: z.optional(zFalAiSam33dObjectsFile),
  metadata: z.array(zSam3dObjectMetadata).register(z.globalRegistry, {
    description: 'Per-object metadata (rotation/translation/scale)',
  }),
  gaussian_splat: zFalAiSam33dObjectsFile,
  artifacts_zip: z.optional(zFalAiSam33dObjectsFile),
  individual_glbs: z.optional(
    z.array(zFalAiSam33dObjectsFile).register(z.globalRegistry, {
      description:
        'Individual GLB mesh files per object (only for multi-object scenes)',
    }),
  ),
  individual_splats: z.optional(
    z.array(zFalAiSam33dObjectsFile).register(z.globalRegistry, {
      description:
        'Individual Gaussian splat files per object (only for multi-object scenes)',
    }),
  ),
})

/**
 * OmnipartInput
 */
export const zOmnipartInput = z.object({
  input_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use while generating the 3D model.',
  }),
  parts: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Specify which segments to merge (e.g., '0,1;3,4' merges segments 0&1 together and 3&4 together)",
      }),
    )
    .default(''),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description:
          '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
      }),
    )
    .default(765464),
  minimum_segment_size: z
    .optional(
      z.int().gte(1).lte(10000).register(z.globalRegistry, {
        description: 'Minimum segment size (pixels) for the model.',
      }),
    )
    .default(2000),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for the model.',
      }),
    )
    .default(7.5),
})

/**
 * File
 */
export const zFalAiOmnipartFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * MultiViewObjectOutput
 */
export const zOmnipartOutput = z.object({
  full_model_mesh: zFalAiOmnipartFile,
  output_zip: zFalAiOmnipartFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
  model_mesh: zFalAiOmnipartFile,
})

/**
 * Seed3DImageTo3DInput
 */
export const zBytedanceSeed3dImageTo3dInput = z.object({
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image for the 3D asset generation.',
  }),
})

/**
 * File
 */
export const zFalAiBytedanceSeed3dImageTo3dFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Seed3DImageTo3DOutput
 */
export const zBytedanceSeed3dImageTo3dOutput = z.object({
  model: zFalAiBytedanceSeed3dImageTo3dFile,
  usage_tokens: z.int().register(z.globalRegistry, {
    description: 'The number of tokens used for the 3D model generation',
  }),
})

/**
 * MultiImageTo3DInput
 *
 * Input for Multi-Image to 3D conversion
 */
export const zMeshyV5MultiImageTo3dInput = z
  .object({
    enable_pbr: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Generate PBR Maps (metallic, roughness, normal) in addition to base color. Requires should_texture to be true.',
        }),
      )
      .default(false),
    should_texture: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to generate textures. False provides mesh without textures for 5 credits, True adds texture generation for additional 10 credits.',
        }),
      )
      .default(true),
    target_polycount: z
      .optional(
        z.int().gte(100).lte(300000).register(z.globalRegistry, {
          description: 'Target number of polygons in the generated model',
        }),
      )
      .default(30000),
    is_a_t_pose: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to generate the model in an A/T pose',
        }),
      )
      .default(false),
    texture_image_url: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          '2D image to guide the texturing process. Requires should_texture to be true.',
      }),
    ),
    topology: z.optional(
      z.enum(['quad', 'triangle']).register(z.globalRegistry, {
        description:
          'Specify the topology of the generated model. Quad for smooth surfaces, Triangle for detailed geometry.',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If set to true, input data will be checked for safety before processing.',
        }),
      )
      .default(true),
    symmetry_mode: z.optional(
      z.enum(['off', 'auto', 'on']).register(z.globalRegistry, {
        description: 'Controls symmetry behavior during model generation.',
      }),
    ),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        '1 to 4 images for 3D model creation. All images should depict the same object from different angles. Supports .jpg, .jpeg, .png formats, and AVIF/HEIF which will be automatically converted. If more than 4 images are provided, only the first 4 will be used.',
    }),
    texture_prompt: z.optional(
      z.string().max(600).register(z.globalRegistry, {
        description:
          'Text prompt to guide the texturing process. Requires should_texture to be true.',
      }),
    ),
    should_remesh: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the remesh phase. When false, returns triangular mesh ignoring topology and target_polycount.',
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: 'Input for Multi-Image to 3D conversion',
  })

/**
 * File
 */
export const zFalAiMeshyV5MultiImageTo3dFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ModelUrls
 *
 * 3D model files in various formats
 */
export const zFalAiMeshyV5MultiImageTo3dModelUrls = z
  .object({
    usdz: z.optional(zFalAiMeshyV5MultiImageTo3dFile),
    fbx: z.optional(zFalAiMeshyV5MultiImageTo3dFile),
    blend: z.optional(zFalAiMeshyV5MultiImageTo3dFile),
    stl: z.optional(zFalAiMeshyV5MultiImageTo3dFile),
    glb: z.optional(zFalAiMeshyV5MultiImageTo3dFile),
    obj: z.optional(zFalAiMeshyV5MultiImageTo3dFile),
  })
  .register(z.globalRegistry, {
    description: '3D model files in various formats',
  })

/**
 * TextureFiles
 *
 * Texture files downloaded and uploaded to CDN
 */
export const zTextureFiles = z
  .object({
    base_color: zFalAiMeshyV5MultiImageTo3dFile,
    normal: z.optional(zFalAiMeshyV5MultiImageTo3dFile),
    roughness: z.optional(zFalAiMeshyV5MultiImageTo3dFile),
    metallic: z.optional(zFalAiMeshyV5MultiImageTo3dFile),
  })
  .register(z.globalRegistry, {
    description: 'Texture files downloaded and uploaded to CDN',
  })

/**
 * MultiImageTo3DOutput
 *
 * Output for Multi-Image to 3D conversion
 */
export const zMeshyV5MultiImageTo3dOutput = z
  .object({
    model_urls: zFalAiMeshyV5MultiImageTo3dModelUrls,
    texture_urls: z.optional(
      z.array(zTextureFiles).register(z.globalRegistry, {
        description: 'Array of texture file objects',
      }),
    ),
    thumbnail: z.optional(zFalAiMeshyV5MultiImageTo3dFile),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The seed used for generation (if available)',
      }),
    ),
    model_glb: zFalAiMeshyV5MultiImageTo3dFile,
  })
  .register(z.globalRegistry, {
    description: 'Output for Multi-Image to 3D conversion',
  })

/**
 * ImageTo3DInput
 *
 * Input for Image to 3D conversion
 */
export const zMeshyV6PreviewImageTo3dInput = z
  .object({
    enable_pbr: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Generate PBR Maps (metallic, roughness, normal) in addition to base color',
        }),
      )
      .default(false),
    is_a_t_pose: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to generate the model in an A/T pose',
        }),
      )
      .default(false),
    target_polycount: z
      .optional(
        z.int().gte(100).lte(300000).register(z.globalRegistry, {
          description: 'Target number of polygons in the generated model',
        }),
      )
      .default(30000),
    should_texture: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to generate textures',
        }),
      )
      .default(true),
    texture_image_url: z.optional(
      z.string().register(z.globalRegistry, {
        description: '2D image to guide the texturing process',
      }),
    ),
    topology: z.optional(
      z.enum(['quad', 'triangle']).register(z.globalRegistry, {
        description:
          'Specify the topology of the generated model. Quad for smooth surfaces, Triangle for detailed geometry.',
      }),
    ),
    image_url: z.string().register(z.globalRegistry, {
      description:
        'Image URL or base64 data URI for 3D model creation. Supports .jpg, .jpeg, and .png formats. Also supports AVIF and HEIF formats which will be automatically converted.',
    }),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If set to true, input data will be checked for safety before processing.',
        }),
      )
      .default(true),
    symmetry_mode: z.optional(
      z.enum(['off', 'auto', 'on']).register(z.globalRegistry, {
        description:
          'Controls symmetry behavior during model generation. Off disables symmetry, Auto determines it automatically, On enforces symmetry.',
      }),
    ),
    texture_prompt: z.optional(
      z.string().max(600).register(z.globalRegistry, {
        description: 'Text prompt to guide the texturing process',
      }),
    ),
    should_remesh: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to enable the remesh phase',
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: 'Input for Image to 3D conversion',
  })

/**
 * File
 */
export const zFalAiMeshyV6PreviewImageTo3dFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ModelUrls
 *
 * 3D model files in various formats
 */
export const zFalAiMeshyV6PreviewImageTo3dModelUrls = z
  .object({
    usdz: z.optional(zFalAiMeshyV6PreviewImageTo3dFile),
    fbx: z.optional(zFalAiMeshyV6PreviewImageTo3dFile),
    blend: z.optional(zFalAiMeshyV6PreviewImageTo3dFile),
    stl: z.optional(zFalAiMeshyV6PreviewImageTo3dFile),
    glb: z.optional(zFalAiMeshyV6PreviewImageTo3dFile),
    obj: z.optional(zFalAiMeshyV6PreviewImageTo3dFile),
  })
  .register(z.globalRegistry, {
    description: '3D model files in various formats',
  })

/**
 * TextureFiles
 *
 * Texture files downloaded and uploaded to CDN
 */
export const zFalAiMeshyV6PreviewImageTo3dTextureFiles = z
  .object({
    base_color: zFalAiMeshyV6PreviewImageTo3dFile,
    normal: z.optional(zFalAiMeshyV6PreviewImageTo3dFile),
    roughness: z.optional(zFalAiMeshyV6PreviewImageTo3dFile),
    metallic: z.optional(zFalAiMeshyV6PreviewImageTo3dFile),
  })
  .register(z.globalRegistry, {
    description: 'Texture files downloaded and uploaded to CDN',
  })

/**
 * ImageTo3DOutput
 *
 * Output for Image to 3D conversion
 */
export const zMeshyV6PreviewImageTo3dOutput = z
  .object({
    model_urls: zFalAiMeshyV6PreviewImageTo3dModelUrls,
    texture_urls: z.optional(
      z
        .array(zFalAiMeshyV6PreviewImageTo3dTextureFiles)
        .register(z.globalRegistry, {
          description:
            'Array of texture file objects, matching Meshy API structure',
        }),
    ),
    thumbnail: z.optional(zFalAiMeshyV6PreviewImageTo3dFile),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The seed used for generation (if available)',
      }),
    ),
    model_glb: zFalAiMeshyV6PreviewImageTo3dFile,
  })
  .register(z.globalRegistry, {
    description: 'Output for Image to 3D conversion',
  })

/**
 * RodinGen2Input
 */
export const zHyper3dRodinV2Input = z.object({
  quality_mesh_option: z.optional(
    z
      .enum([
        '4K Quad',
        '8K Quad',
        '18K Quad',
        '50K Quad',
        '2K Triangle',
        '20K Triangle',
        '150K Triangle',
        '500K Triangle',
      ])
      .register(z.globalRegistry, {
        description:
          "Combined quality and mesh type selection. Quad = smooth surfaces, Triangle = detailed geometry. These corresponds to `mesh_mode` (if the option contains 'Triangle', mesh_mode is 'Raw', otherwise 'Quad') and `quality_override` (the numeric part of the option) parameters in Hyper3D API.",
      }),
  ),
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'A textual prompt to guide model generation. Optional for Image-to-3D mode - if empty, AI will generate a prompt based on your images.',
      }),
    )
    .default(''),
  preview_render: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Generate a preview render image of the 3D model along with the model files.',
      }),
    )
    .default(false),
  bbox_condition: z.optional(
    z.array(z.int()).register(z.globalRegistry, {
      description:
        'An array that specifies the bounding box dimensions [width, height, length].',
    }),
  ),
  TAPose: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Generate characters in T-pose or A-pose format, making them easier to rig and animate in 3D software.',
      }),
    )
    .default(false),
  input_image_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'URL of images to use while generating the 3D model. Required for Image-to-3D mode. Up to 5 images allowed.',
    }),
  ),
  use_original_alpha: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'When enabled, preserves the transparency channel from input images during 3D generation.',
      }),
    )
    .default(false),
  geometry_file_format: z.optional(
    z.enum(['glb', 'usdz', 'fbx', 'obj', 'stl']).register(z.globalRegistry, {
      description:
        'Format of the geometry file. Possible values: glb, usdz, fbx, obj, stl. Default is glb.',
    }),
  ),
  addons: z.optional(
    z.enum(['HighPack']).register(z.globalRegistry, {
      description:
        'The HighPack option will provide 4K resolution textures instead of the default 1K, as well as models with high-poly. It will cost **triple the billable units**.',
    }),
  ),
  seed: z.optional(
    z.int().gte(0).lte(65535).register(z.globalRegistry, {
      description:
        'Seed value for randomization, ranging from 0 to 65535. Optional.',
    }),
  ),
  material: z.optional(
    z.enum(['PBR', 'Shaded', 'All']).register(z.globalRegistry, {
      description:
        'Material type. PBR: Physically-based materials with realistic lighting. Shaded: Simple materials with baked lighting. All: Both types included.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiHyper3dRodinV2File = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Image
 *
 * Represents an image file.
 */
export const zImage = z
  .object({
    height: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The height of the image in pixels.',
      }),
    ),
    file_size: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The size of the file in bytes.',
      }),
    ),
    url: z.string().register(z.globalRegistry, {
      description: 'The URL where the file can be downloaded from.',
    }),
    width: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The width of the image in pixels.',
      }),
    ),
    file_name: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The name of the file. It will be auto-generated if not provided.',
      }),
    ),
    content_type: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The mime type of the file.',
      }),
    ),
    file_data: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'File data',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Represents an image file.',
  })

/**
 * ObjectOutputv2
 */
export const zHyper3dRodinV2Output = z.object({
  model_mesh: zFalAiHyper3dRodinV2File,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
  textures: z.array(zImage).register(z.globalRegistry, {
    description: 'Generated textures for the 3D object.',
  }),
})

/**
 * PSHumanRequest
 */
export const zPshumanInput = z.object({
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Guidance scale for the diffusion process. Controls how much the output adheres to the generated views.',
      }),
    )
    .default(4),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Seed for reproducibility. If None, a random seed will be used.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'A direct URL to the input image of a person.',
  }),
})

/**
 * File
 */
export const zFalAiPshumanFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * PSHumanResponse
 */
export const zPshumanOutput = z.object({
  model_obj: zFalAiPshumanFile,
  preview_image: zFalAiPshumanFile,
})

/**
 * ImageToWorldRequest
 */
export const zHunyuanWorldImageToWorldInput = z.object({
  classes: z.string().register(z.globalRegistry, {
    description: 'Classes to use for the world generation.',
  }),
  export_drc: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to export DRC (Dynamic Resource Configuration).',
      }),
    )
    .default(false),
  labels_fg1: z.string().register(z.globalRegistry, {
    description: 'Labels for the first foreground object.',
  }),
  labels_fg2: z.string().register(z.globalRegistry, {
    description: 'Labels for the second foreground object.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to convert to a world.',
  }),
})

/**
 * File
 */
export const zFalAiHunyuanWorldImageToWorldFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToWorldResponse
 */
export const zHunyuanWorldImageToWorldOutput = z.object({
  world_file: zFalAiHunyuanWorldImageToWorldFile,
})

/**
 * MultiviewTo3dInput
 */
export const zTripoV25MultiviewTo3dInput = z.object({
  face_limit: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Limits the number of faces on the output model. If this option is not set, the face limit will be adaptively determined.',
    }),
  ),
  right_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Right view image of the object.',
    }),
  ),
  style: z.optional(
    z
      .enum([
        'person:person2cartoon',
        'object:clay',
        'object:steampunk',
        'animal:venom',
        'object:barbie',
        'object:christmas',
        'gold',
        'ancient_bronze',
      ])
      .register(z.globalRegistry, {
        description:
          '[DEPRECATED] Defines the artistic style or transformation to be applied to the 3D model, altering its appearance according to preset options (extra $0.05 per generation). Omit this option to keep the original style and apperance.',
      }),
  ),
  quad: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Set True to enable quad mesh output (extra $0.05 per generation). If quad=True and face_limit is not set, the default face_limit will be 10000. Note: Enabling this option will force the output to be an FBX model.',
      }),
    )
    .default(false),
  front_image_url: z.string().register(z.globalRegistry, {
    description: 'Front view image of the object.',
  }),
  texture_seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'This is the random seed for texture generation. Using the same seed will produce identical textures. This parameter is an integer and is randomly chosen if not set. If you want a model with different textures, please use same seed and different texture_seed.',
    }),
  ),
  back_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Back view image of the object.',
    }),
  ),
  pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'A boolean option to enable pbr. The default value is True, set False to get a model without pbr. If this option is set to True, texture will be ignored and used as True.',
      }),
    )
    .default(false),
  texture_alignment: z.optional(
    z.enum(['original_image', 'geometry']).register(z.globalRegistry, {
      description:
        'Determines the prioritization of texture alignment in the 3D model. The default value is original_image.',
    }),
  ),
  texture: z.optional(
    z.enum(['no', 'standard', 'HD']).register(z.globalRegistry, {
      description:
        "An option to enable texturing. Default is 'standard', set 'no' to get a model without any textures, and set 'HD' to get a model with hd quality textures.",
    }),
  ),
  auto_size: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Automatically scale the model to real-world dimensions, with the unit in meters. The default value is False.',
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'This is the random seed for model generation. The seed controls the geometry generation process, ensuring identical models when the same seed is used. This parameter is an integer and is randomly chosen if not set.',
    }),
  ),
  orientation: z.optional(
    z.enum(['default', 'align_image']).register(z.globalRegistry, {
      description:
        'Set orientation=align_image to automatically rotate the model to align the original image. The default value is default.',
    }),
  ),
  left_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Left view image of the object.',
    }),
  ),
})

/**
 * File
 */
export const zTripo3dTripoV25MultiviewTo3dFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Tripo3dOutput
 */
export const zTripoV25MultiviewTo3dOutput = z.object({
  base_model: z.optional(zTripo3dTripoV25MultiviewTo3dFile),
  task_id: z.string().register(z.globalRegistry, {
    description: 'The task id of the 3D model generation.',
  }),
  rendered_image: z.optional(zTripo3dTripoV25MultiviewTo3dFile),
  model_mesh: z.optional(zTripo3dTripoV25MultiviewTo3dFile),
  pbr_model: z.optional(zTripo3dTripoV25MultiviewTo3dFile),
})

/**
 * Hunyuan3DInput
 */
export const zHunyuan3dV21Input = z.object({
  input_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use while generating the 3D model.',
  }),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: 'Octree resolution for the model.',
      }),
    )
    .default(256),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for the model.',
      }),
    )
    .default(7.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps to perform.',
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.',
      }),
    )
    .default(false),
})

/**
 * File
 */
export const zFalAiHunyuan3dV21File = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ObjectOutput
 */
export const zHunyuan3dV21Output = z.object({
  model_glb_pbr: z.optional(zFalAiHunyuan3dV21File),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
  model_mesh: zFalAiHunyuan3dV21File,
  model_glb: zFalAiHunyuan3dV21File,
})

/**
 * MultiImageInputModel
 */
export const zTrellisMultiInput = z.object({
  multiimage_algo: z.optional(
    z.enum(['stochastic', 'multidiffusion']).register(z.globalRegistry, {
      description: 'Algorithm for multi-image generation',
    }),
  ),
  slat_sampling_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Sampling steps for structured latent generation',
      }),
    )
    .default(12),
  ss_sampling_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Sampling steps for sparse structure generation',
      }),
    )
    .default(12),
  ss_guidance_strength: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Guidance strength for sparse structure generation',
      }),
    )
    .default(7.5),
  slat_guidance_strength: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Guidance strength for structured latent generation',
      }),
    )
    .default(3),
  mesh_simplify: z
    .optional(
      z.number().gte(0.9).lte(0.98).register(z.globalRegistry, {
        description: 'Mesh simplification factor',
      }),
    )
    .default(0.95),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  texture_size: z.optional(
    z
      .union([z.literal(512), z.literal(1024), z.literal(2048)])
      .register(z.globalRegistry, {
        description: 'Texture resolution',
      }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: 'List of URLs of input images to convert to 3D',
  }),
})

/**
 * File
 */
export const zFalAiTrellisMultiFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * ObjectOutput
 */
export const zTrellisMultiOutput = z.object({
  model_mesh: zFalAiTrellisMultiFile,
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'Processing timings',
  }),
})

/**
 * ImageTo3dInput
 */
export const zTripoV25ImageTo3dInput = z.object({
  face_limit: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Limits the number of faces on the output model. If this option is not set, the face limit will be adaptively determined.',
    }),
  ),
  style: z.optional(
    z
      .enum([
        'person:person2cartoon',
        'object:clay',
        'object:steampunk',
        'animal:venom',
        'object:barbie',
        'object:christmas',
        'gold',
        'ancient_bronze',
      ])
      .register(z.globalRegistry, {
        description:
          '[DEPRECATED] Defines the artistic style or transformation to be applied to the 3D model, altering its appearance according to preset options (extra $0.05 per generation). Omit this option to keep the original style and apperance.',
      }),
  ),
  pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'A boolean option to enable pbr. The default value is True, set False to get a model without pbr. If this option is set to True, texture will be ignored and used as True.',
      }),
    )
    .default(false),
  texture_alignment: z.optional(
    z.enum(['original_image', 'geometry']).register(z.globalRegistry, {
      description:
        'Determines the prioritization of texture alignment in the 3D model. The default value is original_image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use for model generation.',
  }),
  texture: z.optional(
    z.enum(['no', 'standard', 'HD']).register(z.globalRegistry, {
      description:
        "An option to enable texturing. Default is 'standard', set 'no' to get a model without any textures, and set 'HD' to get a model with hd quality textures.",
    }),
  ),
  auto_size: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Automatically scale the model to real-world dimensions, with the unit in meters. The default value is False.',
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'This is the random seed for model generation. The seed controls the geometry generation process, ensuring identical models when the same seed is used. This parameter is an integer and is randomly chosen if not set.',
    }),
  ),
  quad: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Set True to enable quad mesh output (extra $0.05 per generation). If quad=True and face_limit is not set, the default face_limit will be 10000. Note: Enabling this option will force the output to be an FBX model.',
      }),
    )
    .default(false),
  orientation: z.optional(
    z.enum(['default', 'align_image']).register(z.globalRegistry, {
      description:
        'Set orientation=align_image to automatically rotate the model to align the original image. The default value is default.',
    }),
  ),
  texture_seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'This is the random seed for texture generation. Using the same seed will produce identical textures. This parameter is an integer and is randomly chosen if not set. If you want a model with different textures, please use same seed and different texture_seed.',
    }),
  ),
})

/**
 * File
 */
export const zTripo3dTripoV25ImageTo3dFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Tripo3dOutput
 */
export const zTripoV25ImageTo3dOutput = z.object({
  base_model: z.optional(zTripo3dTripoV25ImageTo3dFile),
  task_id: z.string().register(z.globalRegistry, {
    description: 'The task id of the 3D model generation.',
  }),
  rendered_image: z.optional(zTripo3dTripoV25ImageTo3dFile),
  model_mesh: z.optional(zTripo3dTripoV25ImageTo3dFile),
  pbr_model: z.optional(zTripo3dTripoV25ImageTo3dFile),
})

/**
 * Hunyuan3DInputMultiView
 */
export const zHunyuan3dV2MultiViewTurboInput = z.object({
  front_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use while generating the 3D model.',
  }),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: 'Octree resolution for the model.',
      }),
    )
    .default(256),
  back_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use while generating the 3D model.',
  }),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for the model.',
      }),
    )
    .default(7.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps to perform.',
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.',
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  left_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use while generating the 3D model.',
  }),
})

/**
 * File
 */
export const zFalAiHunyuan3dV2MultiViewTurboFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * MultiViewObjectOutput
 */
export const zHunyuan3dV2MultiViewTurboOutput = z.object({
  model_mesh: zFalAiHunyuan3dV2MultiViewTurboFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
})

/**
 * Hunyuan3DInput
 */
export const zHunyuan3dV2Input = z.object({
  input_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use while generating the 3D model.',
  }),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: 'Octree resolution for the model.',
      }),
    )
    .default(256),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for the model.',
      }),
    )
    .default(7.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps to perform.',
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.',
      }),
    )
    .default(false),
})

/**
 * File
 */
export const zFalAiHunyuan3dV2File = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ObjectOutput
 */
export const zHunyuan3dV2Output = z.object({
  model_mesh: zFalAiHunyuan3dV2File,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
})

/**
 * Hunyuan3DInput
 */
export const zHunyuan3dV2MiniInput = z.object({
  input_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use while generating the 3D model.',
  }),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: 'Octree resolution for the model.',
      }),
    )
    .default(256),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for the model.',
      }),
    )
    .default(7.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps to perform.',
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.',
      }),
    )
    .default(false),
})

/**
 * File
 */
export const zFalAiHunyuan3dV2MiniFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ObjectOutput
 */
export const zHunyuan3dV2MiniOutput = z.object({
  model_mesh: zFalAiHunyuan3dV2MiniFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
})

/**
 * Hunyuan3DInputMultiView
 */
export const zHunyuan3dV2MultiViewInput = z.object({
  front_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use while generating the 3D model.',
  }),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: 'Octree resolution for the model.',
      }),
    )
    .default(256),
  back_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use while generating the 3D model.',
  }),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for the model.',
      }),
    )
    .default(7.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps to perform.',
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.',
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  left_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use while generating the 3D model.',
  }),
})

/**
 * File
 */
export const zFalAiHunyuan3dV2MultiViewFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * MultiViewObjectOutput
 */
export const zHunyuan3dV2MultiViewOutput = z.object({
  model_mesh: zFalAiHunyuan3dV2MultiViewFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
})

/**
 * Hunyuan3DInput
 */
export const zHunyuan3dV2TurboInput = z.object({
  input_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use while generating the 3D model.',
  }),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: 'Octree resolution for the model.',
      }),
    )
    .default(256),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for the model.',
      }),
    )
    .default(7.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps to perform.',
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.',
      }),
    )
    .default(false),
})

/**
 * File
 */
export const zFalAiHunyuan3dV2TurboFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ObjectOutput
 */
export const zHunyuan3dV2TurboOutput = z.object({
  model_mesh: zFalAiHunyuan3dV2TurboFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
})

/**
 * Hunyuan3DInput
 */
export const zHunyuan3dV2MiniTurboInput = z.object({
  input_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use while generating the 3D model.',
  }),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: 'Octree resolution for the model.',
      }),
    )
    .default(256),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for the model.',
      }),
    )
    .default(7.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps to perform.',
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.',
      }),
    )
    .default(false),
})

/**
 * File
 */
export const zFalAiHunyuan3dV2MiniTurboFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ObjectOutput
 */
export const zHunyuan3dV2MiniTurboOutput = z.object({
  model_mesh: zFalAiHunyuan3dV2MiniTurboFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
})

/**
 * Rodin3DInput
 */
export const zHyper3dRodinInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'A textual prompt to guide model generation. Required for Text-to-3D mode. Optional for Image-to-3D mode.',
      }),
    )
    .default(''),
  condition_mode: z.optional(
    z.enum(['fuse', 'concat']).register(z.globalRegistry, {
      description:
        'For fuse mode, One or more images are required.It will generate a model by extracting and fusing features of objects from multiple images.For concat mode, need to upload multiple multi-view images of the same object and generate the model. (You can upload multi-view images in any order, regardless of the order of view.)',
    }),
  ),
  bbox_condition: z.optional(
    z.array(z.int()).register(z.globalRegistry, {
      description:
        'An array that specifies the dimensions and scaling factor of the bounding box. Typically, this array contains 3 elements, Length(X-axis), Width(Y-axis) and Height(Z-axis).',
    }),
  ),
  tier: z.optional(
    z.enum(['Regular', 'Sketch']).register(z.globalRegistry, {
      description:
        'Tier of generation. For Rodin Sketch, set to Sketch. For Rodin Regular, set to Regular.',
    }),
  ),
  quality: z.optional(
    z.enum(['high', 'medium', 'low', 'extra-low']).register(z.globalRegistry, {
      description:
        'Generation quality. Possible values: high, medium, low, extra-low. Default is medium.',
    }),
  ),
  TAPose: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'When generating the human-like model, this parameter control the generation result to T/A Pose.',
      }),
    )
    .default(false),
  input_image_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'URL of images to use while generating the 3D model. Required for Image-to-3D mode. Optional for Text-to-3D mode.',
    }),
  ),
  geometry_file_format: z.optional(
    z.enum(['glb', 'usdz', 'fbx', 'obj', 'stl']).register(z.globalRegistry, {
      description:
        'Format of the geometry file. Possible values: glb, usdz, fbx, obj, stl. Default is glb.',
    }),
  ),
  use_hyper: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to export the model using hyper mode. Default is false.',
      }),
    )
    .default(false),
  addons: z.optional(
    z.enum(['HighPack']).register(z.globalRegistry, {
      description:
        'Generation add-on features. Default is []. Possible values are HighPack. The HighPack option will provide 4K resolution textures instead of the default 1K, as well as models with high-poly. It will cost triple the billable units.',
    }),
  ),
  seed: z.optional(
    z.int().gte(0).lte(65535).register(z.globalRegistry, {
      description:
        'Seed value for randomization, ranging from 0 to 65535. Optional.',
    }),
  ),
  material: z.optional(
    z.enum(['PBR', 'Shaded']).register(z.globalRegistry, {
      description:
        'Material type. Possible values: PBR, Shaded. Default is PBR.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiHyper3dRodinFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Image
 *
 * Represents an image file.
 */
export const zFalAiHyper3dRodinImage = z
  .object({
    height: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The height of the image in pixels.',
      }),
    ),
    file_size: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The size of the file in bytes.',
      }),
    ),
    url: z.string().register(z.globalRegistry, {
      description: 'The URL where the file can be downloaded from.',
    }),
    width: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The width of the image in pixels.',
      }),
    ),
    file_name: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The name of the file. It will be auto-generated if not provided.',
      }),
    ),
    content_type: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The mime type of the file.',
      }),
    ),
    file_data: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'File data',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Represents an image file.',
  })

/**
 * ObjectOutput
 */
export const zHyper3dRodinOutput = z.object({
  model_mesh: zFalAiHyper3dRodinFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
  textures: z.array(zFalAiHyper3dRodinImage).register(z.globalRegistry, {
    description: 'Generated textures for the 3D object.',
  }),
})

/**
 * InputModel
 */
export const zTrellisInput = z.object({
  slat_sampling_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Sampling steps for structured latent generation',
      }),
    )
    .default(12),
  ss_sampling_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Sampling steps for sparse structure generation',
      }),
    )
    .default(12),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the input image to convert to 3D',
  }),
  slat_guidance_strength: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Guidance strength for structured latent generation',
      }),
    )
    .default(3),
  ss_guidance_strength: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Guidance strength for sparse structure generation',
      }),
    )
    .default(7.5),
  mesh_simplify: z
    .optional(
      z.number().gte(0.9).lte(0.98).register(z.globalRegistry, {
        description: 'Mesh simplification factor',
      }),
    )
    .default(0.95),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  texture_size: z.optional(
    z
      .union([z.literal(512), z.literal(1024), z.literal(2048)])
      .register(z.globalRegistry, {
        description: 'Texture resolution',
      }),
  ),
})

/**
 * File
 */
export const zFalAiTrellisFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * ObjectOutput
 */
export const zTrellisOutput = z.object({
  model_mesh: zFalAiTrellisFile,
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'Processing timings',
  }),
})

/**
 * TripoSRInput
 */
export const zTriposrInput = z.object({
  mc_resolution: z
    .optional(
      z.int().gte(32).lte(1024).register(z.globalRegistry, {
        description:
          'Resolution of the marching cubes. Above 512 is not recommended.',
      }),
    )
    .default(256),
  do_remove_background: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to remove the background from the input image.',
      }),
    )
    .default(true),
  foreground_ratio: z
    .optional(
      z.number().gte(0.5).lte(1).register(z.globalRegistry, {
        description: 'Ratio of the foreground image to the original image.',
      }),
    )
    .default(0.9),
  output_format: z.optional(
    z.enum(['glb', 'obj']).register(z.globalRegistry, {
      description: 'Output format for the 3D model.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Path for the image file to be processed.',
  }),
})

/**
 * File
 */
export const zFalAiTriposrFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ObjectOutput
 */
export const zTriposrOutput = z.object({
  remeshing_dir: z.optional(zFalAiTriposrFile),
  model_mesh: zFalAiTriposrFile,
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'Inference timings.',
  }),
})
