// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod'

export const zFile = z.object({
  url: z.url(),
  content_type: z.optional(z.string()),
  file_name: z.optional(z.string()),
  file_size: z.optional(z.int()),
})

export const zQueueStatus = z.object({
  status: z.enum(['IN_PROGRESS', 'COMPLETED', 'FAILED']),
  response_url: z.optional(z.url()),
})

/**
 * BaseInput
 */
export const zWanEffectsInput = z.object({
  effect_type: z.optional(
    z
      .enum([
        'squish',
        'muscle',
        'inflate',
        'crush',
        'rotate',
        'gun-shooting',
        'deflate',
        'cakeify',
        'hulk',
        'baby',
        'bride',
        'classy',
        'puppy',
        'snow-white',
        'disney-princess',
        'mona-lisa',
        'painting',
        'pirate-captain',
        'princess',
        'jungle',
        'samurai',
        'vip',
        'warrior',
        'zen',
        'assassin',
        'timelapse',
        'tsunami',
        'fire',
        'zoom-call',
        'doom-fps',
        'fus-ro-dah',
        'hug-jesus',
        'robot-face-reveal',
        'super-saiyan',
        'jumpscare',
        'laughing',
        'cartoon-jaw-drop',
        'crying',
        'kissing',
        'angry-face',
        'selfie-younger-self',
        'animeify',
        'blast',
      ])
      .register(z.globalRegistry, {
        description: 'The type of effect to apply to the video.',
      }),
  ),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description: 'Aspect ratio of the output video.',
    }),
  ),
  subject: z.string().register(z.globalRegistry, {
    description:
      'The subject to insert into the predefined prompt template for the selected effect.',
  }),
  lora_scale: z
    .optional(
      z.number().gte(0.1).lte(2).register(z.globalRegistry, {
        description:
          'The scale of the LoRA weight. Used to adjust effect intensity.',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the input image.',
  }),
  turbo_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to use turbo mode. If True, the video will be generated faster but with lower quality.',
      }),
    )
    .default(false),
  frames_per_second: z
    .optional(
      z.int().gte(5).lte(24).register(z.globalRegistry, {
        description: 'Frames per second of the generated video.',
      }),
    )
    .default(16),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(40).register(z.globalRegistry, {
        description:
          'Number of inference steps for sampling. Higher values give better quality but take longer.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If None, a random seed is chosen.',
    }),
  ),
  num_frames: z
    .optional(
      z.int().gte(81).lte(100).register(z.globalRegistry, {
        description: 'Number of frames to generate.',
      }),
    )
    .default(81),
})

/**
 * File
 */
export const zFalAiWanEffectsFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * WanEffectsOutput
 */
export const zWanEffectsOutput = z.object({
  seed: z.int(),
  video: zFalAiWanEffectsFile,
})

/**
 * WanProI2VRequest
 */
export const zWanProImageToVideoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the video',
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable the safety checker',
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate the video from',
  }),
})

/**
 * File
 */
export const zFalAiWanProImageToVideoFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * WanProI2VResponse
 */
export const zWanProImageToVideoOutput = z.object({
  video: zFalAiWanProImageToVideoFile,
})

/**
 * ImageToVideoInput
 */
export const zVeo2ImageToVideoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt describing how the image should be animated',
  }),
  duration: z.optional(
    z.enum(['5s', '6s', '7s', '8s']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  aspect_ratio: z.optional(
    z
      .enum(['auto', 'auto_prefer_portrait', '16:9', '9:16'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated video',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the input image to animate. Should be 720p or higher resolution.',
  }),
})

/**
 * File
 */
export const zFalAiVeo2ImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToVideoOutput
 */
export const zVeo2ImageToVideoOutput = z.object({
  video: zFalAiVeo2ImageToVideoFile,
})

/**
 * ProImageToVideoRequest
 */
export const zKlingVideoV16ProImageToVideoInput = z.object({
  prompt: z.string().max(2500),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated video frame',
    }),
  ),
  duration: z.optional(
    z.enum(['5', '10']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  negative_prompt: z
    .optional(z.string().max(2500))
    .default('blur, distort, and low quality'),
  image_url: z.string(),
  tail_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of the image to be used for the end of the video',
    }),
  ),
  cfg_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt.\n        ',
      }),
    )
    .default(0.5),
})

/**
 * File
 */
export const zFalAiKlingVideoV16ProImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * I2VOutput
 */
export const zKlingVideoV16ProImageToVideoOutput = z.object({
  video: zFalAiKlingVideoV16ProImageToVideoFile,
})

/**
 * ImageToVideoRequest
 */
export const zMinimaxVideo01ImageToVideoInput = z.object({
  prompt_optimizer: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the model's prompt optimizer",
      }),
    )
    .default(true),
  prompt: z.string().max(2000),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
})

/**
 * File
 */
export const zFalAiMinimaxVideo01ImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * VideoOutput
 */
export const zMinimaxVideo01ImageToVideoOutput = z.object({
  video: zFalAiMinimaxVideo01ImageToVideoFile,
})

/**
 * ProImageToVideoHailuo23Input
 */
export const zMinimaxHailuo23ProImageToVideoInput = z.object({
  prompt_optimizer: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the model's prompt optimizer",
      }),
    )
    .default(true),
  prompt: z.string().min(1).max(2000).register(z.globalRegistry, {
    description: 'Text prompt for video generation',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
})

/**
 * File
 */
export const zFalAiMinimaxHailuo23ProImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ProImageToVideoHailuo23Output
 */
export const zMinimaxHailuo23ProImageToVideoOutput = z.object({
  video: zFalAiMinimaxHailuo23ProImageToVideoFile,
})

/**
 * ImageToVideoInput
 *
 * Input for image-to-video generation
 */
export const zWan25PreviewImageToVideoInput = z
  .object({
    prompt: z.string().min(1).register(z.globalRegistry, {
      description:
        'The text prompt describing the desired video motion. Max 800 characters.',
    }),
    resolution: z.optional(
      z.enum(['480p', '720p', '1080p']).register(z.globalRegistry, {
        description: 'Video resolution. Valid values: 480p, 720p, 1080p',
      }),
    ),
    duration: z.optional(
      z.enum(['5', '10']).register(z.globalRegistry, {
        description:
          'Duration of the generated video in seconds. Choose between 5 or 10 seconds.',
      }),
    ),
    image_url: z.string().register(z.globalRegistry, {
      description:
        'URL of the image to use as the first frame. Must be publicly accessible or base64 data URI.\n\nMax file size: 25.0MB, Min width: 360px, Min height: 360px, Max width: 2000px, Max height: 2000px, Timeout: 20.0s',
    }),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'If set to true, the safety checker will be enabled.',
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          'Random seed for reproducibility. If None, a random seed is chosen.',
      }),
    ),
    audio_url: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          '\nURL of the audio to use as the background music. Must be publicly accessible.\nLimit handling: If the audio duration exceeds the duration value (5 or 10 seconds),\nthe audio is truncated to the first 5 or 10 seconds, and the rest is discarded. If\nthe audio is shorter than the video, the remaining part of the video will be silent.\nFor example, if the audio is 3 seconds long and the video duration is 5 seconds, the\nfirst 3 seconds of the output video will have sound, and the last 2 seconds will be silent.\n- Format: WAV, MP3.\n- Duration: 3 to 30 s.\n- File size: Up to 15 MB.\n',
      }),
    ),
    negative_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'Negative prompt to describe content to avoid. Max 500 characters.',
      }),
    ),
    enable_prompt_expansion: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to enable prompt rewriting using LLM.',
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: 'Input for image-to-video generation',
  })

/**
 * VideoFile
 */
export const zVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  duration: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The duration of the video',
    }),
  ),
  height: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The height of the video',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  fps: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The FPS of the video',
    }),
  ),
  width: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The width of the video',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  num_frames: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The number of frames in the video',
    }),
  ),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * VideoOutput
 *
 * Base output for video generation
 */
export const zWan25PreviewImageToVideoOutput = z
  .object({
    actual_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The actual prompt used if prompt rewriting was enabled',
      }),
    ),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
    video: zVideoFile,
  })
  .register(z.globalRegistry, {
    description: 'Base output for video generation',
  })

/**
 * ImageToVideoV25ProRequest
 */
export const zKlingVideoV25TurboProImageToVideoInput = z.object({
  prompt: z.string().max(2500),
  duration: z.optional(
    z.enum(['5', '10']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  cfg_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt.\n        ',
      }),
    )
    .default(0.5),
  negative_prompt: z
    .optional(z.string().max(2500))
    .default('blur, distort, and low quality'),
  tail_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of the image to be used for the end of the video',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be used for the video',
  }),
})

/**
 * File
 */
export const zFalAiKlingVideoV25TurboProImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToVideoV25ProOutput
 */
export const zKlingVideoV25TurboProImageToVideoOutput = z.object({
  video: zFalAiKlingVideoV25TurboProImageToVideoFile,
})

/**
 * StandardImageToVideoHailuo02Input
 */
export const zMinimaxHailuo02StandardImageToVideoInput = z.object({
  prompt_optimizer: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the model's prompt optimizer",
      }),
    )
    .default(true),
  duration: z.optional(
    z.enum(['6', '10']).register(z.globalRegistry, {
      description:
        'The duration of the video in seconds. 10 seconds videos are not supported for 1080p resolution.',
    }),
  ),
  resolution: z.optional(
    z.enum(['512P', '768P']).register(z.globalRegistry, {
      description: 'The resolution of the generated video.',
    }),
  ),
  prompt: z.string().max(2000),
  end_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Optional URL of the image to use as the last frame of the video',
    }),
  ),
  image_url: z.string(),
})

/**
 * File
 */
export const zFalAiMinimaxHailuo02StandardImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToVideoHailuo02Output
 */
export const zMinimaxHailuo02StandardImageToVideoOutput = z.object({
  video: zFalAiMinimaxHailuo02StandardImageToVideoFile,
})

/**
 * SeedanceProImageToVideoInput
 */
export const zBytedanceSeedanceV1ProImageToVideoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt used to generate the video',
  }),
  resolution: z.optional(
    z.enum(['480p', '720p', '1080p']).register(z.globalRegistry, {
      description:
        'Video resolution - 480p for faster generation, 720p for balance, 1080p for higher quality',
    }),
  ),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '1:1', '3:4', '9:16', 'auto'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated video',
      }),
  ),
  duration: z.optional(
    z
      .enum(['2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'])
      .register(z.globalRegistry, {
        description: 'Duration of the video in seconds',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image used to generate video',
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  camera_fixed: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to fix the camera position',
      }),
    )
    .default(false),
  end_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The URL of the image the video ends with. Defaults to None.',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed to control video generation. Use -1 for random.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiBytedanceSeedanceV1ProImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * SeedanceProI2VVideoOutput
 */
export const zBytedanceSeedanceV1ProImageToVideoOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation',
  }),
  video: zFalAiBytedanceSeedanceV1ProImageToVideoFile,
})

/**
 * ImageToVideoV21MasterRequest
 */
export const zKlingVideoV21MasterImageToVideoInput = z.object({
  prompt: z.string().max(2500),
  duration: z.optional(
    z.enum(['5', '10']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  cfg_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt.\n        ',
      }),
    )
    .default(0.5),
  negative_prompt: z
    .optional(z.string().max(2500))
    .default('blur, distort, and low quality'),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be used for the video',
  }),
})

/**
 * File
 */
export const zFalAiKlingVideoV21MasterImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToVideoV21MasterOutput
 */
export const zKlingVideoV21MasterImageToVideoOutput = z.object({
  video: zFalAiKlingVideoV21MasterImageToVideoFile,
})

/**
 * ImageToVideoV21StandardRequest
 */
export const zKlingVideoV21StandardImageToVideoInput = z.object({
  prompt: z.string().max(2500),
  duration: z.optional(
    z.enum(['5', '10']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  cfg_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt.\n        ',
      }),
    )
    .default(0.5),
  negative_prompt: z
    .optional(z.string().max(2500))
    .default('blur, distort, and low quality'),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be used for the video',
  }),
})

/**
 * File
 */
export const zFalAiKlingVideoV21StandardImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToVideoV21StandardOutput
 */
export const zKlingVideoV21StandardImageToVideoOutput = z.object({
  video: zFalAiKlingVideoV21StandardImageToVideoFile,
})

/**
 * ImageToVideoV2MasterRequest
 */
export const zKlingVideoV2MasterImageToVideoInput = z.object({
  prompt: z.string().max(2500),
  duration: z.optional(
    z.enum(['5', '10']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  cfg_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt.\n        ',
      }),
    )
    .default(0.5),
  negative_prompt: z
    .optional(z.string().max(2500))
    .default('blur, distort, and low quality'),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be used for the video',
  }),
})

/**
 * File
 */
export const zFalAiKlingVideoV2MasterImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToVideoV2MasterOutput
 */
export const zKlingVideoV2MasterImageToVideoOutput = z.object({
  video: zFalAiKlingVideoV2MasterImageToVideoFile,
})

/**
 * WanI2VRequest
 */
export const zWanI2vInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide video generation.',
  }),
  shift: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: 'Shift parameter for video generation.',
      }),
    )
    .default(5),
  acceleration: z.optional(
    z.enum(['none', 'regular']).register(z.globalRegistry, {
      description:
        "Acceleration level to use. The more acceleration, the faster the generation, but with lower quality. The recommended value is 'regular'.",
    }),
  ),
  frames_per_second: z
    .optional(
      z.int().gte(5).lte(24).register(z.globalRegistry, {
        description:
          'Frames per second of the generated video. Must be between 5 to 24.',
      }),
    )
    .default(16),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
  num_frames: z
    .optional(
      z.int().gte(81).lte(100).register(z.globalRegistry, {
        description:
          'Number of frames to generate. Must be between 81 to 100 (inclusive). If the number of frames is greater than 81, the video will be generated with 1.25x more billing units.',
      }),
    )
    .default(81),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for video generation.',
      }),
    )
    .default(
      'bright colors, overexposed, static, blurred details, subtitles, style, artwork, painting, picture, still, overall gray, worst quality, low quality, JPEG compression residue, ugly, incomplete, extra fingers, poorly drawn hands, poorly drawn faces, deformed, disfigured, malformed limbs, fused fingers, still picture, cluttered background, three legs, many people in the background, walking backwards',
    ),
  aspect_ratio: z.optional(
    z.enum(['auto', '16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description:
        "Aspect ratio of the generated video. If 'auto', the aspect ratio will be determined automatically based on the input image.",
    }),
  ),
  resolution: z.optional(
    z.enum(['480p', '720p']).register(z.globalRegistry, {
      description:
        'Resolution of the generated video (480p or 720p). 480p is 0.5 billing units, and 720p is 1 billing unit.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the input image. If the input image does not match the chosen aspect ratio, it is resized and center cropped.',
  }),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable prompt expansion.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(40).register(z.globalRegistry, {
        description:
          'Number of inference steps for sampling. Higher values give better quality but take longer.',
      }),
    )
    .default(30),
  guide_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher values give better adherence to the prompt but may decrease quality.',
      }),
    )
    .default(5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If None, a random seed is chosen.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiWanI2vFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * WanI2VResponse
 */
export const zWanI2vOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiWanI2vFile,
})

/**
 * Q2ProReferenceToVideoRequest
 */
export const zViduQ2ReferenceToVideoProInput = z.object({
  prompt: z.string().max(2000).register(z.globalRegistry, {
    description: 'Text prompt for video generation, max 2000 characters',
  }),
  resolution: z.optional(
    z.enum(['540p', '720p', '1080p']).register(z.globalRegistry, {
      description: 'Output video resolution',
    }),
  ),
  aspect_ratio: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Aspect ratio of the output video (e.g., auto, 16:9, 9:16, 1:1, or any W:H)',
      }),
    )
    .default('16:9'),
  duration: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description:
          'Duration of the video in seconds (0 for automatic duration)',
      }),
    )
    .default(4),
  reference_video_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'URLs of the reference videos for video editing or motion reference. Supports up to 2 videos.',
    }),
  ),
  bgm: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to add background music to the generated video',
      }),
    )
    .default(false),
  reference_image_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'URLs of the reference images for subject appearance. If videos are provided, up to 4 images are allowed; otherwise up to 7 images.',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If None, a random seed is chosen.',
    }),
  ),
  movement_amplitude: z.optional(
    z.enum(['auto', 'small', 'medium', 'large']).register(z.globalRegistry, {
      description: 'The movement amplitude of objects in the frame',
    }),
  ),
})

/**
 * File
 */
export const zFalAiViduQ2ReferenceToVideoProFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Q2ProReferenceToVideoOutput
 */
export const zViduQ2ReferenceToVideoProOutput = z.object({
  video: zFalAiViduQ2ReferenceToVideoProFile,
})

/**
 * ImageToVideoInput
 *
 * Input for Wan 2.6 image-to-video generation
 */
export const zV26ImageToVideoFlashInput = z
  .object({
    prompt: z.string().min(1).register(z.globalRegistry, {
      description:
        'The text prompt describing the desired video motion. Max 800 characters.',
    }),
    resolution: z.optional(
      z.enum(['720p', '1080p']).register(z.globalRegistry, {
        description: 'Video resolution. Valid values: 720p, 1080p',
      }),
    ),
    duration: z.optional(
      z.enum(['5', '10', '15']).register(z.globalRegistry, {
        description:
          'Duration of the generated video in seconds. Choose between 5, 10 or 15 seconds.',
      }),
    ),
    audio_url: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          '\nURL of the audio to use as the background music. Must be publicly accessible.\nLimit handling: If the audio duration exceeds the duration value (5, 10, or 15 seconds),\nthe audio is truncated to the first N seconds, and the rest is discarded. If\nthe audio is shorter than the video, the remaining part of the video will be silent.\nFor example, if the audio is 3 seconds long and the video duration is 5 seconds, the\nfirst 3 seconds of the output video will have sound, and the last 2 seconds will be silent.\n- Format: WAV, MP3.\n- Duration: 3 to 30 s.\n- File size: Up to 15 MB.\n',
      }),
    ),
    image_url: z.string().register(z.globalRegistry, {
      description:
        'URL of the image to use as the first frame. Must be publicly accessible or base64 data URI. Image dimensions must be between 240 and 7680.',
    }),
    enable_prompt_expansion: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to enable prompt rewriting using LLM.',
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          'Random seed for reproducibility. If None, a random seed is chosen.',
      }),
    ),
    multi_shots: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'When true, enables intelligent multi-shot segmentation. Only active when enable_prompt_expansion is True. Set to false for single-shot generation.',
        }),
      )
      .default(false),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'Negative prompt to describe content to avoid. Max 500 characters.',
        }),
      )
      .default(''),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'If set to true, the safety checker will be enabled.',
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: 'Input for Wan 2.6 image-to-video generation',
  })

/**
 * VideoFile
 */
export const zWanV26ImageToVideoFlashVideoFile = z.object({
  height: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The height of the video',
    }),
  ),
  duration: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The duration of the video',
    }),
  ),
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  fps: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The FPS of the video',
    }),
  ),
  width: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The width of the video',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  num_frames: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The number of frames in the video',
    }),
  ),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToVideoOutput
 *
 * Output for image-to-video generation
 */
export const zV26ImageToVideoFlashOutput = z
  .object({
    actual_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The actual prompt used if prompt rewriting was enabled',
      }),
    ),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
    video: zWanV26ImageToVideoFlashVideoFile,
  })
  .register(z.globalRegistry, {
    description: 'Output for image-to-video generation',
  })

/**
 * LoRAInput
 *
 * LoRA weight configuration.
 */
export const zLoRaInput = z
  .object({
    path: z.string().register(z.globalRegistry, {
      description: 'URL, HuggingFace repo ID (owner/repo) to lora weights.',
    }),
    scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description: 'Scale factor for LoRA application (0.0 to 4.0).',
        }),
      )
      .default(1),
    weight_name: z.optional(z.union([z.string(), z.unknown()])),
  })
  .register(z.globalRegistry, {
    description: 'LoRA weight configuration.',
  })

/**
 * VideoFile
 */
export const zFalAiLtx219bDistilledImageToVideoLoraVideoFile = z.object({
  height: z.optional(z.union([z.int(), z.unknown()])),
  duration: z.optional(z.union([z.number(), z.unknown()])),
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  fps: z.optional(z.union([z.number(), z.unknown()])),
  width: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  num_frames: z.optional(z.union([z.int(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * LTX2ImageToVideoOutput
 */
export const zLtx219bDistilledImageToVideoLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for the generation.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for the random number generator.',
  }),
  video: zFalAiLtx219bDistilledImageToVideoLoraVideoFile,
})

/**
 * ImageSize
 */
export const zImageSize = z.object({
  height: z
    .optional(
      z.int().lte(14142).register(z.globalRegistry, {
        description: 'The height of the generated image.',
      }),
    )
    .default(512),
  width: z
    .optional(
      z.int().lte(14142).register(z.globalRegistry, {
        description: 'The width of the generated image.',
      }),
    )
    .default(512),
})

/**
 * LTX2DistilledImageToVideoInput
 */
export const zLtx219bDistilledImageToVideoInput = z.object({
  use_multiscale: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to use multi-scale generation. If True, the model will generate the video at a smaller scale first, then use the smaller video to guide the generation of a video at or above your requested size. This results in better coherence and details.',
      }),
    )
    .default(true),
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for the generation.',
  }),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high', 'full']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  generate_audio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to generate audio for the video.',
      }),
    )
    .default(true),
  fps: z
    .optional(
      z.number().gte(1).lte(60).register(z.globalRegistry, {
        description: 'The frames per second of the generated video.',
      }),
    )
    .default(25),
  camera_lora: z.optional(
    z
      .enum([
        'dolly_in',
        'dolly_out',
        'dolly_left',
        'dolly_right',
        'jib_up',
        'jib_down',
        'static',
        'none',
      ])
      .register(z.globalRegistry, {
        description:
          'The camera LoRA to use. This allows you to control the camera movement of the generated video more accurately than just prompting the model to move the camera.',
      }),
  ),
  video_size: z.optional(
    z.union([
      zImageSize,
      z.enum([
        'auto',
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable the safety checker.',
      }),
    )
    .default(true),
  num_frames: z
    .optional(
      z.int().gte(9).lte(481).register(z.globalRegistry, {
        description: 'The number of frames to generate.',
      }),
    )
    .default(121),
  image_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'The strength of the image to use for the video generation.',
      }),
    )
    .default(1),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to generate the video from.',
      }),
    )
    .default(
      'blurry, out of focus, overexposed, underexposed, low contrast, washed out colors, excessive noise, grainy texture, poor lighting, flickering, motion blur, distorted proportions, unnatural skin tones, deformed facial features, asymmetrical face, missing facial features, extra limbs, disfigured hands, wrong hand count, artifacts around text, inconsistent perspective, camera shake, incorrect depth of field, background too sharp, background clutter, distracting reflections, harsh shadows, inconsistent lighting direction, color banding, cartoonish rendering, 3D CGI look, unrealistic materials, uncanny valley effect, incorrect ethnicity, wrong gender, exaggerated expressions, wrong gaze direction, mismatched lip sync, silent or muted audio, distorted voice, robotic voice, echo, background noise, off-sync audio,incorrect dialogue, added dialogue, repetitive speech, jittery movement, awkward pauses, incorrect timing, unnatural transitions, inconsistent framing, tilted camera, flat lighting, inconsistent tone, cinematic oversaturation, stylized filters, or AI artifacts.',
    ),
  camera_lora_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'The scale of the camera LoRA to use. This allows you to control the camera movement of the generated video more accurately than just prompting the model to move the camera.',
      }),
    )
    .default(1),
  video_write_mode: z.optional(
    z.enum(['fast', 'balanced', 'small']).register(z.globalRegistry, {
      description: 'The write mode of the generated video.',
    }),
  ),
  video_output_type: z.optional(
    z
      .enum(['X264 (.mp4)', 'VP9 (.webm)', 'PRORES4444 (.mov)', 'GIF (.gif)'])
      .register(z.globalRegistry, {
        description: 'The output type of the generated video.',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate the video from.',
  }),
  video_quality: z.optional(
    z.enum(['low', 'medium', 'high', 'maximum']).register(z.globalRegistry, {
      description: 'The quality of the generated video.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable prompt expansion.',
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
})

/**
 * VideoFile
 */
export const zFalAiLtx219bDistilledImageToVideoVideoFile = z.object({
  height: z.optional(z.union([z.int(), z.unknown()])),
  duration: z.optional(z.union([z.number(), z.unknown()])),
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  fps: z.optional(z.union([z.number(), z.unknown()])),
  width: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  num_frames: z.optional(z.union([z.int(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * LTX2ImageToVideoOutput
 */
export const zLtx219bDistilledImageToVideoOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for the generation.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for the random number generator.',
  }),
  video: zFalAiLtx219bDistilledImageToVideoVideoFile,
})

/**
 * LoRAInput
 *
 * LoRA weight configuration.
 */
export const zFalAiLtx219bImageToVideoLoraLoRaInput = z
  .object({
    path: z.string().register(z.globalRegistry, {
      description: 'URL, HuggingFace repo ID (owner/repo) to lora weights.',
    }),
    scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description: 'Scale factor for LoRA application (0.0 to 4.0).',
        }),
      )
      .default(1),
    weight_name: z.optional(z.union([z.string(), z.unknown()])),
  })
  .register(z.globalRegistry, {
    description: 'LoRA weight configuration.',
  })

/**
 * VideoFile
 */
export const zFalAiLtx219bImageToVideoLoraVideoFile = z.object({
  height: z.optional(z.union([z.int(), z.unknown()])),
  duration: z.optional(z.union([z.number(), z.unknown()])),
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  fps: z.optional(z.union([z.number(), z.unknown()])),
  width: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  num_frames: z.optional(z.union([z.int(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * LTX2ImageToVideoOutput
 */
export const zLtx219bImageToVideoLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for the generation.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for the random number generator.',
  }),
  video: zFalAiLtx219bImageToVideoLoraVideoFile,
})

/**
 * ImageSize
 */
export const zFalAiLtx219bImageToVideoImageSize = z.object({
  height: z
    .optional(
      z.int().lte(14142).register(z.globalRegistry, {
        description: 'The height of the generated image.',
      }),
    )
    .default(512),
  width: z
    .optional(
      z.int().lte(14142).register(z.globalRegistry, {
        description: 'The width of the generated image.',
      }),
    )
    .default(512),
})

/**
 * LTX2ImageToVideoInput
 */
export const zLtx219bImageToVideoInput = z.object({
  use_multiscale: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to use multi-scale generation. If True, the model will generate the video at a smaller scale first, then use the smaller video to guide the generation of a video at or above your requested size. This results in better coherence and details.',
      }),
    )
    .default(true),
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for the generation.',
  }),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high', 'full']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  generate_audio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to generate audio for the video.',
      }),
    )
    .default(true),
  fps: z
    .optional(
      z.number().gte(1).lte(60).register(z.globalRegistry, {
        description: 'The frames per second of the generated video.',
      }),
    )
    .default(25),
  camera_lora: z.optional(
    z
      .enum([
        'dolly_in',
        'dolly_out',
        'dolly_left',
        'dolly_right',
        'jib_up',
        'jib_down',
        'static',
        'none',
      ])
      .register(z.globalRegistry, {
        description:
          'The camera LoRA to use. This allows you to control the camera movement of the generated video more accurately than just prompting the model to move the camera.',
      }),
  ),
  video_size: z.optional(
    z.union([
      zFalAiLtx219bImageToVideoImageSize,
      z.enum([
        'auto',
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: 'The guidance scale to use.',
      }),
    )
    .default(3),
  num_frames: z
    .optional(
      z.int().gte(9).lte(481).register(z.globalRegistry, {
        description: 'The number of frames to generate.',
      }),
    )
    .default(121),
  image_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'The strength of the image to use for the video generation.',
      }),
    )
    .default(1),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to generate the video from.',
      }),
    )
    .default(
      'blurry, out of focus, overexposed, underexposed, low contrast, washed out colors, excessive noise, grainy texture, poor lighting, flickering, motion blur, distorted proportions, unnatural skin tones, deformed facial features, asymmetrical face, missing facial features, extra limbs, disfigured hands, wrong hand count, artifacts around text, inconsistent perspective, camera shake, incorrect depth of field, background too sharp, background clutter, distracting reflections, harsh shadows, inconsistent lighting direction, color banding, cartoonish rendering, 3D CGI look, unrealistic materials, uncanny valley effect, incorrect ethnicity, wrong gender, exaggerated expressions, wrong gaze direction, mismatched lip sync, silent or muted audio, distorted voice, robotic voice, echo, background noise, off-sync audio,incorrect dialogue, added dialogue, repetitive speech, jittery movement, awkward pauses, incorrect timing, unnatural transitions, inconsistent framing, tilted camera, flat lighting, inconsistent tone, cinematic oversaturation, stylized filters, or AI artifacts.',
    ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable the safety checker.',
      }),
    )
    .default(true),
  video_write_mode: z.optional(
    z.enum(['fast', 'balanced', 'small']).register(z.globalRegistry, {
      description: 'The write mode of the generated video.',
    }),
  ),
  video_output_type: z.optional(
    z
      .enum(['X264 (.mp4)', 'VP9 (.webm)', 'PRORES4444 (.mov)', 'GIF (.gif)'])
      .register(z.globalRegistry, {
        description: 'The output type of the generated video.',
      }),
  ),
  camera_lora_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'The scale of the camera LoRA to use. This allows you to control the camera movement of the generated video more accurately than just prompting the model to move the camera.',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate the video from.',
  }),
  video_quality: z.optional(
    z.enum(['low', 'medium', 'high', 'maximum']).register(z.globalRegistry, {
      description: 'The quality of the generated video.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable prompt expansion.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(8).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to use.',
      }),
    )
    .default(40),
  seed: z.optional(z.union([z.int(), z.unknown()])),
})

/**
 * VideoFile
 */
export const zFalAiLtx219bImageToVideoVideoFile = z.object({
  height: z.optional(z.union([z.int(), z.unknown()])),
  duration: z.optional(z.union([z.number(), z.unknown()])),
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  fps: z.optional(z.union([z.number(), z.unknown()])),
  width: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  num_frames: z.optional(z.union([z.int(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * LTX2ImageToVideoOutput
 */
export const zLtx219bImageToVideoOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for the generation.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for the random number generator.',
  }),
  video: zFalAiLtx219bImageToVideoVideoFile,
})

/**
 * VideoFile
 */
export const zFalAiWanMoveVideoFile = z.object({
  height: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The height of the video',
    }),
  ),
  duration: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The duration of the video',
    }),
  ),
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  width: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The width of the video',
    }),
  ),
  fps: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The FPS of the video',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  num_frames: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The number of frames in the video',
    }),
  ),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * WanMoveOutput
 */
export const zWanMoveOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'Random seed used for generation.',
  }),
  video: zFalAiWanMoveVideoFile,
})

/**
 * Placeholder for missing schema TrajectoryPoint (referenced but not defined in source OpenAPI spec)
 */
export const zTrajectoryPoint = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description:
      'Placeholder for missing schema TrajectoryPoint (referenced but not defined in source OpenAPI spec)',
  })

/**
 * WANMoveInput
 */
export const zWanMoveInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text prompt to guide the video generation.',
  }),
  trajectories: z.array(z.array(zTrajectoryPoint)).register(z.globalRegistry, {
    description:
      'A list of trajectories. Each trajectory list means the movement of one object.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the input image. If the input image does not match the chosen aspect ratio, it is resized and center cropped.',
  }),
  guidance_scale: z
    .optional(
      z.number().gte(1).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher values give better adherence to the prompt but may decrease quality.',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description:
          'Number of inference steps for sampling. Higher values give better quality but take longer.',
      }),
    )
    .default(40),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If None, a random seed is chosen.',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to guide the video generation.',
      }),
    )
    .default(
      'JPEG',
    ),
})

/**
 * KandinskyI2VRequest
 */
export const zKandinsky5ProImageToVideoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the video from.',
  }),
  resolution: z.optional(
    z.enum(['512P', '1024P']).register(z.globalRegistry, {
      description: 'Video resolution: 512p or 1024p.',
    }),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular']).register(z.globalRegistry, {
      description: 'Acceleration level for faster generation.',
    }),
  ),
  duration: z.optional(
    z.enum(['5s']).register(z.globalRegistry, {
      description: 'Video duration.',
    }),
  ),
  num_inference_steps: z.optional(z.int().gte(1).lte(40)).default(28),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the image to use as a reference for the video generation.',
  }),
})

/**
 * File
 */
export const zFalAiKandinsky5ProImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * KandinskyI2VResponse
 */
export const zKandinsky5ProImageToVideoOutput = z.object({
  video: z.optional(zFalAiKandinsky5ProImageToVideoFile),
})

/**
 * SeedanceProv15ImageToVideoInput
 */
export const zBytedanceSeedanceV15ProImageToVideoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt used to generate the video',
  }),
  resolution: z.optional(
    z.enum(['480p', '720p', '1080p']).register(z.globalRegistry, {
      description:
        'Video resolution - 480p for faster generation, 720p for balance, 1080p for higher quality',
    }),
  ),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '1:1', '3:4', '9:16'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated video',
      }),
  ),
  generate_audio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to generate audio for the video',
      }),
    )
    .default(true),
  duration: z.optional(
    z
      .enum(['4', '5', '6', '7', '8', '9', '10', '11', '12'])
      .register(z.globalRegistry, {
        description: 'Duration of the video in seconds',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image used to generate video',
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  camera_fixed: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to fix the camera position',
      }),
    )
    .default(false),
  end_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The URL of the image the video ends with. Defaults to None.',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed to control video generation. Use -1 for random.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiBytedanceSeedanceV15ProImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * SeedanceProv15I2VVideoOutput
 */
export const zBytedanceSeedanceV15ProImageToVideoOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation',
  }),
  video: zFalAiBytedanceSeedanceV15ProImageToVideoFile,
})

/**
 * LiveAvatarRequest
 */
export const zLiveAvatarInput = z.object({
  frames_per_clip: z
    .optional(
      z.int().gte(16).lte(80).register(z.globalRegistry, {
        description:
          'Number of frames per clip. Must be a multiple of 4. Higher values = smoother but slower generation.',
      }),
    )
    .default(48),
  prompt: z.string().register(z.globalRegistry, {
    description:
      'A text prompt describing the scene and character. Helps guide the video generation style and context.',
  }),
  acceleration: z.optional(
    z.enum(['none', 'light', 'regular', 'high']).register(z.globalRegistry, {
      description: 'Acceleration level for faster video decoding ',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the reference image for avatar generation. The character in this image will be animated.',
  }),
  num_clips: z
    .optional(
      z.int().gte(1).lte(100).register(z.globalRegistry, {
        description:
          'Number of video clips to generate. Each clip is approximately 3 seconds. Set higher for longer videos.',
      }),
    )
    .default(10),
  audio_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the driving audio file (WAV or MP3). The avatar will be animated to match this audio.',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducible generation.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher values follow the prompt more closely.',
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable safety checker for content moderation.',
      }),
    )
    .default(true),
})

/**
 * VideoFile
 */
export const zFalAiLiveAvatarVideoFile = z.object({
  height: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The height of the video',
    }),
  ),
  duration: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The duration of the video',
    }),
  ),
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  fps: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The FPS of the video',
    }),
  ),
  width: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The width of the video',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  num_frames: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The number of frames in the video',
    }),
  ),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * LiveAvatarResponse
 */
export const zLiveAvatarOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiLiveAvatarVideoFile,
})

/**
 * HunyuanVideo15I2VRequest
 */
export const zHunyuanVideoV15ImageToVideoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the video from.',
  }),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16']).register(z.globalRegistry, {
      description: 'The aspect ratio of the video.',
    }),
  ),
  resolution: z.optional(
    z.enum(['480p']).register(z.globalRegistry, {
      description: 'The resolution of the video.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the reference image for image-to-video generation.',
  }),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable prompt expansion to enhance the input prompt.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducibility.',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps.',
      }),
    )
    .default(28),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to guide what not to generate.',
      }),
    )
    .default(''),
  num_frames: z
    .optional(
      z.int().gte(1).lte(121).register(z.globalRegistry, {
        description: 'The number of frames to generate.',
      }),
    )
    .default(121),
})

/**
 * File
 */
export const zFalAiHunyuanVideoV15ImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * HunyuanVideo15Response
 */
export const zHunyuanVideoV15ImageToVideoOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiHunyuanVideoV15ImageToVideoFile,
})

/**
 * ImageToVideoInput
 *
 * Input for Wan 2.6 image-to-video generation
 */
export const zV26ImageToVideoInput = z
  .object({
    prompt: z.string().min(1).register(z.globalRegistry, {
      description:
        'The text prompt describing the desired video motion. Max 800 characters.',
    }),
    resolution: z.optional(
      z.enum(['720p', '1080p']).register(z.globalRegistry, {
        description: 'Video resolution. Valid values: 720p, 1080p',
      }),
    ),
    duration: z.optional(
      z.enum(['5', '10', '15']).register(z.globalRegistry, {
        description:
          'Duration of the generated video in seconds. Choose between 5, 10 or 15 seconds.',
      }),
    ),
    audio_url: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          '\nURL of the audio to use as the background music. Must be publicly accessible.\nLimit handling: If the audio duration exceeds the duration value (5, 10, or 15 seconds),\nthe audio is truncated to the first N seconds, and the rest is discarded. If\nthe audio is shorter than the video, the remaining part of the video will be silent.\nFor example, if the audio is 3 seconds long and the video duration is 5 seconds, the\nfirst 3 seconds of the output video will have sound, and the last 2 seconds will be silent.\n- Format: WAV, MP3.\n- Duration: 3 to 30 s.\n- File size: Up to 15 MB.\n',
      }),
    ),
    image_url: z.string().register(z.globalRegistry, {
      description:
        'URL of the image to use as the first frame. Must be publicly accessible or base64 data URI. Image dimensions must be between 240 and 7680.',
    }),
    enable_prompt_expansion: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to enable prompt rewriting using LLM.',
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          'Random seed for reproducibility. If None, a random seed is chosen.',
      }),
    ),
    multi_shots: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'When true, enables intelligent multi-shot segmentation. Only active when enable_prompt_expansion is True. Set to false for single-shot generation.',
        }),
      )
      .default(false),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'Negative prompt to describe content to avoid. Max 500 characters.',
        }),
      )
      .default(''),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'If set to true, the safety checker will be enabled.',
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: 'Input for Wan 2.6 image-to-video generation',
  })

/**
 * VideoFile
 */
export const zWanV26ImageToVideoVideoFile = z.object({
  height: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The height of the video',
    }),
  ),
  duration: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The duration of the video',
    }),
  ),
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  fps: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The FPS of the video',
    }),
  ),
  width: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The width of the video',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  num_frames: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The number of frames in the video',
    }),
  ),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToVideoOutput
 *
 * Output for image-to-video generation
 */
export const zV26ImageToVideoOutput = z
  .object({
    actual_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The actual prompt used if prompt rewriting was enabled',
      }),
    ),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
    video: zWanV26ImageToVideoVideoFile,
  })
  .register(z.globalRegistry, {
    description: 'Output for image-to-video generation',
  })

/**
 * OmniVideoElementInput
 */
export const zOmniVideoElementInput = z.object({
  reference_image_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'Additional reference images from different angles. 1-3 images supported. At least one image is required.',
    }),
  ),
  frontal_image_url: z.string().register(z.globalRegistry, {
    description:
      'The frontal image of the element (main view).\n\nMax file size: 10.0MB, Min width: 300px, Min height: 300px, Min aspect ratio: 0.40, Max aspect ratio: 2.50, Timeout: 20.0s',
  }),
})

/**
 * File
 */
export const zFalAiKlingVideoO1StandardReferenceToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * OmniVideoReferenceToVideoOutput
 */
export const zKlingVideoO1StandardReferenceToVideoOutput = z.object({
  video: zFalAiKlingVideoO1StandardReferenceToVideoFile,
})

/**
 * OmniVideoImageToVideoInput
 */
export const zKlingVideoO1StandardImageToVideoInput = z.object({
  prompt: z.string().max(2500).register(z.globalRegistry, {
    description:
      'Use @Image1 to reference the start frame, @Image2 to reference the end frame.',
  }),
  duration: z.optional(
    z
      .enum(['3', '4', '5', '6', '7', '8', '9', '10'])
      .register(z.globalRegistry, {
        description: 'Video duration in seconds.',
      }),
  ),
  start_image_url: z.string().register(z.globalRegistry, {
    description:
      'Image to use as the first frame of the video.\n\nMax file size: 10.0MB, Min width: 300px, Min height: 300px, Min aspect ratio: 0.40, Max aspect ratio: 2.50, Timeout: 20.0s',
  }),
  end_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Image to use as the last frame of the video.\n\nMax file size: 10.0MB, Min width: 300px, Min height: 300px, Min aspect ratio: 0.40, Max aspect ratio: 2.50, Timeout: 20.0s',
    }),
  ),
})

/**
 * File
 */
export const zFalAiKlingVideoO1StandardImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * OmniVideoImageToVideoOutput
 *
 * Output for Kling Omni Video generation.
 */
export const zKlingVideoO1StandardImageToVideoOutput = z
  .object({
    video: zFalAiKlingVideoO1StandardImageToVideoFile,
  })
  .register(z.globalRegistry, {
    description: 'Output for Kling Omni Video generation.',
  })

/**
 * AuroraInputModel
 */
export const zCreatifyAuroraInput = z.object({
  prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'A text prompt to guide the video generation process.',
    }),
  ),
  resolution: z.optional(
    z.enum(['480p', '720p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(5).register(z.globalRegistry, {
        description: 'Guidance scale to be used for text prompt adherence.',
      }),
    )
    .default(1),
  audio_guidance_scale: z
    .optional(
      z.number().gte(0).lte(5).register(z.globalRegistry, {
        description: 'Guidance scale to be used for audio adherence.',
      }),
    )
    .default(2),
  audio_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the audio file to be used for video generation.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image file to be used for video generation.',
  }),
})

/**
 * VideoFile
 */
export const zFalAiCreatifyAuroraVideoFile = z.object({
  height: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The height of the video',
    }),
  ),
  duration: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The duration of the video',
    }),
  ),
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  width: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The width of the video',
    }),
  ),
  fps: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The FPS of the video',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  num_frames: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The number of frames in the video',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * AuroraOutputModel
 */
export const zCreatifyAuroraOutput = z.object({
  video: zFalAiCreatifyAuroraVideoFile,
})

/**
 * AIAvatarInput
 */
export const zKlingVideoAiAvatarV2ProInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The prompt to use for the video generation.',
      }),
    )
    .default('.'),
  audio_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the audio file.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to use as your avatar',
  }),
})

/**
 * File
 */
export const zFalAiKlingVideoAiAvatarV2ProFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * AIAvatarOutput
 */
export const zKlingVideoAiAvatarV2ProOutput = z.object({
  duration: z.number().register(z.globalRegistry, {
    description: 'Duration of the output video in seconds.',
  }),
  video: zFalAiKlingVideoAiAvatarV2ProFile,
})

/**
 * AIAvatarInput
 */
export const zKlingVideoAiAvatarV2StandardInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The prompt to use for the video generation.',
      }),
    )
    .default('.'),
  audio_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the audio file.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to use as your avatar',
  }),
})

/**
 * File
 */
export const zFalAiKlingVideoAiAvatarV2StandardFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * AIAvatarOutput
 */
export const zKlingVideoAiAvatarV2StandardOutput = z.object({
  duration: z.number().register(z.globalRegistry, {
    description: 'Duration of the output video in seconds.',
  }),
  video: zFalAiKlingVideoAiAvatarV2StandardFile,
})

/**
 * ImageToVideoV26ProRequest
 */
export const zKlingVideoV26ProImageToVideoInput = z.object({
  prompt: z.string().max(2500),
  duration: z.optional(
    z.enum(['5', '10']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  voice_ids: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'List of voice IDs to use for voice control. Reference voices in the prompt using <<<voice_1>>>, <<<voice_2>>>. Maximum 2 voices allowed. When provided and referenced in prompt, enables voice control billing.',
    }),
  ),
  generate_audio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to generate native audio for the video. Supports Chinese and English voice output. Other languages are automatically translated to English. For English speech, use lowercase letters; for acronyms or proper nouns, use uppercase.',
      }),
    )
    .default(true),
  start_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be used for the video',
  }),
  end_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of the image to be used for the end of the video',
    }),
  ),
  negative_prompt: z
    .optional(z.string().max(2500))
    .default('blur, distort, and low quality'),
})

/**
 * File
 */
export const zFalAiKlingVideoV26ProImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToVideoV26ProOutput
 */
export const zKlingVideoV26ProImageToVideoOutput = z.object({
  video: zFalAiKlingVideoV26ProImageToVideoFile,
})

/**
 * EffectInputV5_5
 */
export const zPixverseV55EffectsInput = z.object({
  effect: z
    .enum([
      'Kiss Me AI',
      'Kiss',
      'Muscle Surge',
      'Warmth of Jesus',
      'Anything, Robot',
      'The Tiger Touch',
      'Hug',
      'Holy Wings',
      'Microwave',
      'Zombie Mode',
      'Squid Game',
      'Baby Face',
      'Black Myth: Wukong',
      'Long Hair Magic',
      'Leggy Run',
      'Fin-tastic Mermaid',
      'Punch Face',
      'Creepy Devil Smile',
      'Thunder God',
      'Eye Zoom Challenge',
      "Who's Arrested?",
      'Baby Arrived',
      'Werewolf Rage',
      'Bald Swipe',
      'BOOM DROP',
      'Huge Cutie',
      'Liquid Metal',
      'Sharksnap!',
      'Dust Me Away',
      '3D Figurine Factor',
      'Bikini Up',
      'My Girlfriends',
      'My Boyfriends',
      'Subject 3 Fever',
      'Earth Zoom',
      'Pole Dance',
      'Vroom Dance',
      'GhostFace Terror',
      'Dragon Evoker',
      'Skeletal Bae',
      'Summoning succubus',
      'Halloween Voodoo Doll',
      '3D Naked-Eye AD',
      'Package Explosion',
      'Dishes Served',
      'Ocean ad',
      'Supermarket AD',
      'Tree doll',
      'Come Feel My Abs',
      'The Bicep Flex',
      'London Elite Vibe',
      'Flora Nymph Gown',
      'Christmas Costume',
      "It's Snowy",
      'Reindeer Cruiser',
      'Snow Globe Maker',
      'Pet Christmas Outfit',
      'Adopt a Polar Pal',
      'Cat Christmas Box',
      'Starlight Gift Box',
      'Xmas Poster',
      'Pet Christmas Tree',
      'City Santa Hat',
      'Stocking Sweetie',
      'Christmas Night',
      'Xmas Front Page Karma',
      "Grinch's Xmas Hijack",
    ])
    .register(z.globalRegistry, {
      description: 'The effect to apply to the video',
    }),
  duration: z.optional(
    z.enum(['5', '8', '10']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  resolution: z.optional(
    z.enum(['360p', '540p', '720p', '1080p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video.',
    }),
  ),
  thinking_type: z.optional(
    z.enum(['enabled', 'disabled', 'auto']).register(z.globalRegistry, {
      description:
        "Prompt optimization mode: 'enabled' to optimize, 'disabled' to turn off, 'auto' for model decision",
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to be used for the generation',
      }),
    )
    .default(''),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'Optional URL of the image to use as the first frame. If not provided, generates from text',
  }),
})

/**
 * File
 */
export const zFalAiPixverseV55EffectsFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * EffectOutput
 */
export const zPixverseV55EffectsOutput = z.object({
  video: zFalAiPixverseV55EffectsFile,
})

/**
 * TransitionRequestV5_5
 */
export const zPixverseV55TransitionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt for the transition',
  }),
  aspect_ratio: z.optional(
    z.enum(['16:9', '4:3', '1:1', '3:4', '9:16']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated video',
    }),
  ),
  duration: z.optional(
    z.enum(['5', '8', '10']).register(z.globalRegistry, {
      description:
        'The duration of the generated video in seconds. Longer durations cost more. 1080p videos are limited to 5 or 8 seconds',
    }),
  ),
  style: z.optional(
    z
      .enum(['anime', '3d_animation', 'clay', 'comic', 'cyberpunk'])
      .register(z.globalRegistry, {
        description: 'The style of the generated video',
      }),
  ),
  thinking_type: z.optional(
    z.enum(['enabled', 'disabled', 'auto']).register(z.globalRegistry, {
      description:
        "Prompt optimization mode: 'enabled' to optimize, 'disabled' to turn off, 'auto' for model decision",
    }),
  ),
  first_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
  resolution: z.optional(
    z.enum(['360p', '540p', '720p', '1080p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video',
    }),
  ),
  generate_audio_switch: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable audio generation (BGM, SFX, dialogue)',
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same video every time.\n        ',
    }),
  ),
  end_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of the image to use as the last frame',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to be used for the generation',
      }),
    )
    .default(''),
})

/**
 * File
 */
export const zFalAiPixverseV55TransitionFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * TransitionOutputV5_5
 */
export const zPixverseV55TransitionOutput = z.object({
  video: zFalAiPixverseV55TransitionFile,
})

/**
 * ImageToVideoRequestV5_5
 */
export const zPixverseV55ImageToVideoInput = z.object({
  prompt: z.string(),
  duration: z.optional(
    z.enum(['5', '8', '10']).register(z.globalRegistry, {
      description:
        'The duration of the generated video in seconds. Longer durations cost more. 1080p videos are limited to 5 or 8 seconds',
    }),
  ),
  resolution: z.optional(
    z.enum(['360p', '540p', '720p', '1080p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video',
    }),
  ),
  generate_multi_clip_switch: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable multi-clip generation with dynamic camera changes',
      }),
    )
    .default(false),
  thinking_type: z.optional(
    z.enum(['enabled', 'disabled', 'auto']).register(z.globalRegistry, {
      description:
        "Prompt optimization mode: 'enabled' to optimize, 'disabled' to turn off, 'auto' for model decision",
    }),
  ),
  style: z.optional(
    z
      .enum(['anime', '3d_animation', 'clay', 'comic', 'cyberpunk'])
      .register(z.globalRegistry, {
        description: 'The style of the generated video',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
  generate_audio_switch: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable audio generation (BGM, SFX, dialogue)',
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same video every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to be used for the generation',
      }),
    )
    .default(''),
})

/**
 * File
 */
export const zFalAiPixverseV55ImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * I2VOutputV5_5
 */
export const zPixverseV55ImageToVideoOutput = z.object({
  video: zFalAiPixverseV55ImageToVideoFile,
})

/**
 * OmniVideoImageToVideoInput
 */
export const zKlingVideoO1ImageToVideoInput = z.object({
  prompt: z.string().max(2500).register(z.globalRegistry, {
    description:
      'Use @Image1 to reference the start frame, @Image2 to reference the end frame.',
  }),
  duration: z.optional(
    z
      .enum(['3', '4', '5', '6', '7', '8', '9', '10'])
      .register(z.globalRegistry, {
        description: 'Video duration in seconds.',
      }),
  ),
  start_image_url: z.string().register(z.globalRegistry, {
    description:
      'Image to use as the first frame of the video.\n\nMax file size: 10.0MB, Min width: 300px, Min height: 300px, Min aspect ratio: 0.40, Max aspect ratio: 2.50, Timeout: 20.0s',
  }),
  end_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Image to use as the last frame of the video.\n\nMax file size: 10.0MB, Min width: 300px, Min height: 300px, Min aspect ratio: 0.40, Max aspect ratio: 2.50, Timeout: 20.0s',
    }),
  ),
})

/**
 * File
 */
export const zFalAiKlingVideoO1ImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * OmniVideoImageToVideoOutput
 *
 * Output for Kling Omni Video generation.
 */
export const zKlingVideoO1ImageToVideoOutput = z
  .object({
    video: zFalAiKlingVideoO1ImageToVideoFile,
  })
  .register(z.globalRegistry, {
    description: 'Output for Kling Omni Video generation.',
  })

/**
 * OmniVideoElementInput
 */
export const zFalAiKlingVideoO1ReferenceToVideoOmniVideoElementInput = z.object(
  {
    reference_image_urls: z.optional(
      z.array(z.string()).register(z.globalRegistry, {
        description:
          'Additional reference images from different angles. 1-3 images supported. At least one image is required.',
      }),
    ),
    frontal_image_url: z.string().register(z.globalRegistry, {
      description:
        'The frontal image of the element (main view).\n\nMax file size: 10.0MB, Min width: 300px, Min height: 300px, Min aspect ratio: 0.40, Max aspect ratio: 2.50, Timeout: 20.0s',
    }),
  },
)

/**
 * File
 */
export const zFalAiKlingVideoO1ReferenceToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * OmniVideoReferenceToVideoOutput
 */
export const zKlingVideoO1ReferenceToVideoOutput = z.object({
  video: zFalAiKlingVideoO1ReferenceToVideoFile,
})

/**
 * LTXVImageToVideoFastRequest
 */
export const zLtx2ImageToVideoFastInput = z.object({
  prompt: z.string().min(1).max(5000).register(z.globalRegistry, {
    description: 'The prompt to generate the video from',
  }),
  aspect_ratio: z.optional(
    z.enum(['16:9']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated video',
    }),
  ),
  duration: z.optional(
    z
      .union([
        z.literal(6),
        z.literal(8),
        z.literal(10),
        z.literal(12),
        z.literal(14),
        z.literal(16),
        z.literal(18),
        z.literal(20),
      ])
      .register(z.globalRegistry, {
        description:
          'The duration of the generated video in seconds. The fast model supports 6-20 seconds. Note: Durations longer than 10 seconds (12, 14, 16, 18, 20) are only supported with 25 FPS and 1080p resolution.',
      }),
  ),
  generate_audio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to generate audio for the generated video',
      }),
    )
    .default(true),
  resolution: z.optional(
    z.enum(['1080p', '1440p', '2160p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the image to generate the video from. Must be publicly accessible or base64 data URI. Supports PNG, JPEG, WebP, AVIF, and HEIF formats.',
  }),
  fps: z.optional(
    z.union([z.literal(25), z.literal(50)]).register(z.globalRegistry, {
      description: 'The frames per second of the generated video',
    }),
  ),
})

/**
 * VideoFile
 */
export const zFalAiLtx2ImageToVideoFastVideoFile = z.object({
  height: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The height of the video',
    }),
  ),
  duration: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The duration of the video',
    }),
  ),
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  fps: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The FPS of the video',
    }),
  ),
  width: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The width of the video',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  num_frames: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The number of frames in the video',
    }),
  ),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * LTXVImageToVideoResponse
 */
export const zLtx2ImageToVideoFastOutput = z.object({
  video: zFalAiLtx2ImageToVideoFastVideoFile,
})

/**
 * LTXVImageToVideoRequest
 */
export const zLtx2ImageToVideoInput = z.object({
  prompt: z.string().min(1).max(5000).register(z.globalRegistry, {
    description: 'The prompt to generate the video from',
  }),
  aspect_ratio: z.optional(
    z.enum(['16:9']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated video',
    }),
  ),
  duration: z.optional(
    z
      .union([z.literal(6), z.literal(8), z.literal(10)])
      .register(z.globalRegistry, {
        description: 'The duration of the generated video in seconds',
      }),
  ),
  generate_audio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to generate audio for the generated video',
      }),
    )
    .default(true),
  resolution: z.optional(
    z.enum(['1080p', '1440p', '2160p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the image to generate the video from. Must be publicly accessible or base64 data URI. Supports PNG, JPEG, WebP, AVIF, and HEIF formats.',
  }),
  fps: z.optional(
    z.union([z.literal(25), z.literal(50)]).register(z.globalRegistry, {
      description: 'The frames per second of the generated video',
    }),
  ),
})

/**
 * VideoFile
 */
export const zFalAiLtx2ImageToVideoVideoFile = z.object({
  height: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The height of the video',
    }),
  ),
  duration: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The duration of the video',
    }),
  ),
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  fps: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The FPS of the video',
    }),
  ),
  width: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The width of the video',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  num_frames: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The number of frames in the video',
    }),
  ),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * LTXVImageToVideoResponse
 */
export const zLtx2ImageToVideoOutput = z.object({
  video: zFalAiLtx2ImageToVideoVideoFile,
})

/**
 * LynxInput
 */
export const zLynxInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text prompt to guide video generation',
  }),
  resolution: z.optional(
    z.enum(['480p', '580p', '720p']).register(z.globalRegistry, {
      description: 'Resolution of the generated video (480p, 580p, or 720p)',
    }),
  ),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description: 'Aspect ratio of the generated video (16:9, 9:16, or 1:1)',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(75).register(z.globalRegistry, {
        description:
          'Number of inference steps for sampling. Higher values give better quality but take longer.',
      }),
    )
    .default(50),
  guidance_scale_2: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description:
          'Image guidance scale. Controls how closely the generated video follows the reference image. Higher values increase adherence to the reference image but may decrease quality.',
      }),
    )
    .default(2),
  strength: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description:
          'Reference image scale. Controls the influence of the reference image on the generated video.',
      }),
    )
    .default(1),
  frames_per_second: z
    .optional(
      z.int().gte(5).lte(30).register(z.globalRegistry, {
        description:
          'Frames per second of the generated video. Must be between 5 to 30.',
      }),
    )
    .default(16),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the subject image to be used for video generation',
  }),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher values give better adherence to the prompt but may decrease quality.',
      }),
    )
    .default(5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If None, a random seed is chosen.',
    }),
  ),
  num_frames: z
    .optional(
      z.int().gte(9).lte(81).register(z.globalRegistry, {
        description:
          'Number of frames in the generated video. Must be between 9 to 100.',
      }),
    )
    .default(81),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Negative prompt to guide what should not appear in the generated video',
      }),
    )
    .default(
      'Bright tones, overexposed, blurred background, static, subtitles, style, works, paintings, images, overall gray, worst quality, low quality, JPEG compression residue, ugly, incomplete, extra fingers, poorly drawn hands, poorly drawn faces, deformed, disfigured, misshapen limbs, fused fingers, still picture, messy background, three legs, many people in the background, walking backwards',
    ),
  ip_scale: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description:
          "Identity preservation scale. Controls how closely the generated video preserves the subject's identity from the reference image.",
      }),
    )
    .default(1),
})

/**
 * VideoFile
 */
export const zBytedanceLynxVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  duration: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The duration of the video',
    }),
  ),
  height: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The height of the video',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  fps: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The FPS of the video',
    }),
  ),
  width: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The width of the video',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  num_frames: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The number of frames in the video',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * LynxOutput
 */
export const zLynxOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
  video: zBytedanceLynxVideoFile,
})

/**
 * SwapRequest
 */
export const zPixverseSwapInput = z.object({
  original_sound_switch: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to keep the original audio',
      }),
    )
    .default(true),
  video_url: z.string().register(z.globalRegistry, {
    description: 'URL of the external video to swap',
  }),
  resolution: z.optional(
    z.enum(['360p', '540p', '720p']).register(z.globalRegistry, {
      description: 'The output resolution (1080p not supported)',
    }),
  ),
  mode: z.optional(
    z.enum(['person', 'object', 'background']).register(z.globalRegistry, {
      description: 'The swap mode to use',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the target image for swapping',
  }),
  keyframe_id: z
    .optional(
      z.int().gte(1).register(z.globalRegistry, {
        description: 'The keyframe ID (from 1 to the last frame position)',
      }),
    )
    .default(1),
})

/**
 * File
 */
export const zFalAiPixverseSwapFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * SwapOutput
 */
export const zPixverseSwapOutput = z.object({
  video: zFalAiPixverseSwapFile,
})

/**
 * KeyframeTransition
 *
 * Configuration for a transition between two keyframes
 */
export const zKeyframeTransition = z
  .object({
    prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'Specific prompt for this transition. Overrides the global prompt if provided.',
      }),
    ),
    duration: z
      .optional(
        z.int().gte(1).lte(25).register(z.globalRegistry, {
          description: 'Duration of this transition in seconds',
        }),
      )
      .default(5),
  })
  .register(z.globalRegistry, {
    description: 'Configuration for a transition between two keyframes',
  })

/**
 * Pika22KeyframesToVideoRequest
 */
export const zPikaV22PikaframesInput = z.object({
  prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Default prompt for all transitions. Individual transition prompts override this.',
    }),
  ),
  resolution: z.optional(
    z.enum(['720p', '1080p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video',
    }),
  ),
  transitions: z.optional(
    z.array(zKeyframeTransition).register(z.globalRegistry, {
      description:
        'Configuration for each transition. Length must be len(image_urls) - 1. Total duration of all transitions must not exceed 25 seconds. If not provided, uses default 5-second transitions with the global prompt.',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed for the random number generator',
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'URLs of keyframe images (2-5 images) to create transitions between',
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'A negative prompt to guide the model',
      }),
    )
    .default(''),
})

/**
 * File
 */
export const zFalAiPikaV22PikaframesFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Pika22KeyframesToVideoOutput
 *
 * Output model for Pika 2.2 keyframes-to-video generation
 */
export const zPikaV22PikaframesOutput = z
  .object({
    video: zFalAiPikaV22PikaframesFile,
  })
  .register(z.globalRegistry, {
    description: 'Output model for Pika 2.2 keyframes-to-video generation',
  })

/**
 * LongCat720PCFGImageToVideoRequest
 */
export const zLongcatVideoImageToVideo720pInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The prompt to guide the video generation.',
      }),
    )
    .default(
      "First-person view from the cockpit of a Formula 1 car. The driver's gloved hands firmly grip the intricate, carbon-fiber steering wheel adorned with numerous colorful buttons and a vibrant digital display showing race data. Beyond the windshield, a sun-drenched racetrack stretches ahead, lined with cheering spectators in the grandstands. Several rival cars are visible in the distance, creating a dynamic sense of competition. The sky above is a clear, brilliant blue, reflecting the exhilarating atmosphere of a high-speed race. high resolution 4k",
    ),
  acceleration: z.optional(
    z.enum(['none', 'regular']).register(z.globalRegistry, {
      description: 'The acceleration level to use for the video generation.',
    }),
  ),
  fps: z
    .optional(
      z.int().gte(1).lte(60).register(z.globalRegistry, {
        description: 'The frame rate of the generated video.',
      }),
    )
    .default(30),
  num_refine_inference_steps: z
    .optional(
      z.int().gte(8).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to use for refinement.',
      }),
    )
    .default(40),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: 'The guidance scale to use for the video generation.',
      }),
    )
    .default(4),
  num_frames: z
    .optional(
      z.int().gte(17).lte(961).register(z.globalRegistry, {
        description: 'The number of frames to generate.',
      }),
    )
    .default(162),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable safety checker.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to use for the video generation.',
      }),
    )
    .default(
      'Bright tones, overexposed, static, blurred details, subtitles, style, works, paintings, images, static, overall gray, worst quality, low quality, JPEG compression residue, ugly, incomplete, extra fingers, poorly drawn hands, poorly drawn faces, deformed, disfigured, misshapen limbs, fused fingers, still picture, messy background, three legs, many people in the background, walking backwards',
    ),
  video_write_mode: z.optional(
    z.enum(['fast', 'balanced', 'small']).register(z.globalRegistry, {
      description: 'The write mode of the generated video.',
    }),
  ),
  video_output_type: z.optional(
    z
      .enum(['X264 (.mp4)', 'VP9 (.webm)', 'PRORES4444 (.mov)', 'GIF (.gif)'])
      .register(z.globalRegistry, {
        description: 'The output type of the generated video.',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate a video from.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  video_quality: z.optional(
    z.enum(['low', 'medium', 'high', 'maximum']).register(z.globalRegistry, {
      description: 'The quality of the generated video.',
    }),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable prompt expansion.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(8).lte(50).register(z.globalRegistry, {
        description:
          'The number of inference steps to use for the video generation.',
      }),
    )
    .default(40),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed for the random number generator.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiLongcatVideoImageToVideo720pFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * LongCatImageToVideoResponse
 */
export const zLongcatVideoImageToVideo720pOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiLongcatVideoImageToVideo720pFile,
})

/**
 * LongCatCFGImageToVideoRequest
 */
export const zLongcatVideoImageToVideo480pInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The prompt to guide the video generation.',
      }),
    )
    .default(
      "First-person view from the cockpit of a Formula 1 car. The driver's gloved hands firmly grip the intricate, carbon-fiber steering wheel adorned with numerous colorful buttons and a vibrant digital display showing race data. Beyond the windshield, a sun-drenched racetrack stretches ahead, lined with cheering spectators in the grandstands. Several rival cars are visible in the distance, creating a dynamic sense of competition. The sky above is a clear, brilliant blue, reflecting the exhilarating atmosphere of a high-speed race. high resolution 4k",
    ),
  acceleration: z.optional(
    z.enum(['none', 'regular']).register(z.globalRegistry, {
      description: 'The acceleration level to use for the video generation.',
    }),
  ),
  fps: z
    .optional(
      z.int().gte(1).lte(60).register(z.globalRegistry, {
        description: 'The frame rate of the generated video.',
      }),
    )
    .default(15),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: 'The guidance scale to use for the video generation.',
      }),
    )
    .default(4),
  num_frames: z
    .optional(
      z.int().gte(17).lte(961).register(z.globalRegistry, {
        description: 'The number of frames to generate.',
      }),
    )
    .default(162),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable safety checker.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to use for the video generation.',
      }),
    )
    .default(
      'Bright tones, overexposed, static, blurred details, subtitles, style, works, paintings, images, static, overall gray, worst quality, low quality, JPEG compression residue, ugly, incomplete, extra fingers, poorly drawn hands, poorly drawn faces, deformed, disfigured, misshapen limbs, fused fingers, still picture, messy background, three legs, many people in the background, walking backwards',
    ),
  video_write_mode: z.optional(
    z.enum(['fast', 'balanced', 'small']).register(z.globalRegistry, {
      description: 'The write mode of the generated video.',
    }),
  ),
  video_output_type: z.optional(
    z
      .enum(['X264 (.mp4)', 'VP9 (.webm)', 'PRORES4444 (.mov)', 'GIF (.gif)'])
      .register(z.globalRegistry, {
        description: 'The output type of the generated video.',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate a video from.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  video_quality: z.optional(
    z.enum(['low', 'medium', 'high', 'maximum']).register(z.globalRegistry, {
      description: 'The quality of the generated video.',
    }),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable prompt expansion.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(8).lte(50).register(z.globalRegistry, {
        description:
          'The number of inference steps to use for the video generation.',
      }),
    )
    .default(40),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed for the random number generator.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiLongcatVideoImageToVideo480pFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * LongCatImageToVideoResponse
 */
export const zLongcatVideoImageToVideo480pOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiLongcatVideoImageToVideo480pFile,
})

/**
 * LongCat720PImageToVideoRequest
 */
export const zLongcatVideoDistilledImageToVideo720pInput = z.object({
  video_write_mode: z.optional(
    z.enum(['fast', 'balanced', 'small']).register(z.globalRegistry, {
      description: 'The write mode of the generated video.',
    }),
  ),
  video_output_type: z.optional(
    z
      .enum(['X264 (.mp4)', 'VP9 (.webm)', 'PRORES4444 (.mov)', 'GIF (.gif)'])
      .register(z.globalRegistry, {
        description: 'The output type of the generated video.',
      }),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable prompt expansion.',
      }),
    )
    .default(false),
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The prompt to guide the video generation.',
      }),
    )
    .default(
      "First-person view from the cockpit of a Formula 1 car. The driver's gloved hands firmly grip the intricate, carbon-fiber steering wheel adorned with numerous colorful buttons and a vibrant digital display showing race data. Beyond the windshield, a sun-drenched racetrack stretches ahead, lined with cheering spectators in the grandstands. Several rival cars are visible in the distance, creating a dynamic sense of competition. The sky above is a clear, brilliant blue, reflecting the exhilarating atmosphere of a high-speed race. high resolution 4k",
    ),
  fps: z
    .optional(
      z.int().gte(1).lte(60).register(z.globalRegistry, {
        description: 'The frame rate of the generated video.',
      }),
    )
    .default(30),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  num_refine_inference_steps: z
    .optional(
      z.int().gte(2).lte(16).register(z.globalRegistry, {
        description: 'The number of inference steps to use for refinement.',
      }),
    )
    .default(12),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate a video from.',
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable safety checker.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(16).register(z.globalRegistry, {
        description: 'The number of inference steps to use.',
      }),
    )
    .default(12),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed for the random number generator.',
    }),
  ),
  num_frames: z
    .optional(
      z.int().gte(17).lte(961).register(z.globalRegistry, {
        description: 'The number of frames to generate.',
      }),
    )
    .default(162),
  video_quality: z.optional(
    z.enum(['low', 'medium', 'high', 'maximum']).register(z.globalRegistry, {
      description: 'The quality of the generated video.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiLongcatVideoDistilledImageToVideo720pFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * LongCatImageToVideoResponse
 */
export const zLongcatVideoDistilledImageToVideo720pOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiLongcatVideoDistilledImageToVideo720pFile,
})

/**
 * LongCatImageToVideoRequest
 */
export const zLongcatVideoDistilledImageToVideo480pInput = z.object({
  video_write_mode: z.optional(
    z.enum(['fast', 'balanced', 'small']).register(z.globalRegistry, {
      description: 'The write mode of the generated video.',
    }),
  ),
  video_output_type: z.optional(
    z
      .enum(['X264 (.mp4)', 'VP9 (.webm)', 'PRORES4444 (.mov)', 'GIF (.gif)'])
      .register(z.globalRegistry, {
        description: 'The output type of the generated video.',
      }),
  ),
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The prompt to guide the video generation.',
      }),
    )
    .default(
      "First-person view from the cockpit of a Formula 1 car. The driver's gloved hands firmly grip the intricate, carbon-fiber steering wheel adorned with numerous colorful buttons and a vibrant digital display showing race data. Beyond the windshield, a sun-drenched racetrack stretches ahead, lined with cheering spectators in the grandstands. Several rival cars are visible in the distance, creating a dynamic sense of competition. The sky above is a clear, brilliant blue, reflecting the exhilarating atmosphere of a high-speed race. high resolution 4k",
    ),
  fps: z
    .optional(
      z.int().gte(1).lte(60).register(z.globalRegistry, {
        description: 'The frame rate of the generated video.',
      }),
    )
    .default(15),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate a video from.',
  }),
  video_quality: z.optional(
    z.enum(['low', 'medium', 'high', 'maximum']).register(z.globalRegistry, {
      description: 'The quality of the generated video.',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable safety checker.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(16).register(z.globalRegistry, {
        description: 'The number of inference steps to use.',
      }),
    )
    .default(12),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed for the random number generator.',
    }),
  ),
  num_frames: z
    .optional(
      z.int().gte(17).lte(961).register(z.globalRegistry, {
        description: 'The number of frames to generate.',
      }),
    )
    .default(162),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable prompt expansion.',
      }),
    )
    .default(false),
})

/**
 * File
 */
export const zFalAiLongcatVideoDistilledImageToVideo480pFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * LongCatImageToVideoResponse
 */
export const zLongcatVideoDistilledImageToVideo480pOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiLongcatVideoDistilledImageToVideo480pFile,
})

/**
 * StandardFastImageToVideoHailuo23Input
 */
export const zMinimaxHailuo23FastStandardImageToVideoInput = z.object({
  prompt_optimizer: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the model's prompt optimizer",
      }),
    )
    .default(true),
  duration: z.optional(
    z.enum(['6', '10']).register(z.globalRegistry, {
      description: 'The duration of the video in seconds.',
    }),
  ),
  prompt: z.string().min(1).max(2000).register(z.globalRegistry, {
    description: 'Text prompt for video generation',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
})

/**
 * File
 */
export const zFalAiMinimaxHailuo23FastStandardImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * StandardFastImageToVideoHailuo23Output
 */
export const zMinimaxHailuo23FastStandardImageToVideoOutput = z.object({
  video: zFalAiMinimaxHailuo23FastStandardImageToVideoFile,
})

/**
 * StandardImageToVideoHailuo23Input
 */
export const zMinimaxHailuo23StandardImageToVideoInput = z.object({
  prompt_optimizer: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the model's prompt optimizer",
      }),
    )
    .default(true),
  duration: z.optional(
    z.enum(['6', '10']).register(z.globalRegistry, {
      description: 'The duration of the video in seconds.',
    }),
  ),
  prompt: z.string().min(1).max(2000).register(z.globalRegistry, {
    description: 'Text prompt for video generation',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
})

/**
 * File
 */
export const zFalAiMinimaxHailuo23StandardImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * StandardImageToVideoHailuo23Output
 */
export const zMinimaxHailuo23StandardImageToVideoOutput = z.object({
  video: zFalAiMinimaxHailuo23StandardImageToVideoFile,
})

/**
 * ProFastImageToVideoHailuo23Input
 */
export const zMinimaxHailuo23FastProImageToVideoInput = z.object({
  prompt_optimizer: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the model's prompt optimizer",
      }),
    )
    .default(true),
  prompt: z.string().min(1).max(2000).register(z.globalRegistry, {
    description: 'Text prompt for video generation',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
})

/**
 * File
 */
export const zFalAiMinimaxHailuo23FastProImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ProFastImageToVideoHailuo23Output
 */
export const zMinimaxHailuo23FastProImageToVideoOutput = z.object({
  video: zFalAiMinimaxHailuo23FastProImageToVideoFile,
})

/**
 * SeedanceProFastImageToVideoInput
 */
export const zBytedanceSeedanceV1ProFastImageToVideoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt used to generate the video',
  }),
  resolution: z.optional(
    z.enum(['480p', '720p', '1080p']).register(z.globalRegistry, {
      description:
        'Video resolution - 480p for faster generation, 720p for balance, 1080p for higher quality',
    }),
  ),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '1:1', '3:4', '9:16', 'auto'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated video',
      }),
  ),
  duration: z.optional(
    z
      .enum(['2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'])
      .register(z.globalRegistry, {
        description: 'Duration of the video in seconds',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image used to generate video',
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  camera_fixed: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to fix the camera position',
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed to control video generation. Use -1 for random.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiBytedanceSeedanceV1ProFastImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * SeedanceFastI2VVideoOutput
 */
export const zBytedanceSeedanceV1ProFastImageToVideoOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation',
  }),
  video: zFalAiBytedanceSeedanceV1ProFastImageToVideoFile,
})

/**
 * Q2ImageToVideoRequest
 */
export const zViduQ2ImageToVideoTurboInput = z.object({
  prompt: z.string().max(3000).register(z.globalRegistry, {
    description: 'Text prompt for video generation, max 3000 characters',
  }),
  resolution: z.optional(
    z.enum(['720p', '1080p']).register(z.globalRegistry, {
      description: 'Output video resolution',
    }),
  ),
  duration: z.optional(
    z
      .union([
        z.literal(2),
        z.literal(3),
        z.literal(4),
        z.literal(5),
        z.literal(6),
        z.literal(7),
        z.literal(8),
      ])
      .register(z.globalRegistry, {
        description: 'Duration of the video in seconds',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the starting frame',
  }),
  bgm: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to add background music to the video (only for 4-second videos)',
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If None, a random seed is chosen.',
    }),
  ),
  movement_amplitude: z.optional(
    z.enum(['auto', 'small', 'medium', 'large']).register(z.globalRegistry, {
      description: 'The movement amplitude of objects in the frame',
    }),
  ),
  end_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'URL of the image to use as the ending frame. When provided, generates a transition video between start and end frames.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiViduQ2ImageToVideoTurboFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Q2ImageToVideoOutput
 */
export const zViduQ2ImageToVideoTurboOutput = z.object({
  video: zFalAiViduQ2ImageToVideoTurboFile,
})

/**
 * Q2ImageToVideoRequest
 */
export const zViduQ2ImageToVideoProInput = z.object({
  prompt: z.string().max(3000).register(z.globalRegistry, {
    description: 'Text prompt for video generation, max 3000 characters',
  }),
  resolution: z.optional(
    z.enum(['720p', '1080p']).register(z.globalRegistry, {
      description: 'Output video resolution',
    }),
  ),
  duration: z.optional(
    z
      .union([
        z.literal(2),
        z.literal(3),
        z.literal(4),
        z.literal(5),
        z.literal(6),
        z.literal(7),
        z.literal(8),
      ])
      .register(z.globalRegistry, {
        description: 'Duration of the video in seconds',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the starting frame',
  }),
  bgm: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to add background music to the video (only for 4-second videos)',
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If None, a random seed is chosen.',
    }),
  ),
  movement_amplitude: z.optional(
    z.enum(['auto', 'small', 'medium', 'large']).register(z.globalRegistry, {
      description: 'The movement amplitude of objects in the frame',
    }),
  ),
  end_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'URL of the image to use as the ending frame. When provided, generates a transition video between start and end frames.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiViduQ2ImageToVideoProFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Q2ImageToVideoOutput
 */
export const zViduQ2ImageToVideoProOutput = z.object({
  video: zFalAiViduQ2ImageToVideoProFile,
})

/**
 * Q2ReferenceToVideoRequest
 */
export const zViduQ2ReferenceToVideoInput = z.object({
  prompt: z.string().max(3000).register(z.globalRegistry, {
    description: 'Text prompt for video generation, max 3000 characters',
  }),
  resolution: z.optional(
    z.enum(['360p', '520p', '720p', '1080p']).register(z.globalRegistry, {
      description: 'Output video resolution',
    }),
  ),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description: 'The aspect ratio of the output video',
    }),
  ),
  duration: z.optional(
    z
      .union([
        z.literal(1),
        z.literal(2),
        z.literal(3),
        z.literal(4),
        z.literal(5),
        z.literal(6),
        z.literal(7),
        z.literal(8),
      ])
      .register(z.globalRegistry, {
        description: 'Duration of the video in seconds',
      }),
  ),
  bgm: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to add background music to the video (only for 4-second videos)',
      }),
    )
    .default(false),
  reference_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'URLs of the reference images to use for consistent subject appearance (up to 7 images)',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If None, a random seed is chosen.',
    }),
  ),
  movement_amplitude: z.optional(
    z.enum(['auto', 'small', 'medium', 'large']).register(z.globalRegistry, {
      description: 'The movement amplitude of objects in the frame',
    }),
  ),
})

/**
 * File
 */
export const zFalAiViduQ2ReferenceToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Q2ReferenceToVideoOutput
 */
export const zViduQ2ReferenceToVideoOutput = z.object({
  video: zFalAiViduQ2ReferenceToVideoFile,
})

/**
 * ImageToVideoV25StandardRequest
 */
export const zKlingVideoV25TurboStandardImageToVideoInput = z.object({
  prompt: z.string().max(2500),
  duration: z.optional(
    z.enum(['5', '10']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  cfg_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt.\n        ',
      }),
    )
    .default(0.5),
  negative_prompt: z
    .optional(z.string().max(2500))
    .default('blur, distort, and low quality'),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be used for the video',
  }),
})

/**
 * File
 */
export const zFalAiKlingVideoV25TurboStandardImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToVideoV25StandardOutput
 */
export const zKlingVideoV25TurboStandardImageToVideoOutput = z.object({
  video: zFalAiKlingVideoV25TurboStandardImageToVideoFile,
})

/**
 * Veo31FirstLastFrameToVideoInput
 */
export const zVeo31FastFirstLastFrameToVideoInput = z.object({
  prompt: z.string().max(20000).register(z.globalRegistry, {
    description: 'The text prompt describing the video you want to generate',
  }),
  duration: z.optional(
    z.enum(['4s', '6s', '8s']).register(z.globalRegistry, {
      description: 'The duration of the generated video.',
    }),
  ),
  aspect_ratio: z.optional(
    z.enum(['auto', '16:9', '9:16']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated video.',
    }),
  ),
  generate_audio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to generate audio for the video.',
      }),
    )
    .default(true),
  auto_fix: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to automatically attempt to fix prompts that fail content policy or other validation checks by rewriting them.',
      }),
    )
    .default(false),
  resolution: z.optional(
    z.enum(['720p', '1080p', '4k']).register(z.globalRegistry, {
      description: 'The resolution of the generated video.',
    }),
  ),
  first_frame_url: z.string().register(z.globalRegistry, {
    description: 'URL of the first frame of the video',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed for the random number generator.',
    }),
  ),
  last_frame_url: z.string().register(z.globalRegistry, {
    description: 'URL of the last frame of the video',
  }),
  negative_prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'A negative prompt to guide the video generation.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiVeo31FastFirstLastFrameToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Veo31FirstLastFrameToVideoOutput
 */
export const zVeo31FastFirstLastFrameToVideoOutput = z.object({
  video: zFalAiVeo31FastFirstLastFrameToVideoFile,
})

/**
 * Veo31FirstLastFrameToVideoInput
 */
export const zVeo31FirstLastFrameToVideoInput = z.object({
  prompt: z.string().max(20000).register(z.globalRegistry, {
    description: 'The text prompt describing the video you want to generate',
  }),
  duration: z.optional(
    z.enum(['4s', '6s', '8s']).register(z.globalRegistry, {
      description: 'The duration of the generated video.',
    }),
  ),
  aspect_ratio: z.optional(
    z.enum(['auto', '16:9', '9:16']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated video.',
    }),
  ),
  generate_audio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to generate audio for the video.',
      }),
    )
    .default(true),
  auto_fix: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to automatically attempt to fix prompts that fail content policy or other validation checks by rewriting them.',
      }),
    )
    .default(false),
  resolution: z.optional(
    z.enum(['720p', '1080p', '4k']).register(z.globalRegistry, {
      description: 'The resolution of the generated video.',
    }),
  ),
  first_frame_url: z.string().register(z.globalRegistry, {
    description: 'URL of the first frame of the video',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed for the random number generator.',
    }),
  ),
  last_frame_url: z.string().register(z.globalRegistry, {
    description: 'URL of the last frame of the video',
  }),
  negative_prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'A negative prompt to guide the video generation.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiVeo31FirstLastFrameToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Veo31FirstLastFrameToVideoOutput
 */
export const zVeo31FirstLastFrameToVideoOutput = z.object({
  video: zFalAiVeo31FirstLastFrameToVideoFile,
})

/**
 * Veo31ReferenceToVideoInput
 */
export const zVeo31ReferenceToVideoInput = z.object({
  prompt: z.string().max(20000).register(z.globalRegistry, {
    description: 'The text prompt describing the video you want to generate',
  }),
  duration: z.optional(
    z.enum(['8s']).register(z.globalRegistry, {
      description: 'The duration of the generated video.',
    }),
  ),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated video.',
    }),
  ),
  generate_audio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to generate audio for the video.',
      }),
    )
    .default(true),
  resolution: z.optional(
    z.enum(['720p', '1080p', '4k']).register(z.globalRegistry, {
      description: 'The resolution of the generated video.',
    }),
  ),
  auto_fix: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to automatically attempt to fix prompts that fail content policy or other validation checks by rewriting them.',
      }),
    )
    .default(false),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'URLs of the reference images to use for consistent subject appearance',
  }),
})

/**
 * File
 */
export const zFalAiVeo31ReferenceToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Veo31ReferenceToVideoOutput
 */
export const zVeo31ReferenceToVideoOutput = z.object({
  video: zFalAiVeo31ReferenceToVideoFile,
})

/**
 * Veo31ImageToVideoInput
 */
export const zVeo31FastImageToVideoInput = z.object({
  prompt: z.string().max(20000).register(z.globalRegistry, {
    description: 'The text prompt describing the video you want to generate',
  }),
  duration: z.optional(
    z.enum(['4s', '6s', '8s']).register(z.globalRegistry, {
      description: 'The duration of the generated video.',
    }),
  ),
  aspect_ratio: z.optional(
    z.enum(['auto', '16:9', '9:16']).register(z.globalRegistry, {
      description:
        'The aspect ratio of the generated video. Only 16:9 and 9:16 are supported.',
    }),
  ),
  generate_audio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to generate audio for the video.',
      }),
    )
    .default(true),
  auto_fix: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to automatically attempt to fix prompts that fail content policy or other validation checks by rewriting them.',
      }),
    )
    .default(false),
  resolution: z.optional(
    z.enum(['720p', '1080p', '4k']).register(z.globalRegistry, {
      description: 'The resolution of the generated video.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the input image to animate. Should be 720p or higher resolution in 16:9 or 9:16 aspect ratio. If the image is not in 16:9 or 9:16 aspect ratio, it will be cropped to fit.',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed for the random number generator.',
    }),
  ),
  negative_prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'A negative prompt to guide the video generation.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiVeo31FastImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Veo31ImageToVideoOutput
 */
export const zVeo31FastImageToVideoOutput = z.object({
  video: zFalAiVeo31FastImageToVideoFile,
})

/**
 * Veo31ImageToVideoInput
 */
export const zVeo31ImageToVideoInput = z.object({
  prompt: z.string().max(20000).register(z.globalRegistry, {
    description: 'The text prompt describing the video you want to generate',
  }),
  duration: z.optional(
    z.enum(['4s', '6s', '8s']).register(z.globalRegistry, {
      description: 'The duration of the generated video.',
    }),
  ),
  aspect_ratio: z.optional(
    z.enum(['auto', '16:9', '9:16']).register(z.globalRegistry, {
      description:
        'The aspect ratio of the generated video. Only 16:9 and 9:16 are supported.',
    }),
  ),
  generate_audio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to generate audio for the video.',
      }),
    )
    .default(true),
  auto_fix: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to automatically attempt to fix prompts that fail content policy or other validation checks by rewriting them.',
      }),
    )
    .default(false),
  resolution: z.optional(
    z.enum(['720p', '1080p', '4k']).register(z.globalRegistry, {
      description: 'The resolution of the generated video.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the input image to animate. Should be 720p or higher resolution in 16:9 or 9:16 aspect ratio. If the image is not in 16:9 or 9:16 aspect ratio, it will be cropped to fit.',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed for the random number generator.',
    }),
  ),
  negative_prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'A negative prompt to guide the video generation.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiVeo31ImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Veo31ImageToVideoOutput
 */
export const zVeo31ImageToVideoOutput = z.object({
  video: zFalAiVeo31ImageToVideoFile,
})

/**
 * ProImageToVideoInput
 */
export const zSora2ImageToVideoProInput = z.object({
  prompt: z.string().min(1).max(5000).register(z.globalRegistry, {
    description: 'The text prompt describing the video you want to generate',
  }),
  duration: z.optional(
    z
      .union([z.literal(4), z.literal(8), z.literal(12)])
      .register(z.globalRegistry, {
        description: 'Duration of the generated video in seconds',
      }),
  ),
  resolution: z.optional(
    z.enum(['auto', '720p', '1080p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video',
    }),
  ),
  aspect_ratio: z.optional(
    z.enum(['auto', '9:16', '16:9']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated video',
    }),
  ),
  delete_video: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to delete the video after generation for privacy reasons. If True, the video cannot be used for remixing and will be permanently deleted.',
      }),
    )
    .default(true),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to use as the first frame',
  }),
})

/**
 * ImageFile
 */
export const zImageFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  height: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The height of the image',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  width: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The width of the image',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * VideoFile
 */
export const zFalAiSora2ImageToVideoProVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  duration: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The duration of the video',
    }),
  ),
  height: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The height of the video',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  fps: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The FPS of the video',
    }),
  ),
  width: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The width of the video',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  num_frames: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The number of frames in the video',
    }),
  ),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ProImageToVideoOutput
 */
export const zSora2ImageToVideoProOutput = z.object({
  spritesheet: z.optional(zImageFile),
  thumbnail: z.optional(zImageFile),
  video_id: z.string().register(z.globalRegistry, {
    description: 'The ID of the generated video',
  }),
  video: zFalAiSora2ImageToVideoProVideoFile,
})

/**
 * ImageToVideoInput
 */
export const zSora2ImageToVideoInput = z.object({
  prompt: z.string().min(1).max(5000).register(z.globalRegistry, {
    description: 'The text prompt describing the video you want to generate',
  }),
  duration: z.optional(
    z
      .union([z.literal(4), z.literal(8), z.literal(12)])
      .register(z.globalRegistry, {
        description: 'Duration of the generated video in seconds',
      }),
  ),
  resolution: z.optional(
    z.enum(['auto', '720p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video',
    }),
  ),
  aspect_ratio: z.optional(
    z.enum(['auto', '9:16', '16:9']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated video',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to use as the first frame',
  }),
  model: z.optional(
    z
      .enum(['sora-2', 'sora-2-2025-12-08', 'sora-2-2025-10-06'])
      .register(z.globalRegistry, {
        description:
          'The model to use for the generation. When the default model is selected, the latest snapshot of the model will be used - otherwise, select a specific snapshot of the model.',
      }),
  ),
  delete_video: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to delete the video after generation for privacy reasons. If True, the video cannot be used for remixing and will be permanently deleted.',
      }),
    )
    .default(true),
})

/**
 * ImageFile
 */
export const zFalAiSora2ImageToVideoImageFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  height: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The height of the image',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  width: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The width of the image',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * VideoFile
 */
export const zFalAiSora2ImageToVideoVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  duration: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The duration of the video',
    }),
  ),
  height: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The height of the video',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  fps: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The FPS of the video',
    }),
  ),
  width: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The width of the video',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  num_frames: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The number of frames in the video',
    }),
  ),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToVideoOutput
 */
export const zSora2ImageToVideoOutput = z.object({
  spritesheet: z.optional(zFalAiSora2ImageToVideoImageFile),
  thumbnail: z.optional(zFalAiSora2ImageToVideoImageFile),
  video_id: z.string().register(z.globalRegistry, {
    description: 'The ID of the generated video',
  }),
  video: zFalAiSora2ImageToVideoVideoFile,
})

/**
 * OviI2VRequest
 */
export const zOviImageToVideoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide video generation.',
  }),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps.',
      }),
    )
    .default(30),
  audio_negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for audio generation.',
      }),
    )
    .default('robotic, muffled, echo, distorted'),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for video generation.',
      }),
    )
    .default('jitter, bad hands, blur, distortion'),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The image URL to guide video generation.',
  }),
})

/**
 * File
 */
export const zFalAiOviImageToVideoFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * OviI2VResponse
 */
export const zOviImageToVideoOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: z.optional(z.union([zFalAiOviImageToVideoFile, z.unknown()])),
})

/**
 * FabricOneLipsyncInput
 */
export const zFabric10FastInput = z.object({
  resolution: z.enum(['720p', '480p']).register(z.globalRegistry, {
    description: 'Resolution',
  }),
  audio_url: z.url().min(1).max(2083),
  image_url: z.url().min(1).max(2083),
})

/**
 * File
 */
export const zVeedFabric10FastFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * FabricOneOutput
 */
export const zFabric10FastOutput = z.object({
  video: zVeedFabric10FastFile,
})

/**
 * OmniHumanv15Input
 */
export const zBytedanceOmnihumanV15Input = z.object({
  turbo_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Generate a video at a faster rate with a slight quality trade-off.',
      }),
    )
    .default(false),
  resolution: z.optional(
    z.enum(['720p', '1080p']).register(z.globalRegistry, {
      description:
        'The resolution of the generated video. Defaults to 1080p. 720p generation is faster and higher in quality. 1080p generation is limited to 30s audio and 720p generation is limited to 60s audio.',
    }),
  ),
  prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The text prompt used to guide the video generation.',
    }),
  ),
  audio_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the audio file to generate the video. Audio must be under 30s long for 1080p generation and under 60s long for 720p generation.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image used to generate the video',
  }),
})

/**
 * File
 */
export const zFalAiBytedanceOmnihumanV15File = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * OmniHumanv15Output
 */
export const zBytedanceOmnihumanV15Output = z.object({
  duration: z.number().register(z.globalRegistry, {
    description: 'Duration of audio input/video output as used for billing.',
  }),
  video: zFalAiBytedanceOmnihumanV15File,
})

/**
 * FabricOneLipsyncInput
 */
export const zFabric10Input = z.object({
  resolution: z.enum(['720p', '480p']).register(z.globalRegistry, {
    description: 'Resolution',
  }),
  audio_url: z.url().min(1).max(2083),
  image_url: z.url().min(1).max(2083),
})

/**
 * File
 */
export const zVeedFabric10File = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * FabricOneOutput
 */
export const zFabric10Output = z.object({
  video: zVeedFabric10File,
})

/**
 * AIAvatarInput
 */
export const zKlingVideoV1StandardAiAvatarInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The prompt to use for the video generation.',
      }),
    )
    .default('.'),
  audio_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the audio file.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to use as your avatar',
  }),
})

/**
 * File
 */
export const zFalAiKlingVideoV1StandardAiAvatarFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * AIAvatarOutput
 */
export const zKlingVideoV1StandardAiAvatarOutput = z.object({
  duration: z.number().register(z.globalRegistry, {
    description: 'Duration of the output video in seconds.',
  }),
  video: zFalAiKlingVideoV1StandardAiAvatarFile,
})

/**
 * AIAvatarInput
 */
export const zKlingVideoV1ProAiAvatarInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The prompt to use for the video generation.',
      }),
    )
    .default('.'),
  audio_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the audio file.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to use as your avatar',
  }),
})

/**
 * File
 */
export const zFalAiKlingVideoV1ProAiAvatarFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * AIAvatarOutput
 */
export const zKlingVideoV1ProAiAvatarOutput = z.object({
  duration: z.number().register(z.globalRegistry, {
    description: 'Duration of the output video in seconds.',
  }),
  video: zFalAiKlingVideoV1ProAiAvatarFile,
})

/**
 * Lucy14BImageToVideoInput
 */
export const zLucy14bImageToVideoInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated\n            and uploaded before returning the response. This will increase the\n            latency of the function but it allows you to get the image directly\n            in the response without going through the CDN.\n        ',
      }),
    )
    .default(true),
  aspect_ratio: z.optional(
    z.enum(['9:16', '16:9']).register(z.globalRegistry, {
      description: 'Aspect ratio of the generated video.',
    }),
  ),
  prompt: z.string().max(1500).register(z.globalRegistry, {
    description: 'Text description of the desired video content',
  }),
  resolution: z.optional(
    z.enum(['720p']).register(z.globalRegistry, {
      description: 'Resolution of the generated video',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
})

/**
 * File
 */
export const zDecartLucy14bImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Lucy14BOutput
 */
export const zLucy14bImageToVideoOutput = z.object({
  video: zDecartLucy14bImageToVideoFile,
})

/**
 * SeedanceReferenceToVideoInput
 */
export const zBytedanceSeedanceV1LiteReferenceToVideoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt used to generate the video',
  }),
  resolution: z.optional(
    z.enum(['480p', '720p']).register(z.globalRegistry, {
      description:
        'Video resolution - 480p for faster generation, 720p for higher quality',
    }),
  ),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '1:1', '3:4', '9:16', 'auto'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated video',
      }),
  ),
  duration: z.optional(
    z
      .enum(['2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'])
      .register(z.globalRegistry, {
        description: 'Duration of the video in seconds',
      }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  camera_fixed: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to fix the camera position',
      }),
    )
    .default(false),
  reference_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: 'Reference images to generate the video with.',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed to control video generation. Use -1 for random.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiBytedanceSeedanceV1LiteReferenceToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * SeedanceReferenceToVideoOutput
 */
export const zBytedanceSeedanceV1LiteReferenceToVideoOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation',
  }),
  video: zFalAiBytedanceSeedanceV1LiteReferenceToVideoFile,
})

/**
 * File
 */
export const zFalAiWanAtiFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * WanATIResponse
 */
export const zWanAtiOutput = z.object({
  video: zFalAiWanAtiFile,
})

/**
 * Placeholder for missing schema TrackPoint (referenced but not defined in source OpenAPI spec)
 */
export const zTrackPoint = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description:
      'Placeholder for missing schema TrackPoint (referenced but not defined in source OpenAPI spec)',
  })

/**
 * WanATIRequest
 */
export const zWanAtiInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide video generation.',
  }),
  resolution: z.optional(
    z.enum(['480p', '580p', '720p']).register(z.globalRegistry, {
      description: 'Resolution of the generated video (480p, 580p, 720p).',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the input image.',
  }),
  track: z.array(z.array(zTrackPoint)).register(z.globalRegistry, {
    description:
      "Motion tracks to guide video generation. Each track is a sequence of points defining a motion trajectory. Multiple tracks can control different elements or objects in the video. Expected format: array of tracks, where each track is an array of points with 'x' and 'y' coordinates (up to 121 points per track). Points will be automatically padded to 121 if fewer are provided. Coordinates should be within the image dimensions.",
  }),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher values give better adherence to the prompt but may decrease quality.',
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(40).register(z.globalRegistry, {
        description:
          'Number of inference steps for sampling. Higher values give better quality but take longer.',
      }),
    )
    .default(40),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If None, a random seed is chosen.',
    }),
  ),
})

/**
 * ProcessRequest
 */
export const zDecartLucy5bImageToVideoInput = z.object({
  prompt: z.string().max(1500).register(z.globalRegistry, {
    description: 'Text description of the desired video content',
  }),
  aspect_ratio: z.optional(
    z.enum(['9:16', '16:9']).register(z.globalRegistry, {
      description: 'Aspect ratio of the generated video.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(true),
  resolution: z.optional(
    z.enum(['720p']).register(z.globalRegistry, {
      description: 'Resolution of the generated video',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
})

/**
 * File
 */
export const zFalAiDecartLucy5bImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ProcessOutput
 */
export const zDecartLucy5bImageToVideoOutput = z.object({
  video: zFalAiDecartLucy5bImageToVideoFile,
})

/**
 * TransitionRequest
 */
export const zPixverseV5TransitionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt for the transition',
  }),
  aspect_ratio: z.optional(
    z.enum(['16:9', '4:3', '1:1', '3:4', '9:16']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated video',
    }),
  ),
  duration: z.optional(
    z.enum(['5', '8']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  style: z.optional(
    z
      .enum(['anime', '3d_animation', 'clay', 'comic', 'cyberpunk'])
      .register(z.globalRegistry, {
        description: 'The style of the generated video',
      }),
  ),
  first_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
  resolution: z.optional(
    z.enum(['360p', '540p', '720p', '1080p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same video every time.\n        ',
    }),
  ),
  end_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of the image to use as the last frame',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to be used for the generation',
      }),
    )
    .default(''),
})

/**
 * File
 */
export const zFalAiPixverseV5TransitionFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * TransitionOutputV5
 */
export const zPixverseV5TransitionOutput = z.object({
  video: zFalAiPixverseV5TransitionFile,
})

/**
 * EffectInput
 */
export const zPixverseV5EffectsInput = z.object({
  effect: z
    .enum([
      'Kiss Me AI',
      'Kiss',
      'Muscle Surge',
      'Warmth of Jesus',
      'Anything, Robot',
      'The Tiger Touch',
      'Hug',
      'Holy Wings',
      'Microwave',
      'Zombie Mode',
      'Squid Game',
      'Baby Face',
      'Black Myth: Wukong',
      'Long Hair Magic',
      'Leggy Run',
      'Fin-tastic Mermaid',
      'Punch Face',
      'Creepy Devil Smile',
      'Thunder God',
      'Eye Zoom Challenge',
      "Who's Arrested?",
      'Baby Arrived',
      'Werewolf Rage',
      'Bald Swipe',
      'BOOM DROP',
      'Huge Cutie',
      'Liquid Metal',
      'Sharksnap!',
      'Dust Me Away',
      '3D Figurine Factor',
      'Bikini Up',
      'My Girlfriends',
      'My Boyfriends',
      'Subject 3 Fever',
      'Earth Zoom',
      'Pole Dance',
      'Vroom Dance',
      'GhostFace Terror',
      'Dragon Evoker',
      'Skeletal Bae',
      'Summoning succubus',
      'Halloween Voodoo Doll',
      '3D Naked-Eye AD',
      'Package Explosion',
      'Dishes Served',
      'Ocean ad',
      'Supermarket AD',
      'Tree doll',
      'Come Feel My Abs',
      'The Bicep Flex',
      'London Elite Vibe',
      'Flora Nymph Gown',
      'Christmas Costume',
      "It's Snowy",
      'Reindeer Cruiser',
      'Snow Globe Maker',
      'Pet Christmas Outfit',
      'Adopt a Polar Pal',
      'Cat Christmas Box',
      'Starlight Gift Box',
      'Xmas Poster',
      'Pet Christmas Tree',
      'City Santa Hat',
      'Stocking Sweetie',
      'Christmas Night',
      'Xmas Front Page Karma',
      "Grinch's Xmas Hijack",
    ])
    .register(z.globalRegistry, {
      description: 'The effect to apply to the video',
    }),
  duration: z.optional(
    z.enum(['5', '8']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  resolution: z.optional(
    z.enum(['360p', '540p', '720p', '1080p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video.',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to be used for the generation',
      }),
    )
    .default(''),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'Optional URL of the image to use as the first frame. If not provided, generates from text',
  }),
})

/**
 * File
 */
export const zFalAiPixverseV5EffectsFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * EffectOutput
 */
export const zPixverseV5EffectsOutput = z.object({
  video: zFalAiPixverseV5EffectsFile,
})

/**
 * ImageToVideoRequestV5
 */
export const zPixverseV5ImageToVideoInput = z.object({
  prompt: z.string(),
  duration: z.optional(
    z.enum(['5', '8']).register(z.globalRegistry, {
      description:
        'The duration of the generated video in seconds. 8s videos cost double. 1080p videos are limited to 5 seconds',
    }),
  ),
  resolution: z.optional(
    z.enum(['360p', '540p', '720p', '1080p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video',
    }),
  ),
  style: z.optional(
    z
      .enum(['anime', '3d_animation', 'clay', 'comic', 'cyberpunk'])
      .register(z.globalRegistry, {
        description: 'The style of the generated video',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same video every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to be used for the generation',
      }),
    )
    .default(''),
})

/**
 * File
 */
export const zFalAiPixverseV5ImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * I2VOutputV5
 */
export const zPixverseV5ImageToVideoOutput = z.object({
  video: zFalAiPixverseV5ImageToVideoFile,
})

/**
 * MareyInputI2V
 */
export const zMareyI2vInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate a video from',
  }),
  duration: z.optional(
    z.enum(['5s', '10s']).register(z.globalRegistry, {
      description: 'The duration of the generated video.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to use as the first frame of the video.',
  }),
  dimensions: z.optional(
    z
      .enum(['1920x1080', '1080x1920', '1152x1152', '1536x1152', '1152x1536'])
      .register(z.globalRegistry, {
        description:
          'The dimensions of the generated video in width x height format.',
      }),
  ),
  guidance_scale: z.optional(z.union([z.number(), z.unknown()])),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  negative_prompt: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * File
 */
export const zMoonvalleyMareyI2vFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * MareyOutput
 */
export const zMareyI2vOutput = z.object({
  video: zMoonvalleyMareyI2vFile,
})

/**
 * StylizeInput
 */
export const zBytedanceVideoStylizeInput = z.object({
  style: z.string().max(100).register(z.globalRegistry, {
    description:
      'The style for your character in the video. Please use a short description.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to make the stylized video from.',
  }),
})

export const zBytedanceVideoStylizeOutput = z.unknown()

/**
 * LoRAWeight
 */
export const zLoRaWeight = z.object({
  path: z.string().register(z.globalRegistry, {
    description: 'URL or the path to the LoRA weights.',
  }),
  scale: z
    .optional(
      z.number().gte(0).lte(4).register(z.globalRegistry, {
        description:
          '\n            The scale of the LoRA weight. This is used to scale the LoRA weight\n            before merging it with the base model.\n        ',
      }),
    )
    .default(1),
  transformer: z.optional(
    z.enum(['high', 'low', 'both']).register(z.globalRegistry, {
      description:
        "Specifies the transformer to load the lora weight into. 'high' loads into the high-noise transformer, 'low' loads it into the low-noise transformer, while 'both' loads the LoRA into both transformers.",
    }),
  ),
  weight_name: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * WanLoRAI2VRequest
 */
export const zWanV22A14bImageToVideoLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide video generation.',
  }),
  shift: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: 'Shift value for the video. Must be between 1.0 and 10.0.',
      }),
    )
    .default(5),
  acceleration: z.optional(
    z.enum(['none', 'regular']).register(z.globalRegistry, {
      description:
        "Acceleration level to use. The more acceleration, the faster the generation, but with lower quality. The recommended value is 'regular'.",
    }),
  ),
  num_interpolated_frames: z
    .optional(
      z.int().gte(0).lte(4).register(z.globalRegistry, {
        description:
          'Number of frames to interpolate between each pair of generated frames. Must be between 0 and 4.',
      }),
    )
    .default(1),
  reverse_video: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If true, the video will be reversed.',
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoRaWeight).register(z.globalRegistry, {
        description: 'LoRA weights to be used in the inference.',
      }),
    )
    .default([]),
  frames_per_second: z.optional(z.union([z.int().gte(4).lte(60), z.unknown()])),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, input data will be checked for safety before processing.',
      }),
    )
    .default(false),
  num_frames: z
    .optional(
      z.int().gte(17).lte(161).register(z.globalRegistry, {
        description:
          'Number of frames to generate. Must be between 17 to 161 (inclusive).',
      }),
    )
    .default(81),
  end_image_url: z.optional(z.union([z.string(), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for video generation.',
      }),
    )
    .default(''),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher values give better adherence to the prompt but may decrease quality.',
      }),
    )
    .default(3.5),
  video_write_mode: z.optional(
    z.enum(['fast', 'balanced', 'small']).register(z.globalRegistry, {
      description:
        'The write mode of the output video. Faster write mode means faster results but larger file size, balanced write mode is a good compromise between speed and quality, and small write mode is the slowest but produces the smallest file size.',
    }),
  ),
  resolution: z.optional(
    z.enum(['480p', '580p', '720p']).register(z.globalRegistry, {
      description: 'Resolution of the generated video (480p, 580p, or 720p).',
    }),
  ),
  aspect_ratio: z.optional(
    z.enum(['auto', '16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description:
        "Aspect ratio of the generated video. If 'auto', the aspect ratio will be determined automatically based on the input image.",
    }),
  ),
  enable_output_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, output video will be checked for safety after generation.',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the input image. If the input image does not match the chosen aspect ratio, it is resized and center cropped.',
  }),
  video_quality: z.optional(
    z.enum(['low', 'medium', 'high', 'maximum']).register(z.globalRegistry, {
      description:
        'The quality of the output video. Higher quality means better visual quality but larger file size.',
    }),
  ),
  guidance_scale_2: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Guidance scale for the second stage of the model. This is used to control the adherence to the prompt in the second stage of the model.',
      }),
    )
    .default(4),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.',
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  interpolator_model: z.optional(
    z.enum(['none', 'film', 'rife']).register(z.globalRegistry, {
      description:
        'The model to use for frame interpolation. If None, no interpolation is applied.',
    }),
  ),
  adjust_fps_for_interpolation: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If true, the number of frames per second will be multiplied by the number of interpolated frames plus one. For example, if the generated frames per second is 16 and the number of interpolated frames is 1, the final frames per second will be 32. If false, the passed frames per second will be used as-is.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(40).register(z.globalRegistry, {
        description:
          'Number of inference steps for sampling. Higher values give better quality but take longer.',
      }),
    )
    .default(27),
})

/**
 * File
 */
export const zFalAiWanV22A14bImageToVideoLoraFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * WanI2VResponse
 */
export const zWanV22A14bImageToVideoLoraOutput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The text prompt used for video generation.',
      }),
    )
    .default(''),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiWanV22A14bImageToVideoLoraFile,
})

/**
 * FastImageToVideoHailuo02Input
 */
export const zMinimaxHailuo02FastImageToVideoInput = z.object({
  prompt_optimizer: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the model's prompt optimizer",
      }),
    )
    .default(true),
  duration: z.optional(
    z.enum(['6', '10']).register(z.globalRegistry, {
      description:
        'The duration of the video in seconds. 10 seconds videos are not supported for 1080p resolution.',
    }),
  ),
  prompt: z.string().max(2000),
  image_url: z.string(),
})

/**
 * File
 */
export const zFalAiMinimaxHailuo02FastImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToVideoHailuo02FastOutput
 */
export const zMinimaxHailuo02FastImageToVideoOutput = z.object({
  video: zFalAiMinimaxHailuo02FastImageToVideoFile,
})

/**
 * Veo3ImageToVideoInput
 */
export const zVeo3ImageToVideoInput = z.object({
  prompt: z.string().max(20000).register(z.globalRegistry, {
    description: 'The text prompt describing how the image should be animated',
  }),
  resolution: z.optional(
    z.enum(['720p', '1080p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video.',
    }),
  ),
  aspect_ratio: z.optional(
    z.enum(['auto', '16:9', '9:16']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated video.',
    }),
  ),
  generate_audio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to generate audio for the video.',
      }),
    )
    .default(true),
  auto_fix: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to automatically attempt to fix prompts that fail content policy or other validation checks by rewriting them.',
      }),
    )
    .default(false),
  duration: z.optional(
    z.enum(['4s', '6s', '8s']).register(z.globalRegistry, {
      description: 'The duration of the generated video.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the input image to animate. Should be 720p or higher resolution in 16:9 or 9:16 aspect ratio. If the image is not in 16:9 or 9:16 aspect ratio, it will be cropped to fit.',
  }),
})

/**
 * File
 */
export const zFalAiVeo3ImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Veo3ImageToVideoOutput
 */
export const zVeo3ImageToVideoOutput = z.object({
  video: zFalAiVeo3ImageToVideoFile,
})

/**
 * WanTurboI2VRequest
 */
export const zWanV22A14bImageToVideoTurboInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide video generation.',
  }),
  resolution: z.optional(
    z.enum(['480p', '580p', '720p']).register(z.globalRegistry, {
      description: 'Resolution of the generated video (480p, 580p, or 720p).',
    }),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular']).register(z.globalRegistry, {
      description:
        "Acceleration level to use. The more acceleration, the faster the generation, but with lower quality. The recommended value is 'regular'.",
    }),
  ),
  aspect_ratio: z.optional(
    z.enum(['auto', '16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description:
        "Aspect ratio of the generated video. If 'auto', the aspect ratio will be determined automatically based on the input image.",
    }),
  ),
  video_write_mode: z.optional(
    z.enum(['fast', 'balanced', 'small']).register(z.globalRegistry, {
      description:
        'The write mode of the output video. Faster write mode means faster results but larger file size, balanced write mode is a good compromise between speed and quality, and small write mode is the slowest but produces the smallest file size.',
    }),
  ),
  enable_output_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, output video will be checked for safety after generation.',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the input image. If the input image does not match the chosen aspect ratio, it is resized and center cropped.',
  }),
  video_quality: z.optional(
    z.enum(['low', 'medium', 'high', 'maximum']).register(z.globalRegistry, {
      description:
        'The quality of the output video. Higher quality means better visual quality but larger file size.',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, input data will be checked for safety before processing.',
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  end_image_url: z.optional(z.union([z.string(), z.unknown()])),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.',
      }),
    )
    .default(false),
})

/**
 * File
 */
export const zFalAiWanV22A14bImageToVideoTurboFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * WanTurboI2VResponse
 */
export const zWanV22A14bImageToVideoTurboOutput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The text prompt used for video generation.',
      }),
    )
    .default(''),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiWanV22A14bImageToVideoTurboFile,
})

/**
 * WanSmallI2VRequest
 */
export const zWanV225bImageToVideoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide video generation.',
  }),
  shift: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: 'Shift value for the video. Must be between 1.0 and 10.0.',
      }),
    )
    .default(5),
  num_interpolated_frames: z
    .optional(
      z.int().gte(0).lte(4).register(z.globalRegistry, {
        description:
          'Number of frames to interpolate between each pair of generated frames. Must be between 0 and 4.',
      }),
    )
    .default(0),
  frames_per_second: z.optional(z.union([z.int().gte(4).lte(60), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher values give better adherence to the prompt but may decrease quality.',
      }),
    )
    .default(3.5),
  num_frames: z
    .optional(
      z.int().gte(17).lte(161).register(z.globalRegistry, {
        description:
          'Number of frames to generate. Must be between 17 to 161 (inclusive).',
      }),
    )
    .default(81),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, input data will be checked for safety before processing.',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for video generation.',
      }),
    )
    .default(''),
  video_write_mode: z.optional(
    z.enum(['fast', 'balanced', 'small']).register(z.globalRegistry, {
      description:
        'The write mode of the output video. Faster write mode means faster results but larger file size, balanced write mode is a good compromise between speed and quality, and small write mode is the slowest but produces the smallest file size.',
    }),
  ),
  resolution: z.optional(
    z.enum(['580p', '720p']).register(z.globalRegistry, {
      description: 'Resolution of the generated video (580p or 720p).',
    }),
  ),
  aspect_ratio: z.optional(
    z.enum(['auto', '16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description:
        "Aspect ratio of the generated video. If 'auto', the aspect ratio will be determined automatically based on the input image.",
    }),
  ),
  enable_output_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, output video will be checked for safety after generation.',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the input image. If the input image does not match the chosen aspect ratio, it is resized and center cropped.',
  }),
  video_quality: z.optional(
    z.enum(['low', 'medium', 'high', 'maximum']).register(z.globalRegistry, {
      description:
        'The quality of the output video. Higher quality means better visual quality but larger file size.',
    }),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.',
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  interpolator_model: z.optional(
    z.enum(['none', 'film', 'rife']).register(z.globalRegistry, {
      description:
        'The model to use for frame interpolation. If None, no interpolation is applied.',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description:
          'Number of inference steps for sampling. Higher values give better quality but take longer.',
      }),
    )
    .default(40),
  adjust_fps_for_interpolation: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If true, the number of frames per second will be multiplied by the number of interpolated frames plus one. For example, if the generated frames per second is 16 and the number of interpolated frames is 1, the final frames per second will be 32. If false, the passed frames per second will be used as-is.',
      }),
    )
    .default(true),
})

/**
 * File
 */
export const zFalAiWanV225bImageToVideoFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * WanSmallI2VResponse
 */
export const zWanV225bImageToVideoOutput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The text prompt used for video generation.',
      }),
    )
    .default(''),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiWanV225bImageToVideoFile,
})

/**
 * WanI2VRequest
 */
export const zWanV22A14bImageToVideoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide video generation.',
  }),
  shift: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: 'Shift value for the video. Must be between 1.0 and 10.0.',
      }),
    )
    .default(5),
  acceleration: z.optional(
    z.enum(['none', 'regular']).register(z.globalRegistry, {
      description:
        "Acceleration level to use. The more acceleration, the faster the generation, but with lower quality. The recommended value is 'regular'.",
    }),
  ),
  num_interpolated_frames: z
    .optional(
      z.int().gte(0).lte(4).register(z.globalRegistry, {
        description:
          'Number of frames to interpolate between each pair of generated frames. Must be between 0 and 4.',
      }),
    )
    .default(1),
  frames_per_second: z.optional(z.union([z.int().gte(4).lte(60), z.unknown()])),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, input data will be checked for safety before processing.',
      }),
    )
    .default(false),
  num_frames: z
    .optional(
      z.int().gte(17).lte(161).register(z.globalRegistry, {
        description:
          'Number of frames to generate. Must be between 17 to 161 (inclusive).',
      }),
    )
    .default(81),
  end_image_url: z.optional(z.union([z.string(), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for video generation.',
      }),
    )
    .default(''),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher values give better adherence to the prompt but may decrease quality.',
      }),
    )
    .default(3.5),
  video_write_mode: z.optional(
    z.enum(['fast', 'balanced', 'small']).register(z.globalRegistry, {
      description:
        'The write mode of the output video. Faster write mode means faster results but larger file size, balanced write mode is a good compromise between speed and quality, and small write mode is the slowest but produces the smallest file size.',
    }),
  ),
  resolution: z.optional(
    z.enum(['480p', '580p', '720p']).register(z.globalRegistry, {
      description: 'Resolution of the generated video (480p, 580p, or 720p).',
    }),
  ),
  aspect_ratio: z.optional(
    z.enum(['auto', '16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description:
        "Aspect ratio of the generated video. If 'auto', the aspect ratio will be determined automatically based on the input image.",
    }),
  ),
  enable_output_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, output video will be checked for safety after generation.',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the input image. If the input image does not match the chosen aspect ratio, it is resized and center cropped.',
  }),
  video_quality: z.optional(
    z.enum(['low', 'medium', 'high', 'maximum']).register(z.globalRegistry, {
      description:
        'The quality of the output video. Higher quality means better visual quality but larger file size.',
    }),
  ),
  guidance_scale_2: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Guidance scale for the second stage of the model. This is used to control the adherence to the prompt in the second stage of the model.',
      }),
    )
    .default(3.5),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.',
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  interpolator_model: z.optional(
    z.enum(['none', 'film', 'rife']).register(z.globalRegistry, {
      description:
        'The model to use for frame interpolation. If None, no interpolation is applied.',
    }),
  ),
  adjust_fps_for_interpolation: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If true, the number of frames per second will be multiplied by the number of interpolated frames plus one. For example, if the generated frames per second is 16 and the number of interpolated frames is 1, the final frames per second will be 32. If false, the passed frames per second will be used as-is.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(40).register(z.globalRegistry, {
        description:
          'Number of inference steps for sampling. Higher values give better quality but take longer.',
      }),
    )
    .default(27),
})

/**
 * File
 */
export const zFalAiWanV22A14bImageToVideoFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * WanI2VResponse
 */
export const zWanV22A14bImageToVideoOutput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The text prompt used for video generation.',
      }),
    )
    .default(''),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiWanV22A14bImageToVideoFile,
})

/**
 * OmniHumanInput
 */
export const zBytedanceOmnihumanInput = z.object({
  audio_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the audio file to generate the video. Audio must be under 30s long.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image used to generate the video',
  }),
})

/**
 * File
 */
export const zFalAiBytedanceOmnihumanFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * OmniHumanOutput
 */
export const zBytedanceOmnihumanOutput = z.object({
  duration: z.number().register(z.globalRegistry, {
    description: 'Duration of audio input/video output as used for billing.',
  }),
  video: zFalAiBytedanceOmnihumanFile,
})

/**
 * LoRAWeight
 */
export const zFalAiLtxv13B098DistilledImageToVideoLoRaWeight = z.object({
  path: z.string().register(z.globalRegistry, {
    description: 'URL or path to the LoRA weights.',
  }),
  scale: z
    .optional(
      z.number().gte(0).lte(4).register(z.globalRegistry, {
        description:
          'Scale of the LoRA weight. This is a multiplier applied to the LoRA weight when loading it.',
      }),
    )
    .default(1),
  weight_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Name of the LoRA weight. Only used if `path` is a HuggingFace repository, and is only required when the repository contains multiple LoRA weights.',
    }),
  ),
})

/**
 * DistilledImageToVideoInput
 *
 * Distilled model input
 */
export const zLtxv13B098DistilledImageToVideoInput = z
  .object({
    second_pass_skip_initial_steps: z
      .optional(
        z.int().gte(1).lte(11).register(z.globalRegistry, {
          description:
            'The number of inference steps to skip in the initial steps of the second pass. By skipping some steps at the beginning, the second pass can focus on smaller details instead of larger changes.',
        }),
      )
      .default(5),
    first_pass_num_inference_steps: z
      .optional(
        z.int().gte(2).lte(12).register(z.globalRegistry, {
          description: 'Number of inference steps during the first pass.',
        }),
      )
      .default(8),
    frame_rate: z
      .optional(
        z.int().gte(1).lte(60).register(z.globalRegistry, {
          description: 'The frame rate of the video.',
        }),
      )
      .default(24),
    reverse_video: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to reverse the video.',
        }),
      )
      .default(false),
    prompt: z.string().register(z.globalRegistry, {
      description: 'Text prompt to guide generation',
    }),
    expand_prompt: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to expand the prompt using a language model.',
        }),
      )
      .default(false),
    temporal_adain_factor: z
      .optional(
        z.number().gte(0).lte(1).register(z.globalRegistry, {
          description:
            'The factor for adaptive instance normalization (AdaIN) applied to generated video chunks after the first. This can help deal with a gradual increase in saturation/contrast in the generated video by normalizing the color distribution across the video. A high value will ensure the color distribution is more consistent across the video, while a low value will allow for more variation in color distribution.',
        }),
      )
      .default(0.5),
    loras: z
      .optional(
        z
          .array(zFalAiLtxv13B098DistilledImageToVideoLoRaWeight)
          .register(z.globalRegistry, {
            description: 'LoRA weights to use for generation',
          }),
      )
      .default([]),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to enable the safety checker.',
        }),
      )
      .default(true),
    num_frames: z
      .optional(
        z.int().gte(9).lte(1441).register(z.globalRegistry, {
          description: 'The number of frames in the video.',
        }),
      )
      .default(121),
    second_pass_num_inference_steps: z
      .optional(
        z.int().gte(2).lte(12).register(z.globalRegistry, {
          description: 'Number of inference steps during the second pass.',
        }),
      )
      .default(8),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'Negative prompt for generation',
        }),
      )
      .default(
        'worst quality, inconsistent motion, blurry, jittery, distorted',
      ),
    enable_detail_pass: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to use a detail pass. If True, the model will perform a second pass to refine the video and enhance details. This incurs a 2.0x cost multiplier on the base price.',
        }),
      )
      .default(false),
    resolution: z.optional(
      z.enum(['480p', '720p']).register(z.globalRegistry, {
        description: 'Resolution of the generated video.',
      }),
    ),
    aspect_ratio: z.optional(
      z.enum(['9:16', '1:1', '16:9', 'auto']).register(z.globalRegistry, {
        description: 'The aspect ratio of the video.',
      }),
    ),
    tone_map_compression_ratio: z
      .optional(
        z.number().gte(0).lte(1).register(z.globalRegistry, {
          description:
            'The compression ratio for tone mapping. This is used to compress the dynamic range of the video to improve visual quality. A value of 0.0 means no compression, while a value of 1.0 means maximum compression.',
        }),
      )
      .default(0),
    image_url: z.string().register(z.globalRegistry, {
      description: 'Image URL for Image-to-Video task',
    }),
    constant_rate_factor: z
      .optional(
        z.int().gte(0).lte(51).register(z.globalRegistry, {
          description:
            "The constant rate factor (CRF) to compress input media with. Compressed input media more closely matches the model's training data, which can improve motion quality.",
        }),
      )
      .default(29),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'Random seed for generation',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Distilled model input',
  })

/**
 * File
 */
export const zFalAiLtxv13B098DistilledImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToVideoOutput
 */
export const zLtxv13B098DistilledImageToVideoOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiLtxv13B098DistilledImageToVideoFile,
})

/**
 * Veo3ImageToVideoInput
 */
export const zVeo3FastImageToVideoInput = z.object({
  prompt: z.string().max(20000).register(z.globalRegistry, {
    description: 'The text prompt describing how the image should be animated',
  }),
  resolution: z.optional(
    z.enum(['720p', '1080p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video.',
    }),
  ),
  aspect_ratio: z.optional(
    z.enum(['auto', '16:9', '9:16']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated video.',
    }),
  ),
  generate_audio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to generate audio for the video.',
      }),
    )
    .default(true),
  auto_fix: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to automatically attempt to fix prompts that fail content policy or other validation checks by rewriting them.',
      }),
    )
    .default(false),
  duration: z.optional(
    z.enum(['4s', '6s', '8s']).register(z.globalRegistry, {
      description: 'The duration of the generated video.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the input image to animate. Should be 720p or higher resolution in 16:9 or 9:16 aspect ratio. If the image is not in 16:9 or 9:16 aspect ratio, it will be cropped to fit.',
  }),
})

/**
 * File
 */
export const zFalAiVeo3FastImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Veo3ImageToVideoOutput
 */
export const zVeo3FastImageToVideoOutput = z.object({
  video: zFalAiVeo3FastImageToVideoFile,
})

/**
 * Q1ReferenceToVideoRequest
 */
export const zViduQ1ReferenceToVideoInput = z.object({
  prompt: z.string().max(1500).register(z.globalRegistry, {
    description: 'Text prompt for video generation, max 1500 characters',
  }),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description: 'The aspect ratio of the output video',
    }),
  ),
  bgm: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to add background music to the generated video',
      }),
    )
    .default(false),
  reference_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'URLs of the reference images to use for consistent subject appearance. Q1 model supports up to 7 reference images.',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for generation',
    }),
  ),
  movement_amplitude: z.optional(
    z.enum(['auto', 'small', 'medium', 'large']).register(z.globalRegistry, {
      description: 'The movement amplitude of objects in the frame',
    }),
  ),
})

/**
 * File
 */
export const zFalAiViduQ1ReferenceToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Q1ReferenceToVideoOutput
 */
export const zViduQ1ReferenceToVideoOutput = z.object({
  video: zFalAiViduQ1ReferenceToVideoFile,
})

/**
 * AvatarSingleTextRequest
 */
export const zAiAvatarSingleTextInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide video generation.',
  }),
  resolution: z.optional(
    z.enum(['480p', '720p']).register(z.globalRegistry, {
      description:
        'Resolution of the video to generate. Must be either 480p or 720p.',
    }),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use for generation.',
    }),
  ),
  text_input: z.string().register(z.globalRegistry, {
    description: 'The text input to guide video generation.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the input image. If the input image does not match the chosen aspect ratio, it is resized and center cropped.',
  }),
  voice: z
    .enum([
      'Aria',
      'Roger',
      'Sarah',
      'Laura',
      'Charlie',
      'George',
      'Callum',
      'River',
      'Liam',
      'Charlotte',
      'Alice',
      'Matilda',
      'Will',
      'Jessica',
      'Eric',
      'Chris',
      'Brian',
      'Daniel',
      'Lily',
      'Bill',
    ])
    .register(z.globalRegistry, {
      description: 'The voice to use for speech generation',
    }),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description:
          'Random seed for reproducibility. If None, a random seed is chosen.',
      }),
    )
    .default(42),
  num_frames: z
    .optional(
      z.int().gte(41).lte(241).register(z.globalRegistry, {
        description:
          'Number of frames to generate. Must be between 81 to 129 (inclusive). If the number of frames is greater than 81, the video will be generated with 1.25x more billing units.',
      }),
    )
    .default(136),
})

/**
 * File
 */
export const zFalAiAiAvatarSingleTextFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * AvatarSingleTextResponse
 */
export const zAiAvatarSingleTextOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiAiAvatarSingleTextFile,
})

/**
 * AvatarSingleAudioRequest
 */
export const zAiAvatarInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide video generation.',
  }),
  resolution: z.optional(
    z.enum(['480p', '720p']).register(z.globalRegistry, {
      description:
        'Resolution of the video to generate. Must be either 480p or 720p.',
    }),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use for generation.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the input image. If the input image does not match the chosen aspect ratio, it is resized and center cropped.',
  }),
  audio_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the audio file.',
  }),
  num_frames: z
    .optional(
      z.int().gte(41).lte(241).register(z.globalRegistry, {
        description:
          'Number of frames to generate. Must be between 81 to 129 (inclusive). If the number of frames is greater than 81, the video will be generated with 1.25x more billing units.',
      }),
    )
    .default(145),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description:
          'Random seed for reproducibility. If None, a random seed is chosen.',
      }),
    )
    .default(42),
})

/**
 * File
 */
export const zFalAiAiAvatarFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * AvatarSingleAudioResponse
 */
export const zAiAvatarOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiAiAvatarFile,
})

/**
 * AvatarMultiTextRequest
 */
export const zAiAvatarMultiTextInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide video generation.',
  }),
  second_text_input: z.string().register(z.globalRegistry, {
    description: 'The text input to guide video generation.',
  }),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use for generation.',
    }),
  ),
  resolution: z.optional(
    z.enum(['480p', '720p']).register(z.globalRegistry, {
      description:
        'Resolution of the video to generate. Must be either 480p or 720p.',
    }),
  ),
  first_text_input: z.string().register(z.globalRegistry, {
    description: 'The text input to guide video generation.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the input image. If the input image does not match the chosen aspect ratio, it is resized and center cropped.',
  }),
  voice2: z.optional(
    z
      .enum([
        'Aria',
        'Roger',
        'Sarah',
        'Laura',
        'Charlie',
        'George',
        'Callum',
        'River',
        'Liam',
        'Charlotte',
        'Alice',
        'Matilda',
        'Will',
        'Jessica',
        'Eric',
        'Chris',
        'Brian',
        'Daniel',
        'Lily',
        'Bill',
      ])
      .register(z.globalRegistry, {
        description: "The second person's voice to use for speech generation",
      }),
  ),
  voice1: z.optional(
    z
      .enum([
        'Aria',
        'Roger',
        'Sarah',
        'Laura',
        'Charlie',
        'George',
        'Callum',
        'River',
        'Liam',
        'Charlotte',
        'Alice',
        'Matilda',
        'Will',
        'Jessica',
        'Eric',
        'Chris',
        'Brian',
        'Daniel',
        'Lily',
        'Bill',
      ])
      .register(z.globalRegistry, {
        description: "The first person's voice to use for speech generation",
      }),
  ),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description:
          'Random seed for reproducibility. If None, a random seed is chosen.',
      }),
    )
    .default(81),
  num_frames: z
    .optional(
      z.int().gte(41).lte(241).register(z.globalRegistry, {
        description:
          'Number of frames to generate. Must be between 81 to 129 (inclusive). If the number of frames is greater than 81, the video will be generated with 1.25x more billing units.',
      }),
    )
    .default(191),
})

/**
 * File
 */
export const zFalAiAiAvatarMultiTextFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * AvatarMultiTextResponse
 */
export const zAiAvatarMultiTextOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiAiAvatarMultiTextFile,
})

/**
 * AvatarMultiAudioPersonRequest
 */
export const zAiAvatarMultiInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide video generation.',
  }),
  resolution: z.optional(
    z.enum(['480p', '720p']).register(z.globalRegistry, {
      description:
        'Resolution of the video to generate. Must be either 480p or 720p.',
    }),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use for generation.',
    }),
  ),
  first_audio_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the Person 1 audio file.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the input image. If the input image does not match the chosen aspect ratio, it is resized and center cropped.',
  }),
  second_audio_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL of the Person 2 audio file.',
    }),
  ),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description:
          'Random seed for reproducibility. If None, a random seed is chosen.',
      }),
    )
    .default(81),
  use_only_first_audio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to use only the first audio file.',
      }),
    )
    .default(false),
  num_frames: z
    .optional(
      z.int().gte(41).lte(241).register(z.globalRegistry, {
        description:
          'Number of frames to generate. Must be between 81 to 129 (inclusive). If the number of frames is greater than 81, the video will be generated with 1.25x more billing units.',
      }),
    )
    .default(181),
})

/**
 * File
 */
export const zFalAiAiAvatarMultiFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * AvatarMultiAudioResponse
 */
export const zAiAvatarMultiOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiAiAvatarMultiFile,
})

/**
 * ProImageToVideoHailuo02Input
 */
export const zMinimaxHailuo02ProImageToVideoInput = z.object({
  prompt_optimizer: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the model's prompt optimizer",
      }),
    )
    .default(true),
  prompt: z.string().max(2000),
  end_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Optional URL of the image to use as the last frame of the video',
    }),
  ),
  image_url: z.string(),
})

/**
 * File
 */
export const zFalAiMinimaxHailuo02ProImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToVideoHailuo02Output
 */
export const zMinimaxHailuo02ProImageToVideoOutput = z.object({
  video: zFalAiMinimaxHailuo02ProImageToVideoFile,
})

/**
 * SeedanceImageToVideoInput
 */
export const zBytedanceSeedanceV1LiteImageToVideoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt used to generate the video',
  }),
  resolution: z.optional(
    z.enum(['480p', '720p', '1080p']).register(z.globalRegistry, {
      description:
        'Video resolution - 480p for faster generation, 720p for higher quality',
    }),
  ),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '1:1', '3:4', '9:16', 'auto'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated video',
      }),
  ),
  duration: z.optional(
    z
      .enum(['2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'])
      .register(z.globalRegistry, {
        description: 'Duration of the video in seconds',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image used to generate video',
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  camera_fixed: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to fix the camera position',
      }),
    )
    .default(false),
  end_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The URL of the image the video ends with. Defaults to None.',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed to control video generation. Use -1 for random.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiBytedanceSeedanceV1LiteImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * SeedanceVideoOutput
 */
export const zBytedanceSeedanceV1LiteImageToVideoOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation',
  }),
  video: zFalAiBytedanceSeedanceV1LiteImageToVideoFile,
})

/**
 * Input
 */
export const zHunyuanAvatarInput = z.object({
  text: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Text prompt describing the scene.',
      }),
    )
    .default('A cat is singing.'),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the reference image.',
  }),
  turbo_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If true, the video will be generated faster with no noticeable degradation in the visual quality.',
      }),
    )
    .default(true),
  audio_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the audio file.',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for generation.',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(30).lte(50).register(z.globalRegistry, {
        description:
          'Number of inference steps for sampling. Higher values give better quality but take longer.',
      }),
    )
    .default(30),
  num_frames: z
    .optional(
      z.int().gte(129).lte(401).register(z.globalRegistry, {
        description:
          'Number of video frames to generate at 25 FPS. If greater than the input audio length, it will capped to the length of the input audio.',
      }),
    )
    .default(129),
})

/**
 * File
 */
export const zFalAiHunyuanAvatarFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Output
 */
export const zHunyuanAvatarOutput = z.object({
  video: zFalAiHunyuanAvatarFile,
})

/**
 * ImageToVideoV21ProRequest
 */
export const zKlingVideoV21ProImageToVideoInput = z.object({
  prompt: z.string().max(2500),
  duration: z.optional(
    z.enum(['5', '10']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  cfg_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt.\n        ',
      }),
    )
    .default(0.5),
  negative_prompt: z
    .optional(z.string().max(2500))
    .default('blur, distort, and low quality'),
  tail_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of the image to be used for the end of the video',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be used for the video',
  }),
})

/**
 * File
 */
export const zFalAiKlingVideoV21ProImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToVideoV21ProOutput
 */
export const zKlingVideoV21ProImageToVideoOutput = z.object({
  video: zFalAiKlingVideoV21ProImageToVideoFile,
})

/**
 * Input
 */
export const zHunyuanPortraitInput = z.object({
  video_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the driving video.',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for generation. If None, a random seed will be used.',
    }),
  ),
  use_arcface: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to use ArcFace for face recognition.',
      }),
    )
    .default(true),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the source image.',
  }),
})

/**
 * File
 */
export const zFalAiHunyuanPortraitFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Output
 */
export const zHunyuanPortraitOutput = z.object({
  video: zFalAiHunyuanPortraitFile,
})

/**
 * MultiImageToVideoRequest
 */
export const zKlingVideoV16StandardElementsInput = z.object({
  prompt: z.string().max(2500),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated video frame',
    }),
  ),
  duration: z.optional(
    z.enum(['5', '10']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  input_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'List of image URLs to use for video generation. Supports up to 4 images.',
  }),
  negative_prompt: z
    .optional(z.string().max(2500))
    .default('blur, distort, and low quality'),
})

/**
 * File
 */
export const zFalAiKlingVideoV16StandardElementsFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ElementsOutput
 */
export const zKlingVideoV16StandardElementsOutput = z.object({
  video: zFalAiKlingVideoV16StandardElementsFile,
})

/**
 * MultiImageToVideoRequest
 */
export const zKlingVideoV16ProElementsInput = z.object({
  prompt: z.string().max(2500),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated video frame',
    }),
  ),
  duration: z.optional(
    z.enum(['5', '10']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  input_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'List of image URLs to use for video generation. Supports up to 4 images.',
  }),
  negative_prompt: z
    .optional(z.string().max(2500))
    .default('blur, distort, and low quality'),
})

/**
 * File
 */
export const zFalAiKlingVideoV16ProElementsFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ElementsOutput
 */
export const zKlingVideoV16ProElementsOutput = z.object({
  video: zFalAiKlingVideoV16ProElementsFile,
})

/**
 * LoRAWeight
 */
export const zFalAiLtxVideo13bDistilledImageToVideoLoRaWeight = z.object({
  path: z.string().register(z.globalRegistry, {
    description: 'URL or path to the LoRA weights.',
  }),
  scale: z
    .optional(
      z.number().gte(0).lte(4).register(z.globalRegistry, {
        description:
          'Scale of the LoRA weight. This is a multiplier applied to the LoRA weight when loading it.',
      }),
    )
    .default(1),
  weight_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Name of the LoRA weight. Only used if `path` is a HuggingFace repository, and is only required when the repository contains multiple LoRA weights.',
    }),
  ),
})

/**
 * DistilledImageToVideoInput
 *
 * Distilled model input
 */
export const zLtxVideo13bDistilledImageToVideoInput = z
  .object({
    second_pass_skip_initial_steps: z
      .optional(
        z.int().gte(1).lte(20).register(z.globalRegistry, {
          description:
            'The number of inference steps to skip in the initial steps of the second pass. By skipping some steps at the beginning, the second pass can focus on smaller details instead of larger changes.',
        }),
      )
      .default(5),
    first_pass_num_inference_steps: z
      .optional(
        z.int().gte(2).lte(20).register(z.globalRegistry, {
          description: 'Number of inference steps during the first pass.',
        }),
      )
      .default(8),
    frame_rate: z
      .optional(
        z.int().gte(1).lte(60).register(z.globalRegistry, {
          description: 'The frame rate of the video.',
        }),
      )
      .default(30),
    reverse_video: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to reverse the video.',
        }),
      )
      .default(false),
    prompt: z.string().register(z.globalRegistry, {
      description: 'Text prompt to guide generation',
    }),
    expand_prompt: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to expand the prompt using a language model.',
        }),
      )
      .default(false),
    loras: z
      .optional(
        z
          .array(zFalAiLtxVideo13bDistilledImageToVideoLoRaWeight)
          .register(z.globalRegistry, {
            description: 'LoRA weights to use for generation',
          }),
      )
      .default([]),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to enable the safety checker.',
        }),
      )
      .default(true),
    num_frames: z
      .optional(
        z.int().gte(9).lte(161).register(z.globalRegistry, {
          description: 'The number of frames in the video.',
        }),
      )
      .default(121),
    second_pass_num_inference_steps: z
      .optional(
        z.int().gte(2).lte(20).register(z.globalRegistry, {
          description: 'Number of inference steps during the second pass.',
        }),
      )
      .default(8),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'Negative prompt for generation',
        }),
      )
      .default(
        'worst quality, inconsistent motion, blurry, jittery, distorted',
      ),
    resolution: z.optional(
      z.enum(['480p', '720p']).register(z.globalRegistry, {
        description: 'Resolution of the generated video (480p or 720p).',
      }),
    ),
    aspect_ratio: z.optional(
      z.enum(['9:16', '1:1', '16:9', 'auto']).register(z.globalRegistry, {
        description: 'The aspect ratio of the video.',
      }),
    ),
    image_url: z.string().register(z.globalRegistry, {
      description: 'Image URL for Image-to-Video task',
    }),
    constant_rate_factor: z
      .optional(
        z.int().gte(20).lte(60).register(z.globalRegistry, {
          description:
            "The constant rate factor (CRF) to compress input media with. Compressed input media more closely matches the model's training data, which can improve motion quality.",
        }),
      )
      .default(35),
    first_pass_skip_final_steps: z
      .optional(
        z.int().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'Number of inference steps to skip in the final steps of the first pass. By skipping some steps at the end, the first pass can focus on larger changes instead of smaller details.',
        }),
      )
      .default(1),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'Random seed for generation',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Distilled model input',
  })

/**
 * File
 */
export const zFalAiLtxVideo13bDistilledImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToVideoOutput
 */
export const zLtxVideo13bDistilledImageToVideoOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiLtxVideo13bDistilledImageToVideoFile,
})

/**
 * LoRAWeight
 */
export const zFalAiLtxVideo13bDevImageToVideoLoRaWeight = z.object({
  path: z.string().register(z.globalRegistry, {
    description: 'URL or path to the LoRA weights.',
  }),
  scale: z
    .optional(
      z.number().gte(0).lte(4).register(z.globalRegistry, {
        description:
          'Scale of the LoRA weight. This is a multiplier applied to the LoRA weight when loading it.',
      }),
    )
    .default(1),
  weight_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Name of the LoRA weight. Only used if `path` is a HuggingFace repository, and is only required when the repository contains multiple LoRA weights.',
    }),
  ),
})

/**
 * ImageToVideoInput
 */
export const zLtxVideo13bDevImageToVideoInput = z.object({
  second_pass_skip_initial_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description:
          'The number of inference steps to skip in the initial steps of the second pass. By skipping some steps at the beginning, the second pass can focus on smaller details instead of larger changes.',
      }),
    )
    .default(17),
  first_pass_num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps during the first pass.',
      }),
    )
    .default(30),
  frame_rate: z
    .optional(
      z.int().gte(1).lte(60).register(z.globalRegistry, {
        description: 'The frame rate of the video.',
      }),
    )
    .default(30),
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text prompt to guide generation',
  }),
  reverse_video: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to reverse the video.',
      }),
    )
    .default(false),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to expand the prompt using a language model.',
      }),
    )
    .default(false),
  loras: z
    .optional(
      z
        .array(zFalAiLtxVideo13bDevImageToVideoLoRaWeight)
        .register(z.globalRegistry, {
          description: 'LoRA weights to use for generation',
        }),
    )
    .default([]),
  second_pass_num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps during the second pass.',
      }),
    )
    .default(30),
  num_frames: z
    .optional(
      z.int().gte(9).lte(161).register(z.globalRegistry, {
        description: 'The number of frames in the video.',
      }),
    )
    .default(121),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable the safety checker.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for generation',
      }),
    )
    .default('worst quality, inconsistent motion, blurry, jittery, distorted'),
  resolution: z.optional(
    z.enum(['480p', '720p']).register(z.globalRegistry, {
      description: 'Resolution of the generated video (480p or 720p).',
    }),
  ),
  aspect_ratio: z.optional(
    z.enum(['9:16', '1:1', '16:9', 'auto']).register(z.globalRegistry, {
      description: 'The aspect ratio of the video.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image URL for Image-to-Video task',
  }),
  constant_rate_factor: z
    .optional(
      z.int().gte(20).lte(60).register(z.globalRegistry, {
        description:
          "The constant rate factor (CRF) to compress input media with. Compressed input media more closely matches the model's training data, which can improve motion quality.",
      }),
    )
    .default(35),
  first_pass_skip_final_steps: z
    .optional(
      z.int().gte(0).lte(50).register(z.globalRegistry, {
        description:
          'Number of inference steps to skip in the final steps of the first pass. By skipping some steps at the end, the first pass can focus on larger changes instead of smaller details.',
      }),
    )
    .default(3),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for generation',
    }),
  ),
})

/**
 * File
 */
export const zFalAiLtxVideo13bDevImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToVideoOutput
 */
export const zLtxVideo13bDevImageToVideoOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiLtxVideo13bDevImageToVideoFile,
})

/**
 * LoRAWeight
 *
 * LoRA weight to use for generation.
 */
export const zFalAiLtxVideoLoraImageToVideoLoRaWeight = z
  .object({
    path: z.string().register(z.globalRegistry, {
      description: 'URL or path to the LoRA weights.',
    }),
    scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'Scale of the LoRA weight. This is a multiplier applied to the LoRA weight when loading it.',
        }),
      )
      .default(1),
    weight_name: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'Name of the LoRA weight. Only used if `path` is a HuggingFace repository, and is only required when the repository contains multiple LoRA weights.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'LoRA weight to use for generation.',
  })

/**
 * ImageToVideoInput
 *
 * Request model for image-to-video generation.
 */
export const zLtxVideoLoraImageToVideoInput = z
  .object({
    number_of_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to use.',
        }),
      )
      .default(30),
    resolution: z.optional(
      z.enum(['480p', '720p']).register(z.globalRegistry, {
        description: 'The resolution of the video.',
      }),
    ),
    reverse_video: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to reverse the video.',
        }),
      )
      .default(false),
    aspect_ratio: z.optional(
      z.enum(['16:9', '1:1', '9:16', 'auto']).register(z.globalRegistry, {
        description: 'The aspect ratio of the video.',
      }),
    ),
    frame_rate: z
      .optional(
        z.int().gte(1).lte(60).register(z.globalRegistry, {
          description: 'The frame rate of the video.',
        }),
      )
      .default(25),
    expand_prompt: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to expand the prompt using the LLM.',
        }),
      )
      .default(false),
    number_of_frames: z
      .optional(
        z.int().gte(9).lte(161).register(z.globalRegistry, {
          description: 'The number of frames in the video.',
        }),
      )
      .default(89),
    image_url: z.string().register(z.globalRegistry, {
      description: 'The URL of the image to use as input.',
    }),
    loras: z
      .optional(
        z
          .array(zFalAiLtxVideoLoraImageToVideoLoRaWeight)
          .register(z.globalRegistry, {
            description: 'The LoRA weights to use for generation.',
          }),
      )
      .default([]),
    prompt: z.string().register(z.globalRegistry, {
      description: 'The prompt to generate the video from.',
    }),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to enable the safety checker.',
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The seed to use for generation.',
      }),
    ),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt to use.',
        }),
      )
      .default(
        'blurry, low quality, low resolution, inconsistent motion, jittery, distorted',
      ),
  })
  .register(z.globalRegistry, {
    description: 'Request model for image-to-video generation.',
  })

/**
 * File
 */
export const zFalAiLtxVideoLoraImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToVideoOutput
 */
export const zLtxVideoLoraImageToVideoOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiLtxVideoLoraImageToVideoFile,
})

/**
 * TransitionRequest
 */
export const zPixverseV45TransitionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt for the transition',
  }),
  aspect_ratio: z.optional(
    z.enum(['16:9', '4:3', '1:1', '3:4', '9:16']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated video',
    }),
  ),
  duration: z.optional(
    z.enum(['5', '8']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  style: z.optional(
    z
      .enum(['anime', '3d_animation', 'clay', 'comic', 'cyberpunk'])
      .register(z.globalRegistry, {
        description: 'The style of the generated video',
      }),
  ),
  first_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
  resolution: z.optional(
    z.enum(['360p', '540p', '720p', '1080p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same video every time.\n        ',
    }),
  ),
  end_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of the image to use as the last frame',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to be used for the generation',
      }),
    )
    .default(''),
})

/**
 * File
 */
export const zFalAiPixverseV45TransitionFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * TransitionOutput
 */
export const zPixverseV45TransitionOutput = z.object({
  video: zFalAiPixverseV45TransitionFile,
})

/**
 * FastImageToVideoRequestV4
 */
export const zPixverseV45ImageToVideoFastInput = z.object({
  prompt: z.string(),
  resolution: z.optional(
    z.enum(['360p', '540p', '720p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video',
    }),
  ),
  style: z.optional(
    z
      .enum(['anime', '3d_animation', 'clay', 'comic', 'cyberpunk'])
      .register(z.globalRegistry, {
        description: 'The style of the generated video',
      }),
  ),
  camera_movement: z.optional(
    z
      .enum([
        'horizontal_left',
        'horizontal_right',
        'vertical_up',
        'vertical_down',
        'zoom_in',
        'zoom_out',
        'crane_up',
        'quickly_zoom_in',
        'quickly_zoom_out',
        'smooth_zoom_in',
        'camera_rotation',
        'robo_arm',
        'super_dolly_out',
        'whip_pan',
        'hitchcock',
        'left_follow',
        'right_follow',
        'pan_left',
        'pan_right',
        'fix_bg',
      ])
      .register(z.globalRegistry, {
        description: 'The type of camera movement to apply to the video',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same video every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to be used for the generation',
      }),
    )
    .default(''),
})

/**
 * File
 */
export const zFalAiPixverseV45ImageToVideoFastFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * I2VOutputV4
 */
export const zPixverseV45ImageToVideoFastOutput = z.object({
  video: zFalAiPixverseV45ImageToVideoFastFile,
})

/**
 * ImageToVideoRequestV4
 */
export const zPixverseV45ImageToVideoInput = z.object({
  prompt: z.string(),
  duration: z.optional(
    z.enum(['5', '8']).register(z.globalRegistry, {
      description:
        'The duration of the generated video in seconds. 8s videos cost double. 1080p videos are limited to 5 seconds',
    }),
  ),
  resolution: z.optional(
    z.enum(['360p', '540p', '720p', '1080p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video',
    }),
  ),
  style: z.optional(
    z
      .enum(['anime', '3d_animation', 'clay', 'comic', 'cyberpunk'])
      .register(z.globalRegistry, {
        description: 'The style of the generated video',
      }),
  ),
  camera_movement: z.optional(
    z
      .enum([
        'horizontal_left',
        'horizontal_right',
        'vertical_up',
        'vertical_down',
        'zoom_in',
        'zoom_out',
        'crane_up',
        'quickly_zoom_in',
        'quickly_zoom_out',
        'smooth_zoom_in',
        'camera_rotation',
        'robo_arm',
        'super_dolly_out',
        'whip_pan',
        'hitchcock',
        'left_follow',
        'right_follow',
        'pan_left',
        'pan_right',
        'fix_bg',
      ])
      .register(z.globalRegistry, {
        description: 'The type of camera movement to apply to the video',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same video every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to be used for the generation',
      }),
    )
    .default(''),
})

/**
 * File
 */
export const zFalAiPixverseV45ImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * I2VOutputV4
 */
export const zPixverseV45ImageToVideoOutput = z.object({
  video: zFalAiPixverseV45ImageToVideoFile,
})

/**
 * EffectInput
 */
export const zPixverseV45EffectsInput = z.object({
  effect: z
    .enum([
      'Kiss Me AI',
      'Kiss',
      'Muscle Surge',
      'Warmth of Jesus',
      'Anything, Robot',
      'The Tiger Touch',
      'Hug',
      'Holy Wings',
      'Microwave',
      'Zombie Mode',
      'Squid Game',
      'Baby Face',
      'Black Myth: Wukong',
      'Long Hair Magic',
      'Leggy Run',
      'Fin-tastic Mermaid',
      'Punch Face',
      'Creepy Devil Smile',
      'Thunder God',
      'Eye Zoom Challenge',
      "Who's Arrested?",
      'Baby Arrived',
      'Werewolf Rage',
      'Bald Swipe',
      'BOOM DROP',
      'Huge Cutie',
      'Liquid Metal',
      'Sharksnap!',
      'Dust Me Away',
      '3D Figurine Factor',
      'Bikini Up',
      'My Girlfriends',
      'My Boyfriends',
      'Subject 3 Fever',
      'Earth Zoom',
      'Pole Dance',
      'Vroom Dance',
      'GhostFace Terror',
      'Dragon Evoker',
      'Skeletal Bae',
      'Summoning succubus',
      'Halloween Voodoo Doll',
      '3D Naked-Eye AD',
      'Package Explosion',
      'Dishes Served',
      'Ocean ad',
      'Supermarket AD',
      'Tree doll',
      'Come Feel My Abs',
      'The Bicep Flex',
      'London Elite Vibe',
      'Flora Nymph Gown',
      'Christmas Costume',
      "It's Snowy",
      'Reindeer Cruiser',
      'Snow Globe Maker',
      'Pet Christmas Outfit',
      'Adopt a Polar Pal',
      'Cat Christmas Box',
      'Starlight Gift Box',
      'Xmas Poster',
      'Pet Christmas Tree',
      'City Santa Hat',
      'Stocking Sweetie',
      'Christmas Night',
      'Xmas Front Page Karma',
      "Grinch's Xmas Hijack",
    ])
    .register(z.globalRegistry, {
      description: 'The effect to apply to the video',
    }),
  duration: z.optional(
    z.enum(['5', '8']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  resolution: z.optional(
    z.enum(['360p', '540p', '720p', '1080p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video.',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to be used for the generation',
      }),
    )
    .default(''),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'Optional URL of the image to use as the first frame. If not provided, generates from text',
  }),
})

/**
 * File
 */
export const zFalAiPixverseV45EffectsFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * EffectOutput
 */
export const zPixverseV45EffectsOutput = z.object({
  video: zFalAiPixverseV45EffectsFile,
})

/**
 * HunyuanCustomRequest
 */
export const zHunyuanCustomInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text prompt for video generation (max 500 characters).',
  }),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16']).register(z.globalRegistry, {
      description: 'The aspect ratio of the video to generate.',
    }),
  ),
  resolution: z.optional(
    z.enum(['512p', '720p']).register(z.globalRegistry, {
      description:
        'The resolution of the video to generate. 720p generations cost 1.5x more than 480p generations.',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_frames: z
    .optional(
      z.int().gte(81).lte(129).register(z.globalRegistry, {
        description: 'The number of frames to generate.',
      }),
    )
    .default(129),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image input.',
  }),
  fps: z
    .optional(
      z.int().gte(16).lte(30).register(z.globalRegistry, {
        description: 'The frames per second of the generated video.',
      }),
    )
    .default(25),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable prompt expansion.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed to use for generating the video.',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(30).register(z.globalRegistry, {
        description:
          'The number of inference steps to run. Lower gets faster results, higher gets better results.',
      }),
    )
    .default(30),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for video generation.',
      }),
    )
    .default(
      'Aerial view, aerial view, overexposed, low quality, deformation, a poor composition, bad hands, bad teeth, bad eyes, bad limbs, distortion, blurring, text, subtitles, static, picture, black border.',
    ),
  cfg_scale: z
    .optional(
      z.number().gte(1.5).lte(13).register(z.globalRegistry, {
        description: 'Classifier-Free Guidance scale for the generation.',
      }),
    )
    .default(7.5),
})

/**
 * File
 */
export const zFalAiHunyuanCustomFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * HunyuanCustomResponse
 */
export const zHunyuanCustomOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generating the video.',
  }),
  video: zFalAiHunyuanCustomFile,
})

/**
 * FramePackF1Request
 */
export const zFramepackF1Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text prompt for video generation (max 500 characters).',
  }),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16']).register(z.globalRegistry, {
      description: 'The aspect ratio of the video to generate.',
    }),
  ),
  resolution: z.optional(
    z.enum(['720p', '480p']).register(z.globalRegistry, {
      description:
        'The resolution of the video to generate. 720p generations cost 1.5x more than 480p generations.',
    }),
  ),
  num_frames: z
    .optional(
      z.int().gte(30).lte(900).register(z.globalRegistry, {
        description: 'The number of frames to generate.',
      }),
    )
    .default(180),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image input.',
  }),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(32).register(z.globalRegistry, {
        description: 'Guidance scale for the generation.',
      }),
    )
    .default(10),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for video generation.',
      }),
    )
    .default(''),
  cfg_scale: z
    .optional(
      z.number().gte(0).lte(7).register(z.globalRegistry, {
        description: 'Classifier-Free Guidance scale for the generation.',
      }),
    )
    .default(1),
})

/**
 * File
 */
export const zFalAiFramepackF1File = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * FramePackF1Response
 */
export const zFramepackF1Output = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generating the video.',
  }),
  video: zFalAiFramepackF1File,
})

/**
 * Q1StartEndToVideoRequest
 */
export const zViduQ1StartEndToVideoInput = z.object({
  prompt: z.string().max(1500).register(z.globalRegistry, {
    description: 'Text prompt for video generation, max 1500 characters',
  }),
  start_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
  movement_amplitude: z.optional(
    z.enum(['auto', 'small', 'medium', 'large']).register(z.globalRegistry, {
      description: 'The movement amplitude of objects in the frame',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Seed for the random number generator',
    }),
  ),
  end_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the last frame',
  }),
})

/**
 * File
 */
export const zFalAiViduQ1StartEndToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Q1StartEndToVideoOutput
 */
export const zViduQ1StartEndToVideoOutput = z.object({
  video: zFalAiViduQ1StartEndToVideoFile,
})

/**
 * Q1ImageToVideoRequest
 */
export const zViduQ1ImageToVideoInput = z.object({
  prompt: z.string().max(1500).register(z.globalRegistry, {
    description: 'Text prompt for video generation, max 1500 characters',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Seed for the random number generator',
    }),
  ),
  movement_amplitude: z.optional(
    z.enum(['auto', 'small', 'medium', 'large']).register(z.globalRegistry, {
      description: 'The movement amplitude of objects in the frame',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
})

/**
 * File
 */
export const zFalAiViduQ1ImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Q1ImageToVideoOutput
 */
export const zViduQ1ImageToVideoOutput = z.object({
  video: zFalAiViduQ1ImageToVideoFile,
})

/**
 * MagiImageToVideoRequest
 */
export const zMagiImageToVideoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide video generation.',
  }),
  resolution: z.optional(
    z.enum(['480p', '720p']).register(z.globalRegistry, {
      description:
        'Resolution of the generated video (480p or 720p). 480p is 0.5 billing units, and 720p is 1 billing unit.',
    }),
  ),
  aspect_ratio: z.optional(
    z.enum(['auto', '16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description:
        "Aspect ratio of the generated video. If 'auto', the aspect ratio will be determined automatically based on the input image.",
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the input image to represent the first frame of the video. If the input image does not match the chosen aspect ratio, it is resized and center cropped.',
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z.optional(
    z
      .union([
        z.literal(4),
        z.literal(8),
        z.literal(16),
        z.literal(32),
        z.literal(64),
      ])
      .register(z.globalRegistry, {
        description:
          'Number of inference steps for sampling. Higher values give better quality but take longer.',
      }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If None, a random seed is chosen.',
    }),
  ),
  num_frames: z
    .optional(
      z.int().gte(96).lte(192).register(z.globalRegistry, {
        description:
          'Number of frames to generate. Must be between 96 and 192 (inclusive). Each additional 24 frames beyond 96 incurs an additional billing unit.',
      }),
    )
    .default(96),
})

/**
 * File
 */
export const zFalAiMagiImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * MagiImageToVideoResponse
 */
export const zMagiImageToVideoOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiMagiImageToVideoFile,
})

/**
 * EffectInput
 */
export const zPixverseV4EffectsInput = z.object({
  effect: z
    .enum([
      'Kiss Me AI',
      'Kiss',
      'Muscle Surge',
      'Warmth of Jesus',
      'Anything, Robot',
      'The Tiger Touch',
      'Hug',
      'Holy Wings',
      'Microwave',
      'Zombie Mode',
      'Squid Game',
      'Baby Face',
      'Black Myth: Wukong',
      'Long Hair Magic',
      'Leggy Run',
      'Fin-tastic Mermaid',
      'Punch Face',
      'Creepy Devil Smile',
      'Thunder God',
      'Eye Zoom Challenge',
      "Who's Arrested?",
      'Baby Arrived',
      'Werewolf Rage',
      'Bald Swipe',
      'BOOM DROP',
      'Huge Cutie',
      'Liquid Metal',
      'Sharksnap!',
      'Dust Me Away',
      '3D Figurine Factor',
      'Bikini Up',
      'My Girlfriends',
      'My Boyfriends',
      'Subject 3 Fever',
      'Earth Zoom',
      'Pole Dance',
      'Vroom Dance',
      'GhostFace Terror',
      'Dragon Evoker',
      'Skeletal Bae',
      'Summoning succubus',
      'Halloween Voodoo Doll',
      '3D Naked-Eye AD',
      'Package Explosion',
      'Dishes Served',
      'Ocean ad',
      'Supermarket AD',
      'Tree doll',
      'Come Feel My Abs',
      'The Bicep Flex',
      'London Elite Vibe',
      'Flora Nymph Gown',
      'Christmas Costume',
      "It's Snowy",
      'Reindeer Cruiser',
      'Snow Globe Maker',
      'Pet Christmas Outfit',
      'Adopt a Polar Pal',
      'Cat Christmas Box',
      'Starlight Gift Box',
      'Xmas Poster',
      'Pet Christmas Tree',
      'City Santa Hat',
      'Stocking Sweetie',
      'Christmas Night',
      'Xmas Front Page Karma',
      "Grinch's Xmas Hijack",
    ])
    .register(z.globalRegistry, {
      description: 'The effect to apply to the video',
    }),
  duration: z.optional(
    z.enum(['5', '8']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  resolution: z.optional(
    z.enum(['360p', '540p', '720p', '1080p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video.',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to be used for the generation',
      }),
    )
    .default(''),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'Optional URL of the image to use as the first frame. If not provided, generates from text',
  }),
})

/**
 * File
 */
export const zFalAiPixverseV4EffectsFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * EffectOutput
 */
export const zPixverseV4EffectsOutput = z.object({
  video: zFalAiPixverseV4EffectsFile,
})

/**
 * MagiImageToVideoRequest
 */
export const zMagiDistilledImageToVideoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide video generation.',
  }),
  resolution: z.optional(
    z.enum(['480p', '720p']).register(z.globalRegistry, {
      description:
        'Resolution of the generated video (480p or 720p). 480p is 0.5 billing units, and 720p is 1 billing unit.',
    }),
  ),
  aspect_ratio: z.optional(
    z.enum(['auto', '16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description:
        "Aspect ratio of the generated video. If 'auto', the aspect ratio will be determined automatically based on the input image.",
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the input image to represent the first frame of the video. If the input image does not match the chosen aspect ratio, it is resized and center cropped.',
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z.optional(
    z
      .union([z.literal(4), z.literal(8), z.literal(16), z.literal(32)])
      .register(z.globalRegistry, {
        description:
          'Number of inference steps for sampling. Higher values give better quality but take longer.',
      }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If None, a random seed is chosen.',
    }),
  ),
  num_frames: z
    .optional(
      z.int().gte(96).lte(192).register(z.globalRegistry, {
        description:
          'Number of frames to generate. Must be between 96 and 192 (inclusive). Each additional 24 frames beyond 96 incurs an additional billing unit.',
      }),
    )
    .default(96),
})

/**
 * File
 */
export const zFalAiMagiDistilledImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * MagiImageToVideoResponse
 */
export const zMagiDistilledImageToVideoOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiMagiDistilledImageToVideoFile,
})

/**
 * FramePackF2LFRequest
 */
export const zFramepackFlf2vInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text prompt for video generation (max 500 characters).',
  }),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16']).register(z.globalRegistry, {
      description: 'The aspect ratio of the video to generate.',
    }),
  ),
  resolution: z.optional(
    z.enum(['720p', '480p']).register(z.globalRegistry, {
      description:
        'The resolution of the video to generate. 720p generations cost 1.5x more than 480p generations.',
    }),
  ),
  num_frames: z
    .optional(
      z.int().gte(30).lte(1800).register(z.globalRegistry, {
        description: 'The number of frames to generate.',
      }),
    )
    .default(240),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image input.',
  }),
  strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Determines the influence of the final frame on the generated video. Higher values result in the output being more heavily influenced by the last frame.',
      }),
    )
    .default(0.8),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(32).register(z.globalRegistry, {
        description: 'Guidance scale for the generation.',
      }),
    )
    .default(10),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  end_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the end image input.',
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for video generation.',
      }),
    )
    .default(''),
  cfg_scale: z
    .optional(
      z.number().gte(0).lte(7).register(z.globalRegistry, {
        description: 'Classifier-Free Guidance scale for the generation.',
      }),
    )
    .default(1),
})

/**
 * File
 */
export const zFalAiFramepackFlf2vFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * FramePackFLF2VResponse
 */
export const zFramepackFlf2vOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generating the video.',
  }),
  video: zFalAiFramepackFlf2vFile,
})

/**
 * WanFLF2VRequest
 */
export const zWanFlf2vInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide video generation.',
  }),
  shift: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: 'Shift parameter for video generation.',
      }),
    )
    .default(5),
  acceleration: z.optional(
    z.enum(['none', 'regular']).register(z.globalRegistry, {
      description:
        "Acceleration level to use. The more acceleration, the faster the generation, but with lower quality. The recommended value is 'regular'.",
    }),
  ),
  frames_per_second: z
    .optional(
      z.int().gte(5).lte(24).register(z.globalRegistry, {
        description:
          'Frames per second of the generated video. Must be between 5 to 24.',
      }),
    )
    .default(16),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
  start_image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the starting image. If the input image does not match the chosen aspect ratio, it is resized and center cropped.',
  }),
  end_image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the ending image. If the input image does not match the chosen aspect ratio, it is resized and center cropped.',
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for video generation.',
      }),
    )
    .default(
      'bright colors, overexposed, static, blurred details, subtitles, style, artwork, painting, picture, still, overall gray, worst quality, low quality, JPEG compression residue, ugly, incomplete, extra fingers, poorly drawn hands, poorly drawn faces, deformed, disfigured, malformed limbs, fused fingers, still picture, cluttered background, three legs, many people in the background, walking backwards',
    ),
  num_frames: z
    .optional(
      z.int().gte(81).lte(100).register(z.globalRegistry, {
        description:
          'Number of frames to generate. Must be between 81 to 100 (inclusive). If the number of frames is greater than 81, the video will be generated with 1.25x more billing units.',
      }),
    )
    .default(81),
  resolution: z.optional(
    z.enum(['480p', '720p']).register(z.globalRegistry, {
      description:
        'Resolution of the generated video (480p or 720p). 480p is 0.5 billing units, and 720p is 1 billing unit.',
    }),
  ),
  aspect_ratio: z.optional(
    z.enum(['auto', '16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description:
        "Aspect ratio of the generated video. If 'auto', the aspect ratio will be determined automatically based on the input image.",
    }),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable prompt expansion.',
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If None, a random seed is chosen.',
    }),
  ),
  guide_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher values give better adherence to the prompt but may decrease quality.',
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(40).register(z.globalRegistry, {
        description:
          'Number of inference steps for sampling. Higher values give better quality but take longer.',
      }),
    )
    .default(30),
})

/**
 * File
 */
export const zFalAiWanFlf2vFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * WanFLF2VResponse
 */
export const zWanFlf2vOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiWanFlf2vFile,
})

/**
 * FramePackRequest
 */
export const zFramepackInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text prompt for video generation (max 500 characters).',
  }),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16']).register(z.globalRegistry, {
      description: 'The aspect ratio of the video to generate.',
    }),
  ),
  resolution: z.optional(
    z.enum(['720p', '480p']).register(z.globalRegistry, {
      description:
        'The resolution of the video to generate. 720p generations cost 1.5x more than 480p generations.',
    }),
  ),
  num_frames: z
    .optional(
      z.int().gte(30).lte(900).register(z.globalRegistry, {
        description: 'The number of frames to generate.',
      }),
    )
    .default(180),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image input.',
  }),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(32).register(z.globalRegistry, {
        description: 'Guidance scale for the generation.',
      }),
    )
    .default(10),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for video generation.',
      }),
    )
    .default(''),
  cfg_scale: z
    .optional(
      z.number().gte(0).lte(7).register(z.globalRegistry, {
        description: 'Classifier-Free Guidance scale for the generation.',
      }),
    )
    .default(1),
})

/**
 * File
 */
export const zFalAiFramepackFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * FramePackResponse
 */
export const zFramepackOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generating the video.',
  }),
  video: zFalAiFramepackFile,
})

/**
 * FastImageToVideoRequestV4
 */
export const zPixverseV4ImageToVideoFastInput = z.object({
  prompt: z.string(),
  resolution: z.optional(
    z.enum(['360p', '540p', '720p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video',
    }),
  ),
  style: z.optional(
    z
      .enum(['anime', '3d_animation', 'clay', 'comic', 'cyberpunk'])
      .register(z.globalRegistry, {
        description: 'The style of the generated video',
      }),
  ),
  camera_movement: z.optional(
    z
      .enum([
        'horizontal_left',
        'horizontal_right',
        'vertical_up',
        'vertical_down',
        'zoom_in',
        'zoom_out',
        'crane_up',
        'quickly_zoom_in',
        'quickly_zoom_out',
        'smooth_zoom_in',
        'camera_rotation',
        'robo_arm',
        'super_dolly_out',
        'whip_pan',
        'hitchcock',
        'left_follow',
        'right_follow',
        'pan_left',
        'pan_right',
        'fix_bg',
      ])
      .register(z.globalRegistry, {
        description: 'The type of camera movement to apply to the video',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same video every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to be used for the generation',
      }),
    )
    .default(''),
})

/**
 * File
 */
export const zFalAiPixverseV4ImageToVideoFastFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * I2VOutputV4
 */
export const zPixverseV4ImageToVideoFastOutput = z.object({
  video: zFalAiPixverseV4ImageToVideoFastFile,
})

/**
 * ImageToVideoRequestV4
 */
export const zPixverseV4ImageToVideoInput = z.object({
  prompt: z.string(),
  duration: z.optional(
    z.enum(['5', '8']).register(z.globalRegistry, {
      description:
        'The duration of the generated video in seconds. 8s videos cost double. 1080p videos are limited to 5 seconds',
    }),
  ),
  resolution: z.optional(
    z.enum(['360p', '540p', '720p', '1080p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video',
    }),
  ),
  style: z.optional(
    z
      .enum(['anime', '3d_animation', 'clay', 'comic', 'cyberpunk'])
      .register(z.globalRegistry, {
        description: 'The style of the generated video',
      }),
  ),
  camera_movement: z.optional(
    z
      .enum([
        'horizontal_left',
        'horizontal_right',
        'vertical_up',
        'vertical_down',
        'zoom_in',
        'zoom_out',
        'crane_up',
        'quickly_zoom_in',
        'quickly_zoom_out',
        'smooth_zoom_in',
        'camera_rotation',
        'robo_arm',
        'super_dolly_out',
        'whip_pan',
        'hitchcock',
        'left_follow',
        'right_follow',
        'pan_left',
        'pan_right',
        'fix_bg',
      ])
      .register(z.globalRegistry, {
        description: 'The type of camera movement to apply to the video',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same video every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to be used for the generation',
      }),
    )
    .default(''),
})

/**
 * File
 */
export const zFalAiPixverseV4ImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * I2VOutputV4
 */
export const zPixverseV4ImageToVideoOutput = z.object({
  video: zFalAiPixverseV4ImageToVideoFile,
})

/**
 * EffectInput
 */
export const zPixverseV35EffectsInput = z.object({
  effect: z
    .enum([
      'Kiss Me AI',
      'Kiss',
      'Muscle Surge',
      'Warmth of Jesus',
      'Anything, Robot',
      'The Tiger Touch',
      'Hug',
      'Holy Wings',
      'Microwave',
      'Zombie Mode',
      'Squid Game',
      'Baby Face',
      'Black Myth: Wukong',
      'Long Hair Magic',
      'Leggy Run',
      'Fin-tastic Mermaid',
      'Punch Face',
      'Creepy Devil Smile',
      'Thunder God',
      'Eye Zoom Challenge',
      "Who's Arrested?",
      'Baby Arrived',
      'Werewolf Rage',
      'Bald Swipe',
      'BOOM DROP',
      'Huge Cutie',
      'Liquid Metal',
      'Sharksnap!',
      'Dust Me Away',
      '3D Figurine Factor',
      'Bikini Up',
      'My Girlfriends',
      'My Boyfriends',
      'Subject 3 Fever',
      'Earth Zoom',
      'Pole Dance',
      'Vroom Dance',
      'GhostFace Terror',
      'Dragon Evoker',
      'Skeletal Bae',
      'Summoning succubus',
      'Halloween Voodoo Doll',
      '3D Naked-Eye AD',
      'Package Explosion',
      'Dishes Served',
      'Ocean ad',
      'Supermarket AD',
      'Tree doll',
      'Come Feel My Abs',
      'The Bicep Flex',
      'London Elite Vibe',
      'Flora Nymph Gown',
      'Christmas Costume',
      "It's Snowy",
      'Reindeer Cruiser',
      'Snow Globe Maker',
      'Pet Christmas Outfit',
      'Adopt a Polar Pal',
      'Cat Christmas Box',
      'Starlight Gift Box',
      'Xmas Poster',
      'Pet Christmas Tree',
      'City Santa Hat',
      'Stocking Sweetie',
      'Christmas Night',
      'Xmas Front Page Karma',
      "Grinch's Xmas Hijack",
    ])
    .register(z.globalRegistry, {
      description: 'The effect to apply to the video',
    }),
  duration: z.optional(
    z.enum(['5', '8']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  resolution: z.optional(
    z.enum(['360p', '540p', '720p', '1080p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video.',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to be used for the generation',
      }),
    )
    .default(''),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'Optional URL of the image to use as the first frame. If not provided, generates from text',
  }),
})

/**
 * File
 */
export const zFalAiPixverseV35EffectsFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * EffectOutput
 */
export const zPixverseV35EffectsOutput = z.object({
  video: zFalAiPixverseV35EffectsFile,
})

/**
 * TransitionRequest
 */
export const zPixverseV35TransitionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt for the transition',
  }),
  aspect_ratio: z.optional(
    z.enum(['16:9', '4:3', '1:1', '3:4', '9:16']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated video',
    }),
  ),
  duration: z.optional(
    z.enum(['5', '8']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  style: z.optional(
    z
      .enum(['anime', '3d_animation', 'clay', 'comic', 'cyberpunk'])
      .register(z.globalRegistry, {
        description: 'The style of the generated video',
      }),
  ),
  first_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
  resolution: z.optional(
    z.enum(['360p', '540p', '720p', '1080p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same video every time.\n        ',
    }),
  ),
  end_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of the image to use as the last frame',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to be used for the generation',
      }),
    )
    .default(''),
})

/**
 * File
 */
export const zFalAiPixverseV35TransitionFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * TransitionOutput
 */
export const zPixverseV35TransitionOutput = z.object({
  video: zFalAiPixverseV35TransitionFile,
})

/**
 * Ray2ImageToVideoRequest
 */
export const zLumaDreamMachineRay2FlashImageToVideoInput = z.object({
  prompt: z.string().min(3).max(5000),
  aspect_ratio: z.optional(
    z
      .enum(['16:9', '9:16', '4:3', '3:4', '21:9', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated video',
      }),
  ),
  resolution: z.optional(
    z.enum(['540p', '720p', '1080p']).register(z.globalRegistry, {
      description:
        'The resolution of the generated video (720p costs 2x more, 1080p costs 4x more)',
    }),
  ),
  loop: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether the video should loop (end of video is blended with the beginning)',
      }),
    )
    .default(false),
  duration: z.optional(
    z.enum(['5s', '9s']).register(z.globalRegistry, {
      description: 'The duration of the generated video',
    }),
  ),
  image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Initial image to start the video from. Can be used together with end_image_url.',
    }),
  ),
  end_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Final image to end the video with. Can be used together with image_url.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiLumaDreamMachineRay2FlashImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Ray2I2VOutput
 */
export const zLumaDreamMachineRay2FlashImageToVideoOutput = z.object({
  video: zFalAiLumaDreamMachineRay2FlashImageToVideoFile,
})

/**
 * PikaffectsRequest
 *
 * Request model for Pikaffects endpoint
 */
export const zPikaV15PikaffectsInput = z
  .object({
    pikaffect: z
      .enum([
        'Cake-ify',
        'Crumble',
        'Crush',
        'Decapitate',
        'Deflate',
        'Dissolve',
        'Explode',
        'Eye-pop',
        'Inflate',
        'Levitate',
        'Melt',
        'Peel',
        'Poke',
        'Squish',
        'Ta-da',
        'Tear',
      ])
      .register(z.globalRegistry, {
        description: 'The Pikaffect to apply',
      }),
    prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Text prompt to guide the effect',
      }),
    ),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The seed for the random number generator',
      }),
    ),
    negative_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to guide the model',
      }),
    ),
    image_url: z.string().register(z.globalRegistry, {
      description: 'URL of the input image',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Request model for Pikaffects endpoint',
  })

/**
 * File
 */
export const zFalAiPikaV15PikaffectsFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * PikaffectsOutput
 *
 * Output from Pikaffects generation
 */
export const zPikaV15PikaffectsOutput = z
  .object({
    video: zFalAiPikaV15PikaffectsFile,
  })
  .register(z.globalRegistry, {
    description: 'Output from Pikaffects generation',
  })

/**
 * ImageToVideoTurboInput
 *
 * Base request for image-to-video generation
 */
export const zPikaV2TurboImageToVideoInput = z
  .object({
    prompt: z.string(),
    resolution: z.optional(
      z.enum(['720p', '1080p']).register(z.globalRegistry, {
        description: 'The resolution of the generated video',
      }),
    ),
    duration: z
      .optional(
        z.int().register(z.globalRegistry, {
          description: 'The duration of the generated video in seconds',
        }),
      )
      .default(5),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The seed for the random number generator',
      }),
    ),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'A negative prompt to guide the model',
        }),
      )
      .default(''),
    image_url: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'Base request for image-to-video generation',
  })

/**
 * File
 */
export const zFalAiPikaV2TurboImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * TurboImageToVideoOutput
 *
 * Output model for all video generation endpoints
 */
export const zPikaV2TurboImageToVideoOutput = z
  .object({
    video: zFalAiPikaV2TurboImageToVideoFile,
  })
  .register(z.globalRegistry, {
    description: 'Output model for all video generation endpoints',
  })

/**
 * Pika22PikascenesRequest
 *
 * Request model for Pika 2.2 Pikascenes (collection-to-video) generation
 */
export const zPikaV22PikascenesInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'Text prompt describing the desired video',
    }),
    resolution: z.optional(
      z.enum(['720p', '1080p']).register(z.globalRegistry, {
        description: 'The resolution of the generated video',
      }),
    ),
    aspect_ratio: z.optional(
      z
        .enum(['16:9', '9:16', '1:1', '4:5', '5:4', '3:2', '2:3'])
        .register(z.globalRegistry, {
          description: 'The aspect ratio of the generated video',
        }),
    ),
    duration: z.optional(
      z.union([z.literal(5), z.literal(10)]).register(z.globalRegistry, {
        description: 'The duration of the generated video in seconds',
      }),
    ),
    ingredients_mode: z.optional(
      z.enum(['precise', 'creative']).register(z.globalRegistry, {
        description:
          'Mode for integrating multiple images. Precise mode is more accurate, creative mode is more creative.',
      }),
    ),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The seed for the random number generator',
      }),
    ),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: 'URLs of images to combine into a video',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'A negative prompt to guide the model',
        }),
      )
      .default('ugly, bad, terrible'),
  })
  .register(z.globalRegistry, {
    description:
      'Request model for Pika 2.2 Pikascenes (collection-to-video) generation',
  })

/**
 * File
 */
export const zFalAiPikaV22PikascenesFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Pika22PikascenesOutput
 *
 * Output model for Pika 2.2 Pikascenes generation
 */
export const zPikaV22PikascenesOutput = z
  .object({
    video: zFalAiPikaV22PikascenesFile,
  })
  .register(z.globalRegistry, {
    description: 'Output model for Pika 2.2 Pikascenes generation',
  })

/**
 * Pika22ImageToVideoRequest
 *
 * Request model for Pika 2.2 image-to-video generation
 */
export const zPikaV22ImageToVideoInput = z
  .object({
    prompt: z.string(),
    resolution: z.optional(
      z.enum(['720p', '1080p']).register(z.globalRegistry, {
        description: 'The resolution of the generated video',
      }),
    ),
    duration: z.optional(
      z.union([z.literal(5), z.literal(10)]).register(z.globalRegistry, {
        description: 'The duration of the generated video in seconds',
      }),
    ),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The seed for the random number generator',
      }),
    ),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'A negative prompt to guide the model',
        }),
      )
      .default(''),
    image_url: z.string().register(z.globalRegistry, {
      description: 'URL of the image to use as the first frame',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Request model for Pika 2.2 image-to-video generation',
  })

/**
 * File
 */
export const zFalAiPikaV22ImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Pika22ImageToVideoOutput
 *
 * Output model for Pika 2.2 image-to-video generation
 */
export const zPikaV22ImageToVideoOutput = z
  .object({
    video: zFalAiPikaV22ImageToVideoFile,
  })
  .register(z.globalRegistry, {
    description: 'Output model for Pika 2.2 image-to-video generation',
  })

/**
 * ImageToVideov21Input
 *
 * Base request for image-to-video generation
 */
export const zPikaV21ImageToVideoInput = z
  .object({
    prompt: z.string(),
    resolution: z.optional(
      z.enum(['720p', '1080p']).register(z.globalRegistry, {
        description: 'The resolution of the generated video',
      }),
    ),
    duration: z
      .optional(
        z.int().register(z.globalRegistry, {
          description: 'The duration of the generated video in seconds',
        }),
      )
      .default(5),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The seed for the random number generator',
      }),
    ),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'A negative prompt to guide the model',
        }),
      )
      .default(''),
    image_url: z.string(),
  })
  .register(z.globalRegistry, {
    description: 'Base request for image-to-video generation',
  })

/**
 * File
 */
export const zFalAiPikaV21ImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageToVideoV21Output
 *
 * Output from image-to-video generation
 */
export const zPikaV21ImageToVideoOutput = z
  .object({
    video: zFalAiPikaV21ImageToVideoFile,
  })
  .register(z.globalRegistry, {
    description: 'Output from image-to-video generation',
  })

/**
 * ImageToVideoRequest
 */
export const zViduImageToVideoInput = z.object({
  prompt: z.string().max(1500).register(z.globalRegistry, {
    description: 'Text prompt for video generation, max 1500 characters',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for generation',
    }),
  ),
  movement_amplitude: z.optional(
    z.enum(['auto', 'small', 'medium', 'large']).register(z.globalRegistry, {
      description: 'The movement amplitude of objects in the frame',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
})

/**
 * File
 */
export const zFalAiViduImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * VideoOutput
 */
export const zViduImageToVideoOutput = z.object({
  video: zFalAiViduImageToVideoFile,
})

/**
 * StartEndToVideoRequest
 */
export const zViduStartEndToVideoInput = z.object({
  prompt: z.string().max(1500).register(z.globalRegistry, {
    description: 'Text prompt for video generation, max 1500 characters',
  }),
  start_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
  movement_amplitude: z.optional(
    z.enum(['auto', 'small', 'medium', 'large']).register(z.globalRegistry, {
      description: 'The movement amplitude of objects in the frame',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for generation',
    }),
  ),
  end_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the last frame',
  }),
})

/**
 * File
 */
export const zFalAiViduStartEndToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * StartEndToVideoOutput
 */
export const zViduStartEndToVideoOutput = z.object({
  video: zFalAiViduStartEndToVideoFile,
})

/**
 * ReferenceToVideoRequest
 */
export const zViduReferenceToVideoInput = z.object({
  prompt: z.string().max(1500).register(z.globalRegistry, {
    description: 'Text prompt for video generation, max 1500 characters',
  }),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description: 'The aspect ratio of the output video',
    }),
  ),
  reference_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'URLs of the reference images to use for consistent subject appearance',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for generation',
    }),
  ),
  movement_amplitude: z.optional(
    z.enum(['auto', 'small', 'medium', 'large']).register(z.globalRegistry, {
      description: 'The movement amplitude of objects in the frame',
    }),
  ),
})

/**
 * File
 */
export const zFalAiViduReferenceToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ReferenceToVideoOutput
 */
export const zViduReferenceToVideoOutput = z.object({
  video: zFalAiViduReferenceToVideoFile,
})

/**
 * TemplateToVideoRequest
 */
export const zViduTemplateToVideoInput = z.object({
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16']).register(z.globalRegistry, {
      description: 'The aspect ratio of the output video',
    }),
  ),
  template: z.optional(
    z
      .enum([
        'dreamy_wedding',
        'romantic_lift',
        'sweet_proposal',
        'couple_arrival',
        'cupid_arrow',
        'pet_lovers',
        'lunar_newyear',
        'hug',
        'kiss',
        'dynasty_dress',
        'wish_sender',
        'love_pose',
        'hair_swap',
        'youth_rewind',
        'morphlab',
        'live_photo',
        'emotionlab',
        'live_memory',
        'interaction',
        'christmas',
        'pet_finger',
        'eat_mushrooms',
        'beast_chase_library',
        'beast_chase_supermarket',
        'petal_scattered',
        'emoji_figure',
        'hair_color_change',
        'multiple_people_kissing',
        'beast_chase_amazon',
        'beast_chase_mountain',
        'balloonman_explodes_pro',
        'get_thinner',
        'jump2pool',
        'bodyshake',
        'jiggle_up',
        'shake_it_dance',
        'subject_3',
        'pubg_winner_hit',
        'shake_it_down',
        'blueprint_supreme',
        'hip_twist',
        'motor_dance',
        'rat_dance',
        'kwok_dance',
        'leg_sweep_dance',
        'heeseung_march',
        'shake_to_max',
        'dame_un_grrr',
        'i_know',
        'lit_bounce',
        'wave_dance',
        'chill_dance',
        'hip_flicking',
        'sakura_season',
        'zongzi_wrap',
        'zongzi_drop',
        'dragonboat_shot',
        'rain_kiss',
        'child_memory',
        'couple_drop',
        'couple_walk',
        'flower_receive',
        'love_drop',
        'cheek_kiss',
        'carry_me',
        'blow_kiss',
        'love_fall',
        'french_kiss_8s',
        'workday_feels',
        'love_story',
        'bloom_magic',
        'ghibli',
        'minecraft',
        'box_me',
        'claw_me',
        'clayshot',
        'manga_meme',
        'quad_meme',
        'pixel_me',
        'clayshot_duo',
        'irasutoya',
        'american_comic',
        'simpsons_comic',
        'yayoi_kusama_style',
        'pop_art',
        'jojo_style',
        'slice_therapy',
        'balloon_flyaway',
        'flying',
        'paperman',
        'pinch',
        'bloom_doorobear',
        'gender_swap',
        'nap_me',
        'sexy_me',
        'spin360',
        'smooth_shift',
        'paper_fall',
        'jump_to_cloud',
        'pilot',
        'sweet_dreams',
        'soul_depart',
        'punch_hit',
        'watermelon_hit',
        'split_stance_pet',
        'make_face',
        'break_glass',
        'split_stance_human',
        'covered_liquid_metal',
        'fluffy_plunge',
        'pet_belly_dance',
        'water_float',
        'relax_cut',
        'head_to_balloon',
        'cloning',
        'across_the_universe_jungle',
        'clothes_spinning_remnant',
        'across_the_universe_jurassic',
        'across_the_universe_moon',
        'fisheye_pet',
        'hitchcock_zoom',
        'cute_bangs',
        'earth_zoom_out',
        'fisheye_human',
        'drive_yacht',
        'virtual_singer',
        'earth_zoom_in',
        'aliens_coming',
        'drive_ferrari',
        'bjd_style',
        'virtual_fitting',
        'orbit',
        'zoom_in',
        'ai_outfit',
        'spin180',
        'orbit_dolly',
        'orbit_dolly_fast',
        'auto_spin',
        'walk_forward',
        'outfit_show',
        'zoom_in_fast',
        'zoom_out_image',
        'zoom_out_startend',
        'muscling',
        'captain_america',
        'hulk',
        'cap_walk',
        'hulk_dive',
        'exotic_princess',
        'beast_companion',
        'cartoon_doll',
        'golden_epoch',
        'oscar_gala',
        'fashion_stride',
        'star_carpet',
        'flame_carpet',
        'frost_carpet',
        'mecha_x',
        'style_me',
        'tap_me',
        'saber_warrior',
        'pet2human',
        'graduation',
        'fishermen',
        'happy_birthday',
        'fairy_me',
        'ladudu_me',
        'ladudu_me_random',
        'squid_game',
        'superman',
        'grow_wings',
        'clevage',
        'fly_with_doraemon',
        'creatice_product_down',
        'pole_dance',
        'hug_from_behind',
        'creatice_product_up_cybercity',
        'creatice_product_up_bluecircuit',
        'creatice_product_up',
        'run_fast',
        'background_explosion',
      ])
      .register(z.globalRegistry, {
        description:
          'AI video template to use. Pricing varies by template: Standard templates (hug, kiss, love_pose, etc.) cost 4 credits ($0.20), Premium templates (lunar_newyear, dynasty_dress, dreamy_wedding, etc.) cost 6 credits ($0.30), and Advanced templates (live_photo) cost 10 credits ($0.50).',
      }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for generation',
    }),
  ),
  input_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      "URLs of the images to use with the template. Number of images required varies by template: 'dynasty_dress' and 'shop_frame' accept 1-2 images, 'wish_sender' requires exactly 3 images, all other templates accept only 1 image.",
  }),
})

/**
 * File
 */
export const zFalAiViduTemplateToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * TemplateToVideoOutput
 */
export const zViduTemplateToVideoOutput = z.object({
  video: zFalAiViduTemplateToVideoFile,
})

/**
 * LoraWeight
 */
export const zLoraWeight = z.object({
  path: z.string().register(z.globalRegistry, {
    description: 'URL or the path to the LoRA weights.',
  }),
  scale: z
    .optional(
      z.number().gte(0).lte(4).register(z.globalRegistry, {
        description:
          '\n            The scale of the LoRA weight. This is used to scale the LoRA weight\n            before merging it with the base model.\n        ',
      }),
    )
    .default(1),
  weight_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Name of the LoRA weight. Used only if `path` is a Hugging Face repository, and required only if you have more than 1 safetensors file in the repo.',
    }),
  ),
})

/**
 * WanLoRAI2VRequest
 */
export const zWanI2vLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide video generation.',
  }),
  shift: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: 'Shift parameter for video generation.',
      }),
    )
    .default(5),
  reverse_video: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If true, the video will be reversed.',
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zLoraWeight).register(z.globalRegistry, {
        description: 'LoRA weights to be used in the inference.',
      }),
    )
    .default([]),
  frames_per_second: z
    .optional(
      z.int().gte(5).lte(24).register(z.globalRegistry, {
        description:
          'Frames per second of the generated video. Must be between 5 to 24.',
      }),
    )
    .default(16),
  turbo_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If true, the video will be generated faster with no noticeable degradation in the visual quality.',
      }),
    )
    .default(true),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
  num_frames: z
    .optional(
      z.int().gte(81).lte(100).register(z.globalRegistry, {
        description:
          'Number of frames to generate. Must be between 81 to 100 (inclusive). If the number of frames is greater than 81, the video will be generated with 1.25x more billing units.',
      }),
    )
    .default(81),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for video generation.',
      }),
    )
    .default(
      'bright colors, overexposed, static, blurred details, subtitles, style, artwork, painting, picture, still, overall gray, worst quality, low quality, JPEG compression residue, ugly, incomplete, extra fingers, poorly drawn hands, poorly drawn faces, deformed, disfigured, malformed limbs, fused fingers, still picture, cluttered background, three legs, many people in the background, walking backwards',
    ),
  aspect_ratio: z.optional(
    z.enum(['auto', '16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description: 'Aspect ratio of the output video.',
    }),
  ),
  resolution: z.optional(
    z.enum(['480p', '720p']).register(z.globalRegistry, {
      description:
        'Resolution of the generated video (480p or 720p). 480p is 0.5 billing units, and 720p is 1 billing unit.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the input image. If the input image does not match the chosen aspect ratio, it is resized and center cropped.',
  }),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable prompt expansion.',
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If None, a random seed is chosen.',
    }),
  ),
  guide_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher values give better adherence to the prompt but may decrease quality.',
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(40).register(z.globalRegistry, {
        description:
          'Number of inference steps for sampling. Higher values give better quality but take longer.',
      }),
    )
    .default(30),
})

/**
 * File
 */
export const zFalAiWanI2vLoraFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * WanI2VResponse
 */
export const zWanI2vLoraOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
  video: zFalAiWanI2vLoraFile,
})

/**
 * HunyuanVideoRequest
 */
export const zHunyuanVideoImageToVideoInput = z.object({
  prompt: z.string().max(1000).register(z.globalRegistry, {
    description: 'The prompt to generate the video from.',
  }),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16']).register(z.globalRegistry, {
      description: 'The aspect ratio of the video to generate.',
    }),
  ),
  resolution: z.optional(
    z.enum(['720p']).register(z.globalRegistry, {
      description: 'The resolution of the video to generate.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image input.',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed to use for generating the video.',
    }),
  ),
  num_frames: z.optional(
    z.enum(['129']).register(z.globalRegistry, {
      description: 'The number of frames to generate.',
    }),
  ),
  i2v_stability: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Turning on I2V Stability reduces hallucination but also reduces motion.',
      }),
    )
    .default(false),
})

/**
 * File
 */
export const zFalAiHunyuanVideoImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * HunyuanI2VResponse
 */
export const zHunyuanVideoImageToVideoOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generating the video.',
  }),
  video: zFalAiHunyuanVideoImageToVideoFile,
})

/**
 * ImageToVideoDirectorRequest
 */
export const zMinimaxVideo01DirectorImageToVideoInput = z.object({
  prompt_optimizer: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the model's prompt optimizer",
      }),
    )
    .default(true),
  prompt: z.string().max(2000).register(z.globalRegistry, {
    description:
      'Text prompt for video generation. Camera movement instructions can be added using square brackets (e.g. [Pan left] or [Zoom in]). You can use up to 3 combined movements per prompt. Supported movements: Truck left/right, Pan left/right, Push in/Pull out, Pedestal up/down, Tilt up/down, Zoom in/out, Shake, Tracking shot, Static shot. For example: [Truck left, Pan right, Zoom in]. For a more detailed guide, refer https://sixth-switch-2ac.notion.site/T2V-01-Director-Model-Tutorial-with-camera-movement-1886c20a98eb80f395b8e05291ad8645',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
})

/**
 * File
 */
export const zFalAiMinimaxVideo01DirectorImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * I2VDirectorOutput
 */
export const zMinimaxVideo01DirectorImageToVideoOutput = z.object({
  video: zFalAiMinimaxVideo01DirectorImageToVideoFile,
})

/**
 * SkyreelsI2VRequest
 */
export const zSkyreelsI2vInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the video from.',
  }),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16']).register(z.globalRegistry, {
      description: 'Aspect ratio of the output video',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image input.',
  }),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for generation (between 1.0 and 20.0)',
      }),
    )
    .default(6),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for generation. If not provided, a random seed will be used.',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description:
          'Number of denoising steps (between 1 and 50). Higher values give better quality but take longer.',
      }),
    )
    .default(30),
  negative_prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Negative prompt to guide generation away from certain attributes.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiSkyreelsI2vFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * SkyreelsI2VResponse
 */
export const zSkyreelsI2vOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
  video: zFalAiSkyreelsI2vFile,
})

/**
 * Ray2ImageToVideoRequest
 */
export const zLumaDreamMachineRay2ImageToVideoInput = z.object({
  prompt: z.string().min(3).max(5000),
  aspect_ratio: z.optional(
    z
      .enum(['16:9', '9:16', '4:3', '3:4', '21:9', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated video',
      }),
  ),
  resolution: z.optional(
    z.enum(['540p', '720p', '1080p']).register(z.globalRegistry, {
      description:
        'The resolution of the generated video (720p costs 2x more, 1080p costs 4x more)',
    }),
  ),
  loop: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether the video should loop (end of video is blended with the beginning)',
      }),
    )
    .default(false),
  duration: z.optional(
    z.enum(['5s', '9s']).register(z.globalRegistry, {
      description: 'The duration of the generated video',
    }),
  ),
  image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Initial image to start the video from. Can be used together with end_image_url.',
    }),
  ),
  end_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Final image to end the video with. Can be used together with image_url.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiLumaDreamMachineRay2ImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Ray2I2VOutput
 */
export const zLumaDreamMachineRay2ImageToVideoOutput = z.object({
  video: zFalAiLumaDreamMachineRay2ImageToVideoFile,
})

/**
 * Input
 */
export const zHunyuanVideoImg2VidLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the video from.',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed to use for generating the video.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL to the image to generate the video from. The image must be 960x544 or it will get cropped and resized to that size.',
  }),
})

/**
 * File
 */
export const zFalAiHunyuanVideoImg2VidLoraFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Output
 */
export const zHunyuanVideoImg2VidLoraOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generating the video.',
  }),
  video: zFalAiHunyuanVideoImg2VidLoraFile,
})

/**
 * FastImageToVideoRequest
 */
export const zPixverseV35ImageToVideoFastInput = z.object({
  prompt: z.string(),
  resolution: z.optional(
    z.enum(['360p', '540p', '720p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video',
    }),
  ),
  style: z.optional(
    z
      .enum(['anime', '3d_animation', 'clay', 'comic', 'cyberpunk'])
      .register(z.globalRegistry, {
        description: 'The style of the generated video',
      }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same video every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to be used for the generation',
      }),
    )
    .default(''),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
})

/**
 * File
 */
export const zFalAiPixverseV35ImageToVideoFastFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * I2VOutput
 */
export const zPixverseV35ImageToVideoFastOutput = z.object({
  video: zFalAiPixverseV35ImageToVideoFastFile,
})

/**
 * ImageToVideoRequest
 */
export const zPixverseV35ImageToVideoInput = z.object({
  prompt: z.string(),
  duration: z.optional(
    z.enum(['5', '8']).register(z.globalRegistry, {
      description:
        'The duration of the generated video in seconds. 8s videos cost double. 1080p videos are limited to 5 seconds',
    }),
  ),
  resolution: z.optional(
    z.enum(['360p', '540p', '720p', '1080p']).register(z.globalRegistry, {
      description: 'The resolution of the generated video',
    }),
  ),
  style: z.optional(
    z
      .enum(['anime', '3d_animation', 'clay', 'comic', 'cyberpunk'])
      .register(z.globalRegistry, {
        description: 'The style of the generated video',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same video every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to be used for the generation',
      }),
    )
    .default(''),
})

/**
 * File
 */
export const zFalAiPixverseV35ImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * I2VOutput
 */
export const zPixverseV35ImageToVideoOutput = z.object({
  video: zFalAiPixverseV35ImageToVideoFile,
})

/**
 * SubjectReferenceRequest
 */
export const zMinimaxVideo01SubjectReferenceInput = z.object({
  prompt_optimizer: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the model's prompt optimizer",
      }),
    )
    .default(true),
  prompt: z.string().max(2000),
  subject_reference_image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the subject reference image to use for consistent subject appearance',
  }),
})

/**
 * File
 */
export const zFalAiMinimaxVideo01SubjectReferenceFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * SubjectReferenceOutput
 */
export const zMinimaxVideo01SubjectReferenceOutput = z.object({
  video: zFalAiMinimaxVideo01SubjectReferenceFile,
})

/**
 * ImageToVideoRequest
 */
export const zKlingVideoV16StandardImageToVideoInput = z.object({
  prompt: z.string().max(2500),
  duration: z.optional(
    z.enum(['5', '10']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  cfg_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt.\n        ',
      }),
    )
    .default(0.5),
  negative_prompt: z
    .optional(z.string().max(2500))
    .default('blur, distort, and low quality'),
  image_url: z.string(),
})

/**
 * File
 */
export const zFalAiKlingVideoV16StandardImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * I2VOutput
 */
export const zKlingVideoV16StandardImageToVideoOutput = z.object({
  video: zFalAiKlingVideoV16StandardImageToVideoFile,
})

/**
 * SadTalkerRefVideoInput
 */
export const zSadtalkerReferenceInput = z.object({
  pose_style: z
    .optional(
      z.int().gte(0).lte(45).register(z.globalRegistry, {
        description: 'The style of the pose',
      }),
    )
    .default(0),
  source_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the source image',
  }),
  reference_pose_video_url: z.string().register(z.globalRegistry, {
    description: 'URL of the reference video',
  }),
  driven_audio_url: z.string().register(z.globalRegistry, {
    description: 'URL of the driven audio',
  }),
  face_enhancer: z.optional(
    z.enum(['gfpgan']).register(z.globalRegistry, {
      description: 'The type of face enhancer to use',
    }),
  ),
  expression_scale: z
    .optional(
      z.number().gte(0).lte(3).register(z.globalRegistry, {
        description: 'The scale of the expression',
      }),
    )
    .default(1),
  face_model_resolution: z.optional(
    z.enum(['256', '512']).register(z.globalRegistry, {
      description: 'The resolution of the face model',
    }),
  ),
  still_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to use still mode. Fewer head motion, works with preprocess `full`.',
      }),
    )
    .default(false),
  preprocess: z.optional(
    z
      .enum(['crop', 'extcrop', 'resize', 'full', 'extfull'])
      .register(z.globalRegistry, {
        description: 'The type of preprocessing to use',
      }),
  ),
})

/**
 * File
 */
export const zFalAiSadtalkerReferenceFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * SadTalkerOutput
 */
export const zSadtalkerReferenceOutput = z.object({
  video: zFalAiSadtalkerReferenceFile,
})

/**
 * ImageToVideoRequest
 */
export const zMinimaxVideo01LiveImageToVideoInput = z.object({
  prompt_optimizer: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: "Whether to use the model's prompt optimizer",
      }),
    )
    .default(true),
  prompt: z.string().max(2000),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to use as the first frame',
  }),
})

/**
 * File
 */
export const zFalAiMinimaxVideo01LiveImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * I2VLiveOutput
 */
export const zMinimaxVideo01LiveImageToVideoOutput = z.object({
  video: zFalAiMinimaxVideo01LiveImageToVideoFile,
})

/**
 * ImageToVideoInput
 */
export const zLtxVideoImageToVideoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the video from.',
  }),
  guidance_scale: z
    .optional(
      z.number().lte(10).register(z.globalRegistry, {
        description: 'The guidance scale to use.',
      }),
    )
    .default(3),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed to use for random number generation.',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to take.',
      }),
    )
    .default(30),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to generate the video from.',
      }),
    )
    .default(
      'low quality, worst quality, deformed, distorted, disfigured, motion smear, motion artifacts, fused fingers, bad anatomy, weird hand, ugly',
    ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate the video from.',
  }),
})

/**
 * File
 */
export const zFalAiLtxVideoImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Output
 */
export const zLtxVideoImageToVideoOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for random number generation.',
  }),
  video: zFalAiLtxVideoImageToVideoFile,
})

/**
 * LoraWeight
 */
export const zFalAiCogvideox5bImageToVideoLoraWeight = z.object({
  path: z.string().register(z.globalRegistry, {
    description: 'URL or the path to the LoRA weights.',
  }),
  scale: z
    .optional(
      z.number().gte(0).lte(4).register(z.globalRegistry, {
        description:
          '\n            The scale of the LoRA weight. This is used to scale the LoRA weight\n            before merging it with the base model.\n        ',
      }),
    )
    .default(1),
})

/**
 * ImageSize
 */
export const zFalAiCogvideox5bImageToVideoImageSize = z.object({
  height: z
    .optional(
      z.int().lte(14142).register(z.globalRegistry, {
        description: 'The height of the generated image.',
      }),
    )
    .default(512),
  width: z
    .optional(
      z.int().lte(14142).register(z.globalRegistry, {
        description: 'The width of the generated image.',
      }),
    )
    .default(512),
})

/**
 * ImageToVideoInput
 */
export const zCogvideox5bImageToVideoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the video from.',
  }),
  use_rife: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Use RIFE for video interpolation',
      }),
    )
    .default(true),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL to the image to generate the video from.',
  }),
  loras: z
    .optional(
      z
        .array(zFalAiCogvideox5bImageToVideoLoraWeight)
        .register(z.globalRegistry, {
          description:
            '\n            The LoRAs to use for the image generation. We currently support one lora.\n        ',
        }),
    )
    .default([]),
  video_size: z.optional(
    z.union([
      zFalAiCogvideox5bImageToVideoImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related video to show you.\n        ',
      }),
    )
    .default(7),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(50),
  export_fps: z
    .optional(
      z.int().gte(4).lte(32).register(z.globalRegistry, {
        description: 'The target FPS of the video',
      }),
    )
    .default(16),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to generate video from',
      }),
    )
    .default(''),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same video every time.\n        ',
    }),
  ),
})

/**
 * File
 */
export const zFalAiCogvideox5bImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Output
 */
export const zCogvideox5bImageToVideoOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the video.',
  }),
  timings: z.record(z.string(), z.number()),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated video. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  video: zFalAiCogvideox5bImageToVideoFile,
})

/**
 * Trajectory
 */
export const zTrajectory = z.object({
  y: z.int().register(z.globalRegistry, {
    description: 'Y coordinate of the motion trajectory',
  }),
  x: z.int().register(z.globalRegistry, {
    description: 'X coordinate of the motion trajectory',
  }),
})

/**
 * DynamicMask
 */
export const zDynamicMask = z.object({
  trajectories: z.optional(
    z.array(zTrajectory).register(z.globalRegistry, {
      description: 'List of trajectories',
    }),
  ),
  mask_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the image for Dynamic Brush Application Area (Mask image created by users using the motion brush)',
  }),
})

/**
 * KlingV15ProImageToVideoRequest
 */
export const zKlingVideoV15ProImageToVideoInput = z.object({
  prompt: z.string().max(2500),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated video frame',
    }),
  ),
  duration: z.optional(
    z.enum(['5', '10']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  negative_prompt: z
    .optional(z.string().max(2500))
    .default('blur, distort, and low quality'),
  image_url: z.string(),
  static_mask_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'URL of the image for Static Brush Application Area (Mask image created by users using the motion brush)',
    }),
  ),
  dynamic_masks: z.optional(
    z.array(zDynamicMask).register(z.globalRegistry, {
      description: 'List of dynamic masks',
    }),
  ),
  tail_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of the image to be used for the end of the video',
    }),
  ),
  cfg_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt.\n        ',
      }),
    )
    .default(0.5),
})

/**
 * File
 */
export const zFalAiKlingVideoV15ProImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * I2VOutput
 */
export const zKlingVideoV15ProImageToVideoOutput = z.object({
  video: zFalAiKlingVideoV15ProImageToVideoFile,
})

/**
 * Trajectory
 */
export const zFalAiKlingVideoV1StandardImageToVideoTrajectory = z.object({
  y: z.int().register(z.globalRegistry, {
    description: 'Y coordinate of the motion trajectory',
  }),
  x: z.int().register(z.globalRegistry, {
    description: 'X coordinate of the motion trajectory',
  }),
})

/**
 * DynamicMask
 */
export const zFalAiKlingVideoV1StandardImageToVideoDynamicMask = z.object({
  trajectories: z.optional(
    z
      .array(zFalAiKlingVideoV1StandardImageToVideoTrajectory)
      .register(z.globalRegistry, {
        description: 'List of trajectories',
      }),
  ),
  mask_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the image for Dynamic Brush Application Area (Mask image created by users using the motion brush)',
  }),
})

/**
 * V1ImageToVideoRequest
 */
export const zKlingVideoV1StandardImageToVideoInput = z.object({
  prompt: z.string().max(2500).register(z.globalRegistry, {
    description: 'The prompt for the video',
  }),
  duration: z.optional(
    z.enum(['5', '10']).register(z.globalRegistry, {
      description: 'The duration of the generated video in seconds',
    }),
  ),
  negative_prompt: z
    .optional(z.string().max(2500))
    .default('blur, distort, and low quality'),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be used for the video',
  }),
  static_mask_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'URL of the image for Static Brush Application Area (Mask image created by users using the motion brush)',
    }),
  ),
  dynamic_masks: z.optional(
    z
      .array(zFalAiKlingVideoV1StandardImageToVideoDynamicMask)
      .register(z.globalRegistry, {
        description: 'List of dynamic masks',
      }),
  ),
  tail_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of the image to be used for the end of the video',
    }),
  ),
  cfg_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt.\n        ',
      }),
    )
    .default(0.5),
})

/**
 * File
 */
export const zFalAiKlingVideoV1StandardImageToVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * KlingV1I2VOutput
 */
export const zKlingVideoV1StandardImageToVideoOutput = z.object({
  video: zFalAiKlingVideoV1StandardImageToVideoFile,
})

/**
 * ImageInput
 */
export const zStableVideoInput = z.object({
  motion_bucket_id: z
    .optional(
      z.int().gte(1).lte(255).register(z.globalRegistry, {
        description:
          '\n            The motion bucket id determines the motion of the generated video. The\n            higher the number, the more motion there will be.\n        ',
      }),
    )
    .default(127),
  fps: z
    .optional(
      z.int().gte(10).lte(100).register(z.globalRegistry, {
        description: 'The frames per second of the generated video.',
      }),
    )
    .default(25),
  cond_aug: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description:
          '\n            The conditoning augmentation determines the amount of noise that will be\n            added to the conditioning frame. The higher the number, the more noise\n            there will be, and the less the video will look like the initial image.\n            Increase it for more motion.\n        ',
      }),
    )
    .default(0.02),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  image_url: z.string().min(1).register(z.globalRegistry, {
    description:
      'The URL of the image to use as a starting point for the generation.',
  }),
})

/**
 * File
 */
export const zFalAiStableVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * VideoOutput
 */
export const zStableVideoOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed for random number generator',
  }),
  video: zFalAiStableVideoFile,
})

/**
 * Frame
 */
export const zFrame = z.object({
  url: z.string().register(z.globalRegistry, {
    description: 'URL of the frame',
  }),
})

/**
 * AMTFrameInterpolationInput
 */
export const zAmtInterpolationFrameInterpolationInput = z.object({
  frames: z.array(zFrame).register(z.globalRegistry, {
    description: 'Frames to interpolate',
  }),
  recursive_interpolation_passes: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Number of recursive interpolation passes',
      }),
    )
    .default(4),
  output_fps: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Output frames per second',
      }),
    )
    .default(24),
})

/**
 * File
 */
export const zFalAiAmtInterpolationFrameInterpolationFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * AMTInterpolationOutput
 */
export const zAmtInterpolationFrameInterpolationOutput = z.object({
  video: zFalAiAmtInterpolationFrameInterpolationFile,
})

/**
 * LivePortraitInput
 */
export const zLivePortraitInput = z.object({
  smile: z
    .optional(
      z.number().gte(-2).lte(2).register(z.globalRegistry, {
        description: 'Amount to smile',
      }),
    )
    .default(0),
  video_url: z.string().register(z.globalRegistry, {
    description: 'URL of the video to drive the lip syncing.',
  }),
  eyebrow: z
    .optional(
      z.number().gte(-30).lte(30).register(z.globalRegistry, {
        description: 'Amount to raise or lower eyebrows',
      }),
    )
    .default(0),
  flag_stitching: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable stitching. Recommended to set to True.',
      }),
    )
    .default(true),
  wink: z
    .optional(
      z.number().gte(0).lte(25).register(z.globalRegistry, {
        description: 'Amount to wink',
      }),
    )
    .default(0),
  rotate_pitch: z
    .optional(
      z.number().gte(-45).lte(45).register(z.globalRegistry, {
        description: 'Amount to rotate the face in pitch',
      }),
    )
    .default(0),
  blink: z
    .optional(
      z.number().gte(-30).lte(30).register(z.globalRegistry, {
        description: 'Amount to blink the eyes',
      }),
    )
    .default(0),
  scale: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'Scaling factor for the face crop.',
      }),
    )
    .default(2.3),
  eee: z
    .optional(
      z.number().gte(-40).lte(40).register(z.globalRegistry, {
        description: "Amount to shape mouth in 'eee' position",
      }),
    )
    .default(0),
  flag_pasteback: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to paste-back/stitch the animated face cropping from the face-cropping space to the original image space.',
      }),
    )
    .default(true),
  pupil_y: z
    .optional(
      z.number().gte(-45).lte(45).register(z.globalRegistry, {
        description: 'Amount to move pupils vertically',
      }),
    )
    .default(0),
  rotate_yaw: z
    .optional(
      z.number().gte(-45).lte(45).register(z.globalRegistry, {
        description: 'Amount to rotate the face in yaw',
      }),
    )
    .default(0),
  flag_do_rot: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to conduct the rotation when flag_do_crop is True.',
      }),
    )
    .default(true),
  woo: z
    .optional(
      z.number().gte(-100).lte(100).register(z.globalRegistry, {
        description: "Amount to shape mouth in 'woo' position",
      }),
    )
    .default(0),
  aaa: z
    .optional(
      z.number().gte(-200).lte(200).register(z.globalRegistry, {
        description: "Amount to open mouth in 'aaa' shape",
      }),
    )
    .default(0),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be animated',
  }),
  flag_relative: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to use relative motion.',
      }),
    )
    .default(true),
  flag_eye_retargeting: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable eye retargeting.',
      }),
    )
    .default(false),
  flag_lip_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to set the lip to closed state before animation. Only takes effect when flag_eye_retargeting and flag_lip_retargeting are False.',
      }),
    )
    .default(true),
  batch_size: z
    .optional(
      z.int().register(z.globalRegistry, {
        description:
          'Batch size for the model. The larger the batch size, the faster the model will run, but the more memory it will consume.',
      }),
    )
    .default(32),
  rotate_roll: z
    .optional(
      z.number().gte(-45).lte(45).register(z.globalRegistry, {
        description: 'Amount to rotate the face in roll',
      }),
    )
    .default(0),
  pupil_x: z
    .optional(
      z.number().gte(-45).lte(45).register(z.globalRegistry, {
        description: 'Amount to move pupils horizontally',
      }),
    )
    .default(0),
  vy_ratio: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          'Vertical offset ratio for face crop. Positive values move up, negative values move down.',
      }),
    )
    .default(-0.125),
  dsize: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Size of the output image.',
      }),
    )
    .default(512),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n        Whether to enable the safety checker. If enabled, the model will check if the input image contains a face before processing it.\n        The safety checker will process the input image\n        ',
      }),
    )
    .default(false),
  vx_ratio: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'Horizontal offset ratio for face crop.',
      }),
    )
    .default(0),
  flag_lip_retargeting: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable lip retargeting.',
      }),
    )
    .default(false),
  flag_do_crop: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to crop the source portrait to the face-cropping space.',
      }),
    )
    .default(true),
})

/**
 * File
 */
export const zFalAiLivePortraitFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * LivePortraitOutput
 */
export const zLivePortraitOutput = z.object({
  video: zFalAiLivePortraitFile,
})

/**
 * MuseTalkInput
 */
export const zMusetalkInput = z.object({
  source_video_url: z.string().register(z.globalRegistry, {
    description: 'URL of the source video',
  }),
  audio_url: z.string().register(z.globalRegistry, {
    description: 'URL of the audio',
  }),
})

/**
 * File
 */
export const zFalAiMusetalkFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * MuseTalkOutput
 */
export const zMusetalkOutput = z.object({
  video: zFalAiMusetalkFile,
})

/**
 * SadTalkerInput
 */
export const zSadtalkerInput = z.object({
  pose_style: z
    .optional(
      z.int().gte(0).lte(45).register(z.globalRegistry, {
        description: 'The style of the pose',
      }),
    )
    .default(0),
  source_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the source image',
  }),
  driven_audio_url: z.string().register(z.globalRegistry, {
    description: 'URL of the driven audio',
  }),
  face_enhancer: z.optional(
    z.enum(['gfpgan']).register(z.globalRegistry, {
      description: 'The type of face enhancer to use',
    }),
  ),
  expression_scale: z
    .optional(
      z.number().gte(0).lte(3).register(z.globalRegistry, {
        description: 'The scale of the expression',
      }),
    )
    .default(1),
  face_model_resolution: z.optional(
    z.enum(['256', '512']).register(z.globalRegistry, {
      description: 'The resolution of the face model',
    }),
  ),
  still_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to use still mode. Fewer head motion, works with preprocess `full`.',
      }),
    )
    .default(false),
  preprocess: z.optional(
    z
      .enum(['crop', 'extcrop', 'resize', 'full', 'extfull'])
      .register(z.globalRegistry, {
        description: 'The type of preprocessing to use',
      }),
  ),
})

/**
 * File
 */
export const zFalAiSadtalkerFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * SadTalkerOutput
 */
export const zSadtalkerOutput = z.object({
  video: zFalAiSadtalkerFile,
})

/**
 * FastSVDImageInput
 */
export const zFastSvdLcmInput = z.object({
  motion_bucket_id: z
    .optional(
      z.int().gte(1).lte(255).register(z.globalRegistry, {
        description:
          '\n            The motion bucket id determines the motion of the generated video. The\n            higher the number, the more motion there will be.\n        ',
      }),
    )
    .default(127),
  fps: z
    .optional(
      z.int().gte(1).lte(25).register(z.globalRegistry, {
        description:
          '\n            The FPS of the generated video. The higher the number, the faster the video will\n            play. Total video length is 25 frames.\n        ',
      }),
    )
    .default(10),
  steps: z
    .optional(
      z.int().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n            The number of steps to run the model for. The higher the number the better\n            the quality and longer it will take to generate.\n        ',
      }),
    )
    .default(4),
  cond_aug: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description:
          '\n            The conditoning augmentation determines the amount of noise that will be\n            added to the conditioning frame. The higher the number, the more noise\n            there will be, and the less the video will look like the initial image.\n            Increase it for more motion.\n        ',
      }),
    )
    .default(0.02),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the image to use as a starting point for the generation.',
  }),
})

/**
 * File
 */
export const zFalAiFastSvdLcmFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * FastSVDOutput
 */
export const zFastSvdLcmOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n\n        ',
  }),
  video: zFalAiFastSvdLcmFile,
})
