// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: `${string}://${string}` | (string & {});
};

export type File = {
    url: string;
    content_type?: string;
    file_name?: string;
    file_size?: number;
};

export type QueueStatus = {
    status: 'IN_PROGRESS' | 'COMPLETED' | 'FAILED';
    response_url?: string;
};

/**
 * MusicRequest
 *
 * Request format for Elevenlabs Music API
 */
export type ElevenlabsMusicInput = {
    /**
     * Prompt
     *
     * The text prompt describing the music to generate
     */
    prompt?: string | unknown;
    /**
     * The composition plan for the music
     */
    composition_plan?: MusicCompositionPlan | unknown;
    /**
     * Music Length Ms
     *
     * The length of the song to generate in milliseconds. Used only in conjunction with prompt. Must be between 3000ms and 600000ms. Optional - if not provided, the model will choose a length based on the prompt.
     */
    music_length_ms?: number | unknown;
    /**
     * Output Format
     *
     * Output format of the generated audio. Formatted as codec_sample_rate_bitrate. So an mp3 with 22.05kHz sample rate at 32kbs is represented as mp3_22050_32. MP3 with 192kbps bitrate requires you to be subscribed to Creator tier or above. PCM with 44.1kHz sample rate requires you to be subscribed to Pro tier or above. Note that the Î¼-law format (sometimes written mu-law, often approximated as u-law) is commonly used for Twilio audio inputs.
     */
    output_format?: 'mp3_22050_32' | 'mp3_44100_32' | 'mp3_44100_64' | 'mp3_44100_96' | 'mp3_44100_128' | 'mp3_44100_192' | 'pcm_8000' | 'pcm_16000' | 'pcm_22050' | 'pcm_24000' | 'pcm_44100' | 'pcm_48000' | 'ulaw_8000' | 'alaw_8000' | 'opus_48000_32' | 'opus_48000_64' | 'opus_48000_96' | 'opus_48000_128' | 'opus_48000_192';
    /**
     * Respect Sections Durations
     *
     * Controls how strictly section durations in the composition_plan are enforced. It will only have an effect if it is used with composition_plan. When set to true, the model will precisely respect each section's duration_ms from the plan. When set to false, the model may adjust individual section durations which will generally lead to better generation quality and improved latency, while always preserving the total song duration from the plan.
     */
    respect_sections_durations?: boolean;
    /**
     * Force Instrumental
     *
     * If true, guarantees that the generated song will be instrumental. If false, the song may or may not be instrumental depending on the prompt. Can only be used with prompt.
     */
    force_instrumental?: boolean;
};

/**
 * MusicOutput
 */
export type ElevenlabsMusicOutput = {
    audio: FalAiElevenlabsMusicFile;
};

/**
 * MusicCompositionPlan
 */
export type MusicCompositionPlan = {
    /**
     * Negative Global Styles
     *
     * The styles that should not be present in the entire song.
     */
    negative_global_styles: Array<string>;
    /**
     * Sections
     *
     * The sections of the song.
     */
    sections: Array<MusicSection>;
    /**
     * Positive Global Styles
     *
     * The styles that should be present in the entire song.
     */
    positive_global_styles: Array<string>;
};

/**
 * File
 */
export type FalAiElevenlabsMusicFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
};

/**
 * MusicSection
 */
export type MusicSection = {
    /**
     * Positive Local Styles
     *
     * The styles that should be present in this section.
     */
    positive_local_styles: Array<string>;
    /**
     * Lines
     *
     * The lyrics of the section. Each line must be at most 200 characters long.
     */
    lines: Array<string>;
    /**
     * Negative Local Styles
     *
     * The styles that should not be present in this section.
     */
    negative_local_styles: Array<string>;
    /**
     * Duration Ms
     *
     * The duration of the section in milliseconds. Must be between 3000ms and 120000ms.
     */
    duration_ms: number;
    /**
     * Section Name
     *
     * The name of the section. Must be between 1 and 100 characters.
     */
    section_name: string;
};

/**
 * TextToMusic20Request
 */
export type MinimaxMusicV2Input = {
    /**
     * Prompt
     *
     * A description of the music, specifying style, mood, and scenario. 10-300 characters.
     */
    prompt: string;
    /**
     * Lyrics Prompt
     *
     * Lyrics of the song. Use n to separate lines. You may add structure tags like [Intro], [Verse], [Chorus], [Bridge], [Outro] to enhance the arrangement. 10-3000 characters.
     */
    lyrics_prompt: string;
    /**
     * Audio Setting
     *
     * Audio configuration settings
     */
    audio_setting?: AudioSetting;
};

/**
 * MusicV15Output
 */
export type MinimaxMusicV2Output = {
    /**
     * Audio
     *
     * The generated music
     */
    audio: FalAiMinimaxMusicV2File;
};

/**
 * AudioSetting
 */
export type AudioSetting = {
    /**
     * Format
     *
     * Audio format
     */
    format?: 'mp3' | 'pcm' | 'flac';
    /**
     * Sample Rate
     *
     * Sample rate of generated audio
     */
    sample_rate?: 8000 | 16000 | 22050 | 24000 | 32000 | 44100;
    /**
     * Bitrate
     *
     * Bitrate of generated audio
     */
    bitrate?: 32000 | 64000 | 128000 | 256000;
};

/**
 * File
 */
export type FalAiMinimaxMusicV2File = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * SoundEffectGenerationInput
 *
 * Input schema for sound effect generation with form controls for the playground.
 */
export type SoundEffectGenerationInput = {
    /**
     * Prompt
     *
     * Describe the sound effect you want to generate
     */
    prompt: string;
    /**
     * Duration
     *
     * Length of the generated sound effect in seconds
     */
    duration?: number;
    /**
     * Refinement
     *
     * Refinement level - Higher values may improve quality but take longer
     */
    refinement?: number;
    /**
     * Seed
     *
     * Random seed for reproducible results - leave empty for random generation
     */
    seed?: number | unknown;
    /**
     * Negative Prompt
     *
     * Describe the types of sounds you don't want to generate in the output, avoid double-negatives, compare with positive prompts
     */
    negative_prompt?: string;
    /**
     * Creativity
     *
     * Creativity level - higher values allow more creative interpretation of the prompt
     */
    creativity?: number;
};

/**
 * SoundEffectGenerationOutput
 *
 * Output schema for sound effect generation.
 */
export type SoundEffectGenerationOutput = {
    /**
     * Prompt
     *
     * The processed prompt used for generation
     */
    prompt: string;
    /**
     * Metadata
     *
     * Generation metadata including duration, sample rate, and parameters
     */
    metadata: {
        [key: string]: unknown;
    };
    audio: BeatovenSoundEffectGenerationFile;
};

/**
 * File
 */
export type BeatovenSoundEffectGenerationFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
};

/**
 * MusicGenerationInput
 *
 * Input schema for music generation with form controls for the playground.
 */
export type MusicGenerationInput = {
    /**
     * Prompt
     *
     * Describe the music you want to generate
     */
    prompt: string;
    /**
     * Duration
     *
     * Length of the generated music in seconds
     */
    duration?: number;
    /**
     * Refinement
     *
     * Refinement level - higher values may improve quality but take longer
     */
    refinement?: number;
    /**
     * Seed
     *
     * Random seed for reproducible results - leave empty for random generation
     */
    seed?: number | unknown;
    /**
     * Negative Prompt
     *
     * Describe what you want to avoid in the music (instruments, styles, moods). Leave blank for none.
     */
    negative_prompt?: string;
    /**
     * Creativity
     *
     * Creativity level - higher values allow more creative interpretation of the prompt
     */
    creativity?: number;
};

/**
 * MusicGenerationOutput
 *
 * Output schema for music generation.
 */
export type MusicGenerationOutput = {
    /**
     * Prompt
     *
     * The processed prompt used for generation
     */
    prompt: string;
    /**
     * Metadata
     *
     * Generation metadata including duration, sample rate, and parameters
     */
    metadata: {
        [key: string]: unknown;
    };
    audio: BeatovenMusicGenerationFile;
};

/**
 * File
 */
export type BeatovenMusicGenerationFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
};

/**
 * TextToMusic15Request
 */
export type MinimaxMusicV15Input = {
    /**
     * Prompt
     *
     * Lyrics, supports [intro][verse][chorus][bridge][outro] sections. 10-600 characters.
     */
    prompt: string;
    /**
     * Lyrics Prompt
     *
     * Control music generation. 10-3000 characters.
     */
    lyrics_prompt: string;
    /**
     * Audio Setting
     *
     * Audio configuration settings
     */
    audio_setting?: FalAiMinimaxMusicV15AudioSetting;
};

/**
 * MusicV15Output
 */
export type MinimaxMusicV15Output = {
    /**
     * Audio
     *
     * The generated music
     */
    audio: FalAiMinimaxMusicV15File;
};

/**
 * AudioSetting
 */
export type FalAiMinimaxMusicV15AudioSetting = {
    /**
     * Format
     *
     * Audio format
     */
    format?: 'mp3' | 'pcm' | 'flac';
    /**
     * Sample Rate
     *
     * Sample rate of generated audio
     */
    sample_rate?: 8000 | 16000 | 22050 | 24000 | 32000 | 44100;
    /**
     * Bitrate
     *
     * Bitrate of generated audio
     */
    bitrate?: 32000 | 64000 | 128000 | 256000;
};

/**
 * File
 */
export type FalAiMinimaxMusicV15File = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * TextToAudioInput
 */
export type StableAudio25TextToAudioInput = {
    /**
     * Prompt
     *
     * The prompt to generate audio from
     */
    prompt: string;
    /**
     * Sync Mode
     *
     * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
     */
    sync_mode?: boolean;
    /**
     * Seconds Total
     *
     * The duration of the audio clip to generate
     */
    seconds_total?: number;
    /**
     * Num Inference Steps
     *
     * The number of steps to denoise the audio for
     */
    num_inference_steps?: number;
    /**
     * Guidance Scale
     *
     * How strictly the diffusion process adheres to the prompt text (higher values make your audio closer to your prompt).
     */
    guidance_scale?: number;
    /**
     * Seed
     */
    seed?: number;
};

/**
 * TextToAudioOutput
 */
export type StableAudio25TextToAudioOutput = {
    /**
     * Seed
     *
     * The random seed used for generation
     */
    seed: number;
    /**
     * Audio
     *
     * The generated audio clip
     */
    audio: FalAiStableAudio25TextToAudioFile;
};

/**
 * File
 */
export type FalAiStableAudio25TextToAudioFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * TextToDialogueRequest
 */
export type ElevenlabsTextToDialogueElevenV3Input = {
    /**
     * Stability
     *
     * Determines how stable the voice is and the randomness between each generation. Lower values introduce broader emotional range for the voice. Higher values can result in a monotonous voice with limited emotion. Must be one of 0.0, 0.5, 1.0, else it will be rounded to the nearest value.
     */
    stability?: number | unknown;
    /**
     * Inputs
     *
     * A list of dialogue inputs, each containing text and a voice ID which will be converted into speech.
     */
    inputs: Array<DialogueBlock>;
    /**
     * Language Code
     *
     * Language code (ISO 639-1) used to enforce a language for the model. An error will be returned if language code is not supported by the model.
     */
    language_code?: string | unknown;
    /**
     * Seed
     *
     * Random seed for reproducibility.
     */
    seed?: number | unknown;
    /**
     * Use Speaker Boost
     *
     * This setting boosts the similarity to the original speaker. Using this setting requires a slightly higher computational load, which in turn increases latency.
     */
    use_speaker_boost?: boolean | unknown;
    /**
     * Pronunciation Dictionary Locators
     *
     * A list of pronunciation dictionary locators (id, version_id) to be applied to the text. They will be applied in order. You may have up to 3 locators per request
     */
    pronunciation_dictionary_locators?: Array<PronunciationDictionaryLocator>;
};

/**
 * TextToDialogueOutput
 */
export type ElevenlabsTextToDialogueElevenV3Output = {
    /**
     * Seed
     *
     * Random seed for reproducibility.
     */
    seed: number;
    audio: FalAiElevenlabsTextToDialogueElevenV3File;
};

/**
 * DialogueBlock
 */
export type DialogueBlock = {
    /**
     * Text
     *
     * The dialogue text
     */
    text: string;
    /**
     * Voice
     *
     * The name or the ID of the voice to be used for the generation.
     */
    voice: string;
};

/**
 * PronunciationDictionaryLocator
 */
export type PronunciationDictionaryLocator = {
    /**
     * Version Id
     *
     * The ID of the version of the pronunciation dictionary. If not provided, the latest version will be used.
     */
    version_id?: string | unknown;
    /**
     * Pronunciation Dictionary Id
     *
     * The ID of the pronunciation dictionary.
     */
    pronunciation_dictionary_id: string | unknown;
};

/**
 * File
 */
export type FalAiElevenlabsTextToDialogueElevenV3File = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
};

/**
 * SoundEffectRequestV2
 */
export type ElevenlabsSoundEffectsV2Input = {
    /**
     * Text
     *
     * The text describing the sound effect to generate
     */
    text: string;
    /**
     * Loop
     *
     * Whether to create a sound effect that loops smoothly.
     */
    loop?: boolean;
    /**
     * Prompt Influence
     *
     * How closely to follow the prompt (0-1). Higher values mean less variation.
     */
    prompt_influence?: number;
    /**
     * Output Format
     *
     * Output format of the generated audio. Formatted as codec_sample_rate_bitrate.
     */
    output_format?: 'mp3_22050_32' | 'mp3_44100_32' | 'mp3_44100_64' | 'mp3_44100_96' | 'mp3_44100_128' | 'mp3_44100_192' | 'pcm_8000' | 'pcm_16000' | 'pcm_22050' | 'pcm_24000' | 'pcm_44100' | 'pcm_48000' | 'ulaw_8000' | 'alaw_8000' | 'opus_48000_32' | 'opus_48000_64' | 'opus_48000_96' | 'opus_48000_128' | 'opus_48000_192';
    /**
     * Duration Seconds
     *
     * Duration in seconds (0.5-22). If None, optimal duration will be determined from prompt.
     */
    duration_seconds?: number | unknown;
};

/**
 * SoundEffectOutput
 *
 * Output format for generated sound effects
 */
export type ElevenlabsSoundEffectsV2Output = {
    audio: FalAiElevenlabsSoundEffectsV2File;
};

/**
 * File
 */
export type FalAiElevenlabsSoundEffectsV2File = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
};

/**
 * InpaintInput
 */
export type V2InpaintInput = {
    /**
     * Lyrics Prompt
     *
     * The lyrics sung in the generated song. An empty string will generate an instrumental track.
     */
    lyrics_prompt: string;
    /**
     * Tags
     *
     * Tags/styles of the music to generate. You can view a list of all available tags at https://sonauto.ai/tag-explorer.
     */
    tags?: Array<string>;
    /**
     * Prompt Strength
     *
     * Controls how strongly your prompt influences the output. Greater values adhere more to the prompt but sound less natural. (This is CFG.)
     */
    prompt_strength?: number;
    /**
     * Output Bit Rate
     *
     * The bit rate to use for mp3 and m4a formats. Not available for other formats.
     */
    output_bit_rate?: 128 | 192 | 256 | 320 | unknown;
    /**
     * Num Songs
     *
     * Generating 2 songs costs 1.5x the price of generating 1 song. Also, note that using the same seed may not result in identical songs if the number of songs generated is changed.
     */
    num_songs?: number;
    /**
     * Output Format
     */
    output_format?: 'flac' | 'mp3' | 'wav' | 'ogg' | 'm4a';
    /**
     * Selection Crop
     *
     * Crop to the selected region
     */
    selection_crop?: boolean;
    /**
     * Sections
     *
     * List of sections to inpaint. Currently, only one section is supported so the list length must be 1.
     */
    sections: Array<InpaintSection>;
    /**
     * Balance Strength
     *
     * Greater means more natural vocals. Lower means sharper instrumentals. We recommend 0.7.
     */
    balance_strength?: number;
    /**
     * Audio Url
     *
     * The URL of the audio file to alter. Must be a valid publicly accessible URL.
     */
    audio_url: string;
    /**
     * Seed
     *
     * The seed to use for generation. Will pick a random seed if not provided. Repeating a request with identical parameters (must use lyrics and tags, not prompt) and the same seed will generate the same song.
     */
    seed?: number | unknown;
};

/**
 * InpaintOutput
 */
export type V2InpaintOutput = {
    /**
     * Seed
     *
     * The seed used for generation. This can be used to generate an identical song by passing the same parameters with this seed in a future request.
     */
    seed: number;
    /**
     * Audio
     *
     * The generated audio files.
     */
    audio: Array<SonautoV2InpaintFile>;
};

/**
 * InpaintSection
 */
export type InpaintSection = {
    /**
     * End
     *
     * End time in seconds of the section to inpaint.
     */
    end: number;
    /**
     * Start
     *
     * Start time in seconds of the section to inpaint.
     */
    start: number;
};

/**
 * File
 */
export type SonautoV2InpaintFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
};

/**
 * GenerateInput
 */
export type V2TextToMusicInput = {
    /**
     * Prompt
     *
     * A description of the track you want to generate. This prompt will be used to automatically generate the tags and lyrics unless you manually set them. For example, if you set prompt and tags, then the prompt will be used to generate only the lyrics.
     */
    prompt?: string | unknown;
    /**
     * Lyrics Prompt
     *
     * The lyrics sung in the generated song. An empty string will generate an instrumental track.
     */
    lyrics_prompt?: string | unknown;
    /**
     * Tags
     *
     * Tags/styles of the music to generate. You can view a list of all available tags at https://sonauto.ai/tag-explorer.
     */
    tags?: Array<string> | unknown;
    /**
     * Prompt Strength
     *
     * Controls how strongly your prompt influences the output. Greater values adhere more to the prompt but sound less natural. (This is CFG.)
     */
    prompt_strength?: number;
    /**
     * Output Bit Rate
     *
     * The bit rate to use for mp3 and m4a formats. Not available for other formats.
     */
    output_bit_rate?: 128 | 192 | 256 | 320 | unknown;
    /**
     * Num Songs
     *
     * Generating 2 songs costs 1.5x the price of generating 1 song. Also, note that using the same seed may not result in identical songs if the number of songs generated is changed.
     */
    num_songs?: number;
    /**
     * Output Format
     */
    output_format?: 'flac' | 'mp3' | 'wav' | 'ogg' | 'm4a';
    /**
     * Bpm
     *
     * The beats per minute of the song. This can be set to an integer or the literal string "auto" to pick a suitable bpm based on the tags. Set bpm to null to not condition the model on bpm information.
     */
    bpm?: number | string | unknown;
    /**
     * Balance Strength
     *
     * Greater means more natural vocals. Lower means sharper instrumentals. We recommend 0.7.
     */
    balance_strength?: number;
    /**
     * Seed
     *
     * The seed to use for generation. Will pick a random seed if not provided. Repeating a request with identical parameters (must use lyrics and tags, not prompt) and the same seed will generate the same song.
     */
    seed?: number | unknown;
};

/**
 * GenerateOutput
 */
export type V2TextToMusicOutput = {
    /**
     * Tags
     *
     * The style tags used for generation.
     */
    tags?: Array<string> | unknown;
    /**
     * Seed
     *
     * The seed used for generation. This can be used to generate an identical song by passing the same parameters with this seed in a future request.
     */
    seed: number;
    /**
     * Lyrics
     *
     * The lyrics used for generation.
     */
    lyrics?: string | unknown;
    /**
     * Audio
     *
     * The generated audio files.
     */
    audio: Array<SonautoV2TextToMusicFile>;
};

/**
 * File
 */
export type SonautoV2TextToMusicFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
};

/**
 * TextToSpeechRequestV3
 *
 * Request model for eleven_v3 which doesn't support previous_text/next_text
 */
export type ElevenlabsTtsElevenV3Input = {
    /**
     * Stability
     *
     * Voice stability (0-1)
     */
    stability?: number;
    /**
     * Speed
     *
     * Speech speed (0.7-1.2). Values below 1.0 slow down the speech, above 1.0 speed it up. Extreme values may affect quality.
     */
    speed?: number;
    /**
     * Text
     *
     * The text to convert to speech
     */
    text: string;
    /**
     * Style
     *
     * Style exaggeration (0-1)
     */
    style?: number;
    /**
     * Timestamps
     *
     * Whether to return timestamps for each word in the generated speech
     */
    timestamps?: boolean;
    /**
     * Similarity Boost
     *
     * Similarity boost (0-1)
     */
    similarity_boost?: number;
    /**
     * Voice
     *
     * The voice to use for speech generation
     */
    voice?: string;
    /**
     * Language Code
     *
     * Language code (ISO 639-1) used to enforce a language for the model.
     */
    language_code?: string | unknown;
};

/**
 * TTSOutput
 */
export type ElevenlabsTtsElevenV3Output = {
    audio: FalAiElevenlabsTtsElevenV3File;
    /**
     * Timestamps
     *
     * Timestamps for each word in the generated speech. Only returned if `timestamps` is set to True in the request.
     */
    timestamps?: Array<unknown> | unknown;
};

/**
 * File
 */
export type FalAiElevenlabsTtsElevenV3File = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
};

/**
 * TextToMusicInput
 */
export type Lyria2Input = {
    /**
     * Prompt
     *
     * The text prompt describing the music you want to generate
     */
    prompt: string;
    /**
     * Seed
     *
     * A seed for deterministic generation. If provided, the model will attempt to produce the same audio given the same prompt and other parameters.
     */
    seed?: number;
    /**
     * Negative Prompt
     *
     * A description of what to exclude from the generated audio
     */
    negative_prompt?: string;
};

/**
 * TextToMusicOutput
 */
export type Lyria2Output = {
    /**
     * Audio
     *
     * The generated music
     */
    audio: FalAiLyria2File;
};

/**
 * File
 */
export type FalAiLyria2File = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * ACEStepPromptToAudioRequest
 */
export type AceStepPromptToAudioInput = {
    /**
     * Number Of Steps
     *
     * Number of steps to generate the audio.
     */
    number_of_steps?: number;
    /**
     * Duration
     *
     * The duration of the generated audio in seconds.
     */
    duration?: number;
    /**
     * Prompt
     *
     * Prompt to control the style of the generated audio. This will be used to generate tags and lyrics.
     */
    prompt: string;
    /**
     * Minimum Guidance Scale
     *
     * Minimum guidance scale for the generation after the decay.
     */
    minimum_guidance_scale?: number;
    /**
     * Tag Guidance Scale
     *
     * Tag guidance scale for the generation.
     */
    tag_guidance_scale?: number;
    /**
     * Scheduler
     *
     * Scheduler to use for the generation process.
     */
    scheduler?: 'euler' | 'heun';
    /**
     * Guidance Scale
     *
     * Guidance scale for the generation.
     */
    guidance_scale?: number;
    /**
     * Guidance Type
     *
     * Type of CFG to use for the generation process.
     */
    guidance_type?: 'cfg' | 'apg' | 'cfg_star';
    /**
     * Instrumental
     *
     * Whether to generate an instrumental version of the audio.
     */
    instrumental?: boolean;
    /**
     * Lyric Guidance Scale
     *
     * Lyric guidance scale for the generation.
     */
    lyric_guidance_scale?: number;
    /**
     * Guidance Interval
     *
     * Guidance interval for the generation. 0.5 means only apply guidance in the middle steps (0.25 * infer_steps to 0.75 * infer_steps)
     */
    guidance_interval?: number;
    /**
     * Guidance Interval Decay
     *
     * Guidance interval decay for the generation. Guidance scale will decay from guidance_scale to min_guidance_scale in the interval. 0.0 means no decay.
     */
    guidance_interval_decay?: number;
    /**
     * Seed
     *
     * Random seed for reproducibility. If not provided, a random seed will be used.
     */
    seed?: number;
    /**
     * Granularity Scale
     *
     * Granularity scale for the generation process. Higher values can reduce artifacts.
     */
    granularity_scale?: number;
};

/**
 * ACEStepResponse
 */
export type AceStepPromptToAudioOutput = {
    /**
     * Tags
     *
     * The genre tags used in the generation process.
     */
    tags: string;
    /**
     * Lyrics
     *
     * The lyrics used in the generation process.
     */
    lyrics: string;
    /**
     * Seed
     *
     * The random seed used for the generation process.
     */
    seed: number;
    /**
     * Audio
     *
     * The generated audio file.
     */
    audio: FalAiAceStepPromptToAudioFile;
};

/**
 * File
 */
export type FalAiAceStepPromptToAudioFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * ACEStepTextToAudioRequest
 */
export type AceStepInput = {
    /**
     * Number Of Steps
     *
     * Number of steps to generate the audio.
     */
    number_of_steps?: number;
    /**
     * Duration
     *
     * The duration of the generated audio in seconds.
     */
    duration?: number;
    /**
     * Tags
     *
     * Comma-separated list of genre tags to control the style of the generated audio.
     */
    tags: string;
    /**
     * Minimum Guidance Scale
     *
     * Minimum guidance scale for the generation after the decay.
     */
    minimum_guidance_scale?: number;
    /**
     * Lyrics
     *
     * Lyrics to be sung in the audio. If not provided or if [inst] or [instrumental] is the content of this field, no lyrics will be sung. Use control structures like [verse], [chorus] and [bridge] to control the structure of the song.
     */
    lyrics?: string;
    /**
     * Tag Guidance Scale
     *
     * Tag guidance scale for the generation.
     */
    tag_guidance_scale?: number;
    /**
     * Scheduler
     *
     * Scheduler to use for the generation process.
     */
    scheduler?: 'euler' | 'heun';
    /**
     * Guidance Scale
     *
     * Guidance scale for the generation.
     */
    guidance_scale?: number;
    /**
     * Guidance Type
     *
     * Type of CFG to use for the generation process.
     */
    guidance_type?: 'cfg' | 'apg' | 'cfg_star';
    /**
     * Lyric Guidance Scale
     *
     * Lyric guidance scale for the generation.
     */
    lyric_guidance_scale?: number;
    /**
     * Guidance Interval
     *
     * Guidance interval for the generation. 0.5 means only apply guidance in the middle steps (0.25 * infer_steps to 0.75 * infer_steps)
     */
    guidance_interval?: number;
    /**
     * Guidance Interval Decay
     *
     * Guidance interval decay for the generation. Guidance scale will decay from guidance_scale to min_guidance_scale in the interval. 0.0 means no decay.
     */
    guidance_interval_decay?: number;
    /**
     * Seed
     *
     * Random seed for reproducibility. If not provided, a random seed will be used.
     */
    seed?: number;
    /**
     * Granularity Scale
     *
     * Granularity scale for the generation process. Higher values can reduce artifacts.
     */
    granularity_scale?: number;
};

/**
 * ACEStepResponse
 */
export type AceStepOutput = {
    /**
     * Tags
     *
     * The genre tags used in the generation process.
     */
    tags: string;
    /**
     * Lyrics
     *
     * The lyrics used in the generation process.
     */
    lyrics: string;
    /**
     * Seed
     *
     * The random seed used for the generation process.
     */
    seed: number;
    /**
     * Audio
     *
     * The generated audio file.
     */
    audio: FalAiAceStepFile;
};

/**
 * File
 */
export type FalAiAceStepFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * Input
 */
export type SoundEffectsGeneratorInput = {
    /**
     * Prompt
     *
     * The prompt to generate SFX.
     */
    prompt: string;
    /**
     * Duration
     *
     * The duration of the generated SFX in seconds.
     */
    duration: number;
};

/**
 * AudioOutput
 *
 * Example Pydantic model showing how to include a File in the output.
 */
export type SoundEffectsGeneratorOutput = {
    audio_file: CassetteaiSoundEffectsGeneratorFile;
};

/**
 * File
 */
export type CassetteaiSoundEffectsGeneratorFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
};

/**
 * Input
 */
export type MusicGeneratorInput = {
    /**
     * Prompt
     *
     * The prompt to generate music from.
     */
    prompt: string;
    /**
     * Duration
     *
     * The duration of the generated music in seconds.
     */
    duration: number;
};

/**
 * AudioOutput
 *
 * Example Pydantic model showing how to include a File in the output.
 */
export type MusicGeneratorOutput = {
    audio_file: CassetteaiMusicGeneratorFile;
};

/**
 * File
 */
export type CassetteaiMusicGeneratorFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
};

/**
 * Input
 */
export type Csm1bInput = {
    /**
     * Scene
     *
     * The text to generate an audio from.
     */
    scene: Array<Turn>;
    /**
     * Context
     *
     * The context to generate an audio from.
     */
    context?: Array<Speaker>;
};

/**
 * Output
 */
export type Csm1bOutput = {
    /**
     * Audio
     *
     * The generated audio.
     */
    audio: FalAiCsm1bFile | Blob | File;
};

/**
 * Turn
 */
export type Turn = {
    /**
     * Text
     */
    text: string;
    /**
     * Speaker Id
     */
    speaker_id: number;
};

/**
 * Speaker
 */
export type Speaker = {
    /**
     * Prompt
     */
    prompt: string;
    /**
     * Audio Url
     */
    audio_url: string;
    /**
     * Speaker Id
     */
    speaker_id: number;
};

/**
 * File
 */
export type FalAiCsm1bFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
};

/**
 * TextToMusicInput
 */
export type DiffrhythmInput = {
    /**
     * Lyrics
     *
     * The prompt to generate the song from. Must have two sections. Sections start with either [chorus] or a [verse].
     */
    lyrics: string;
    /**
     * CFG Strength
     *
     * The CFG strength to use for the music generation.
     */
    cfg_strength?: number;
    /**
     * Reference Audio URL
     *
     * The URL of the reference audio to use for the music generation.
     */
    reference_audio_url?: string;
    /**
     * Music Duration
     *
     * The duration of the music to generate.
     */
    music_duration?: '95s' | '285s';
    /**
     * Scheduler
     *
     * The scheduler to use for the music generation.
     */
    scheduler?: 'euler' | 'midpoint' | 'rk4' | 'implicit_adams';
    /**
     * Number of Inference Steps
     *
     * The number of inference steps to use for the music generation.
     */
    num_inference_steps?: number;
    /**
     * Style Prompt
     *
     * The style prompt to use for the music generation.
     */
    style_prompt?: string;
};

/**
 * Output
 */
export type DiffrhythmOutput = {
    /**
     * Audio
     *
     * Generated music file.
     */
    audio: FalAiDiffrhythmFile;
};

/**
 * File
 */
export type FalAiDiffrhythmFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * TextToSpeechRequest
 */
export type ElevenlabsTtsMultilingualV2Input = {
    /**
     * Stability
     *
     * Voice stability (0-1)
     */
    stability?: number;
    /**
     * Next Text
     *
     * The text that comes after the text of the current request. Can be used to improve the speech's continuity when concatenating together multiple generations or to influence the speech's continuity in the current generation.
     */
    next_text?: string | unknown;
    /**
     * Speed
     *
     * Speech speed (0.7-1.2). Values below 1.0 slow down the speech, above 1.0 speed it up. Extreme values may affect quality.
     */
    speed?: number;
    /**
     * Style
     *
     * Style exaggeration (0-1)
     */
    style?: number;
    /**
     * Text
     *
     * The text to convert to speech
     */
    text: string;
    /**
     * Timestamps
     *
     * Whether to return timestamps for each word in the generated speech
     */
    timestamps?: boolean;
    /**
     * Similarity Boost
     *
     * Similarity boost (0-1)
     */
    similarity_boost?: number;
    /**
     * Voice
     *
     * The voice to use for speech generation
     */
    voice?: string;
    /**
     * Language Code
     *
     * Language code (ISO 639-1) used to enforce a language for the model. An error will be returned if language code is not supported by the model.
     */
    language_code?: string | unknown;
    /**
     * Previous Text
     *
     * The text that came before the text of the current request. Can be used to improve the speech's continuity when concatenating together multiple generations or to influence the speech's continuity in the current generation.
     */
    previous_text?: string | unknown;
};

/**
 * TTSOutput
 */
export type ElevenlabsTtsMultilingualV2Output = {
    audio: FalAiElevenlabsTtsMultilingualV2File;
    /**
     * Timestamps
     *
     * Timestamps for each word in the generated speech. Only returned if `timestamps` is set to True in the request.
     */
    timestamps?: Array<unknown> | unknown;
};

/**
 * File
 */
export type FalAiElevenlabsTtsMultilingualV2File = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
};

/**
 * HindiRequest
 */
export type KokoroHindiInput = {
    /**
     * Prompt
     */
    prompt: string;
    /**
     * Voice
     *
     * Voice ID for the desired voice.
     */
    voice: 'hf_alpha' | 'hf_beta' | 'hm_omega' | 'hm_psi';
    /**
     * Speed
     *
     * Speed of the generated audio. Default is 1.0.
     */
    speed?: number;
};

/**
 * HindiOutput
 */
export type KokoroHindiOutput = {
    /**
     * Audio
     *
     * The generated music
     */
    audio: FalAiKokoroHindiFile;
};

/**
 * File
 */
export type FalAiKokoroHindiFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * MandarinRequest
 */
export type KokoroMandarinChineseInput = {
    /**
     * Prompt
     */
    prompt: string;
    /**
     * Voice
     *
     * Voice ID for the desired voice.
     */
    voice: 'zf_xiaobei' | 'zf_xiaoni' | 'zf_xiaoxiao' | 'zf_xiaoyi' | 'zm_yunjian' | 'zm_yunxi' | 'zm_yunxia' | 'zm_yunyang';
    /**
     * Speed
     *
     * Speed of the generated audio. Default is 1.0.
     */
    speed?: number;
};

/**
 * MandarinOutput
 */
export type KokoroMandarinChineseOutput = {
    /**
     * Audio
     *
     * The generated music
     */
    audio: FalAiKokoroMandarinChineseFile;
};

/**
 * File
 */
export type FalAiKokoroMandarinChineseFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * BrPortugueseRequest
 */
export type KokoroBrazilianPortugueseInput = {
    /**
     * Prompt
     */
    prompt: string;
    /**
     * Voice
     *
     * Voice ID for the desired voice.
     */
    voice: 'pf_dora' | 'pm_alex' | 'pm_santa';
    /**
     * Speed
     *
     * Speed of the generated audio. Default is 1.0.
     */
    speed?: number;
};

/**
 * BrPortugeseOutput
 */
export type KokoroBrazilianPortugueseOutput = {
    /**
     * Audio
     *
     * The generated music
     */
    audio: FalAiKokoroBrazilianPortugueseFile;
};

/**
 * File
 */
export type FalAiKokoroBrazilianPortugueseFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * FrenchRequest
 */
export type KokoroFrenchInput = {
    /**
     * Prompt
     */
    prompt: string;
    /**
     * Voice
     *
     * Voice ID for the desired voice.
     */
    voice: 'ff_siwis';
    /**
     * Speed
     *
     * Speed of the generated audio. Default is 1.0.
     */
    speed?: number;
};

/**
 * FrenchOutput
 */
export type KokoroFrenchOutput = {
    /**
     * Audio
     *
     * The generated music
     */
    audio: FalAiKokoroFrenchFile;
};

/**
 * File
 */
export type FalAiKokoroFrenchFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * JapaneseRequest
 */
export type KokoroJapaneseInput = {
    /**
     * Prompt
     */
    prompt: string;
    /**
     * Voice
     *
     * Voice ID for the desired voice.
     */
    voice: 'jf_alpha' | 'jf_gongitsune' | 'jf_nezumi' | 'jf_tebukuro' | 'jm_kumo';
    /**
     * Speed
     *
     * Speed of the generated audio. Default is 1.0.
     */
    speed?: number;
};

/**
 * JapaneseOutput
 */
export type KokoroJapaneseOutput = {
    /**
     * Audio
     *
     * The generated music
     */
    audio: FalAiKokoroJapaneseFile;
};

/**
 * File
 */
export type FalAiKokoroJapaneseFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * AmEnglishRequest
 */
export type KokoroAmericanEnglishInput = {
    /**
     * Prompt
     */
    prompt?: string;
    /**
     * Voice
     *
     * Voice ID for the desired voice.
     */
    voice?: 'af_heart' | 'af_alloy' | 'af_aoede' | 'af_bella' | 'af_jessica' | 'af_kore' | 'af_nicole' | 'af_nova' | 'af_river' | 'af_sarah' | 'af_sky' | 'am_adam' | 'am_echo' | 'am_eric' | 'am_fenrir' | 'am_liam' | 'am_michael' | 'am_onyx' | 'am_puck' | 'am_santa';
    /**
     * Speed
     *
     * Speed of the generated audio. Default is 1.0.
     */
    speed?: number;
};

/**
 * AmEngOutput
 */
export type KokoroAmericanEnglishOutput = {
    /**
     * Audio
     *
     * The generated music
     */
    audio: FalAiKokoroAmericanEnglishFile;
};

/**
 * File
 */
export type FalAiKokoroAmericanEnglishFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * BrEnglishRequest
 */
export type KokoroBritishEnglishInput = {
    /**
     * Prompt
     */
    prompt: string;
    /**
     * Voice
     *
     * Voice ID for the desired voice.
     */
    voice: 'bf_alice' | 'bf_emma' | 'bf_isabella' | 'bf_lily' | 'bm_daniel' | 'bm_fable' | 'bm_george' | 'bm_lewis';
    /**
     * Speed
     *
     * Speed of the generated audio. Default is 1.0.
     */
    speed?: number;
};

/**
 * BrEngOutput
 */
export type KokoroBritishEnglishOutput = {
    /**
     * Audio
     *
     * The generated music
     */
    audio: FalAiKokoroBritishEnglishFile;
};

/**
 * File
 */
export type FalAiKokoroBritishEnglishFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * SpanishRequest
 */
export type KokoroSpanishInput = {
    /**
     * Prompt
     */
    prompt: string;
    /**
     * Voice
     *
     * Voice ID for the desired voice.
     */
    voice: 'ef_dora' | 'em_alex' | 'em_santa';
    /**
     * Speed
     *
     * Speed of the generated audio. Default is 1.0.
     */
    speed?: number;
};

/**
 * SpanishOutput
 */
export type KokoroSpanishOutput = {
    /**
     * Audio
     *
     * The generated music
     */
    audio: FalAiKokoroSpanishFile;
};

/**
 * File
 */
export type FalAiKokoroSpanishFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * ZonosInput
 */
export type ZonosInput = {
    /**
     * Prompt
     *
     * The content generated using cloned voice.
     */
    prompt: string;
    /**
     * Reference Audio Url
     *
     * The reference audio.
     */
    reference_audio_url: string;
};

/**
 * ZonosOutput
 */
export type ZonosOutput = {
    /**
     * Audio
     *
     * The generated audio
     */
    audio: FalAiZonosFile;
};

/**
 * File
 */
export type FalAiZonosFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * ItalianRequest
 */
export type KokoroItalianInput = {
    /**
     * Prompt
     */
    prompt: string;
    /**
     * Voice
     *
     * Voice ID for the desired voice.
     */
    voice: 'if_sara' | 'im_nicola';
    /**
     * Speed
     *
     * Speed of the generated audio. Default is 1.0.
     */
    speed?: number;
};

/**
 * ItalianOutput
 */
export type KokoroItalianOutput = {
    /**
     * Audio
     *
     * The generated music
     */
    audio: FalAiKokoroItalianFile;
};

/**
 * File
 */
export type FalAiKokoroItalianFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * TextToMusicInput
 */
export type YueInput = {
    /**
     * Lyrics
     *
     * The prompt to generate an image from. Must have two sections. Sections start with either [chorus] or a [verse].
     */
    lyrics: string;
    /**
     * Genres
     *
     * The genres (separated by a space ' ') to guide the music generation.
     */
    genres: string;
};

/**
 * Output
 */
export type YueOutput = {
    /**
     * Audio
     *
     * Generated music file.
     */
    audio: FalAiYueFile;
};

/**
 * File
 */
export type FalAiYueFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * AudioInput
 */
export type MmaudioV2TextToAudioInput = {
    /**
     * Prompt
     *
     * The prompt to generate the audio for.
     */
    prompt: string;
    /**
     * Num Steps
     *
     * The number of steps to generate the audio for.
     */
    num_steps?: number;
    /**
     * Duration
     *
     * The duration of the audio to generate.
     */
    duration?: number;
    /**
     * Cfg Strength
     *
     * The strength of Classifier Free Guidance.
     */
    cfg_strength?: number;
    /**
     * Seed
     *
     * The seed for the random number generator
     */
    seed?: number;
    /**
     * Mask Away Clip
     *
     * Whether to mask away the clip.
     */
    mask_away_clip?: boolean;
    /**
     * Negative Prompt
     *
     * The negative prompt to generate the audio for.
     */
    negative_prompt?: string;
};

/**
 * AudioOutput
 */
export type MmaudioV2TextToAudioOutput = {
    /**
     * Audio
     *
     * The generated audio.
     */
    audio: FalAiMmaudioV2TextToAudioFile;
};

/**
 * File
 */
export type FalAiMmaudioV2TextToAudioFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * TextToMusicRequest
 */
export type MinimaxMusicInput = {
    /**
     * Prompt
     *
     * Lyrics with optional formatting. You can use a newline to separate each line of lyrics. You can use two newlines to add a pause between lines. You can use double hash marks (##) at the beginning and end of the lyrics to add accompaniment. Maximum 600 characters.
     */
    prompt: string;
    /**
     * Reference Audio Url
     *
     * Reference song, should contain music and vocals. Must be a .wav or .mp3 file longer than 15 seconds.
     */
    reference_audio_url: string;
};

/**
 * MusicOutput
 */
export type MinimaxMusicOutput = {
    /**
     * Audio
     *
     * The generated music
     */
    audio: FalAiMinimaxMusicFile;
};

/**
 * File
 */
export type FalAiMinimaxMusicFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
    /**
     * File Data
     *
     * File data
     */
    file_data?: Blob | File;
};

/**
 * TTSInput
 */
export type F5TtsInput = {
    /**
     * Reference Text for the Reference Audio
     *
     * The reference text to be used for TTS. If not provided, an ASR (Automatic Speech Recognition) model will be used to generate the reference text.
     */
    ref_text?: string;
    /**
     * Remove Silence
     *
     * Whether to remove the silence from the audio file.
     */
    remove_silence?: boolean;
    /**
     * Text to be converted to speech
     *
     * The text to be converted to speech.
     */
    gen_text: string;
    /**
     * Model Type
     *
     * The name of the model to be used for TTS.
     */
    model_type: 'F5-TTS' | 'E2-TTS';
    /**
     * Reference Audio URL
     *
     * The URL of the reference audio file.
     */
    ref_audio_url: string;
};

/**
 * TTSOutput
 */
export type F5TtsOutput = {
    audio_url: AudioFile;
};

/**
 * AudioFile
 */
export type AudioFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     */
    file_name?: string;
    /**
     * Content Type
     */
    content_type?: string;
    /**
     * Url
     */
    url: string;
};

/**
 * Input
 */
export type StableAudioInput = {
    /**
     * Prompt
     *
     * The prompt to generate audio from
     */
    prompt: string;
    /**
     * Steps
     *
     * The number of steps to denoise the audio for
     */
    steps?: number;
    /**
     * Seconds Total
     *
     * The duration of the audio clip to generate
     */
    seconds_total?: number;
    /**
     * Seconds Start
     *
     * The start point of the audio clip to generate
     */
    seconds_start?: number;
};

/**
 * Output
 */
export type StableAudioOutput = {
    audio_file: FalAiStableAudioFile;
};

/**
 * File
 */
export type FalAiStableAudioFile = {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown;
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown;
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown;
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string;
};
