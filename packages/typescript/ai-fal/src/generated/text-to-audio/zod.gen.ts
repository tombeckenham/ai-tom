// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod'

export const zFile = z.object({
  url: z.url(),
  content_type: z.optional(z.string()),
  file_name: z.optional(z.string()),
  file_size: z.optional(z.int()),
})

export const zQueueStatus = z.object({
  status: z.enum(['IN_PROGRESS', 'COMPLETED', 'FAILED']),
  response_url: z.optional(z.url()),
})

/**
 * MusicSection
 */
export const zMusicSection = z.object({
  positive_local_styles: z.array(z.string()).register(z.globalRegistry, {
    description: 'The styles that should be present in this section.',
  }),
  lines: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The lyrics of the section. Each line must be at most 200 characters long.',
  }),
  negative_local_styles: z.array(z.string()).register(z.globalRegistry, {
    description: 'The styles that should not be present in this section.',
  }),
  duration_ms: z.int().gte(3000).lte(120000).register(z.globalRegistry, {
    description:
      'The duration of the section in milliseconds. Must be between 3000ms and 120000ms.',
  }),
  section_name: z.string().min(1).max(100).register(z.globalRegistry, {
    description:
      'The name of the section. Must be between 1 and 100 characters.',
  }),
})

/**
 * MusicCompositionPlan
 */
export const zMusicCompositionPlan = z.object({
  negative_global_styles: z.array(z.string()).register(z.globalRegistry, {
    description: 'The styles that should not be present in the entire song.',
  }),
  sections: z.array(zMusicSection).register(z.globalRegistry, {
    description: 'The sections of the song.',
  }),
  positive_global_styles: z.array(z.string()).register(z.globalRegistry, {
    description: 'The styles that should be present in the entire song.',
  }),
})

/**
 * MusicRequest
 *
 * Request format for Elevenlabs Music API
 */
export const zElevenlabsMusicInput = z
  .object({
    prompt: z.optional(z.union([z.string(), z.unknown()])),
    composition_plan: z.optional(z.union([zMusicCompositionPlan, z.unknown()])),
    music_length_ms: z.optional(
      z.union([z.int().gte(3000).lte(600000), z.unknown()]),
    ),
    output_format: z.optional(
      z
        .enum([
          'mp3_22050_32',
          'mp3_44100_32',
          'mp3_44100_64',
          'mp3_44100_96',
          'mp3_44100_128',
          'mp3_44100_192',
          'pcm_8000',
          'pcm_16000',
          'pcm_22050',
          'pcm_24000',
          'pcm_44100',
          'pcm_48000',
          'ulaw_8000',
          'alaw_8000',
          'opus_48000_32',
          'opus_48000_64',
          'opus_48000_96',
          'opus_48000_128',
          'opus_48000_192',
        ])
        .register(z.globalRegistry, {
          description:
            'Output format of the generated audio. Formatted as codec_sample_rate_bitrate. So an mp3 with 22.05kHz sample rate at 32kbs is represented as mp3_22050_32. MP3 with 192kbps bitrate requires you to be subscribed to Creator tier or above. PCM with 44.1kHz sample rate requires you to be subscribed to Pro tier or above. Note that the Î¼-law format (sometimes written mu-law, often approximated as u-law) is commonly used for Twilio audio inputs.',
        }),
    ),
    respect_sections_durations: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Controls how strictly section durations in the composition_plan are enforced. It will only have an effect if it is used with composition_plan. When set to true, the model will precisely respect each section's duration_ms from the plan. When set to false, the model may adjust individual section durations which will generally lead to better generation quality and improved latency, while always preserving the total song duration from the plan.",
        }),
      )
      .default(true),
    force_instrumental: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If true, guarantees that the generated song will be instrumental. If false, the song may or may not be instrumental depending on the prompt. Can only be used with prompt.',
        }),
      )
      .default(false),
  })
  .register(z.globalRegistry, {
    description: 'Request format for Elevenlabs Music API',
  })

/**
 * File
 */
export const zFalAiElevenlabsMusicFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * MusicOutput
 */
export const zElevenlabsMusicOutput = z.object({
  audio: zFalAiElevenlabsMusicFile,
})

/**
 * AudioSetting
 */
export const zAudioSetting = z.object({
  format: z.optional(
    z.enum(['mp3', 'pcm', 'flac']).register(z.globalRegistry, {
      description: 'Audio format',
    }),
  ),
  sample_rate: z.optional(
    z
      .union([
        z.literal(8000),
        z.literal(16000),
        z.literal(22050),
        z.literal(24000),
        z.literal(32000),
        z.literal(44100),
      ])
      .register(z.globalRegistry, {
        description: 'Sample rate of generated audio',
      }),
  ),
  bitrate: z.optional(
    z
      .union([
        z.literal(32000),
        z.literal(64000),
        z.literal(128000),
        z.literal(256000),
      ])
      .register(z.globalRegistry, {
        description: 'Bitrate of generated audio',
      }),
  ),
})

/**
 * TextToMusic20Request
 */
export const zMinimaxMusicV2Input = z.object({
  prompt: z.string().min(10).max(2000).register(z.globalRegistry, {
    description:
      'A description of the music, specifying style, mood, and scenario. 10-300 characters.',
  }),
  lyrics_prompt: z.string().min(10).max(3000).register(z.globalRegistry, {
    description:
      'Lyrics of the song. Use n to separate lines. You may add structure tags like [Intro], [Verse], [Chorus], [Bridge], [Outro] to enhance the arrangement. 10-3000 characters.',
  }),
  audio_setting: z.optional(zAudioSetting),
})

/**
 * File
 */
export const zFalAiMinimaxMusicV2File = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * MusicV15Output
 */
export const zMinimaxMusicV2Output = z.object({
  audio: zFalAiMinimaxMusicV2File,
})

/**
 * SoundEffectGenerationInput
 *
 * Input schema for sound effect generation with form controls for the playground.
 */
export const zSoundEffectGenerationInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'Describe the sound effect you want to generate',
    }),
    duration: z
      .optional(
        z.number().gte(1).lte(35).register(z.globalRegistry, {
          description: 'Length of the generated sound effect in seconds',
        }),
      )
      .default(5),
    refinement: z
      .optional(
        z.int().gte(10).lte(200).register(z.globalRegistry, {
          description:
            'Refinement level - Higher values may improve quality but take longer',
        }),
      )
      .default(40),
    seed: z.optional(z.union([z.int().gte(0).lte(2147483647), z.unknown()])),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe the types of sounds you don't want to generate in the output, avoid double-negatives, compare with positive prompts",
        }),
      )
      .default(''),
    creativity: z
      .optional(
        z.number().gte(1).lte(20).register(z.globalRegistry, {
          description:
            'Creativity level - higher values allow more creative interpretation of the prompt',
        }),
      )
      .default(16),
  })
  .register(z.globalRegistry, {
    description:
      'Input schema for sound effect generation with form controls for the playground.',
  })

/**
 * File
 */
export const zBeatovenSoundEffectGenerationFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * SoundEffectGenerationOutput
 *
 * Output schema for sound effect generation.
 */
export const zSoundEffectGenerationOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'The processed prompt used for generation',
    }),
    metadata: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description:
        'Generation metadata including duration, sample rate, and parameters',
    }),
    audio: zBeatovenSoundEffectGenerationFile,
  })
  .register(z.globalRegistry, {
    description: 'Output schema for sound effect generation.',
  })

/**
 * MusicGenerationInput
 *
 * Input schema for music generation with form controls for the playground.
 */
export const zMusicGenerationInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'Describe the music you want to generate',
    }),
    duration: z
      .optional(
        z.number().gte(5).lte(150).register(z.globalRegistry, {
          description: 'Length of the generated music in seconds',
        }),
      )
      .default(90),
    refinement: z
      .optional(
        z.int().gte(10).lte(200).register(z.globalRegistry, {
          description:
            'Refinement level - higher values may improve quality but take longer',
        }),
      )
      .default(100),
    seed: z.optional(z.union([z.int().gte(0).lte(2147483647), z.unknown()])),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'Describe what you want to avoid in the music (instruments, styles, moods). Leave blank for none.',
        }),
      )
      .default(''),
    creativity: z
      .optional(
        z.number().gte(1).lte(20).register(z.globalRegistry, {
          description:
            'Creativity level - higher values allow more creative interpretation of the prompt',
        }),
      )
      .default(16),
  })
  .register(z.globalRegistry, {
    description:
      'Input schema for music generation with form controls for the playground.',
  })

/**
 * File
 */
export const zBeatovenMusicGenerationFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * MusicGenerationOutput
 *
 * Output schema for music generation.
 */
export const zMusicGenerationOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'The processed prompt used for generation',
    }),
    metadata: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description:
        'Generation metadata including duration, sample rate, and parameters',
    }),
    audio: zBeatovenMusicGenerationFile,
  })
  .register(z.globalRegistry, {
    description: 'Output schema for music generation.',
  })

/**
 * AudioSetting
 */
export const zFalAiMinimaxMusicV15AudioSetting = z.object({
  format: z.optional(
    z.enum(['mp3', 'pcm', 'flac']).register(z.globalRegistry, {
      description: 'Audio format',
    }),
  ),
  sample_rate: z.optional(
    z
      .union([
        z.literal(8000),
        z.literal(16000),
        z.literal(22050),
        z.literal(24000),
        z.literal(32000),
        z.literal(44100),
      ])
      .register(z.globalRegistry, {
        description: 'Sample rate of generated audio',
      }),
  ),
  bitrate: z.optional(
    z
      .union([
        z.literal(32000),
        z.literal(64000),
        z.literal(128000),
        z.literal(256000),
      ])
      .register(z.globalRegistry, {
        description: 'Bitrate of generated audio',
      }),
  ),
})

/**
 * TextToMusic15Request
 */
export const zMinimaxMusicV15Input = z.object({
  prompt: z.string().min(10).max(600).register(z.globalRegistry, {
    description:
      'Lyrics, supports [intro][verse][chorus][bridge][outro] sections. 10-600 characters.',
  }),
  lyrics_prompt: z.string().min(10).max(3000).register(z.globalRegistry, {
    description: 'Control music generation. 10-3000 characters.',
  }),
  audio_setting: z.optional(zFalAiMinimaxMusicV15AudioSetting),
})

/**
 * File
 */
export const zFalAiMinimaxMusicV15File = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * MusicV15Output
 */
export const zMinimaxMusicV15Output = z.object({
  audio: zFalAiMinimaxMusicV15File,
})

/**
 * TextToAudioInput
 */
export const zStableAudio25TextToAudioInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate audio from',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seconds_total: z
    .optional(
      z.int().gte(1).lte(190).register(z.globalRegistry, {
        description: 'The duration of the audio clip to generate',
      }),
    )
    .default(190),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(8).register(z.globalRegistry, {
        description: 'The number of steps to denoise the audio for',
      }),
    )
    .default(8),
  guidance_scale: z
    .optional(
      z.int().gte(1).lte(25).register(z.globalRegistry, {
        description:
          'How strictly the diffusion process adheres to the prompt text (higher values make your audio closer to your prompt).',
      }),
    )
    .default(1),
  seed: z.optional(z.int()),
})

/**
 * File
 */
export const zFalAiStableAudio25TextToAudioFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * TextToAudioOutput
 */
export const zStableAudio25TextToAudioOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The random seed used for generation',
  }),
  audio: zFalAiStableAudio25TextToAudioFile,
})

/**
 * DialogueBlock
 */
export const zDialogueBlock = z.object({
  text: z.string().register(z.globalRegistry, {
    description: 'The dialogue text',
  }),
  voice: z.string().register(z.globalRegistry, {
    description:
      'The name or the ID of the voice to be used for the generation.',
  }),
})

/**
 * PronunciationDictionaryLocator
 */
export const zPronunciationDictionaryLocator = z.object({
  version_id: z.optional(z.union([z.string(), z.unknown()])),
  pronunciation_dictionary_id: z.union([z.string(), z.unknown()]),
})

/**
 * TextToDialogueRequest
 */
export const zElevenlabsTextToDialogueElevenV3Input = z.object({
  stability: z.optional(z.union([z.number().gte(0).lte(1), z.unknown()])),
  inputs: z.array(zDialogueBlock).register(z.globalRegistry, {
    description:
      'A list of dialogue inputs, each containing text and a voice ID which will be converted into speech.',
  }),
  language_code: z.optional(z.union([z.string(), z.unknown()])),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  use_speaker_boost: z.optional(z.union([z.boolean(), z.unknown()])),
  pronunciation_dictionary_locators: z
    .optional(
      z.array(zPronunciationDictionaryLocator).register(z.globalRegistry, {
        description:
          'A list of pronunciation dictionary locators (id, version_id) to be applied to the text. They will be applied in order. You may have up to 3 locators per request',
      }),
    )
    .default([]),
})

/**
 * File
 */
export const zFalAiElevenlabsTextToDialogueElevenV3File = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * TextToDialogueOutput
 */
export const zElevenlabsTextToDialogueElevenV3Output = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'Random seed for reproducibility.',
  }),
  audio: zFalAiElevenlabsTextToDialogueElevenV3File,
})

/**
 * SoundEffectRequestV2
 */
export const zElevenlabsSoundEffectsV2Input = z.object({
  text: z.string().register(z.globalRegistry, {
    description: 'The text describing the sound effect to generate',
  }),
  loop: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to create a sound effect that loops smoothly.',
      }),
    )
    .default(false),
  prompt_influence: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'How closely to follow the prompt (0-1). Higher values mean less variation.',
      }),
    )
    .default(0.3),
  output_format: z.optional(
    z
      .enum([
        'mp3_22050_32',
        'mp3_44100_32',
        'mp3_44100_64',
        'mp3_44100_96',
        'mp3_44100_128',
        'mp3_44100_192',
        'pcm_8000',
        'pcm_16000',
        'pcm_22050',
        'pcm_24000',
        'pcm_44100',
        'pcm_48000',
        'ulaw_8000',
        'alaw_8000',
        'opus_48000_32',
        'opus_48000_64',
        'opus_48000_96',
        'opus_48000_128',
        'opus_48000_192',
      ])
      .register(z.globalRegistry, {
        description:
          'Output format of the generated audio. Formatted as codec_sample_rate_bitrate.',
      }),
  ),
  duration_seconds: z.optional(
    z.union([z.number().gte(0.5).lte(22), z.unknown()]),
  ),
})

/**
 * File
 */
export const zFalAiElevenlabsSoundEffectsV2File = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * SoundEffectOutput
 *
 * Output format for generated sound effects
 */
export const zElevenlabsSoundEffectsV2Output = z
  .object({
    audio: zFalAiElevenlabsSoundEffectsV2File,
  })
  .register(z.globalRegistry, {
    description: 'Output format for generated sound effects',
  })

/**
 * InpaintSection
 */
export const zInpaintSection = z.object({
  end: z.number().register(z.globalRegistry, {
    description: 'End time in seconds of the section to inpaint.',
  }),
  start: z.number().gte(0).register(z.globalRegistry, {
    description: 'Start time in seconds of the section to inpaint.',
  }),
})

/**
 * InpaintInput
 */
export const zV2InpaintInput = z.object({
  lyrics_prompt: z.string().register(z.globalRegistry, {
    description:
      'The lyrics sung in the generated song. An empty string will generate an instrumental track.',
  }),
  tags: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'Tags/styles of the music to generate. You can view a list of all available tags at https://sonauto.ai/tag-explorer.',
    }),
  ),
  prompt_strength: z
    .optional(
      z.number().gte(1.4).lte(3.1).register(z.globalRegistry, {
        description:
          'Controls how strongly your prompt influences the output. Greater values adhere more to the prompt but sound less natural. (This is CFG.)',
      }),
    )
    .default(2),
  output_bit_rate: z.optional(
    z.union([
      z.union([z.literal(128), z.literal(192), z.literal(256), z.literal(320)]),
      z.unknown(),
    ]),
  ),
  num_songs: z
    .optional(
      z.int().gte(1).lte(2).register(z.globalRegistry, {
        description:
          'Generating 2 songs costs 1.5x the price of generating 1 song. Also, note that using the same seed may not result in identical songs if the number of songs generated is changed.',
      }),
    )
    .default(1),
  output_format: z.optional(z.enum(['flac', 'mp3', 'wav', 'ogg', 'm4a'])),
  selection_crop: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Crop to the selected region',
      }),
    )
    .default(false),
  sections: z.array(zInpaintSection).register(z.globalRegistry, {
    description:
      'List of sections to inpaint. Currently, only one section is supported so the list length must be 1.',
  }),
  balance_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Greater means more natural vocals. Lower means sharper instrumentals. We recommend 0.7.',
      }),
    )
    .default(0.7),
  audio_url: z.url().min(1).max(2083).register(z.globalRegistry, {
    description:
      'The URL of the audio file to alter. Must be a valid publicly accessible URL.',
  }),
  seed: z.optional(
    z.union([
      z.int().gte(-9223372036854776000).lte(9223372036854776000),
      z.unknown(),
    ]),
  ),
})

/**
 * File
 */
export const zSonautoV2InpaintFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * InpaintOutput
 */
export const zV2InpaintOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description:
      'The seed used for generation. This can be used to generate an identical song by passing the same parameters with this seed in a future request.',
  }),
  audio: z.array(zSonautoV2InpaintFile).register(z.globalRegistry, {
    description: 'The generated audio files.',
  }),
})

/**
 * GenerateInput
 */
export const zV2TextToMusicInput = z.object({
  prompt: z.optional(z.union([z.string(), z.unknown()])),
  lyrics_prompt: z.optional(z.union([z.string(), z.unknown()])),
  tags: z.optional(z.union([z.array(z.string()), z.unknown()])),
  prompt_strength: z
    .optional(
      z.number().gte(1.4).lte(3.1).register(z.globalRegistry, {
        description:
          'Controls how strongly your prompt influences the output. Greater values adhere more to the prompt but sound less natural. (This is CFG.)',
      }),
    )
    .default(2),
  output_bit_rate: z.optional(
    z.union([
      z.union([z.literal(128), z.literal(192), z.literal(256), z.literal(320)]),
      z.unknown(),
    ]),
  ),
  num_songs: z
    .optional(
      z.int().gte(1).lte(2).register(z.globalRegistry, {
        description:
          'Generating 2 songs costs 1.5x the price of generating 1 song. Also, note that using the same seed may not result in identical songs if the number of songs generated is changed.',
      }),
    )
    .default(1),
  output_format: z.optional(z.enum(['flac', 'mp3', 'wav', 'ogg', 'm4a'])),
  bpm: z.optional(z.union([z.int(), z.string(), z.unknown()])),
  balance_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Greater means more natural vocals. Lower means sharper instrumentals. We recommend 0.7.',
      }),
    )
    .default(0.7),
  seed: z.optional(
    z.union([
      z.int().gte(-9223372036854776000).lte(9223372036854776000),
      z.unknown(),
    ]),
  ),
})

/**
 * File
 */
export const zSonautoV2TextToMusicFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * GenerateOutput
 */
export const zV2TextToMusicOutput = z.object({
  tags: z.optional(z.union([z.array(z.string()), z.unknown()])),
  seed: z.int().register(z.globalRegistry, {
    description:
      'The seed used for generation. This can be used to generate an identical song by passing the same parameters with this seed in a future request.',
  }),
  lyrics: z.optional(z.union([z.string(), z.unknown()])),
  audio: z.array(zSonautoV2TextToMusicFile).register(z.globalRegistry, {
    description: 'The generated audio files.',
  }),
})

/**
 * TextToSpeechRequestV3
 *
 * Request model for eleven_v3 which doesn't support previous_text/next_text
 */
export const zElevenlabsTtsElevenV3Input = z
  .object({
    stability: z
      .optional(
        z.number().gte(0).lte(1).register(z.globalRegistry, {
          description: 'Voice stability (0-1)',
        }),
      )
      .default(0.5),
    speed: z
      .optional(
        z.number().gte(0.7).lte(1.2).register(z.globalRegistry, {
          description:
            'Speech speed (0.7-1.2). Values below 1.0 slow down the speech, above 1.0 speed it up. Extreme values may affect quality.',
        }),
      )
      .default(1),
    text: z.string().min(1).max(5000).register(z.globalRegistry, {
      description: 'The text to convert to speech',
    }),
    style: z
      .optional(
        z.number().gte(0).lte(1).register(z.globalRegistry, {
          description: 'Style exaggeration (0-1)',
        }),
      )
      .default(0),
    timestamps: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to return timestamps for each word in the generated speech',
        }),
      )
      .default(false),
    similarity_boost: z
      .optional(
        z.number().gte(0).lte(1).register(z.globalRegistry, {
          description: 'Similarity boost (0-1)',
        }),
      )
      .default(0.75),
    voice: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The voice to use for speech generation',
        }),
      )
      .default('Rachel'),
    language_code: z.optional(z.union([z.string(), z.unknown()])),
  })
  .register(z.globalRegistry, {
    description:
      "Request model for eleven_v3 which doesn't support previous_text/next_text",
  })

/**
 * File
 */
export const zFalAiElevenlabsTtsElevenV3File = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * TTSOutput
 */
export const zElevenlabsTtsElevenV3Output = z.object({
  audio: zFalAiElevenlabsTtsElevenV3File,
  timestamps: z.optional(z.union([z.array(z.unknown()), z.unknown()])),
})

/**
 * TextToMusicInput
 */
export const zLyria2Input = z.object({
  prompt: z.string().min(1).max(2000).register(z.globalRegistry, {
    description: 'The text prompt describing the music you want to generate',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'A seed for deterministic generation. If provided, the model will attempt to produce the same audio given the same prompt and other parameters.',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'A description of what to exclude from the generated audio',
      }),
    )
    .default('low quality'),
})

/**
 * File
 */
export const zFalAiLyria2File = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * TextToMusicOutput
 */
export const zLyria2Output = z.object({
  audio: zFalAiLyria2File,
})

/**
 * ACEStepPromptToAudioRequest
 */
export const zAceStepPromptToAudioInput = z.object({
  number_of_steps: z
    .optional(
      z.int().gte(3).lte(60).register(z.globalRegistry, {
        description: 'Number of steps to generate the audio.',
      }),
    )
    .default(27),
  duration: z
    .optional(
      z.number().gte(5).lte(240).register(z.globalRegistry, {
        description: 'The duration of the generated audio in seconds.',
      }),
    )
    .default(60),
  prompt: z.string().register(z.globalRegistry, {
    description:
      'Prompt to control the style of the generated audio. This will be used to generate tags and lyrics.',
  }),
  minimum_guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description:
          'Minimum guidance scale for the generation after the decay.',
      }),
    )
    .default(3),
  tag_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Tag guidance scale for the generation.',
      }),
    )
    .default(5),
  scheduler: z.optional(
    z.enum(['euler', 'heun']).register(z.globalRegistry, {
      description: 'Scheduler to use for the generation process.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description: 'Guidance scale for the generation.',
      }),
    )
    .default(15),
  guidance_type: z.optional(
    z.enum(['cfg', 'apg', 'cfg_star']).register(z.globalRegistry, {
      description: 'Type of CFG to use for the generation process.',
    }),
  ),
  instrumental: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to generate an instrumental version of the audio.',
      }),
    )
    .default(false),
  lyric_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Lyric guidance scale for the generation.',
      }),
    )
    .default(1.5),
  guidance_interval: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Guidance interval for the generation. 0.5 means only apply guidance in the middle steps (0.25 * infer_steps to 0.75 * infer_steps)',
      }),
    )
    .default(0.5),
  guidance_interval_decay: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Guidance interval decay for the generation. Guidance scale will decay from guidance_scale to min_guidance_scale in the interval. 0.0 means no decay.',
      }),
    )
    .default(0),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If not provided, a random seed will be used.',
    }),
  ),
  granularity_scale: z
    .optional(
      z.int().gte(-100).lte(100).register(z.globalRegistry, {
        description:
          'Granularity scale for the generation process. Higher values can reduce artifacts.',
      }),
    )
    .default(10),
})

/**
 * File
 */
export const zFalAiAceStepPromptToAudioFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ACEStepResponse
 */
export const zAceStepPromptToAudioOutput = z.object({
  tags: z.string().register(z.globalRegistry, {
    description: 'The genre tags used in the generation process.',
  }),
  lyrics: z.string().register(z.globalRegistry, {
    description: 'The lyrics used in the generation process.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The random seed used for the generation process.',
  }),
  audio: zFalAiAceStepPromptToAudioFile,
})

/**
 * ACEStepTextToAudioRequest
 */
export const zAceStepInput = z.object({
  number_of_steps: z
    .optional(
      z.int().gte(3).lte(60).register(z.globalRegistry, {
        description: 'Number of steps to generate the audio.',
      }),
    )
    .default(27),
  duration: z
    .optional(
      z.number().gte(5).lte(240).register(z.globalRegistry, {
        description: 'The duration of the generated audio in seconds.',
      }),
    )
    .default(60),
  tags: z.string().register(z.globalRegistry, {
    description:
      'Comma-separated list of genre tags to control the style of the generated audio.',
  }),
  minimum_guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description:
          'Minimum guidance scale for the generation after the decay.',
      }),
    )
    .default(3),
  lyrics: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Lyrics to be sung in the audio. If not provided or if [inst] or [instrumental] is the content of this field, no lyrics will be sung. Use control structures like [verse], [chorus] and [bridge] to control the structure of the song.',
      }),
    )
    .default(''),
  tag_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Tag guidance scale for the generation.',
      }),
    )
    .default(5),
  scheduler: z.optional(
    z.enum(['euler', 'heun']).register(z.globalRegistry, {
      description: 'Scheduler to use for the generation process.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description: 'Guidance scale for the generation.',
      }),
    )
    .default(15),
  guidance_type: z.optional(
    z.enum(['cfg', 'apg', 'cfg_star']).register(z.globalRegistry, {
      description: 'Type of CFG to use for the generation process.',
    }),
  ),
  lyric_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Lyric guidance scale for the generation.',
      }),
    )
    .default(1.5),
  guidance_interval: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Guidance interval for the generation. 0.5 means only apply guidance in the middle steps (0.25 * infer_steps to 0.75 * infer_steps)',
      }),
    )
    .default(0.5),
  guidance_interval_decay: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Guidance interval decay for the generation. Guidance scale will decay from guidance_scale to min_guidance_scale in the interval. 0.0 means no decay.',
      }),
    )
    .default(0),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If not provided, a random seed will be used.',
    }),
  ),
  granularity_scale: z
    .optional(
      z.int().gte(-100).lte(100).register(z.globalRegistry, {
        description:
          'Granularity scale for the generation process. Higher values can reduce artifacts.',
      }),
    )
    .default(10),
})

/**
 * File
 */
export const zFalAiAceStepFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ACEStepResponse
 */
export const zAceStepOutput = z.object({
  tags: z.string().register(z.globalRegistry, {
    description: 'The genre tags used in the generation process.',
  }),
  lyrics: z.string().register(z.globalRegistry, {
    description: 'The lyrics used in the generation process.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The random seed used for the generation process.',
  }),
  audio: zFalAiAceStepFile,
})

/**
 * Input
 */
export const zSoundEffectsGeneratorInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate SFX.',
  }),
  duration: z.int().gte(1).lte(30).register(z.globalRegistry, {
    description: 'The duration of the generated SFX in seconds.',
  }),
})

/**
 * File
 */
export const zCassetteaiSoundEffectsGeneratorFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * AudioOutput
 *
 * Example Pydantic model showing how to include a File in the output.
 */
export const zSoundEffectsGeneratorOutput = z
  .object({
    audio_file: zCassetteaiSoundEffectsGeneratorFile,
  })
  .register(z.globalRegistry, {
    description:
      'Example Pydantic model showing how to include a File in the output.',
  })

/**
 * Input
 */
export const zMusicGeneratorInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate music from.',
  }),
  duration: z.int().gte(10).lte(180).register(z.globalRegistry, {
    description: 'The duration of the generated music in seconds.',
  }),
})

/**
 * File
 */
export const zCassetteaiMusicGeneratorFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * AudioOutput
 *
 * Example Pydantic model showing how to include a File in the output.
 */
export const zMusicGeneratorOutput = z
  .object({
    audio_file: zCassetteaiMusicGeneratorFile,
  })
  .register(z.globalRegistry, {
    description:
      'Example Pydantic model showing how to include a File in the output.',
  })

/**
 * Turn
 */
export const zTurn = z.object({
  text: z.string(),
  speaker_id: z.int(),
})

/**
 * Speaker
 */
export const zSpeaker = z.object({
  prompt: z.string(),
  audio_url: z.string(),
  speaker_id: z.int(),
})

/**
 * Input
 */
export const zCsm1bInput = z.object({
  scene: z.array(zTurn).register(z.globalRegistry, {
    description: 'The text to generate an audio from.',
  }),
  context: z.optional(
    z.array(zSpeaker).register(z.globalRegistry, {
      description: 'The context to generate an audio from.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiCsm1bFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * Output
 */
export const zCsm1bOutput = z.object({
  audio: z.union([zFalAiCsm1bFile, z.string()]),
})

/**
 * TextToMusicInput
 */
export const zDiffrhythmInput = z.object({
  lyrics: z.string().register(z.globalRegistry, {
    description:
      'The prompt to generate the song from. Must have two sections. Sections start with either [chorus] or a [verse].',
  }),
  cfg_strength: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: 'The CFG strength to use for the music generation.',
      }),
    )
    .default(4),
  reference_audio_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The URL of the reference audio to use for the music generation.',
    }),
  ),
  music_duration: z.optional(
    z.enum(['95s', '285s']).register(z.globalRegistry, {
      description: 'The duration of the music to generate.',
    }),
  ),
  scheduler: z.optional(
    z
      .enum(['euler', 'midpoint', 'rk4', 'implicit_adams'])
      .register(z.globalRegistry, {
        description: 'The scheduler to use for the music generation.',
      }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(100).register(z.globalRegistry, {
        description:
          'The number of inference steps to use for the music generation.',
      }),
    )
    .default(32),
  style_prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The style prompt to use for the music generation.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiDiffrhythmFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Output
 */
export const zDiffrhythmOutput = z.object({
  audio: zFalAiDiffrhythmFile,
})

/**
 * TextToSpeechRequest
 */
export const zElevenlabsTtsMultilingualV2Input = z.object({
  stability: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Voice stability (0-1)',
      }),
    )
    .default(0.5),
  next_text: z.optional(z.union([z.string(), z.unknown()])),
  speed: z
    .optional(
      z.number().gte(0.7).lte(1.2).register(z.globalRegistry, {
        description:
          'Speech speed (0.7-1.2). Values below 1.0 slow down the speech, above 1.0 speed it up. Extreme values may affect quality.',
      }),
    )
    .default(1),
  style: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Style exaggeration (0-1)',
      }),
    )
    .default(0),
  text: z.string().min(1).register(z.globalRegistry, {
    description: 'The text to convert to speech',
  }),
  timestamps: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to return timestamps for each word in the generated speech',
      }),
    )
    .default(false),
  similarity_boost: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Similarity boost (0-1)',
      }),
    )
    .default(0.75),
  voice: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The voice to use for speech generation',
      }),
    )
    .default('Rachel'),
  language_code: z.optional(z.union([z.string(), z.unknown()])),
  previous_text: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * File
 */
export const zFalAiElevenlabsTtsMultilingualV2File = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * TTSOutput
 */
export const zElevenlabsTtsMultilingualV2Output = z.object({
  audio: zFalAiElevenlabsTtsMultilingualV2File,
  timestamps: z.optional(z.union([z.array(z.unknown()), z.unknown()])),
})

/**
 * HindiRequest
 */
export const zKokoroHindiInput = z.object({
  prompt: z.string(),
  voice: z
    .enum(['hf_alpha', 'hf_beta', 'hm_omega', 'hm_psi'])
    .register(z.globalRegistry, {
      description: 'Voice ID for the desired voice.',
    }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * File
 */
export const zFalAiKokoroHindiFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * HindiOutput
 */
export const zKokoroHindiOutput = z.object({
  audio: zFalAiKokoroHindiFile,
})

/**
 * MandarinRequest
 */
export const zKokoroMandarinChineseInput = z.object({
  prompt: z.string(),
  voice: z
    .enum([
      'zf_xiaobei',
      'zf_xiaoni',
      'zf_xiaoxiao',
      'zf_xiaoyi',
      'zm_yunjian',
      'zm_yunxi',
      'zm_yunxia',
      'zm_yunyang',
    ])
    .register(z.globalRegistry, {
      description: 'Voice ID for the desired voice.',
    }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * File
 */
export const zFalAiKokoroMandarinChineseFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * MandarinOutput
 */
export const zKokoroMandarinChineseOutput = z.object({
  audio: zFalAiKokoroMandarinChineseFile,
})

/**
 * BrPortugueseRequest
 */
export const zKokoroBrazilianPortugueseInput = z.object({
  prompt: z.string(),
  voice: z.enum(['pf_dora', 'pm_alex', 'pm_santa']).register(z.globalRegistry, {
    description: 'Voice ID for the desired voice.',
  }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * File
 */
export const zFalAiKokoroBrazilianPortugueseFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * BrPortugeseOutput
 */
export const zKokoroBrazilianPortugueseOutput = z.object({
  audio: zFalAiKokoroBrazilianPortugueseFile,
})

/**
 * FrenchRequest
 */
export const zKokoroFrenchInput = z.object({
  prompt: z.string(),
  voice: z.enum(['ff_siwis']).register(z.globalRegistry, {
    description: 'Voice ID for the desired voice.',
  }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * File
 */
export const zFalAiKokoroFrenchFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * FrenchOutput
 */
export const zKokoroFrenchOutput = z.object({
  audio: zFalAiKokoroFrenchFile,
})

/**
 * JapaneseRequest
 */
export const zKokoroJapaneseInput = z.object({
  prompt: z.string(),
  voice: z
    .enum(['jf_alpha', 'jf_gongitsune', 'jf_nezumi', 'jf_tebukuro', 'jm_kumo'])
    .register(z.globalRegistry, {
      description: 'Voice ID for the desired voice.',
    }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * File
 */
export const zFalAiKokoroJapaneseFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * JapaneseOutput
 */
export const zKokoroJapaneseOutput = z.object({
  audio: zFalAiKokoroJapaneseFile,
})

/**
 * AmEnglishRequest
 */
export const zKokoroAmericanEnglishInput = z.object({
  prompt: z.optional(z.string()).default(''),
  voice: z.optional(
    z
      .enum([
        'af_heart',
        'af_alloy',
        'af_aoede',
        'af_bella',
        'af_jessica',
        'af_kore',
        'af_nicole',
        'af_nova',
        'af_river',
        'af_sarah',
        'af_sky',
        'am_adam',
        'am_echo',
        'am_eric',
        'am_fenrir',
        'am_liam',
        'am_michael',
        'am_onyx',
        'am_puck',
        'am_santa',
      ])
      .register(z.globalRegistry, {
        description: 'Voice ID for the desired voice.',
      }),
  ),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * File
 */
export const zFalAiKokoroAmericanEnglishFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * AmEngOutput
 */
export const zKokoroAmericanEnglishOutput = z.object({
  audio: zFalAiKokoroAmericanEnglishFile,
})

/**
 * BrEnglishRequest
 */
export const zKokoroBritishEnglishInput = z.object({
  prompt: z.string(),
  voice: z
    .enum([
      'bf_alice',
      'bf_emma',
      'bf_isabella',
      'bf_lily',
      'bm_daniel',
      'bm_fable',
      'bm_george',
      'bm_lewis',
    ])
    .register(z.globalRegistry, {
      description: 'Voice ID for the desired voice.',
    }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * File
 */
export const zFalAiKokoroBritishEnglishFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * BrEngOutput
 */
export const zKokoroBritishEnglishOutput = z.object({
  audio: zFalAiKokoroBritishEnglishFile,
})

/**
 * SpanishRequest
 */
export const zKokoroSpanishInput = z.object({
  prompt: z.string(),
  voice: z.enum(['ef_dora', 'em_alex', 'em_santa']).register(z.globalRegistry, {
    description: 'Voice ID for the desired voice.',
  }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * File
 */
export const zFalAiKokoroSpanishFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * SpanishOutput
 */
export const zKokoroSpanishOutput = z.object({
  audio: zFalAiKokoroSpanishFile,
})

/**
 * ZonosInput
 */
export const zZonosInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The content generated using cloned voice.',
  }),
  reference_audio_url: z.string().register(z.globalRegistry, {
    description: 'The reference audio.',
  }),
})

/**
 * File
 */
export const zFalAiZonosFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ZonosOutput
 */
export const zZonosOutput = z.object({
  audio: zFalAiZonosFile,
})

/**
 * ItalianRequest
 */
export const zKokoroItalianInput = z.object({
  prompt: z.string(),
  voice: z.enum(['if_sara', 'im_nicola']).register(z.globalRegistry, {
    description: 'Voice ID for the desired voice.',
  }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * File
 */
export const zFalAiKokoroItalianFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ItalianOutput
 */
export const zKokoroItalianOutput = z.object({
  audio: zFalAiKokoroItalianFile,
})

/**
 * TextToMusicInput
 */
export const zYueInput = z.object({
  lyrics: z.string().register(z.globalRegistry, {
    description:
      'The prompt to generate an image from. Must have two sections. Sections start with either [chorus] or a [verse].',
  }),
  genres: z.string().register(z.globalRegistry, {
    description:
      "The genres (separated by a space ' ') to guide the music generation.",
  }),
})

/**
 * File
 */
export const zFalAiYueFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Output
 */
export const zYueOutput = z.object({
  audio: zFalAiYueFile,
})

/**
 * AudioInput
 */
export const zMmaudioV2TextToAudioInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the audio for.',
  }),
  num_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: 'The number of steps to generate the audio for.',
      }),
    )
    .default(25),
  duration: z
    .optional(
      z.number().gte(1).lte(30).register(z.globalRegistry, {
        description: 'The duration of the audio to generate.',
      }),
    )
    .default(8),
  cfg_strength: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'The strength of Classifier Free Guidance.',
      }),
    )
    .default(4.5),
  seed: z.optional(
    z.int().gte(0).lte(65535).register(z.globalRegistry, {
      description: 'The seed for the random number generator',
    }),
  ),
  mask_away_clip: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to mask away the clip.',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to generate the audio for.',
      }),
    )
    .default(''),
})

/**
 * File
 */
export const zFalAiMmaudioV2TextToAudioFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * AudioOutput
 */
export const zMmaudioV2TextToAudioOutput = z.object({
  audio: zFalAiMmaudioV2TextToAudioFile,
})

/**
 * TextToMusicRequest
 */
export const zMinimaxMusicInput = z.object({
  prompt: z.string().min(1).max(600).register(z.globalRegistry, {
    description:
      'Lyrics with optional formatting. You can use a newline to separate each line of lyrics. You can use two newlines to add a pause between lines. You can use double hash marks (##) at the beginning and end of the lyrics to add accompaniment. Maximum 600 characters.',
  }),
  reference_audio_url: z.string().register(z.globalRegistry, {
    description:
      'Reference song, should contain music and vocals. Must be a .wav or .mp3 file longer than 15 seconds.',
  }),
})

/**
 * File
 */
export const zFalAiMinimaxMusicFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * MusicOutput
 */
export const zMinimaxMusicOutput = z.object({
  audio: zFalAiMinimaxMusicFile,
})

/**
 * TTSInput
 */
export const zF5TtsInput = z.object({
  ref_text: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The reference text to be used for TTS. If not provided, an ASR (Automatic Speech Recognition) model will be used to generate the reference text.',
      }),
    )
    .default(''),
  remove_silence: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to remove the silence from the audio file.',
      }),
    )
    .default(true),
  gen_text: z.string().register(z.globalRegistry, {
    description: 'The text to be converted to speech.',
  }),
  model_type: z.enum(['F5-TTS', 'E2-TTS']).register(z.globalRegistry, {
    description: 'The name of the model to be used for TTS.',
  }),
  ref_audio_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the reference audio file.',
  }),
})

/**
 * AudioFile
 */
export const zAudioFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z
    .optional(z.string())
    .default('8535dd59e911496a947daa35c07e67a3_tmplkcy6tut.wav'),
  content_type: z.optional(z.string()).default('audio/wav'),
  url: z.string(),
})

/**
 * TTSOutput
 */
export const zF5TtsOutput = z.object({
  audio_url: zAudioFile,
})

/**
 * Input
 */
export const zStableAudioInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate audio from',
  }),
  steps: z
    .optional(
      z.int().gte(1).lte(1000).register(z.globalRegistry, {
        description: 'The number of steps to denoise the audio for',
      }),
    )
    .default(100),
  seconds_total: z
    .optional(
      z.int().gte(0).lte(47).register(z.globalRegistry, {
        description: 'The duration of the audio clip to generate',
      }),
    )
    .default(30),
  seconds_start: z
    .optional(
      z.int().gte(0).lte(47).register(z.globalRegistry, {
        description: 'The start point of the audio clip to generate',
      }),
    )
    .default(0),
})

/**
 * File
 */
export const zFalAiStableAudioFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * Output
 */
export const zStableAudioOutput = z.object({
  audio_file: zFalAiStableAudioFile,
})
