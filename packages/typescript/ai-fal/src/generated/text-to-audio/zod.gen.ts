// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod'

/**
 * File
 */
export const zSchemaFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * Output
 */
export const zSchemaStableAudioOutput = z.object({
  audio_file: zSchemaFile,
})

/**
 * Input
 */
export const zSchemaStableAudioInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate audio from',
  }),
  steps: z
    .optional(
      z.int().gte(1).lte(1000).register(z.globalRegistry, {
        description: 'The number of steps to denoise the audio for',
      }),
    )
    .default(100),
  seconds_total: z
    .optional(
      z.int().gte(0).lte(47).register(z.globalRegistry, {
        description: 'The duration of the audio clip to generate',
      }),
    )
    .default(30),
  seconds_start: z
    .optional(
      z.int().gte(0).lte(47).register(z.globalRegistry, {
        description: 'The start point of the audio clip to generate',
      }),
    )
    .default(0),
})

/**
 * AudioFile
 */
export const zSchemaAudioFile = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z
    .optional(z.string())
    .default('8535dd59e911496a947daa35c07e67a3_tmplkcy6tut.wav'),
  content_type: z.optional(z.string()).default('audio/wav'),
  url: z.string(),
})

/**
 * TTSOutput
 */
export const zSchemaF5TtsOutput = z.object({
  audio_url: zSchemaAudioFile,
})

/**
 * TTSInput
 */
export const zSchemaF5TtsInput = z.object({
  ref_text: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The reference text to be used for TTS. If not provided, an ASR (Automatic Speech Recognition) model will be used to generate the reference text.',
      }),
    )
    .default(''),
  remove_silence: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to remove the silence from the audio file.',
      }),
    )
    .default(true),
  gen_text: z.string().register(z.globalRegistry, {
    description: 'The text to be converted to speech.',
  }),
  model_type: z.enum(['F5-TTS', 'E2-TTS']).register(z.globalRegistry, {
    description: 'The name of the model to be used for TTS.',
  }),
  ref_audio_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the reference audio file.',
  }),
})

/**
 * MusicOutput
 */
export const zSchemaMinimaxMusicOutput = z.object({
  audio: zSchemaFile,
})

/**
 * TextToMusicRequest
 */
export const zSchemaMinimaxMusicInput = z.object({
  prompt: z.string().min(1).max(600).register(z.globalRegistry, {
    description:
      'Lyrics with optional formatting. You can use a newline to separate each line of lyrics. You can use two newlines to add a pause between lines. You can use double hash marks (##) at the beginning and end of the lyrics to add accompaniment. Maximum 600 characters.',
  }),
  reference_audio_url: z.string().register(z.globalRegistry, {
    description:
      'Reference song, should contain music and vocals. Must be a .wav or .mp3 file longer than 15 seconds.',
  }),
})

/**
 * AudioOutput
 */
export const zSchemaMmaudioV2TextToAudioOutput = z.object({
  audio: zSchemaFile,
})

/**
 * AudioInput
 */
export const zSchemaMmaudioV2TextToAudioInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the audio for.',
  }),
  num_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: 'The number of steps to generate the audio for.',
      }),
    )
    .default(25),
  duration: z
    .optional(
      z.number().gte(1).lte(30).register(z.globalRegistry, {
        description: 'The duration of the audio to generate.',
      }),
    )
    .default(8),
  cfg_strength: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'The strength of Classifier Free Guidance.',
      }),
    )
    .default(4.5),
  seed: z.optional(
    z.int().gte(0).lte(65535).register(z.globalRegistry, {
      description: 'The seed for the random number generator',
    }),
  ),
  mask_away_clip: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to mask away the clip.',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to generate the audio for.',
      }),
    )
    .default(''),
})

/**
 * Output
 */
export const zSchemaYueOutput = z.object({
  audio: zSchemaFile,
})

/**
 * TextToMusicInput
 */
export const zSchemaYueInput = z.object({
  lyrics: z.string().register(z.globalRegistry, {
    description:
      'The prompt to generate an image from. Must have two sections. Sections start with either [chorus] or a [verse].',
  }),
  genres: z.string().register(z.globalRegistry, {
    description:
      "The genres (separated by a space ' ') to guide the music generation.",
  }),
})

/**
 * ItalianOutput
 */
export const zSchemaKokoroItalianOutput = z.object({
  audio: zSchemaFile,
})

/**
 * ItalianRequest
 */
export const zSchemaKokoroItalianInput = z.object({
  prompt: z.string(),
  voice: z.enum(['if_sara', 'im_nicola']).register(z.globalRegistry, {
    description: 'Voice ID for the desired voice.',
  }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * ZonosOutput
 */
export const zSchemaZonosOutput = z.object({
  audio: zSchemaFile,
})

/**
 * ZonosInput
 */
export const zSchemaZonosInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The content generated using cloned voice.',
  }),
  reference_audio_url: z.string().register(z.globalRegistry, {
    description: 'The reference audio.',
  }),
})

/**
 * AmEngOutput
 */
export const zSchemaKokoroAmericanEnglishOutput = z.object({
  audio: zSchemaFile,
})

/**
 * AmEnglishRequest
 */
export const zSchemaKokoroAmericanEnglishInput = z.object({
  prompt: z.optional(z.string()).default(''),
  voice: z.optional(
    z
      .enum([
        'af_heart',
        'af_alloy',
        'af_aoede',
        'af_bella',
        'af_jessica',
        'af_kore',
        'af_nicole',
        'af_nova',
        'af_river',
        'af_sarah',
        'af_sky',
        'am_adam',
        'am_echo',
        'am_eric',
        'am_fenrir',
        'am_liam',
        'am_michael',
        'am_onyx',
        'am_puck',
        'am_santa',
      ])
      .register(z.globalRegistry, {
        description: 'Voice ID for the desired voice.',
      }),
  ),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * JapaneseOutput
 */
export const zSchemaKokoroJapaneseOutput = z.object({
  audio: zSchemaFile,
})

/**
 * JapaneseRequest
 */
export const zSchemaKokoroJapaneseInput = z.object({
  prompt: z.string(),
  voice: z
    .enum(['jf_alpha', 'jf_gongitsune', 'jf_nezumi', 'jf_tebukuro', 'jm_kumo'])
    .register(z.globalRegistry, {
      description: 'Voice ID for the desired voice.',
    }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * FrenchOutput
 */
export const zSchemaKokoroFrenchOutput = z.object({
  audio: zSchemaFile,
})

/**
 * FrenchRequest
 */
export const zSchemaKokoroFrenchInput = z.object({
  prompt: z.string(),
  voice: z.enum(['ff_siwis']).register(z.globalRegistry, {
    description: 'Voice ID for the desired voice.',
  }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * BrEngOutput
 */
export const zSchemaKokoroBritishEnglishOutput = z.object({
  audio: zSchemaFile,
})

/**
 * BrEnglishRequest
 */
export const zSchemaKokoroBritishEnglishInput = z.object({
  prompt: z.string(),
  voice: z
    .enum([
      'bf_alice',
      'bf_emma',
      'bf_isabella',
      'bf_lily',
      'bm_daniel',
      'bm_fable',
      'bm_george',
      'bm_lewis',
    ])
    .register(z.globalRegistry, {
      description: 'Voice ID for the desired voice.',
    }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * BrPortugeseOutput
 */
export const zSchemaKokoroBrazilianPortugueseOutput = z.object({
  audio: zSchemaFile,
})

/**
 * BrPortugueseRequest
 */
export const zSchemaKokoroBrazilianPortugueseInput = z.object({
  prompt: z.string(),
  voice: z.enum(['pf_dora', 'pm_alex', 'pm_santa']).register(z.globalRegistry, {
    description: 'Voice ID for the desired voice.',
  }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * SpanishOutput
 */
export const zSchemaKokoroSpanishOutput = z.object({
  audio: zSchemaFile,
})

/**
 * SpanishRequest
 */
export const zSchemaKokoroSpanishInput = z.object({
  prompt: z.string(),
  voice: z.enum(['ef_dora', 'em_alex', 'em_santa']).register(z.globalRegistry, {
    description: 'Voice ID for the desired voice.',
  }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * MandarinOutput
 */
export const zSchemaKokoroMandarinChineseOutput = z.object({
  audio: zSchemaFile,
})

/**
 * MandarinRequest
 */
export const zSchemaKokoroMandarinChineseInput = z.object({
  prompt: z.string(),
  voice: z
    .enum([
      'zf_xiaobei',
      'zf_xiaoni',
      'zf_xiaoxiao',
      'zf_xiaoyi',
      'zm_yunjian',
      'zm_yunxi',
      'zm_yunxia',
      'zm_yunyang',
    ])
    .register(z.globalRegistry, {
      description: 'Voice ID for the desired voice.',
    }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * HindiOutput
 */
export const zSchemaKokoroHindiOutput = z.object({
  audio: zSchemaFile,
})

/**
 * HindiRequest
 */
export const zSchemaKokoroHindiInput = z.object({
  prompt: z.string(),
  voice: z
    .enum(['hf_alpha', 'hf_beta', 'hm_omega', 'hm_psi'])
    .register(z.globalRegistry, {
      description: 'Voice ID for the desired voice.',
    }),
  speed: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Speed of the generated audio. Default is 1.0.',
      }),
    )
    .default(1),
})

/**
 * TTSOutput
 */
export const zSchemaElevenlabsTtsMultilingualV2Output = z.object({
  audio: zSchemaFile,
  timestamps: z.optional(z.union([z.array(z.unknown()), z.unknown()])),
})

/**
 * TextToSpeechRequest
 */
export const zSchemaElevenlabsTtsMultilingualV2Input = z.object({
  stability: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Voice stability (0-1)',
      }),
    )
    .default(0.5),
  next_text: z.optional(z.union([z.string(), z.unknown()])),
  speed: z
    .optional(
      z.number().gte(0.7).lte(1.2).register(z.globalRegistry, {
        description:
          'Speech speed (0.7-1.2). Values below 1.0 slow down the speech, above 1.0 speed it up. Extreme values may affect quality.',
      }),
    )
    .default(1),
  style: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Style exaggeration (0-1)',
      }),
    )
    .default(0),
  text: z.string().min(1).register(z.globalRegistry, {
    description: 'The text to convert to speech',
  }),
  timestamps: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to return timestamps for each word in the generated speech',
      }),
    )
    .default(false),
  similarity_boost: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Similarity boost (0-1)',
      }),
    )
    .default(0.75),
  voice: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The voice to use for speech generation',
      }),
    )
    .default('Rachel'),
  language_code: z.optional(z.union([z.string(), z.unknown()])),
  previous_text: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * Output
 */
export const zSchemaDiffrhythmOutput = z.object({
  audio: zSchemaFile,
})

/**
 * TextToMusicInput
 */
export const zSchemaDiffrhythmInput = z.object({
  lyrics: z.string().register(z.globalRegistry, {
    description:
      'The prompt to generate the song from. Must have two sections. Sections start with either [chorus] or a [verse].',
  }),
  cfg_strength: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: 'The CFG strength to use for the music generation.',
      }),
    )
    .default(4),
  reference_audio_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The URL of the reference audio to use for the music generation.',
    }),
  ),
  music_duration: z.optional(
    z.enum(['95s', '285s']).register(z.globalRegistry, {
      description: 'The duration of the music to generate.',
    }),
  ),
  scheduler: z.optional(
    z
      .enum(['euler', 'midpoint', 'rk4', 'implicit_adams'])
      .register(z.globalRegistry, {
        description: 'The scheduler to use for the music generation.',
      }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(100).register(z.globalRegistry, {
        description:
          'The number of inference steps to use for the music generation.',
      }),
    )
    .default(32),
  style_prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The style prompt to use for the music generation.',
    }),
  ),
})

/**
 * Speaker
 */
export const zSchemaSpeaker = z.object({
  prompt: z.string(),
  audio_url: z.string(),
  speaker_id: z.int(),
})

/**
 * Turn
 */
export const zSchemaTurn = z.object({
  text: z.string(),
  speaker_id: z.int(),
})

/**
 * Output
 */
export const zSchemaCsm1bOutput = z.object({
  audio: z.union([zSchemaFile, z.string()]),
})

/**
 * Input
 */
export const zSchemaCsm1bInput = z.object({
  scene: z.array(zSchemaTurn).register(z.globalRegistry, {
    description: 'The text to generate an audio from.',
  }),
  context: z.optional(
    z.array(zSchemaSpeaker).register(z.globalRegistry, {
      description: 'The context to generate an audio from.',
    }),
  ),
})

/**
 * AudioOutput
 *
 * Example Pydantic model showing how to include a File in the output.
 */
export const zSchemaMusicGeneratorOutput = z
  .object({
    audio_file: zSchemaFile,
  })
  .register(z.globalRegistry, {
    description:
      'Example Pydantic model showing how to include a File in the output.',
  })

/**
 * Input
 */
export const zSchemaMusicGeneratorInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate music from.',
  }),
  duration: z.int().gte(10).lte(180).register(z.globalRegistry, {
    description: 'The duration of the generated music in seconds.',
  }),
})

/**
 * AudioOutput
 *
 * Example Pydantic model showing how to include a File in the output.
 */
export const zSchemaSoundEffectsGeneratorOutput = z
  .object({
    audio_file: zSchemaFile,
  })
  .register(z.globalRegistry, {
    description:
      'Example Pydantic model showing how to include a File in the output.',
  })

/**
 * Input
 */
export const zSchemaSoundEffectsGeneratorInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate SFX.',
  }),
  duration: z.int().gte(1).lte(30).register(z.globalRegistry, {
    description: 'The duration of the generated SFX in seconds.',
  }),
})

/**
 * ACEStepResponse
 */
export const zSchemaAceStepOutput = z.object({
  tags: z.string().register(z.globalRegistry, {
    description: 'The genre tags used in the generation process.',
  }),
  lyrics: z.string().register(z.globalRegistry, {
    description: 'The lyrics used in the generation process.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The random seed used for the generation process.',
  }),
  audio: zSchemaFile,
})

/**
 * ACEStepTextToAudioRequest
 */
export const zSchemaAceStepInput = z.object({
  number_of_steps: z
    .optional(
      z.int().gte(3).lte(60).register(z.globalRegistry, {
        description: 'Number of steps to generate the audio.',
      }),
    )
    .default(27),
  duration: z
    .optional(
      z.number().gte(5).lte(240).register(z.globalRegistry, {
        description: 'The duration of the generated audio in seconds.',
      }),
    )
    .default(60),
  tags: z.string().register(z.globalRegistry, {
    description:
      'Comma-separated list of genre tags to control the style of the generated audio.',
  }),
  minimum_guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description:
          'Minimum guidance scale for the generation after the decay.',
      }),
    )
    .default(3),
  lyrics: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Lyrics to be sung in the audio. If not provided or if [inst] or [instrumental] is the content of this field, no lyrics will be sung. Use control structures like [verse], [chorus] and [bridge] to control the structure of the song.',
      }),
    )
    .default(''),
  tag_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Tag guidance scale for the generation.',
      }),
    )
    .default(5),
  scheduler: z.optional(
    z.enum(['euler', 'heun']).register(z.globalRegistry, {
      description: 'Scheduler to use for the generation process.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description: 'Guidance scale for the generation.',
      }),
    )
    .default(15),
  guidance_type: z.optional(
    z.enum(['cfg', 'apg', 'cfg_star']).register(z.globalRegistry, {
      description: 'Type of CFG to use for the generation process.',
    }),
  ),
  lyric_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Lyric guidance scale for the generation.',
      }),
    )
    .default(1.5),
  guidance_interval: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Guidance interval for the generation. 0.5 means only apply guidance in the middle steps (0.25 * infer_steps to 0.75 * infer_steps)',
      }),
    )
    .default(0.5),
  guidance_interval_decay: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Guidance interval decay for the generation. Guidance scale will decay from guidance_scale to min_guidance_scale in the interval. 0.0 means no decay.',
      }),
    )
    .default(0),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If not provided, a random seed will be used.',
    }),
  ),
  granularity_scale: z
    .optional(
      z.int().gte(-100).lte(100).register(z.globalRegistry, {
        description:
          'Granularity scale for the generation process. Higher values can reduce artifacts.',
      }),
    )
    .default(10),
})

/**
 * ACEStepResponse
 */
export const zSchemaAceStepPromptToAudioOutput = z.object({
  tags: z.string().register(z.globalRegistry, {
    description: 'The genre tags used in the generation process.',
  }),
  lyrics: z.string().register(z.globalRegistry, {
    description: 'The lyrics used in the generation process.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The random seed used for the generation process.',
  }),
  audio: zSchemaFile,
})

/**
 * ACEStepPromptToAudioRequest
 */
export const zSchemaAceStepPromptToAudioInput = z.object({
  number_of_steps: z
    .optional(
      z.int().gte(3).lte(60).register(z.globalRegistry, {
        description: 'Number of steps to generate the audio.',
      }),
    )
    .default(27),
  duration: z
    .optional(
      z.number().gte(5).lte(240).register(z.globalRegistry, {
        description: 'The duration of the generated audio in seconds.',
      }),
    )
    .default(60),
  prompt: z.string().register(z.globalRegistry, {
    description:
      'Prompt to control the style of the generated audio. This will be used to generate tags and lyrics.',
  }),
  minimum_guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description:
          'Minimum guidance scale for the generation after the decay.',
      }),
    )
    .default(3),
  tag_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Tag guidance scale for the generation.',
      }),
    )
    .default(5),
  scheduler: z.optional(
    z.enum(['euler', 'heun']).register(z.globalRegistry, {
      description: 'Scheduler to use for the generation process.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(200).register(z.globalRegistry, {
        description: 'Guidance scale for the generation.',
      }),
    )
    .default(15),
  guidance_type: z.optional(
    z.enum(['cfg', 'apg', 'cfg_star']).register(z.globalRegistry, {
      description: 'Type of CFG to use for the generation process.',
    }),
  ),
  instrumental: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to generate an instrumental version of the audio.',
      }),
    )
    .default(false),
  lyric_guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Lyric guidance scale for the generation.',
      }),
    )
    .default(1.5),
  guidance_interval: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Guidance interval for the generation. 0.5 means only apply guidance in the middle steps (0.25 * infer_steps to 0.75 * infer_steps)',
      }),
    )
    .default(0.5),
  guidance_interval_decay: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Guidance interval decay for the generation. Guidance scale will decay from guidance_scale to min_guidance_scale in the interval. 0.0 means no decay.',
      }),
    )
    .default(0),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If not provided, a random seed will be used.',
    }),
  ),
  granularity_scale: z
    .optional(
      z.int().gte(-100).lte(100).register(z.globalRegistry, {
        description:
          'Granularity scale for the generation process. Higher values can reduce artifacts.',
      }),
    )
    .default(10),
})

/**
 * TextToMusicOutput
 */
export const zSchemaLyria2Output = z.object({
  audio: zSchemaFile,
})

/**
 * TextToMusicInput
 */
export const zSchemaLyria2Input = z.object({
  prompt: z.string().min(1).max(2000).register(z.globalRegistry, {
    description: 'The text prompt describing the music you want to generate',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'A seed for deterministic generation. If provided, the model will attempt to produce the same audio given the same prompt and other parameters.',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'A description of what to exclude from the generated audio',
      }),
    )
    .default('low quality'),
})

/**
 * TTSOutput
 */
export const zSchemaElevenlabsTtsElevenV3Output = z.object({
  audio: zSchemaFile,
  timestamps: z.optional(z.union([z.array(z.unknown()), z.unknown()])),
})

/**
 * TextToSpeechRequestV3
 *
 * Request model for eleven_v3 which doesn't support previous_text/next_text
 */
export const zSchemaElevenlabsTtsElevenV3Input = z
  .object({
    stability: z
      .optional(
        z.number().gte(0).lte(1).register(z.globalRegistry, {
          description: 'Voice stability (0-1)',
        }),
      )
      .default(0.5),
    speed: z
      .optional(
        z.number().gte(0.7).lte(1.2).register(z.globalRegistry, {
          description:
            'Speech speed (0.7-1.2). Values below 1.0 slow down the speech, above 1.0 speed it up. Extreme values may affect quality.',
        }),
      )
      .default(1),
    text: z.string().min(1).max(5000).register(z.globalRegistry, {
      description: 'The text to convert to speech',
    }),
    style: z
      .optional(
        z.number().gte(0).lte(1).register(z.globalRegistry, {
          description: 'Style exaggeration (0-1)',
        }),
      )
      .default(0),
    timestamps: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to return timestamps for each word in the generated speech',
        }),
      )
      .default(false),
    similarity_boost: z
      .optional(
        z.number().gte(0).lte(1).register(z.globalRegistry, {
          description: 'Similarity boost (0-1)',
        }),
      )
      .default(0.75),
    voice: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The voice to use for speech generation',
        }),
      )
      .default('Rachel'),
    language_code: z.optional(z.union([z.string(), z.unknown()])),
  })
  .register(z.globalRegistry, {
    description:
      "Request model for eleven_v3 which doesn't support previous_text/next_text",
  })

/**
 * GenerateOutput
 */
export const zSchemaV2TextToMusicOutput = z.object({
  tags: z.optional(z.union([z.array(z.string()), z.unknown()])),
  seed: z.int().register(z.globalRegistry, {
    description:
      'The seed used for generation. This can be used to generate an identical song by passing the same parameters with this seed in a future request.',
  }),
  lyrics: z.optional(z.union([z.string(), z.unknown()])),
  audio: z.array(zSchemaFile).register(z.globalRegistry, {
    description: 'The generated audio files.',
  }),
})

/**
 * GenerateInput
 */
export const zSchemaV2TextToMusicInput = z.object({
  prompt: z.optional(z.union([z.string(), z.unknown()])),
  lyrics_prompt: z.optional(z.union([z.string(), z.unknown()])),
  tags: z.optional(z.union([z.array(z.string()), z.unknown()])),
  prompt_strength: z
    .optional(
      z.number().gte(1.4).lte(3.1).register(z.globalRegistry, {
        description:
          'Controls how strongly your prompt influences the output. Greater values adhere more to the prompt but sound less natural. (This is CFG.)',
      }),
    )
    .default(2),
  output_bit_rate: z.optional(
    z.union([
      z.union([z.literal(128), z.literal(192), z.literal(256), z.literal(320)]),
      z.unknown(),
    ]),
  ),
  num_songs: z
    .optional(
      z.int().gte(1).lte(2).register(z.globalRegistry, {
        description:
          'Generating 2 songs costs 1.5x the price of generating 1 song. Also, note that using the same seed may not result in identical songs if the number of songs generated is changed.',
      }),
    )
    .default(1),
  output_format: z.optional(z.enum(['flac', 'mp3', 'wav', 'ogg', 'm4a'])),
  bpm: z.optional(z.union([z.int(), z.string(), z.unknown()])),
  balance_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Greater means more natural vocals. Lower means sharper instrumentals. We recommend 0.7.',
      }),
    )
    .default(0.7),
  seed: z.optional(
    z.union([
      z.int().gte(-9223372036854776000).lte(9223372036854776000),
      z.unknown(),
    ]),
  ),
})

/**
 * InpaintSection
 */
export const zSchemaInpaintSection = z.object({
  end: z.number().register(z.globalRegistry, {
    description: 'End time in seconds of the section to inpaint.',
  }),
  start: z.number().gte(0).register(z.globalRegistry, {
    description: 'Start time in seconds of the section to inpaint.',
  }),
})

/**
 * InpaintOutput
 */
export const zSchemaV2InpaintOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description:
      'The seed used for generation. This can be used to generate an identical song by passing the same parameters with this seed in a future request.',
  }),
  audio: z.array(zSchemaFile).register(z.globalRegistry, {
    description: 'The generated audio files.',
  }),
})

/**
 * InpaintInput
 */
export const zSchemaV2InpaintInput = z.object({
  lyrics_prompt: z.string().register(z.globalRegistry, {
    description:
      'The lyrics sung in the generated song. An empty string will generate an instrumental track.',
  }),
  tags: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'Tags/styles of the music to generate. You can view a list of all available tags at https://sonauto.ai/tag-explorer.',
    }),
  ),
  prompt_strength: z
    .optional(
      z.number().gte(1.4).lte(3.1).register(z.globalRegistry, {
        description:
          'Controls how strongly your prompt influences the output. Greater values adhere more to the prompt but sound less natural. (This is CFG.)',
      }),
    )
    .default(2),
  output_bit_rate: z.optional(
    z.union([
      z.union([z.literal(128), z.literal(192), z.literal(256), z.literal(320)]),
      z.unknown(),
    ]),
  ),
  num_songs: z
    .optional(
      z.int().gte(1).lte(2).register(z.globalRegistry, {
        description:
          'Generating 2 songs costs 1.5x the price of generating 1 song. Also, note that using the same seed may not result in identical songs if the number of songs generated is changed.',
      }),
    )
    .default(1),
  output_format: z.optional(z.enum(['flac', 'mp3', 'wav', 'ogg', 'm4a'])),
  selection_crop: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Crop to the selected region',
      }),
    )
    .default(false),
  sections: z.array(zSchemaInpaintSection).register(z.globalRegistry, {
    description:
      'List of sections to inpaint. Currently, only one section is supported so the list length must be 1.',
  }),
  balance_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Greater means more natural vocals. Lower means sharper instrumentals. We recommend 0.7.',
      }),
    )
    .default(0.7),
  audio_url: z.url().min(1).max(2083).register(z.globalRegistry, {
    description:
      'The URL of the audio file to alter. Must be a valid publicly accessible URL.',
  }),
  seed: z.optional(
    z.union([
      z.int().gte(-9223372036854776000).lte(9223372036854776000),
      z.unknown(),
    ]),
  ),
})

/**
 * SoundEffectOutput
 *
 * Output format for generated sound effects
 */
export const zSchemaElevenlabsSoundEffectsV2Output = z
  .object({
    audio: zSchemaFile,
  })
  .register(z.globalRegistry, {
    description: 'Output format for generated sound effects',
  })

/**
 * SoundEffectRequestV2
 */
export const zSchemaElevenlabsSoundEffectsV2Input = z.object({
  text: z.string().register(z.globalRegistry, {
    description: 'The text describing the sound effect to generate',
  }),
  loop: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to create a sound effect that loops smoothly.',
      }),
    )
    .default(false),
  prompt_influence: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'How closely to follow the prompt (0-1). Higher values mean less variation.',
      }),
    )
    .default(0.3),
  output_format: z.optional(
    z
      .enum([
        'mp3_22050_32',
        'mp3_44100_32',
        'mp3_44100_64',
        'mp3_44100_96',
        'mp3_44100_128',
        'mp3_44100_192',
        'pcm_8000',
        'pcm_16000',
        'pcm_22050',
        'pcm_24000',
        'pcm_44100',
        'pcm_48000',
        'ulaw_8000',
        'alaw_8000',
        'opus_48000_32',
        'opus_48000_64',
        'opus_48000_96',
        'opus_48000_128',
        'opus_48000_192',
      ])
      .register(z.globalRegistry, {
        description:
          'Output format of the generated audio. Formatted as codec_sample_rate_bitrate.',
      }),
  ),
  duration_seconds: z.optional(
    z.union([z.number().gte(0.5).lte(22), z.unknown()]),
  ),
})

/**
 * PronunciationDictionaryLocator
 */
export const zSchemaPronunciationDictionaryLocator = z.object({
  version_id: z.optional(z.union([z.string(), z.unknown()])),
  pronunciation_dictionary_id: z.union([z.string(), z.unknown()]),
})

/**
 * DialogueBlock
 */
export const zSchemaDialogueBlock = z.object({
  text: z.string().register(z.globalRegistry, {
    description: 'The dialogue text',
  }),
  voice: z.string().register(z.globalRegistry, {
    description:
      'The name or the ID of the voice to be used for the generation.',
  }),
})

/**
 * TextToDialogueOutput
 */
export const zSchemaElevenlabsTextToDialogueElevenV3Output = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'Random seed for reproducibility.',
  }),
  audio: zSchemaFile,
})

/**
 * TextToDialogueRequest
 */
export const zSchemaElevenlabsTextToDialogueElevenV3Input = z.object({
  stability: z.optional(z.union([z.number().gte(0).lte(1), z.unknown()])),
  inputs: z.array(zSchemaDialogueBlock).register(z.globalRegistry, {
    description:
      'A list of dialogue inputs, each containing text and a voice ID which will be converted into speech.',
  }),
  language_code: z.optional(z.union([z.string(), z.unknown()])),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  use_speaker_boost: z.optional(z.union([z.boolean(), z.unknown()])),
  pronunciation_dictionary_locators: z
    .optional(
      z
        .array(zSchemaPronunciationDictionaryLocator)
        .register(z.globalRegistry, {
          description:
            'A list of pronunciation dictionary locators (id, version_id) to be applied to the text. They will be applied in order. You may have up to 3 locators per request',
        }),
    )
    .default([]),
})

/**
 * TextToAudioOutput
 */
export const zSchemaStableAudio25TextToAudioOutput = z.object({
  seed: z.int().register(z.globalRegistry, {
    description: 'The random seed used for generation',
  }),
  audio: zSchemaFile,
})

/**
 * TextToAudioInput
 */
export const zSchemaStableAudio25TextToAudioInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate audio from',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seconds_total: z
    .optional(
      z.int().gte(1).lte(190).register(z.globalRegistry, {
        description: 'The duration of the audio clip to generate',
      }),
    )
    .default(190),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(8).register(z.globalRegistry, {
        description: 'The number of steps to denoise the audio for',
      }),
    )
    .default(8),
  guidance_scale: z
    .optional(
      z.int().gte(1).lte(25).register(z.globalRegistry, {
        description:
          'How strictly the diffusion process adheres to the prompt text (higher values make your audio closer to your prompt).',
      }),
    )
    .default(1),
  seed: z.optional(z.int()),
})

/**
 * MusicV15Output
 */
export const zSchemaMinimaxMusicV15Output = z.object({
  audio: zSchemaFile,
})

/**
 * AudioSetting
 */
export const zSchemaAudioSetting = z.object({
  format: z.optional(
    z.enum(['mp3', 'pcm', 'flac']).register(z.globalRegistry, {
      description: 'Audio format',
    }),
  ),
  sample_rate: z.optional(
    z
      .union([
        z.literal(8000),
        z.literal(16000),
        z.literal(22050),
        z.literal(24000),
        z.literal(32000),
        z.literal(44100),
      ])
      .register(z.globalRegistry, {
        description: 'Sample rate of generated audio',
      }),
  ),
  bitrate: z.optional(
    z
      .union([
        z.literal(32000),
        z.literal(64000),
        z.literal(128000),
        z.literal(256000),
      ])
      .register(z.globalRegistry, {
        description: 'Bitrate of generated audio',
      }),
  ),
})

/**
 * TextToMusic15Request
 */
export const zSchemaMinimaxMusicV15Input = z.object({
  prompt: z.string().min(10).max(600).register(z.globalRegistry, {
    description:
      'Lyrics, supports [intro][verse][chorus][bridge][outro] sections. 10-600 characters.',
  }),
  lyrics_prompt: z.string().min(10).max(3000).register(z.globalRegistry, {
    description: 'Control music generation. 10-3000 characters.',
  }),
  audio_setting: z.optional(zSchemaAudioSetting),
})

/**
 * MusicGenerationOutput
 *
 * Output schema for music generation.
 */
export const zSchemaMusicGenerationOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'The processed prompt used for generation',
    }),
    metadata: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description:
        'Generation metadata including duration, sample rate, and parameters',
    }),
    audio: zSchemaFile,
  })
  .register(z.globalRegistry, {
    description: 'Output schema for music generation.',
  })

/**
 * MusicGenerationInput
 *
 * Input schema for music generation with form controls for the playground.
 */
export const zSchemaMusicGenerationInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'Describe the music you want to generate',
    }),
    duration: z
      .optional(
        z.number().gte(5).lte(150).register(z.globalRegistry, {
          description: 'Length of the generated music in seconds',
        }),
      )
      .default(90),
    refinement: z
      .optional(
        z.int().gte(10).lte(200).register(z.globalRegistry, {
          description:
            'Refinement level - higher values may improve quality but take longer',
        }),
      )
      .default(100),
    seed: z.optional(z.union([z.int().gte(0).lte(2147483647), z.unknown()])),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'Describe what you want to avoid in the music (instruments, styles, moods). Leave blank for none.',
        }),
      )
      .default(''),
    creativity: z
      .optional(
        z.number().gte(1).lte(20).register(z.globalRegistry, {
          description:
            'Creativity level - higher values allow more creative interpretation of the prompt',
        }),
      )
      .default(16),
  })
  .register(z.globalRegistry, {
    description:
      'Input schema for music generation with form controls for the playground.',
  })

/**
 * SoundEffectGenerationOutput
 *
 * Output schema for sound effect generation.
 */
export const zSchemaSoundEffectGenerationOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'The processed prompt used for generation',
    }),
    metadata: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description:
        'Generation metadata including duration, sample rate, and parameters',
    }),
    audio: zSchemaFile,
  })
  .register(z.globalRegistry, {
    description: 'Output schema for sound effect generation.',
  })

/**
 * SoundEffectGenerationInput
 *
 * Input schema for sound effect generation with form controls for the playground.
 */
export const zSchemaSoundEffectGenerationInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'Describe the sound effect you want to generate',
    }),
    duration: z
      .optional(
        z.number().gte(1).lte(35).register(z.globalRegistry, {
          description: 'Length of the generated sound effect in seconds',
        }),
      )
      .default(5),
    refinement: z
      .optional(
        z.int().gte(10).lte(200).register(z.globalRegistry, {
          description:
            'Refinement level - Higher values may improve quality but take longer',
        }),
      )
      .default(40),
    seed: z.optional(z.union([z.int().gte(0).lte(2147483647), z.unknown()])),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe the types of sounds you don't want to generate in the output, avoid double-negatives, compare with positive prompts",
        }),
      )
      .default(''),
    creativity: z
      .optional(
        z.number().gte(1).lte(20).register(z.globalRegistry, {
          description:
            'Creativity level - higher values allow more creative interpretation of the prompt',
        }),
      )
      .default(16),
  })
  .register(z.globalRegistry, {
    description:
      'Input schema for sound effect generation with form controls for the playground.',
  })

/**
 * MusicV15Output
 */
export const zSchemaMinimaxMusicV2Output = z.object({
  audio: zSchemaFile,
})

/**
 * TextToMusic20Request
 */
export const zSchemaMinimaxMusicV2Input = z.object({
  prompt: z.string().min(10).max(2000).register(z.globalRegistry, {
    description:
      'A description of the music, specifying style, mood, and scenario. 10-300 characters.',
  }),
  lyrics_prompt: z.string().min(10).max(3000).register(z.globalRegistry, {
    description:
      'Lyrics of the song. Use n to separate lines. You may add structure tags like [Intro], [Verse], [Chorus], [Bridge], [Outro] to enhance the arrangement. 10-3000 characters.',
  }),
  audio_setting: z.optional(zSchemaAudioSetting),
})

/**
 * MusicSection
 */
export const zSchemaMusicSection = z.object({
  positive_local_styles: z.array(z.string()).register(z.globalRegistry, {
    description: 'The styles that should be present in this section.',
  }),
  lines: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The lyrics of the section. Each line must be at most 200 characters long.',
  }),
  negative_local_styles: z.array(z.string()).register(z.globalRegistry, {
    description: 'The styles that should not be present in this section.',
  }),
  duration_ms: z.int().gte(3000).lte(120000).register(z.globalRegistry, {
    description:
      'The duration of the section in milliseconds. Must be between 3000ms and 120000ms.',
  }),
  section_name: z.string().min(1).max(100).register(z.globalRegistry, {
    description:
      'The name of the section. Must be between 1 and 100 characters.',
  }),
})

/**
 * MusicCompositionPlan
 */
export const zSchemaMusicCompositionPlan = z.object({
  negative_global_styles: z.array(z.string()).register(z.globalRegistry, {
    description: 'The styles that should not be present in the entire song.',
  }),
  sections: z.array(zSchemaMusicSection).register(z.globalRegistry, {
    description: 'The sections of the song.',
  }),
  positive_global_styles: z.array(z.string()).register(z.globalRegistry, {
    description: 'The styles that should be present in the entire song.',
  }),
})

/**
 * MusicOutput
 */
export const zSchemaElevenlabsMusicOutput = z.object({
  audio: zSchemaFile,
})

/**
 * MusicRequest
 *
 * Request format for Elevenlabs Music API
 */
export const zSchemaElevenlabsMusicInput = z
  .object({
    prompt: z.optional(z.union([z.string(), z.unknown()])),
    composition_plan: z.optional(
      z.union([zSchemaMusicCompositionPlan, z.unknown()]),
    ),
    music_length_ms: z.optional(
      z.union([z.int().gte(3000).lte(600000), z.unknown()]),
    ),
    output_format: z.optional(
      z
        .enum([
          'mp3_22050_32',
          'mp3_44100_32',
          'mp3_44100_64',
          'mp3_44100_96',
          'mp3_44100_128',
          'mp3_44100_192',
          'pcm_8000',
          'pcm_16000',
          'pcm_22050',
          'pcm_24000',
          'pcm_44100',
          'pcm_48000',
          'ulaw_8000',
          'alaw_8000',
          'opus_48000_32',
          'opus_48000_64',
          'opus_48000_96',
          'opus_48000_128',
          'opus_48000_192',
        ])
        .register(z.globalRegistry, {
          description:
            'Output format of the generated audio. Formatted as codec_sample_rate_bitrate. So an mp3 with 22.05kHz sample rate at 32kbs is represented as mp3_22050_32. MP3 with 192kbps bitrate requires you to be subscribed to Creator tier or above. PCM with 44.1kHz sample rate requires you to be subscribed to Pro tier or above. Note that the Î¼-law format (sometimes written mu-law, often approximated as u-law) is commonly used for Twilio audio inputs.',
        }),
    ),
    respect_sections_durations: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "Controls how strictly section durations in the composition_plan are enforced. It will only have an effect if it is used with composition_plan. When set to true, the model will precisely respect each section's duration_ms from the plan. When set to false, the model may adjust individual section durations which will generally lead to better generation quality and improved latency, while always preserving the total song duration from the plan.",
        }),
      )
      .default(true),
    force_instrumental: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If true, guarantees that the generated song will be instrumental. If false, the song may or may not be instrumental depending on the prompt. Can only be used with prompt.',
        }),
      )
      .default(false),
  })
  .register(z.globalRegistry, {
    description: 'Request format for Elevenlabs Music API',
  })

export const zSchemaQueueStatus = z.object({
  status: z.enum(['IN_QUEUE', 'IN_PROGRESS', 'COMPLETED']),
  request_id: z.string().register(z.globalRegistry, {
    description: 'The request id.',
  }),
  response_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The response url.',
    }),
  ),
  status_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The status url.',
    }),
  ),
  cancel_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The cancel url.',
    }),
  ),
  logs: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The logs.',
    }),
  ),
  metrics: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The metrics.',
    }),
  ),
  queue_position: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The queue position.',
    }),
  ),
})

export const zGetFalAiElevenlabsMusicRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiElevenlabsMusicRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiElevenlabsMusicRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiElevenlabsMusicRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiElevenlabsMusicData = z.object({
  body: zSchemaElevenlabsMusicInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiElevenlabsMusicResponse = zSchemaQueueStatus

export const zGetFalAiElevenlabsMusicRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiElevenlabsMusicRequestsByRequestIdResponse =
  zSchemaElevenlabsMusicOutput

export const zGetFalAiMinimaxMusicV2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiMinimaxMusicV2RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiMinimaxMusicV2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiMinimaxMusicV2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiMinimaxMusicV2Data = z.object({
  body: zSchemaMinimaxMusicV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiMinimaxMusicV2Response = zSchemaQueueStatus

export const zGetFalAiMinimaxMusicV2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiMinimaxMusicV2RequestsByRequestIdResponse =
  zSchemaMinimaxMusicV2Output

export const zGetBeatovenSoundEffectGenerationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetBeatovenSoundEffectGenerationRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBeatovenSoundEffectGenerationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutBeatovenSoundEffectGenerationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostBeatovenSoundEffectGenerationData = z.object({
  body: zSchemaSoundEffectGenerationInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBeatovenSoundEffectGenerationResponse = zSchemaQueueStatus

export const zGetBeatovenSoundEffectGenerationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetBeatovenSoundEffectGenerationRequestsByRequestIdResponse =
  zSchemaSoundEffectGenerationOutput

export const zGetBeatovenMusicGenerationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetBeatovenMusicGenerationRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBeatovenMusicGenerationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutBeatovenMusicGenerationRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostBeatovenMusicGenerationData = z.object({
  body: zSchemaMusicGenerationInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBeatovenMusicGenerationResponse = zSchemaQueueStatus

export const zGetBeatovenMusicGenerationRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetBeatovenMusicGenerationRequestsByRequestIdResponse =
  zSchemaMusicGenerationOutput

export const zGetFalAiMinimaxMusicV15RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiMinimaxMusicV15RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiMinimaxMusicV15RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiMinimaxMusicV15RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiMinimaxMusicV15Data = z.object({
  body: zSchemaMinimaxMusicV15Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiMinimaxMusicV15Response = zSchemaQueueStatus

export const zGetFalAiMinimaxMusicV15RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiMinimaxMusicV15RequestsByRequestIdResponse =
  zSchemaMinimaxMusicV15Output

export const zGetFalAiStableAudio25TextToAudioRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiStableAudio25TextToAudioRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiStableAudio25TextToAudioRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiStableAudio25TextToAudioRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiStableAudio25TextToAudioData = z.object({
  body: zSchemaStableAudio25TextToAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiStableAudio25TextToAudioResponse = zSchemaQueueStatus

export const zGetFalAiStableAudio25TextToAudioRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiStableAudio25TextToAudioRequestsByRequestIdResponse =
  zSchemaStableAudio25TextToAudioOutput

export const zGetFalAiElevenlabsTextToDialogueElevenV3RequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiElevenlabsTextToDialogueElevenV3RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiElevenlabsTextToDialogueElevenV3RequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiElevenlabsTextToDialogueElevenV3RequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiElevenlabsTextToDialogueElevenV3Data = z.object({
  body: zSchemaElevenlabsTextToDialogueElevenV3Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiElevenlabsTextToDialogueElevenV3Response =
  zSchemaQueueStatus

export const zGetFalAiElevenlabsTextToDialogueElevenV3RequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiElevenlabsTextToDialogueElevenV3RequestsByRequestIdResponse =
  zSchemaElevenlabsTextToDialogueElevenV3Output

export const zGetFalAiElevenlabsSoundEffectsV2RequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiElevenlabsSoundEffectsV2RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiElevenlabsSoundEffectsV2RequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiElevenlabsSoundEffectsV2RequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiElevenlabsSoundEffectsV2Data = z.object({
  body: zSchemaElevenlabsSoundEffectsV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiElevenlabsSoundEffectsV2Response = zSchemaQueueStatus

export const zGetFalAiElevenlabsSoundEffectsV2RequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiElevenlabsSoundEffectsV2RequestsByRequestIdResponse =
  zSchemaElevenlabsSoundEffectsV2Output

export const zGetSonautoV2InpaintRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetSonautoV2InpaintRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutSonautoV2InpaintRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutSonautoV2InpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostSonautoV2InpaintData = z.object({
  body: zSchemaV2InpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostSonautoV2InpaintResponse = zSchemaQueueStatus

export const zGetSonautoV2InpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetSonautoV2InpaintRequestsByRequestIdResponse =
  zSchemaV2InpaintOutput

export const zGetSonautoV2TextToMusicRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetSonautoV2TextToMusicRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutSonautoV2TextToMusicRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutSonautoV2TextToMusicRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostSonautoV2TextToMusicData = z.object({
  body: zSchemaV2TextToMusicInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostSonautoV2TextToMusicResponse = zSchemaQueueStatus

export const zGetSonautoV2TextToMusicRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetSonautoV2TextToMusicRequestsByRequestIdResponse =
  zSchemaV2TextToMusicOutput

export const zGetFalAiElevenlabsTtsElevenV3RequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiElevenlabsTtsElevenV3RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiElevenlabsTtsElevenV3RequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiElevenlabsTtsElevenV3RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiElevenlabsTtsElevenV3Data = z.object({
  body: zSchemaElevenlabsTtsElevenV3Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiElevenlabsTtsElevenV3Response = zSchemaQueueStatus

export const zGetFalAiElevenlabsTtsElevenV3RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiElevenlabsTtsElevenV3RequestsByRequestIdResponse =
  zSchemaElevenlabsTtsElevenV3Output

export const zGetFalAiLyria2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiLyria2RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLyria2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiLyria2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLyria2Data = z.object({
  body: zSchemaLyria2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLyria2Response = zSchemaQueueStatus

export const zGetFalAiLyria2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLyria2RequestsByRequestIdResponse = zSchemaLyria2Output

export const zGetFalAiAceStepPromptToAudioRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiAceStepPromptToAudioRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiAceStepPromptToAudioRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiAceStepPromptToAudioRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiAceStepPromptToAudioData = z.object({
  body: zSchemaAceStepPromptToAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiAceStepPromptToAudioResponse = zSchemaQueueStatus

export const zGetFalAiAceStepPromptToAudioRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiAceStepPromptToAudioRequestsByRequestIdResponse =
  zSchemaAceStepPromptToAudioOutput

export const zGetFalAiAceStepRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiAceStepRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiAceStepRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiAceStepRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiAceStepData = z.object({
  body: zSchemaAceStepInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiAceStepResponse = zSchemaQueueStatus

export const zGetFalAiAceStepRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiAceStepRequestsByRequestIdResponse = zSchemaAceStepOutput

export const zGetCassetteaiSoundEffectsGeneratorRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetCassetteaiSoundEffectsGeneratorRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutCassetteaiSoundEffectsGeneratorRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutCassetteaiSoundEffectsGeneratorRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostCassetteaiSoundEffectsGeneratorData = z.object({
  body: zSchemaSoundEffectsGeneratorInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostCassetteaiSoundEffectsGeneratorResponse = zSchemaQueueStatus

export const zGetCassetteaiSoundEffectsGeneratorRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetCassetteaiSoundEffectsGeneratorRequestsByRequestIdResponse =
  zSchemaSoundEffectsGeneratorOutput

export const zGetCassetteaiMusicGeneratorRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetCassetteaiMusicGeneratorRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutCassetteaiMusicGeneratorRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutCassetteaiMusicGeneratorRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostCassetteaiMusicGeneratorData = z.object({
  body: zSchemaMusicGeneratorInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostCassetteaiMusicGeneratorResponse = zSchemaQueueStatus

export const zGetCassetteaiMusicGeneratorRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetCassetteaiMusicGeneratorRequestsByRequestIdResponse =
  zSchemaMusicGeneratorOutput

export const zGetFalAiCsm1bRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiCsm1bRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiCsm1bRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiCsm1bRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiCsm1bData = z.object({
  body: zSchemaCsm1bInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiCsm1bResponse = zSchemaQueueStatus

export const zGetFalAiCsm1bRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiCsm1bRequestsByRequestIdResponse = zSchemaCsm1bOutput

export const zGetFalAiDiffrhythmRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiDiffrhythmRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiDiffrhythmRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiDiffrhythmRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiDiffrhythmData = z.object({
  body: zSchemaDiffrhythmInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiDiffrhythmResponse = zSchemaQueueStatus

export const zGetFalAiDiffrhythmRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiDiffrhythmRequestsByRequestIdResponse =
  zSchemaDiffrhythmOutput

export const zGetFalAiElevenlabsTtsMultilingualV2RequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiElevenlabsTtsMultilingualV2RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiElevenlabsTtsMultilingualV2RequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiElevenlabsTtsMultilingualV2RequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiElevenlabsTtsMultilingualV2Data = z.object({
  body: zSchemaElevenlabsTtsMultilingualV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiElevenlabsTtsMultilingualV2Response = zSchemaQueueStatus

export const zGetFalAiElevenlabsTtsMultilingualV2RequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiElevenlabsTtsMultilingualV2RequestsByRequestIdResponse =
  zSchemaElevenlabsTtsMultilingualV2Output

export const zGetFalAiKokoroHindiRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiKokoroHindiRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKokoroHindiRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroHindiRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKokoroHindiData = z.object({
  body: zSchemaKokoroHindiInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKokoroHindiResponse = zSchemaQueueStatus

export const zGetFalAiKokoroHindiRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKokoroHindiRequestsByRequestIdResponse =
  zSchemaKokoroHindiOutput

export const zGetFalAiKokoroMandarinChineseRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiKokoroMandarinChineseRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKokoroMandarinChineseRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroMandarinChineseRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKokoroMandarinChineseData = z.object({
  body: zSchemaKokoroMandarinChineseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKokoroMandarinChineseResponse = zSchemaQueueStatus

export const zGetFalAiKokoroMandarinChineseRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKokoroMandarinChineseRequestsByRequestIdResponse =
  zSchemaKokoroMandarinChineseOutput

export const zGetFalAiKokoroSpanishRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiKokoroSpanishRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKokoroSpanishRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroSpanishRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKokoroSpanishData = z.object({
  body: zSchemaKokoroSpanishInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKokoroSpanishResponse = zSchemaQueueStatus

export const zGetFalAiKokoroSpanishRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKokoroSpanishRequestsByRequestIdResponse =
  zSchemaKokoroSpanishOutput

export const zGetFalAiKokoroBrazilianPortugueseRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiKokoroBrazilianPortugueseRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKokoroBrazilianPortugueseRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroBrazilianPortugueseRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiKokoroBrazilianPortugueseData = z.object({
  body: zSchemaKokoroBrazilianPortugueseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKokoroBrazilianPortugueseResponse = zSchemaQueueStatus

export const zGetFalAiKokoroBrazilianPortugueseRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiKokoroBrazilianPortugueseRequestsByRequestIdResponse =
  zSchemaKokoroBrazilianPortugueseOutput

export const zGetFalAiKokoroBritishEnglishRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiKokoroBritishEnglishRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKokoroBritishEnglishRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroBritishEnglishRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKokoroBritishEnglishData = z.object({
  body: zSchemaKokoroBritishEnglishInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKokoroBritishEnglishResponse = zSchemaQueueStatus

export const zGetFalAiKokoroBritishEnglishRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKokoroBritishEnglishRequestsByRequestIdResponse =
  zSchemaKokoroBritishEnglishOutput

export const zGetFalAiKokoroFrenchRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiKokoroFrenchRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKokoroFrenchRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroFrenchRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKokoroFrenchData = z.object({
  body: zSchemaKokoroFrenchInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKokoroFrenchResponse = zSchemaQueueStatus

export const zGetFalAiKokoroFrenchRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKokoroFrenchRequestsByRequestIdResponse =
  zSchemaKokoroFrenchOutput

export const zGetFalAiKokoroJapaneseRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiKokoroJapaneseRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKokoroJapaneseRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroJapaneseRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKokoroJapaneseData = z.object({
  body: zSchemaKokoroJapaneseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKokoroJapaneseResponse = zSchemaQueueStatus

export const zGetFalAiKokoroJapaneseRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKokoroJapaneseRequestsByRequestIdResponse =
  zSchemaKokoroJapaneseOutput

export const zGetFalAiKokoroAmericanEnglishRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiKokoroAmericanEnglishRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKokoroAmericanEnglishRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroAmericanEnglishRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKokoroAmericanEnglishData = z.object({
  body: zSchemaKokoroAmericanEnglishInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKokoroAmericanEnglishResponse = zSchemaQueueStatus

export const zGetFalAiKokoroAmericanEnglishRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKokoroAmericanEnglishRequestsByRequestIdResponse =
  zSchemaKokoroAmericanEnglishOutput

export const zGetFalAiZonosRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiZonosRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiZonosRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiZonosRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiZonosData = z.object({
  body: zSchemaZonosInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiZonosResponse = zSchemaQueueStatus

export const zGetFalAiZonosRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiZonosRequestsByRequestIdResponse = zSchemaZonosOutput

export const zGetFalAiKokoroItalianRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiKokoroItalianRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKokoroItalianRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiKokoroItalianRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKokoroItalianData = z.object({
  body: zSchemaKokoroItalianInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKokoroItalianResponse = zSchemaQueueStatus

export const zGetFalAiKokoroItalianRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKokoroItalianRequestsByRequestIdResponse =
  zSchemaKokoroItalianOutput

export const zGetFalAiYueRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiYueRequestsByRequestIdStatusResponse = zSchemaQueueStatus

export const zPutFalAiYueRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiYueRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiYueData = z.object({
  body: zSchemaYueInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiYueResponse = zSchemaQueueStatus

export const zGetFalAiYueRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiYueRequestsByRequestIdResponse = zSchemaYueOutput

export const zGetFalAiMmaudioV2TextToAudioRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiMmaudioV2TextToAudioRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiMmaudioV2TextToAudioRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiMmaudioV2TextToAudioRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiMmaudioV2TextToAudioData = z.object({
  body: zSchemaMmaudioV2TextToAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiMmaudioV2TextToAudioResponse = zSchemaQueueStatus

export const zGetFalAiMmaudioV2TextToAudioRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiMmaudioV2TextToAudioRequestsByRequestIdResponse =
  zSchemaMmaudioV2TextToAudioOutput

export const zGetFalAiMinimaxMusicRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiMinimaxMusicRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiMinimaxMusicRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiMinimaxMusicRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiMinimaxMusicData = z.object({
  body: zSchemaMinimaxMusicInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiMinimaxMusicResponse = zSchemaQueueStatus

export const zGetFalAiMinimaxMusicRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiMinimaxMusicRequestsByRequestIdResponse =
  zSchemaMinimaxMusicOutput

export const zGetFalAiF5TtsRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiF5TtsRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiF5TtsRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiF5TtsRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiF5TtsData = z.object({
  body: zSchemaF5TtsInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiF5TtsResponse = zSchemaQueueStatus

export const zGetFalAiF5TtsRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiF5TtsRequestsByRequestIdResponse = zSchemaF5TtsOutput

export const zGetFalAiStableAudioRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiStableAudioRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiStableAudioRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiStableAudioRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiStableAudioData = z.object({
  body: zSchemaStableAudioInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiStableAudioResponse = zSchemaQueueStatus

export const zGetFalAiStableAudioRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiStableAudioRequestsByRequestIdResponse =
  zSchemaStableAudioOutput
