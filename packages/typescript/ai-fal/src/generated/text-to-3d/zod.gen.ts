// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod'

export const zFile = z.object({
  url: z.url(),
  content_type: z.optional(z.string()),
  file_name: z.optional(z.string()),
  file_size: z.optional(z.int()),
})

export const zQueueStatus = z.object({
  status: z.enum(['IN_PROGRESS', 'COMPLETED', 'FAILED']),
  response_url: z.optional(z.url()),
})

/**
 * HYMotionInput
 */
export const zHunyuanMotionFastInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text prompt describing the motion to generate.',
  }),
  duration: z
    .optional(
      z.number().gte(0.5).lte(12).register(z.globalRegistry, {
        description: 'Motion duration in seconds (0.5-12.0).',
      }),
    )
    .default(5),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher = more faithful to prompt.',
      }),
    )
    .default(5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducible generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['fbx', 'dict']).register(z.globalRegistry, {
      description:
        "Output format: 'fbx' for animation files, 'dict' for raw JSON.",
    }),
  ),
})

/**
 * File
 */
export const zFalAiHunyuanMotionFastFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * HYMotionOutput
 */
export const zHunyuanMotionFastOutput = z.object({
  fbx_file: z.optional(zFalAiHunyuanMotionFastFile),
  motion_json: z.optional(zFalAiHunyuanMotionFastFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation.',
  }),
})

/**
 * HYMotionInput
 */
export const zHunyuanMotionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text prompt describing the motion to generate.',
  }),
  duration: z
    .optional(
      z.number().gte(0.5).lte(12).register(z.globalRegistry, {
        description: 'Motion duration in seconds (0.5-12.0).',
      }),
    )
    .default(5),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher = more faithful to prompt.',
      }),
    )
    .default(5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducible generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['fbx', 'dict']).register(z.globalRegistry, {
      description:
        "Output format: 'fbx' for animation files, 'dict' for raw JSON.",
    }),
  ),
})

/**
 * File
 */
export const zFalAiHunyuanMotionFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * HYMotionOutput
 */
export const zHunyuanMotionOutput = z.object({
  fbx_file: z.optional(zFalAiHunyuanMotionFile),
  motion_json: z.optional(zFalAiHunyuanMotionFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation.',
  }),
})

/**
 * TextTo3DInput
 */
export const zHunyuan3dV3TextTo3dInput = z.object({
  enable_pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable PBR material generation',
      }),
    )
    .default(false),
  polygon_type: z.optional(
    z.enum(['triangle', 'quadrilateral']).register(z.globalRegistry, {
      description:
        'Polygon type. Only takes effect when GenerateType is LowPoly.',
    }),
  ),
  face_count: z
    .optional(
      z.int().gte(40000).lte(1500000).register(z.globalRegistry, {
        description: 'Target face count. Range: 40000-1500000',
      }),
    )
    .default(500000),
  prompt: z.string().max(1024).register(z.globalRegistry, {
    description:
      'Text description of the 3D content to generate. Supports up to 1024 UTF-8 characters.',
  }),
  generate_type: z.optional(
    z.enum(['Normal', 'LowPoly', 'Geometry']).register(z.globalRegistry, {
      description:
        'Generation type. Normal: textured model. LowPoly: polygon reduction. Geometry: white model without texture.',
    }),
  ),
})

/**
 * File
 */
export const zFalAiHunyuan3dV3TextTo3dFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ModelUrls
 */
export const zModelUrls = z.object({
  fbx: z.optional(zFalAiHunyuan3dV3TextTo3dFile),
  usdz: z.optional(zFalAiHunyuan3dV3TextTo3dFile),
  glb: z.optional(zFalAiHunyuan3dV3TextTo3dFile),
  obj: z.optional(zFalAiHunyuan3dV3TextTo3dFile),
})

/**
 * TextTo3DOutput
 */
export const zHunyuan3dV3TextTo3dOutput = z.object({
  model_urls: zModelUrls,
  thumbnail: z.optional(zFalAiHunyuan3dV3TextTo3dFile),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
  ),
  model_glb: zFalAiHunyuan3dV3TextTo3dFile,
})

/**
 * TextTo3DInput
 *
 * Input for Text to 3D conversion
 */
export const zMeshyV6PreviewTextTo3dInput = z
  .object({
    prompt: z.string().max(600).register(z.globalRegistry, {
      description:
        'Describe what kind of object the 3D model is. Maximum 600 characters.',
    }),
    enable_pbr: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Generate PBR Maps (metallic, roughness, normal) in addition to base color. Should be false for sculpture style.',
        }),
      )
      .default(false),
    target_polycount: z
      .optional(
        z.int().gte(100).lte(300000).register(z.globalRegistry, {
          description: 'Target number of polygons in the generated model',
        }),
      )
      .default(30000),
    art_style: z.optional(
      z.enum(['realistic', 'sculpture']).register(z.globalRegistry, {
        description:
          'Desired art style of the object. Note: enable_pbr should be false for sculpture style.',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If set to true, input data will be checked for safety before processing.',
        }),
      )
      .default(true),
    mode: z.optional(
      z.enum(['preview', 'full']).register(z.globalRegistry, {
        description:
          "Generation mode. 'preview' returns untextured geometry only, 'full' returns textured model (preview + refine).",
      }),
    ),
    symmetry_mode: z.optional(
      z.enum(['off', 'auto', 'on']).register(z.globalRegistry, {
        description: 'Controls symmetry behavior during model generation.',
      }),
    ),
    should_remesh: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the remesh phase. When false, returns unprocessed triangular mesh.',
        }),
      )
      .default(true),
    texture_image_url: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          "2D image to guide the texturing process (only used in 'full' mode)",
      }),
    ),
    topology: z.optional(
      z.enum(['quad', 'triangle']).register(z.globalRegistry, {
        description:
          'Specify the topology of the generated model. Quad for smooth surfaces, Triangle for detailed geometry.',
      }),
    ),
    enable_prompt_expansion: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.',
        }),
      )
      .default(false),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          'Seed for reproducible results. Same prompt and seed usually generate the same result.',
      }),
    ),
    is_a_t_pose: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to generate the model in an A/T pose',
        }),
      )
      .default(false),
    texture_prompt: z.optional(
      z.string().max(600).register(z.globalRegistry, {
        description:
          "Additional text prompt to guide the texturing process (only used in 'full' mode)",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Input for Text to 3D conversion',
  })

/**
 * File
 */
export const zFalAiMeshyV6PreviewTextTo3dFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * TextureFiles
 *
 * Texture files downloaded and uploaded to CDN
 */
export const zTextureFiles = z
  .object({
    base_color: zFalAiMeshyV6PreviewTextTo3dFile,
    normal: z.optional(zFalAiMeshyV6PreviewTextTo3dFile),
    roughness: z.optional(zFalAiMeshyV6PreviewTextTo3dFile),
    metallic: z.optional(zFalAiMeshyV6PreviewTextTo3dFile),
  })
  .register(z.globalRegistry, {
    description: 'Texture files downloaded and uploaded to CDN',
  })

/**
 * ModelUrls
 *
 * 3D model files in various formats
 */
export const zFalAiMeshyV6PreviewTextTo3dModelUrls = z
  .object({
    usdz: z.optional(zFalAiMeshyV6PreviewTextTo3dFile),
    fbx: z.optional(zFalAiMeshyV6PreviewTextTo3dFile),
    blend: z.optional(zFalAiMeshyV6PreviewTextTo3dFile),
    stl: z.optional(zFalAiMeshyV6PreviewTextTo3dFile),
    glb: z.optional(zFalAiMeshyV6PreviewTextTo3dFile),
    obj: z.optional(zFalAiMeshyV6PreviewTextTo3dFile),
  })
  .register(z.globalRegistry, {
    description: '3D model files in various formats',
  })

/**
 * TextTo3DOutput
 *
 * Output for Text to 3D generation
 */
export const zMeshyV6PreviewTextTo3dOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'The text prompt used for generation',
    }),
    thumbnail: z.optional(zFalAiMeshyV6PreviewTextTo3dFile),
    actual_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The actual prompt used if prompt expansion was enabled',
      }),
    ),
    texture_urls: z.optional(
      z.array(zTextureFiles).register(z.globalRegistry, {
        description: 'Array of texture file objects',
      }),
    ),
    model_glb: zFalAiMeshyV6PreviewTextTo3dFile,
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The seed used for generation',
      }),
    ),
    model_urls: zFalAiMeshyV6PreviewTextTo3dModelUrls,
  })
  .register(z.globalRegistry, {
    description: 'Output for Text to 3D generation',
  })
