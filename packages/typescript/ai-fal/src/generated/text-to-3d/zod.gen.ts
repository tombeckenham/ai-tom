// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod'

/**
 * File
 */
export const zSchemaFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * TextureFiles
 *
 * Texture files downloaded and uploaded to CDN
 */
export const zSchemaTextureFiles = z
  .object({
    base_color: zSchemaFile,
    normal: z.optional(zSchemaFile),
    roughness: z.optional(zSchemaFile),
    metallic: z.optional(zSchemaFile),
  })
  .register(z.globalRegistry, {
    description: 'Texture files downloaded and uploaded to CDN',
  })

/**
 * ModelUrls
 *
 * 3D model files in various formats
 */
export const zSchemaModelUrls = z
  .object({
    usdz: z.optional(zSchemaFile),
    fbx: z.optional(zSchemaFile),
    blend: z.optional(zSchemaFile),
    stl: z.optional(zSchemaFile),
    glb: z.optional(zSchemaFile),
    obj: z.optional(zSchemaFile),
  })
  .register(z.globalRegistry, {
    description: '3D model files in various formats',
  })

/**
 * TextTo3DOutput
 *
 * Output for Text to 3D generation
 */
export const zSchemaMeshyV6PreviewTextTo3dOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'The text prompt used for generation',
    }),
    thumbnail: z.optional(zSchemaFile),
    actual_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The actual prompt used if prompt expansion was enabled',
      }),
    ),
    texture_urls: z.optional(
      z.array(zSchemaTextureFiles).register(z.globalRegistry, {
        description: 'Array of texture file objects',
      }),
    ),
    model_glb: zSchemaFile,
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The seed used for generation',
      }),
    ),
    model_urls: zSchemaModelUrls,
  })
  .register(z.globalRegistry, {
    description: 'Output for Text to 3D generation',
  })

/**
 * TextTo3DInput
 *
 * Input for Text to 3D conversion
 */
export const zSchemaMeshyV6PreviewTextTo3dInput = z
  .object({
    prompt: z.string().max(600).register(z.globalRegistry, {
      description:
        'Describe what kind of object the 3D model is. Maximum 600 characters.',
    }),
    enable_pbr: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Generate PBR Maps (metallic, roughness, normal) in addition to base color. Should be false for sculpture style.',
        }),
      )
      .default(false),
    target_polycount: z
      .optional(
        z.int().gte(100).lte(300000).register(z.globalRegistry, {
          description: 'Target number of polygons in the generated model',
        }),
      )
      .default(30000),
    art_style: z.optional(
      z.enum(['realistic', 'sculpture']).register(z.globalRegistry, {
        description:
          'Desired art style of the object. Note: enable_pbr should be false for sculpture style.',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If set to true, input data will be checked for safety before processing.',
        }),
      )
      .default(true),
    mode: z.optional(
      z.enum(['preview', 'full']).register(z.globalRegistry, {
        description:
          "Generation mode. 'preview' returns untextured geometry only, 'full' returns textured model (preview + refine).",
      }),
    ),
    symmetry_mode: z.optional(
      z.enum(['off', 'auto', 'on']).register(z.globalRegistry, {
        description: 'Controls symmetry behavior during model generation.',
      }),
    ),
    should_remesh: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the remesh phase. When false, returns unprocessed triangular mesh.',
        }),
      )
      .default(true),
    texture_image_url: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          "2D image to guide the texturing process (only used in 'full' mode)",
      }),
    ),
    topology: z.optional(
      z.enum(['quad', 'triangle']).register(z.globalRegistry, {
        description:
          'Specify the topology of the generated model. Quad for smooth surfaces, Triangle for detailed geometry.',
      }),
    ),
    enable_prompt_expansion: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.',
        }),
      )
      .default(false),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          'Seed for reproducible results. Same prompt and seed usually generate the same result.',
      }),
    ),
    is_a_t_pose: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to generate the model in an A/T pose',
        }),
      )
      .default(false),
    texture_prompt: z.optional(
      z.string().max(600).register(z.globalRegistry, {
        description:
          "Additional text prompt to guide the texturing process (only used in 'full' mode)",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Input for Text to 3D conversion',
  })

/**
 * TextTo3DOutput
 */
export const zSchemaHunyuan3dV3TextTo3dOutput = z.object({
  model_urls: zSchemaModelUrls,
  thumbnail: z.optional(zSchemaFile),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
  ),
  model_glb: zSchemaFile,
})

/**
 * TextTo3DInput
 */
export const zSchemaHunyuan3dV3TextTo3dInput = z.object({
  enable_pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable PBR material generation',
      }),
    )
    .default(false),
  polygon_type: z.optional(
    z.enum(['triangle', 'quadrilateral']).register(z.globalRegistry, {
      description:
        'Polygon type. Only takes effect when GenerateType is LowPoly.',
    }),
  ),
  face_count: z
    .optional(
      z.int().gte(40000).lte(1500000).register(z.globalRegistry, {
        description: 'Target face count. Range: 40000-1500000',
      }),
    )
    .default(500000),
  prompt: z.string().max(1024).register(z.globalRegistry, {
    description:
      'Text description of the 3D content to generate. Supports up to 1024 UTF-8 characters.',
  }),
  generate_type: z.optional(
    z.enum(['Normal', 'LowPoly', 'Geometry']).register(z.globalRegistry, {
      description:
        'Generation type. Normal: textured model. LowPoly: polygon reduction. Geometry: white model without texture.',
    }),
  ),
})

/**
 * HYMotionOutput
 */
export const zSchemaHunyuanMotionOutput = z.object({
  fbx_file: z.optional(zSchemaFile),
  motion_json: z.optional(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation.',
  }),
})

/**
 * HYMotionInput
 */
export const zSchemaHunyuanMotionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text prompt describing the motion to generate.',
  }),
  duration: z
    .optional(
      z.number().gte(0.5).lte(12).register(z.globalRegistry, {
        description: 'Motion duration in seconds (0.5-12.0).',
      }),
    )
    .default(5),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher = more faithful to prompt.',
      }),
    )
    .default(5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducible generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['fbx', 'dict']).register(z.globalRegistry, {
      description:
        "Output format: 'fbx' for animation files, 'dict' for raw JSON.",
    }),
  ),
})

/**
 * HYMotionOutput
 */
export const zSchemaHunyuanMotionFastOutput = z.object({
  fbx_file: z.optional(zSchemaFile),
  motion_json: z.optional(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation.',
  }),
})

/**
 * HYMotionInput
 */
export const zSchemaHunyuanMotionFastInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text prompt describing the motion to generate.',
  }),
  duration: z
    .optional(
      z.number().gte(0.5).lte(12).register(z.globalRegistry, {
        description: 'Motion duration in seconds (0.5-12.0).',
      }),
    )
    .default(5),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher = more faithful to prompt.',
      }),
    )
    .default(5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducible generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['fbx', 'dict']).register(z.globalRegistry, {
      description:
        "Output format: 'fbx' for animation files, 'dict' for raw JSON.",
    }),
  ),
})

export const zSchemaQueueStatus = z.object({
  status: z.enum(['IN_QUEUE', 'IN_PROGRESS', 'COMPLETED']),
  request_id: z.string().register(z.globalRegistry, {
    description: 'The request id.',
  }),
  response_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The response url.',
    }),
  ),
  status_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The status url.',
    }),
  ),
  cancel_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The cancel url.',
    }),
  ),
  logs: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The logs.',
    }),
  ),
  metrics: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The metrics.',
    }),
  ),
  queue_position: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The queue position.',
    }),
  ),
})

export const zGetFalAiHunyuanMotionFastRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiHunyuanMotionFastRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuanMotionFastRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuanMotionFastRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHunyuanMotionFastData = z.object({
  body: zSchemaHunyuanMotionFastInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuanMotionFastResponse = zSchemaQueueStatus

export const zGetFalAiHunyuanMotionFastRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHunyuanMotionFastRequestsByRequestIdResponse =
  zSchemaHunyuanMotionFastOutput

export const zGetFalAiHunyuanMotionRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiHunyuanMotionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuanMotionRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuanMotionRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHunyuanMotionData = z.object({
  body: zSchemaHunyuanMotionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuanMotionResponse = zSchemaQueueStatus

export const zGetFalAiHunyuanMotionRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHunyuanMotionRequestsByRequestIdResponse =
  zSchemaHunyuanMotionOutput

export const zGetFalAiHunyuan3dV3TextTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV3TextTo3dRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuan3dV3TextTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV3TextTo3dRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHunyuan3dV3TextTo3dData = z.object({
  body: zSchemaHunyuan3dV3TextTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV3TextTo3dResponse = zSchemaQueueStatus

export const zGetFalAiHunyuan3dV3TextTo3dRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV3TextTo3dRequestsByRequestIdResponse =
  zSchemaHunyuan3dV3TextTo3dOutput

export const zGetFalAiMeshyV6PreviewTextTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiMeshyV6PreviewTextTo3dRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiMeshyV6PreviewTextTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiMeshyV6PreviewTextTo3dRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiMeshyV6PreviewTextTo3dData = z.object({
  body: zSchemaMeshyV6PreviewTextTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiMeshyV6PreviewTextTo3dResponse = zSchemaQueueStatus

export const zGetFalAiMeshyV6PreviewTextTo3dRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiMeshyV6PreviewTextTo3dRequestsByRequestIdResponse =
  zSchemaMeshyV6PreviewTextTo3dOutput
