// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

export const zFile = z.object({
    url: z.url(),
    content_type: z.optional(z.string()),
    file_name: z.optional(z.string()),
    file_size: z.optional(z.int())
});

export const zQueueStatus = z.object({
    status: z.enum([
        'IN_PROGRESS',
        'COMPLETED',
        'FAILED'
    ]),
    response_url: z.optional(z.url())
});

/**
 * SpeechToTextRequestScribeV2
 */
export const zElevenlabsSpeechToTextScribeV2Input = z.object({
    keyterms: z.optional(z.array(z.string()).max(100)).default([]),
    audio_url: z.string(),
    diarize: z.optional(z.boolean()).default(true),
    language_code: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    tag_audio_events: z.optional(z.boolean()).default(true)
});

/**
 * TranscriptionWord
 */
export const zTranscriptionWord = z.object({
    text: z.string(),
    start: z.union([
        z.number(),
        z.unknown()
    ]),
    type: z.string(),
    end: z.union([
        z.number(),
        z.unknown()
    ]),
    speaker_id: z.optional(z.union([
        z.string(),
        z.unknown()
    ]))
});

/**
 * TranscriptionOutputV2
 */
export const zElevenlabsSpeechToTextScribeV2Output = z.object({
    text: z.string(),
    language_probability: z.number(),
    language_code: z.string(),
    words: z.array(zTranscriptionWord)
});

/**
 * SmartTurnInput
 */
export const zSmartTurnInput = z.object({
    audio_url: z.string()
});

/**
 * Output
 */
export const zSmartTurnOutput = z.object({
    prediction: z.int(),
    probability: z.number(),
    metrics: z.record(z.string(), z.unknown())
});

/**
 * SpeechInput
 */
export const zSpeechToTextTurboInput = z.object({
    audio_url: z.string(),
    use_pnc: z.optional(z.boolean()).default(true)
});

/**
 * SpeechOutput
 */
export const zSpeechToTextTurboOutput = z.object({
    partial: z.optional(z.boolean()).default(false),
    output: z.string()
});

/**
 * SpeechInput
 */
export const zSpeechToTextTurboStreamInput = z.object({
    audio_url: z.string(),
    use_pnc: z.optional(z.boolean()).default(true)
});

export const zSpeechToTextTurboStreamOutput = z.unknown();

/**
 * SpeechInput
 */
export const zSpeechToTextStreamInput = z.object({
    audio_url: z.string(),
    use_pnc: z.optional(z.boolean()).default(true)
});

export const zSpeechToTextStreamOutput = z.unknown();

/**
 * SpeechInput
 */
export const zSpeechToTextInput = z.object({
    audio_url: z.string(),
    use_pnc: z.optional(z.boolean()).default(true)
});

/**
 * SpeechOutput
 */
export const zSpeechToTextOutput = z.object({
    partial: z.optional(z.boolean()).default(false),
    output: z.string()
});

/**
 * SpeechToTextRequest
 */
export const zElevenlabsSpeechToTextInput = z.object({
    language_code: z.optional(z.union([
        z.string(),
        z.unknown()
    ])),
    audio_url: z.string(),
    diarize: z.optional(z.boolean()).default(true),
    tag_audio_events: z.optional(z.boolean()).default(true)
});

/**
 * TranscriptionWord
 */
export const zFalAiElevenlabsSpeechToTextTranscriptionWord = z.object({
    text: z.string(),
    start: z.union([
        z.number(),
        z.unknown()
    ]),
    type: z.string(),
    end: z.union([
        z.number(),
        z.unknown()
    ]),
    speaker_id: z.optional(z.union([
        z.string(),
        z.unknown()
    ]))
});

/**
 * TranscriptionOutput
 */
export const zElevenlabsSpeechToTextOutput = z.object({
    text: z.string(),
    language_probability: z.number(),
    language_code: z.string(),
    words: z.array(zFalAiElevenlabsSpeechToTextTranscriptionWord)
});

/**
 * WhisperInput
 */
export const zWizperInput = z.object({
    language: z.optional(z.union([
        z.enum([
            'af',
            'am',
            'ar',
            'as',
            'az',
            'ba',
            'be',
            'bg',
            'bn',
            'bo',
            'br',
            'bs',
            'ca',
            'cs',
            'cy',
            'da',
            'de',
            'el',
            'en',
            'es',
            'et',
            'eu',
            'fa',
            'fi',
            'fo',
            'fr',
            'gl',
            'gu',
            'ha',
            'haw',
            'he',
            'hi',
            'hr',
            'ht',
            'hu',
            'hy',
            'id',
            'is',
            'it',
            'ja',
            'jw',
            'ka',
            'kk',
            'km',
            'kn',
            'ko',
            'la',
            'lb',
            'ln',
            'lo',
            'lt',
            'lv',
            'mg',
            'mi',
            'mk',
            'ml',
            'mn',
            'mr',
            'ms',
            'mt',
            'my',
            'ne',
            'nl',
            'nn',
            'no',
            'oc',
            'pa',
            'pl',
            'ps',
            'pt',
            'ro',
            'ru',
            'sa',
            'sd',
            'si',
            'sk',
            'sl',
            'sn',
            'so',
            'sq',
            'sr',
            'su',
            'sv',
            'sw',
            'ta',
            'te',
            'tg',
            'th',
            'tk',
            'tl',
            'tr',
            'tt',
            'uk',
            'ur',
            'uz',
            'vi',
            'yi',
            'yo',
            'zh'
        ]),
        z.unknown()
    ])),
    version: z.optional(z.string()).default('3'),
    max_segment_len: z.optional(z.int().gte(10).lte(29)).default(29),
    task: z.optional(z.enum(['transcribe', 'translate'])),
    chunk_level: z.optional(z.string()).default('segment'),
    audio_url: z.string(),
    merge_chunks: z.optional(z.boolean()).default(true)
});

/**
 * WhisperChunk
 */
export const zWhisperChunk = z.object({
    text: z.string(),
    timestamp: z.tuple([])
});

/**
 * WhisperOutput
 */
export const zWizperOutput = z.object({
    text: z.string(),
    languages: z.array(z.enum([
        'af',
        'am',
        'ar',
        'as',
        'az',
        'ba',
        'be',
        'bg',
        'bn',
        'bo',
        'br',
        'bs',
        'ca',
        'cs',
        'cy',
        'da',
        'de',
        'el',
        'en',
        'es',
        'et',
        'eu',
        'fa',
        'fi',
        'fo',
        'fr',
        'gl',
        'gu',
        'ha',
        'haw',
        'he',
        'hi',
        'hr',
        'ht',
        'hu',
        'hy',
        'id',
        'is',
        'it',
        'ja',
        'jw',
        'ka',
        'kk',
        'km',
        'kn',
        'ko',
        'la',
        'lb',
        'ln',
        'lo',
        'lt',
        'lv',
        'mg',
        'mi',
        'mk',
        'ml',
        'mn',
        'mr',
        'ms',
        'mt',
        'my',
        'ne',
        'nl',
        'nn',
        'no',
        'oc',
        'pa',
        'pl',
        'ps',
        'pt',
        'ro',
        'ru',
        'sa',
        'sd',
        'si',
        'sk',
        'sl',
        'sn',
        'so',
        'sq',
        'sr',
        'su',
        'sv',
        'sw',
        'ta',
        'te',
        'tg',
        'th',
        'tk',
        'tl',
        'tr',
        'tt',
        'uk',
        'ur',
        'uz',
        'vi',
        'yi',
        'yo',
        'zh'
    ])),
    chunks: z.array(zWhisperChunk)
});

/**
 * WhisperInput
 */
export const zWhisperInput = z.object({
    version: z.optional(z.enum(['3'])),
    batch_size: z.optional(z.int().gte(1).lte(64)).default(64),
    language: z.optional(z.enum([
        'af',
        'am',
        'ar',
        'as',
        'az',
        'ba',
        'be',
        'bg',
        'bn',
        'bo',
        'br',
        'bs',
        'ca',
        'cs',
        'cy',
        'da',
        'de',
        'el',
        'en',
        'es',
        'et',
        'eu',
        'fa',
        'fi',
        'fo',
        'fr',
        'gl',
        'gu',
        'ha',
        'haw',
        'he',
        'hi',
        'hr',
        'ht',
        'hu',
        'hy',
        'id',
        'is',
        'it',
        'ja',
        'jw',
        'ka',
        'kk',
        'km',
        'kn',
        'ko',
        'la',
        'lb',
        'ln',
        'lo',
        'lt',
        'lv',
        'mg',
        'mi',
        'mk',
        'ml',
        'mn',
        'mr',
        'ms',
        'mt',
        'my',
        'ne',
        'nl',
        'nn',
        'no',
        'oc',
        'pa',
        'pl',
        'ps',
        'pt',
        'ro',
        'ru',
        'sa',
        'sd',
        'si',
        'sk',
        'sl',
        'sn',
        'so',
        'sq',
        'sr',
        'su',
        'sv',
        'sw',
        'ta',
        'te',
        'tg',
        'th',
        'tk',
        'tl',
        'tr',
        'tt',
        'uk',
        'ur',
        'uz',
        'vi',
        'yi',
        'yo',
        'zh'
    ])),
    prompt: z.optional(z.string()).default(''),
    num_speakers: z.optional(z.union([
        z.int().gte(1),
        z.null()
    ])),
    task: z.optional(z.enum(['transcribe', 'translate'])),
    chunk_level: z.optional(z.enum([
        'none',
        'segment',
        'word'
    ])),
    audio_url: z.string(),
    diarize: z.optional(z.boolean()).default(false)
});

/**
 * WhisperChunk
 */
export const zFalAiWhisperWhisperChunk = z.object({
    text: z.string(),
    timestamp: z.tuple([z.unknown(), z.unknown()]),
    speaker: z.optional(z.string())
});

/**
 * DiarizationSegment
 */
export const zDiarizationSegment = z.object({
    timestamp: z.tuple([z.unknown(), z.unknown()]),
    speaker: z.string()
});

/**
 * WhisperOutput
 */
export const zWhisperOutput = z.object({
    text: z.string(),
    inferred_languages: z.array(z.enum([
        'af',
        'am',
        'ar',
        'as',
        'az',
        'ba',
        'be',
        'bg',
        'bn',
        'bo',
        'br',
        'bs',
        'ca',
        'cs',
        'cy',
        'da',
        'de',
        'el',
        'en',
        'es',
        'et',
        'eu',
        'fa',
        'fi',
        'fo',
        'fr',
        'gl',
        'gu',
        'ha',
        'haw',
        'he',
        'hi',
        'hr',
        'ht',
        'hu',
        'hy',
        'id',
        'is',
        'it',
        'ja',
        'jw',
        'ka',
        'kk',
        'km',
        'kn',
        'ko',
        'la',
        'lb',
        'ln',
        'lo',
        'lt',
        'lv',
        'mg',
        'mi',
        'mk',
        'ml',
        'mn',
        'mr',
        'ms',
        'mt',
        'my',
        'ne',
        'nl',
        'nn',
        'no',
        'oc',
        'pa',
        'pl',
        'ps',
        'pt',
        'ro',
        'ru',
        'sa',
        'sd',
        'si',
        'sk',
        'sl',
        'sn',
        'so',
        'sq',
        'sr',
        'su',
        'sv',
        'sw',
        'ta',
        'te',
        'tg',
        'th',
        'tk',
        'tl',
        'tr',
        'tt',
        'uk',
        'ur',
        'uz',
        'vi',
        'yi',
        'yo',
        'zh'
    ])),
    chunks: z.optional(z.array(zFalAiWhisperWhisperChunk)),
    diarization_segments: z.array(zDiarizationSegment)
});
