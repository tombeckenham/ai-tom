// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
  baseUrl: 'https://queue.fal.run' | (string & {})
}

/**
 * RemoveBackgroundOutput
 */
export type SchemaImageutilsRembgOutput = {
  /**
   * Image
   *
   * Background removed image.
   */
  image: SchemaImage
}

/**
 * Image
 *
 * Represents an image file.
 */
export type SchemaImage = {
  /**
   * Height
   *
   * The height of the image in pixels.
   */
  height?: number
  /**
   * File Size
   *
   * The size of the file in bytes.
   */
  file_size?: number
  /**
   * Url
   *
   * The URL where the file can be downloaded from.
   */
  url: string
  /**
   * Width
   *
   * The width of the image in pixels.
   */
  width?: number
  /**
   * File Name
   *
   * The name of the file. It will be auto-generated if not provided.
   */
  file_name?: string
  /**
   * Content Type
   *
   * The mime type of the file.
   */
  content_type?: string
  /**
   * File Data
   *
   * File data
   */
  file_data?: Blob | File
}

/**
 * RemoveBackgroundInput
 */
export type SchemaImageutilsRembgInput = {
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Crop To Bbox
   *
   *
   * If set to true, the resulting image be cropped to a bounding box around the subject
   *
   */
  crop_to_bbox?: boolean
  /**
   * Image Url
   *
   * Input image url.
   */
  image_url: string
}

/**
 * UpscaleOutput
 */
export type SchemaEsrganOutput = {
  /**
   * Image
   *
   * Upscaled image
   */
  image: SchemaImage
}

/**
 * UpscaleInput
 */
export type SchemaEsrganInput = {
  /**
   * Model
   *
   * Model to use for upscaling
   */
  model?:
    | 'RealESRGAN_x4plus'
    | 'RealESRGAN_x2plus'
    | 'RealESRGAN_x4plus_anime_6B'
    | 'RealESRGAN_x4_v3'
    | 'RealESRGAN_x4_wdn_v3'
    | 'RealESRGAN_x4_anime_v3'
  /**
   * Face
   *
   * Upscaling a face
   */
  face?: boolean
  /**
   * Scale
   *
   * Rescaling factor
   */
  scale?: number
  /**
   * Tile
   *
   * Tile size. Default is 0, that is no tile. When encountering the out-of-GPU-memory issue, please specify it, e.g., 400 or 200
   */
  tile?: number
  /**
   * Output Format
   *
   * Output image format (png or jpeg)
   */
  output_format?: 'png' | 'jpeg'
  /**
   * Image Url
   *
   * Url to input image
   */
  image_url: string
}

/**
 * InpaintOutput
 */
export type SchemaInpaintOutput = {
  /**
   * Image
   *
   * The generated image files info.
   */
  image: SchemaImage
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * InpaintInput
 */
export type SchemaInpaintInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Url
   *
   * Input image for img2img or inpaint mode
   */
  image_url: string
  /**
   * Model Name
   *
   * URL or HuggingFace ID of the base model to generate the image.
   */
  model_name: string
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Number of inference steps
   *
   *
   * Increasing the amount of steps tells Stable Diffusion that it should take more steps
   * to generate your final result which can increase the amount of detail in your image.
   *
   */
  num_inference_steps?: number
  /**
   * Mask Url
   *
   * Input mask for inpaint mode. Black areas will be preserved, white areas will be inpainted.
   */
  mask_url: string
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * LCMOutput
 */
export type SchemaLcmSd15I2iOutput = {
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Num Inference Steps
   *
   *
   * Number of inference steps used to generate the image. It will be the same value of the one passed in the
   * input or the default one in case none was passed.
   *
   */
  num_inference_steps?: number
  /**
   * Nsfw Content Detected
   *
   *
   * A list of booleans indicating whether the generated image contains any
   * potentially unsafe content. If the safety check is disabled, this field
   * will have a false for each generated image.
   *
   */
  nsfw_content_detected: Array<boolean>
}

/**
 * LCMI2IInput
 */
export type SchemaLcmSd15I2iInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Num Images
   *
   *
   * The number of images to generate. The function will return a list of images
   * with the same prompt and negative prompt but different seeds.
   *
   */
  num_images?: number
  /**
   * Image Url
   *
   * The image to use as a base.
   */
  image_url: string
  /**
   * Strength
   *
   * The strength of the image.
   */
  strength?: number
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checks
   *
   *
   * If set to true, the resulting image will be checked whether it includes any
   * potentially unsafe content. If it does, it will be replaced with a black
   * image.
   *
   */
  enable_safety_checks?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use.Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   *
   * The number of inference steps to use for generating the image. The more steps
   * the better the image will be but it will also take longer to generate.
   *
   */
  num_inference_steps?: number
}

/**
 * Output
 */
export type SchemaFastSdxlControlnetCannyInpaintingOutput = {
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * InpaintingControlNetInput
 */
export type SchemaFastSdxlControlnetCannyInpaintingInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image. Leave it none to automatically infer from the control image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | null
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Loras
   *
   * The list of LoRA weights to use.
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use.Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Controlnet Conditioning Scale
   *
   * The scale of the controlnet conditioning.
   */
  controlnet_conditioning_scale?: number
  /**
   * Image Url
   *
   * The URL of the image to use as a starting point for the generation.
   */
  image_url: string
  /**
   * Strength
   *
   * determines how much the generated image resembles the initial image
   */
  strength?: number
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Control Image Url
   *
   * The URL of the control image.
   */
  control_image_url: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Mask Url
   *
   * The URL of the mask to use for inpainting.
   */
  mask_url: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * LoraWeight
 */
export type SchemaLoraWeight = {
  /**
   * Path
   *
   * URL or the path to the LoRA weights. Or HF model name.
   */
  path: string
  /**
   * Scale
   *
   *
   * The scale of the LoRA weight. This is used to scale the LoRA weight
   * before merging it with the base model.
   *
   */
  scale?: number
}

/**
 * ImageSize
 */
export type SchemaImageSize = {
  /**
   * Height
   *
   * The height of the generated image.
   */
  height?: number
  /**
   * Width
   *
   * The width of the generated image.
   */
  width?: number
}

/**
 * Output
 */
export type SchemaFastSdxlControlnetCannyImageToImageOutput = {
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * ImageToImageControlNetInput
 */
export type SchemaFastSdxlControlnetCannyImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image. Leave it none to automatically infer from the control image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | null
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Loras
   *
   * The list of LoRA weights to use.
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use.Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Controlnet Conditioning Scale
   *
   * The scale of the controlnet conditioning.
   */
  controlnet_conditioning_scale?: number
  /**
   * Image Url
   *
   * The URL of the image to use as a starting point for the generation.
   */
  image_url: string
  /**
   * Strength
   *
   * determines how much the generated image resembles the initial image
   */
  strength?: number
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Control Image Url
   *
   * The URL of the control image.
   */
  control_image_url: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * ReferenceFace
 */
export type SchemaReferenceFace = {
  /**
   * Image Url
   *
   * URL of the reference face image
   */
  image_url: string
}

/**
 * OutputModel
 */
export type SchemaPulidOutput = {
  /**
   * Images
   *
   * List of generated images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * Random seed used for reproducibility
   */
  seed: number
}

/**
 * InputModel
 */
export type SchemaPulidInput = {
  /**
   * Prompt
   *
   * Prompt to generate the face from
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * Size of the generated image
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Id Scale
   *
   * ID scale
   */
  id_scale?: number
  /**
   * Mode
   *
   * Mode of generation
   */
  mode?: 'fidelity' | 'extreme style'
  /**
   * Id Mix
   *
   * if you want to mix two ID image, please turn this on, otherwise, turn this off
   */
  id_mix?: boolean
  /**
   * Guidance Scale
   *
   * Guidance scale
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of steps to take
   */
  num_inference_steps?: number
  /**
   * Reference Images
   *
   * List of reference faces, ideally 4 images.
   */
  reference_images: Array<SchemaReferenceFace>
  /**
   * Negative Prompt
   *
   * Negative prompt to generate the face from
   */
  negative_prompt?: string
  /**
   * Seed
   *
   * Random seed for reproducibility
   */
  seed?: number
}

/**
 * MarigoldDepthMapOutput
 */
export type SchemaImageutilsMarigoldDepthOutput = {
  /**
   * Image
   *
   * The depth map.
   */
  image: SchemaImage
}

/**
 * MarigoldDepthMapInput
 */
export type SchemaImageutilsMarigoldDepthInput = {
  /**
   * Ensemble Size
   *
   * Number of predictions to average over. Defaults to `10`. The higher the number, the more accurate the result, but the slower the inference.
   */
  ensemble_size?: number
  /**
   * Num Inference Steps
   *
   * Number of denoising steps. Defaults to `10`. The higher the number, the more accurate the result, but the slower the inference.
   */
  num_inference_steps?: number
  /**
   * Processing Res
   *
   * Maximum processing resolution. Defaults `0` which means it uses the size of the input image.
   */
  processing_res?: number
  /**
   * Image Url
   *
   * Input image url.
   */
  image_url: string
}

/**
 * DepthMapOutput
 */
export type SchemaImageutilsDepthOutput = {
  /**
   * Image
   *
   * The depth map.
   */
  image: SchemaImage
}

/**
 * DepthMapInput
 */
export type SchemaImageutilsDepthInput = {
  /**
   * Bg Th
   *
   * bg_th
   */
  bg_th?: number
  /**
   * A
   *
   * a
   */
  a?: number
  /**
   * Depth And Normal
   *
   * depth_and_normal
   */
  depth_and_normal?: boolean
  /**
   * Image Url
   *
   * Input image url.
   */
  image_url: string
}

/**
 * RetoucherOutput
 */
export type SchemaRetoucherOutput = {
  /**
   * Image
   *
   * The generated image file info.
   */
  image: SchemaImage
  /**
   * Seed
   *
   * The seed used for the generation.
   */
  seed: number
}

/**
 * RetoucherInput
 */
export type SchemaRetoucherInput = {
  /**
   * Seed
   *
   * Seed for reproducibility. Different seeds will make slightly different results.
   */
  seed?: number
  /**
   * Image Url
   *
   * The URL of the image to be retouched.
   */
  image_url: string
}

/**
 * Output
 */
export type SchemaFastLcmDiffusionImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * ImageToImageLCMInput
 */
export type SchemaFastLcmDiffusionImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Guidance Rescale
   *
   * The rescale factor for the CFG.
   */
  guidance_rescale?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Preserve Aspect Ratio
   *
   *
   * If set to true, the aspect ratio of the generated image will be preserved even
   * if the image size is too large. However, if the image is not a multiple of 32
   * in width or height, it will be resized to the nearest multiple of 32. By default,
   * this snapping to the nearest multiple of 32 will not preserve the aspect ratio.
   * Set crop_output to True, to crop the output to the proper aspect ratio
   * after generating.
   *
   */
  preserve_aspect_ratio?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use.Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Crop Output
   *
   *
   * If set to true, the output cropped to the proper aspect ratio after generating.
   *
   */
  crop_output?: boolean
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Url
   *
   * The URL of the image to use as a starting point for the generation.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Model Name
   *
   * The name of the model to use.
   */
  model_name?:
    | 'stabilityai/stable-diffusion-xl-base-1.0'
    | 'runwayml/stable-diffusion-v1-5'
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Strength
   *
   * determines how much the generated image resembles the initial image
   */
  strength?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaFastLcmDiffusionInpaintingOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * InpaintingLCMInput
 */
export type SchemaFastLcmDiffusionInpaintingInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Guidance Rescale
   *
   * The rescale factor for the CFG.
   */
  guidance_rescale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use.Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Url
   *
   * The URL of the image to use as a starting point for the generation.
   */
  image_url: string
  /**
   * Strength
   *
   * determines how much the generated image resembles the initial image
   */
  strength?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Mask Url
   *
   * The URL of the mask to use for inpainting.
   */
  mask_url: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Model Name
   *
   * The name of the model to use.
   */
  model_name?:
    | 'stabilityai/stable-diffusion-xl-base-1.0'
    | 'runwayml/stable-diffusion-v1-5'
}

/**
 * Output
 */
export type SchemaPlaygroundV25InpaintingOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * InpaintingPlaygroundv25Input
 */
export type SchemaPlaygroundV25InpaintingInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Embeddings
   *
   * The list of embeddings to use.
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Guidance Rescale
   *
   * The rescale factor for the CFG.
   */
  guidance_rescale?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use.Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Url
   *
   * The URL of the image to use as a starting point for the generation.
   */
  image_url: string
  /**
   * Strength
   *
   * determines how much the generated image resembles the initial image
   */
  strength?: number
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Mask Url
   *
   * The URL of the mask to use for inpainting.
   */
  mask_url: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * Embedding
 */
export type SchemaEmbedding = {
  /**
   * Tokens
   *
   * The list of tokens to use for the embedding.
   */
  tokens?: Array<string>
  /**
   * Path
   *
   * URL or the path to the embedding weights.
   */
  path: string
}

/**
 * Output
 */
export type SchemaFastLightningSdxlInpaintingOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * InpaintingLightningInput
 */
export type SchemaFastLightningSdxlInpaintingInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Embeddings
   *
   * The list of embeddings to use.
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Guidance Rescale
   *
   * The rescale factor for the CFG.
   */
  guidance_rescale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Url
   *
   * The URL of the image to use as a starting point for the generation.
   */
  image_url: string
  /**
   * Strength
   *
   * determines how much the generated image resembles the initial image
   */
  strength?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: '1' | '2' | '4' | '8'
  /**
   * Mask Url
   *
   * The URL of the mask to use for inpainting.
   */
  mask_url: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaFastLightningSdxlImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * ImageToImageLightningInput
 */
export type SchemaFastLightningSdxlImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Embeddings
   *
   * The list of embeddings to use.
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Guidance Rescale
   *
   * The rescale factor for the CFG.
   */
  guidance_rescale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Preserve Aspect Ratio
   *
   *
   * If set to true, the aspect ratio of the generated image will be preserved even
   * if the image size is too large. However, if the image is not a multiple of 32
   * in width or height, it will be resized to the nearest multiple of 32. By default,
   * this snapping to the nearest multiple of 32 will not preserve the aspect ratio.
   * Set crop_output to True, to crop the output to the proper aspect ratio
   * after generating.
   *
   */
  preserve_aspect_ratio?: boolean
  /**
   * Crop Output
   *
   *
   * If set to true, the output cropped to the proper aspect ratio after generating.
   *
   */
  crop_output?: boolean
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Url
   *
   * The URL of the image to use as a starting point for the generation.
   */
  image_url: string
  /**
   * Strength
   *
   * determines how much the generated image resembles the initial image
   */
  strength?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: '1' | '2' | '4' | '8'
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaPlaygroundV25ImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * ImageToImagePlaygroundv25Input
 */
export type SchemaPlaygroundV25ImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Embeddings
   *
   * The list of embeddings to use.
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Guidance Rescale
   *
   * The rescale factor for the CFG.
   */
  guidance_rescale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Preserve Aspect Ratio
   *
   *
   * If set to true, the aspect ratio of the generated image will be preserved even
   * if the image size is too large. However, if the image is not a multiple of 32
   * in width or height, it will be resized to the nearest multiple of 32. By default,
   * this snapping to the nearest multiple of 32 will not preserve the aspect ratio.
   * Set crop_output to True, to crop the output to the proper aspect ratio
   * after generating.
   *
   */
  preserve_aspect_ratio?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use.Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Crop Output
   *
   *
   * If set to true, the output cropped to the proper aspect ratio after generating.
   *
   */
  crop_output?: boolean
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Url
   *
   * The URL of the image to use as a starting point for the generation.
   */
  image_url: string
  /**
   * Strength
   *
   * determines how much the generated image resembles the initial image
   */
  strength?: number
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * Output
 */
export type SchemaBirefnetOutput = {
  /**
   * Image
   *
   * Image with background removed
   */
  image: SchemaImageFile
  /**
   * Mask Image
   *
   * Mask used to remove the background
   */
  mask_image?: SchemaImageFile
}

/**
 * ImageFile
 */
export type SchemaImageFile = {
  /**
   * Height
   *
   * The height of the image
   */
  height?: number
  /**
   * File Size
   *
   * The size of the file in bytes.
   */
  file_size?: number
  /**
   * Url
   *
   * The URL where the file can be downloaded from.
   */
  url: string
  /**
   * Width
   *
   * The width of the image
   */
  width?: number
  /**
   * File Name
   *
   * The name of the file. It will be auto-generated if not provided.
   */
  file_name?: string
  /**
   * Content Type
   *
   * The mime type of the file.
   */
  content_type?: string
  /**
   * File Data
   *
   * File data
   */
  file_data?: Blob | File
}

/**
 * Input
 */
export type SchemaBirefnetInput = {
  /**
   * Operating Resolution
   *
   * The resolution to operate on. The higher the resolution, the more accurate the output will be for high res input images.
   */
  operating_resolution?: '1024x1024' | '2048x2048'
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'webp' | 'png' | 'gif'
  /**
   * Image Url
   *
   * URL of the image to remove background from
   */
  image_url: string
  /**
   * Model
   *
   *
   * Model to use for background removal.
   * The 'General Use (Light)' model is the original model used in the BiRefNet repository.
   * The 'General Use (Heavy)' model is a slower but more accurate model.
   * The 'Portrait' model is a model trained specifically for portrait images.
   * The 'General Use (Light)' model is recommended for most use cases.
   *
   * The corresponding models are as follows:
   * - 'General Use (Light)': BiRefNet-DIS_ep580.pth
   * - 'General Use (Heavy)': BiRefNet-massive-epoch_240.pth
   * - 'Portrait': BiRefNet-portrait-TR_P3M_10k-epoch_120.pth
   *
   */
  model?: 'General Use (Light)' | 'General Use (Heavy)' | 'Portrait'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Output Mask
   *
   * Whether to output the mask used to remove the background
   */
  output_mask?: boolean
  /**
   * Refine Foreground
   *
   * Whether to refine the foreground using the estimated mask
   */
  refine_foreground?: boolean
}

/**
 * CreativeUpscalerOutput
 */
export type SchemaCreativeUpscalerOutput = {
  /**
   * Image
   *
   * The generated image file info.
   */
  image: SchemaImage
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * CreativeUpscalerInput
 */
export type SchemaCreativeUpscalerInput = {
  /**
   * Shape Preservation
   *
   * How much to preserve the shape of the original image
   */
  shape_preservation?: number
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results. If no prompt is provide BLIP2 will be used to generate a prompt.
   */
  prompt?: string | null
  /**
   * Additional Embedding Url
   *
   * The URL to the additional embeddings to use for the upscaling. Default is None
   */
  additional_embedding_url?: string
  /**
   * Enable Safety Checks
   *
   *
   * If set to true, the resulting image will be checked whether it includes any
   * potentially unsafe content. If it does, it will be replaced with a black
   * image.
   *
   */
  enable_safety_checks?: boolean
  /**
   * Additional Lora Url
   *
   * The URL to the additional LORA model to use for the upscaling. Default is None
   */
  additional_lora_url?: string
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Scale
   *
   * The scale of the output image. The higher the scale, the bigger the output image will be.
   */
  scale?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use.Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Skip Ccsr
   *
   *
   * If set to true, the image will not be processed by the CCSR model before
   * being processed by the creativity model.
   *
   */
  skip_ccsr?: boolean
  /**
   * Additional Lora Scale
   *
   * The scale of the additional LORA model to use for the upscaling. Default is 1.0
   */
  additional_lora_scale?: number
  /**
   * Detail
   *
   * How much detail to add
   */
  detail?: number
  /**
   * Base Model Url
   *
   * The URL to the base model to use for the upscaling
   */
  base_model_url?: string
  /**
   * Image Url
   *
   * The image to upscale.
   */
  image_url: string
  /**
   * Creativity
   *
   * How much the output can deviate from the original
   */
  creativity?: number
  /**
   * Override Size Limits
   *
   *
   * Allow for large uploads that could take a very long time.
   *
   */
  override_size_limits?: boolean
  /**
   * Prompt Suffix
   *
   * The suffix to add to the prompt. This is useful to add a common ending to all prompts such as 'high quality' etc or embedding tokens.
   */
  prompt_suffix?: string
  /**
   * Num Inference Steps
   *
   *
   * The number of inference steps to use for generating the image. The more steps
   * the better the image will be but it will also take longer to generate.
   *
   */
  num_inference_steps?: number
  /**
   * Model Type
   *
   * The type of model to use for the upscaling. Default is SD_1_5
   */
  model_type?: 'SD_1_5' | 'SDXL'
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * PhotoMakerOutput
 */
export type SchemaPhotomakerOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * PhotoMakerInput
 */
export type SchemaPhotomakerInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Number of images
   *
   *
   * Number of images to generate in one request. Note that the higher the batch size,
   * the longer it will take to generate the images.
   *
   */
  num_images?: number
  /**
   * Style strength (in %)
   */
  style_strength?: number
  /**
   * Style
   */
  style?:
    | '(No style)'
    | 'Cinematic'
    | 'Disney Character'
    | 'Digital Art'
    | 'Photographic'
    | 'Fantasy art'
    | 'Neonpunk'
    | 'Enhance'
    | 'Comic book'
    | 'Lowpoly'
    | 'Line art'
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Image Archive Url
   *
   * The URL of the image archive containing the images you want to use.
   */
  image_archive_url: string
  /**
   * Initial Image Url
   *
   * Optional initial image for img2img
   */
  initial_image_url?: string
  /**
   * Number of inference steps
   *
   *
   * Increasing the amount of steps tells Stable Diffusion that it should take more steps
   * to generate your final result which can increase the amount of detail in your image.
   *
   */
  num_inference_steps?: number
  /**
   * Initial Image Strength
   *
   * How much noise to add to the latent image. O for no noise, 1 for maximum noise.
   */
  initial_image_strength?: number
  /**
   * Base Pipeline
   *
   * The base pipeline to use for generating the image.
   */
  base_pipeline?: 'photomaker' | 'photomaker-style'
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use.Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
}

/**
 * FaceToStickerOutput
 */
export type SchemaFaceToStickerOutput = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImage>
  /**
   * Sticker Image
   *
   * The generated face sticker image.
   */
  sticker_image: SchemaImage
  /**
   * Sticker Image Background Removed
   *
   * The generated face sticker image with the background removed.
   */
  sticker_image_background_removed: SchemaImage
  /**
   * Seed
   *
   * Seed used during the inference.
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   *
   * Whether the generated images contain NSFW concepts.
   * The key is the image type and the value is a boolean.
   *
   */
  has_nsfw_concepts: {
    [key: string]: boolean
  }
}

/**
 * FaceToStickerInput
 */
export type SchemaFaceToStickerInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Enable Safety Checker
   *
   * If set to false, the safety checker will be disabled.
   */
  enable_safety_checker?: boolean
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * IP adapter weight
   *
   * The weight of the IP adapter.
   */
  ip_adapter_weight?: number
  /**
   * Image Url
   *
   * URL of the video.
   */
  image_url: string
  /**
   * Upscale steps
   *
   * The number of steps to use for upscaling. Only used if `upscale` is `true`.
   */
  upscale_steps?: number
  /**
   * Instant ID strength
   *
   * The strength of the instant ID.
   */
  instant_id_strength?: number
  /**
   * Upscale
   *
   * Whether to upscale the image 2x.
   */
  upscale?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Number of inference steps
   *
   *
   * Increasing the amount of steps tells Stable Diffusion that it should take more steps
   * to generate your final result which can increase the amount of detail in your image.
   *
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * IP adapter noise
   *
   * The amount of noise to add to the IP adapter.
   */
  ip_adapter_noise?: number
}

/**
 * Output
 */
export type SchemaFastSdxlInpaintingOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * InpaintingInput
 */
export type SchemaFastSdxlInpaintingInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Embeddings
   *
   * The list of embeddings to use.
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Loras
   *
   * The list of LoRA weights to use.
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use.Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Url
   *
   * The URL of the image to use as a starting point for the generation.
   */
  image_url: string
  /**
   * Strength
   *
   * determines how much the generated image resembles the initial image
   */
  strength?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Mask Url
   *
   * The URL of the mask to use for inpainting.
   */
  mask_url: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaFastSdxlImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * ImageToImageInput
 */
export type SchemaFastSdxlImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Embeddings
   *
   * The list of embeddings to use.
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Loras
   *
   * The list of LoRA weights to use.
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Preserve Aspect Ratio
   *
   *
   * If set to true, the aspect ratio of the generated image will be preserved even
   * if the image size is too large. However, if the image is not a multiple of 32
   * in width or height, it will be resized to the nearest multiple of 32. By default,
   * this snapping to the nearest multiple of 32 will not preserve the aspect ratio.
   * Set crop_output to True, to crop the output to the proper aspect ratio
   * after generating.
   *
   */
  preserve_aspect_ratio?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use.Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Crop Output
   *
   *
   * If set to true, the output cropped to the proper aspect ratio after generating.
   *
   */
  crop_output?: boolean
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Url
   *
   * The URL of the image to use as a starting point for the generation.
   */
  image_url: string
  /**
   * Strength
   *
   * determines how much the generated image resembles the initial image
   */
  strength?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * OutputParameters
 */
export type SchemaLoraImageToImageOutput = {
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Debug Latents
   *
   * The latents saved for debugging.
   */
  debug_latents?: SchemaFile
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Debug Per Pass Latents
   *
   * The latents saved for debugging per pass.
   */
  debug_per_pass_latents?: SchemaFile
}

/**
 * File
 */
export type SchemaFile = {
  /**
   * File Size
   *
   * The size of the file in bytes.
   */
  file_size?: number
  /**
   * File Name
   *
   * The name of the file. It will be auto-generated if not provided.
   */
  file_name?: string
  /**
   * Content Type
   *
   * The mime type of the file.
   */
  content_type?: string
  /**
   * Url
   *
   * The URL where the file can be downloaded from.
   */
  url: string
  /**
   * File Data
   *
   * File data
   */
  file_data?: Blob | File
}

/**
 * ImageToImageInput
 */
export type SchemaLoraImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Noise Strength
   *
   * The amount of noise to add to noise image for image. Only used if the image_url is provided. 1.0 is complete noise and 0 is no noise.
   */
  noise_strength?: number
  /**
   * Tile Height
   *
   * The size of the tiles to be used for the image generation.
   */
  tile_height?: number
  /**
   * Embeddings
   *
   *
   * The embeddings to use for the image generation. Only a single embedding is supported at the moment.
   * The embeddings will be used to map the tokens in the prompt to the embedding weights.
   *
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Ic Light Model Url
   *
   *
   * The URL of the IC Light model to use for the image generation.
   *
   */
  ic_light_model_url?: string
  /**
   * Image Encoder Weight Name
   *
   *
   * The weight name of the image encoder model to use for the image generation.
   *
   */
  image_encoder_weight_name?: string
  /**
   * Ip Adapter
   *
   *
   * The IP adapter to use for the image generation.
   *
   */
  ip_adapter?: Array<SchemaIpAdapter>
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Scheduler
   *
   * Scheduler / sampler to use for the image denoising process.
   */
  scheduler?:
    | 'DPM++ 2M'
    | 'DPM++ 2M Karras'
    | 'DPM++ 2M SDE'
    | 'DPM++ 2M SDE Karras'
    | 'Euler'
    | 'Euler A'
    | 'Euler (trailing timesteps)'
    | 'LCM'
    | 'LCM (trailing timesteps)'
    | 'DDIM'
    | 'TCD'
  /**
   * Sigmas
   *
   *
   * Optionally override the sigmas to use for the denoising process. Only works with schedulers which support the `sigmas` argument in their `set_sigmas` method.
   * Defaults to not overriding, in which case the scheduler automatically sets the sigmas based on the `num_inference_steps` parameter.
   * If set to a custom sigma schedule, the `num_inference_steps` parameter will be ignored. Cannot be set if `timesteps` is set.
   *
   */
  sigmas?: SchemaSigmasInput
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Tile Stride Width
   *
   * The stride of the tiles to be used for the image generation.
   */
  tile_stride_width?: number
  /**
   * Debug Per Pass Latents
   *
   * If set to true, the latents will be saved for debugging per pass.
   */
  debug_per_pass_latents?: boolean
  /**
   * Timesteps
   *
   *
   * Optionally override the timesteps to use for the denoising process. Only works with schedulers which support the `timesteps` argument in their `set_timesteps` method.
   * Defaults to not overriding, in which case the scheduler automatically sets the timesteps based on the `num_inference_steps` parameter.
   * If set to a custom timestep schedule, the `num_inference_steps` parameter will be ignored. Cannot be set if `sigmas` is set.
   *
   */
  timesteps?: SchemaTimestepsInput
  /**
   * Model Name
   *
   * URL or HuggingFace ID of the base model to generate the image.
   */
  model_name: string
  /**
   * Prompt Weighting
   *
   *
   * If set to true, the prompt weighting syntax will be used.
   * Additionally, this will lift the 77 token limit by averaging embeddings.
   *
   */
  prompt_weighting?: boolean
  /**
   * Variant
   *
   * The variant of the model to use for huggingface models, e.g. 'fp16'.
   */
  variant?: string
  /**
   * Image Url
   *
   * URL of image to use for image to image/inpainting.
   */
  image_url?: string
  /**
   * Controlnet Guess Mode
   *
   *
   * If set to true, the controlnet will be applied to only the conditional predictions.
   *
   */
  controlnet_guess_mode?: boolean
  /**
   * Image Encoder Subfolder
   *
   *
   * The subfolder of the image encoder model to use for the image generation.
   *
   */
  image_encoder_subfolder?: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Ic Light Model Background Image Url
   *
   *
   * The URL of the IC Light model background image to use for the image generation.
   * Make sure to use a background compatible with the model.
   *
   */
  ic_light_model_background_image_url?: string
  /**
   * Rescale Betas Snr Zero
   *
   *
   * Whether to set the rescale_betas_snr_zero option or not for the sampler
   *
   */
  rescale_betas_snr_zero?: boolean
  /**
   * Tile Width
   *
   * The size of the tiles to be used for the image generation.
   */
  tile_width?: number
  /**
   * Prediction Type
   *
   *
   * The type of prediction to use for the image generation.
   * The `epsilon` is the default.
   *
   */
  prediction_type?: 'v_prediction' | 'epsilon'
  /**
   * Eta
   *
   * The eta value to be used for the image generation.
   */
  eta?: number
  /**
   * Image Encoder Path
   *
   *
   * The path to the image encoder model to use for the image generation.
   *
   */
  image_encoder_path?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use.Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Image Format
   *
   * The format of the generated image.
   */
  image_format?: 'jpeg' | 'png'
  /**
   * Number of images
   *
   *
   * Number of images to generate in one request. Note that the higher the batch size,
   * the longer it will take to generate the images.
   *
   */
  num_images?: number
  /**
   * Debug Latents
   *
   * If set to true, the latents will be saved for debugging.
   */
  debug_latents?: boolean
  /**
   * Ic Light Image Url
   *
   *
   * The URL of the IC Light model image to use for the image generation.
   *
   */
  ic_light_image_url?: string
  /**
   * Unet Name
   *
   * URL or HuggingFace ID of the custom U-Net model to use for the image generation.
   */
  unet_name?: string
  /**
   * Clip Skip
   *
   *
   * Skips part of the image generation process, leading to slightly different results.
   * This means the image renders faster, too.
   *
   */
  clip_skip?: number
  /**
   * Tile Stride Height
   *
   * The stride of the tiles to be used for the image generation.
   */
  tile_stride_height?: number
  /**
   * Controlnets
   *
   *
   * The control nets to use for the image generation. You can use any number of control nets
   * and they will be applied to the image at the specified timesteps.
   *
   */
  controlnets?: Array<SchemaControlNet>
  /**
   * Number of inference steps
   *
   *
   * Increasing the amount of steps tells Stable Diffusion that it should take more steps
   * to generate your final result which can increase the amount of detail in your image.
   *
   */
  num_inference_steps?: number
}

/**
 * ControlNet
 */
export type SchemaControlNet = {
  /**
   * Conditioning Scale
   *
   *
   * The scale of the control net weight. This is used to scale the control net weight
   * before merging it with the base model.
   *
   */
  conditioning_scale?: number
  /**
   * Path
   *
   * URL or the path to the control net weights.
   */
  path: string
  /**
   * Ip Adapter Index
   *
   *
   * The index of the IP adapter to be applied to the controlnet. This is only needed for InstantID ControlNets.
   *
   */
  ip_adapter_index?: number
  /**
   * End Percentage
   *
   *
   * The percentage of the image to end applying the controlnet in terms of the total timesteps.
   *
   */
  end_percentage?: number
  /**
   * Config Url
   *
   * optional URL to the controlnet config.json file.
   */
  config_url?: string
  /**
   * Image Url
   *
   * URL of the image to be used as the control net.
   */
  image_url: string
  /**
   * Variant
   *
   * The optional variant if a Hugging Face repo key is used.
   */
  variant?: string
  /**
   * Mask Url
   *
   *
   * The mask to use for the controlnet. When using a mask, the control image size and the mask size must be the same and divisible by 32.
   *
   */
  mask_url?: string
  /**
   * Start Percentage
   *
   *
   * The percentage of the image to start applying the controlnet in terms of the total timesteps.
   *
   */
  start_percentage?: number
}

/**
 * TimestepsInput
 */
export type SchemaTimestepsInput = {
  /**
   * Method
   *
   *
   * The method to use for the timesteps. If set to 'array', the timesteps will be set based
   * on the provided timesteps schedule in the `array` field.
   * Defaults to 'default' which means the scheduler will use the `num_inference_steps` parameter.
   *
   */
  method?: 'default' | 'array'
  /**
   * Array
   *
   *
   * Timesteps schedule to be used if 'custom' method is selected.
   *
   */
  array?: Array<number>
}

/**
 * SigmasInput
 */
export type SchemaSigmasInput = {
  /**
   * Method
   *
   *
   * The method to use for the sigmas. If set to 'custom', the sigmas will be set based
   * on the provided sigmas schedule in the `array` field.
   * Defaults to 'default' which means the scheduler will use the sigmas of the scheduler.
   *
   */
  method?: 'default' | 'array'
  /**
   * Array
   *
   *
   * Sigmas schedule to be used if 'custom' method is selected.
   *
   */
  array?: Array<number>
}

/**
 * IPAdapter
 */
export type SchemaIpAdapter = {
  /**
   * Unconditional Noising Factor
   *
   * The factor to apply to the unconditional noising of the IP adapter.
   */
  unconditional_noising_factor?: number
  /**
   * Ip Adapter Image Url
   *
   * URL of the image to be used as the IP adapter.
   */
  ip_adapter_image_url: string | Array<string>
  /**
   * Path
   *
   * URL or the path to the IP adapter weights.
   */
  path: string
  /**
   * Image Projection Shortcut
   *
   *
   * The value to set the image projection shortcut to. For FaceID plus V1 models,
   * this should be set to False. For FaceID plus V2 models, this should be set to True.
   * Default is True.
   *
   */
  image_projection_shortcut?: boolean
  /**
   * Scale Json
   *
   *
   * The scale of the IP adapter weight. This is used to scale the IP adapter weight
   * before merging it with the base model.
   *
   */
  scale_json?: {
    [key: string]: unknown
  }
  /**
   * Ip Adapter Mask Url
   *
   *
   * The mask to use for the IP adapter. When using a mask, the ip-adapter image size and the mask size must be the same
   *
   */
  ip_adapter_mask_url?: string
  /**
   * Model Subfolder
   *
   * Subfolder in the model directory where the IP adapter weights are stored.
   */
  model_subfolder?: string
  /**
   * Scale
   *
   *
   * The scale of the IP adapter weight. This is used to scale the IP adapter weight
   * before merging it with the base model.
   *
   */
  scale?: number
  /**
   * Insight Face Model Path
   *
   * URL or the path to the InsightFace model weights.
   */
  insight_face_model_path?: string
  /**
   * Weight Name
   *
   * Name of the weight file.
   */
  weight_name?: string
}

/**
 * OutputParameters
 */
export type SchemaLoraInpaintOutput = {
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Debug Latents
   *
   * The latents saved for debugging.
   */
  debug_latents?: SchemaFile
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Debug Per Pass Latents
   *
   * The latents saved for debugging per pass.
   */
  debug_per_pass_latents?: SchemaFile
}

/**
 * InpaintInput
 */
export type SchemaLoraInpaintInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Noise Strength
   *
   * The amount of noise to add to noise image for image. Only used if the image_url is provided. 1.0 is complete noise and 0 is no noise.
   */
  noise_strength?: number
  /**
   * Tile Height
   *
   * The size of the tiles to be used for the image generation.
   */
  tile_height?: number
  /**
   * Embeddings
   *
   *
   * The embeddings to use for the image generation. Only a single embedding is supported at the moment.
   * The embeddings will be used to map the tokens in the prompt to the embedding weights.
   *
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Ic Light Model Url
   *
   *
   * The URL of the IC Light model to use for the image generation.
   *
   */
  ic_light_model_url?: string
  /**
   * Image Encoder Weight Name
   *
   *
   * The weight name of the image encoder model to use for the image generation.
   *
   */
  image_encoder_weight_name?: string
  /**
   * Ip Adapter
   *
   *
   * The IP adapter to use for the image generation.
   *
   */
  ip_adapter?: Array<SchemaIpAdapter>
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Scheduler
   *
   * Scheduler / sampler to use for the image denoising process.
   */
  scheduler?:
    | 'DPM++ 2M'
    | 'DPM++ 2M Karras'
    | 'DPM++ 2M SDE'
    | 'DPM++ 2M SDE Karras'
    | 'Euler'
    | 'Euler A'
    | 'Euler (trailing timesteps)'
    | 'LCM'
    | 'LCM (trailing timesteps)'
    | 'DDIM'
    | 'TCD'
  /**
   * Sigmas
   *
   *
   * Optionally override the sigmas to use for the denoising process. Only works with schedulers which support the `sigmas` argument in their `set_sigmas` method.
   * Defaults to not overriding, in which case the scheduler automatically sets the sigmas based on the `num_inference_steps` parameter.
   * If set to a custom sigma schedule, the `num_inference_steps` parameter will be ignored. Cannot be set if `timesteps` is set.
   *
   */
  sigmas?: SchemaSigmasInput
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Tile Stride Width
   *
   * The stride of the tiles to be used for the image generation.
   */
  tile_stride_width?: number
  /**
   * Debug Per Pass Latents
   *
   * If set to true, the latents will be saved for debugging per pass.
   */
  debug_per_pass_latents?: boolean
  /**
   * Timesteps
   *
   *
   * Optionally override the timesteps to use for the denoising process. Only works with schedulers which support the `timesteps` argument in their `set_timesteps` method.
   * Defaults to not overriding, in which case the scheduler automatically sets the timesteps based on the `num_inference_steps` parameter.
   * If set to a custom timestep schedule, the `num_inference_steps` parameter will be ignored. Cannot be set if `sigmas` is set.
   *
   */
  timesteps?: SchemaTimestepsInput
  /**
   * Model Name
   *
   * URL or HuggingFace ID of the base model to generate the image.
   */
  model_name: string
  /**
   * Prompt Weighting
   *
   *
   * If set to true, the prompt weighting syntax will be used.
   * Additionally, this will lift the 77 token limit by averaging embeddings.
   *
   */
  prompt_weighting?: boolean
  /**
   * Variant
   *
   * The variant of the model to use for huggingface models, e.g. 'fp16'.
   */
  variant?: string
  /**
   * Image Url
   *
   * URL of image to use for image to image/inpainting.
   */
  image_url?: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Mask Url
   *
   * URL of black-and-white image to use as mask during inpainting.
   */
  mask_url?: string
  /**
   * Image Encoder Subfolder
   *
   *
   * The subfolder of the image encoder model to use for the image generation.
   *
   */
  image_encoder_subfolder?: string
  /**
   * Ic Light Model Background Image Url
   *
   *
   * The URL of the IC Light model background image to use for the image generation.
   * Make sure to use a background compatible with the model.
   *
   */
  ic_light_model_background_image_url?: string
  /**
   * Rescale Betas Snr Zero
   *
   *
   * Whether to set the rescale_betas_snr_zero option or not for the sampler
   *
   */
  rescale_betas_snr_zero?: boolean
  /**
   * Tile Width
   *
   * The size of the tiles to be used for the image generation.
   */
  tile_width?: number
  /**
   * Controlnet Guess Mode
   *
   *
   * If set to true, the controlnet will be applied to only the conditional predictions.
   *
   */
  controlnet_guess_mode?: boolean
  /**
   * Prediction Type
   *
   *
   * The type of prediction to use for the image generation.
   * The `epsilon` is the default.
   *
   */
  prediction_type?: 'v_prediction' | 'epsilon'
  /**
   * Eta
   *
   * The eta value to be used for the image generation.
   */
  eta?: number
  /**
   * Image Encoder Path
   *
   *
   * The path to the image encoder model to use for the image generation.
   *
   */
  image_encoder_path?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use.Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Image Format
   *
   * The format of the generated image.
   */
  image_format?: 'jpeg' | 'png'
  /**
   * Number of images
   *
   *
   * Number of images to generate in one request. Note that the higher the batch size,
   * the longer it will take to generate the images.
   *
   */
  num_images?: number
  /**
   * Debug Latents
   *
   * If set to true, the latents will be saved for debugging.
   */
  debug_latents?: boolean
  /**
   * Ic Light Image Url
   *
   *
   * The URL of the IC Light model image to use for the image generation.
   *
   */
  ic_light_image_url?: string
  /**
   * Unet Name
   *
   * URL or HuggingFace ID of the custom U-Net model to use for the image generation.
   */
  unet_name?: string
  /**
   * Clip Skip
   *
   *
   * Skips part of the image generation process, leading to slightly different results.
   * This means the image renders faster, too.
   *
   */
  clip_skip?: number
  /**
   * Tile Stride Height
   *
   * The stride of the tiles to be used for the image generation.
   */
  tile_stride_height?: number
  /**
   * Controlnets
   *
   *
   * The control nets to use for the image generation. You can use any number of control nets
   * and they will be applied to the image at the specified timesteps.
   *
   */
  controlnets?: Array<SchemaControlNet>
  /**
   * Number of inference steps
   *
   *
   * Increasing the amount of steps tells Stable Diffusion that it should take more steps
   * to generate your final result which can increase the amount of detail in your image.
   *
   */
  num_inference_steps?: number
}

/**
 * IpAdapterFaceIdOutput
 */
export type SchemaIpAdapterFaceIdOutput = {
  /**
   * Image
   *
   * The generated image file info.
   */
  image: SchemaImage
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * IpAdapterFaceIdInput
 */
export type SchemaIpAdapterFaceIdInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Face Image Url
   *
   * An image of a face to match. If an image with a size of 640x640 is not provided, it will be scaled and cropped to that size.
   */
  face_image_url?: string
  /**
   * Width
   *
   *
   * The width of the generated image.
   *
   */
  width?: number
  /**
   * Face Id Det Size
   *
   *
   * The size of the face detection model. The higher the number the more accurate
   * the detection will be but it will also take longer to run. The higher the number the more
   * likely it will fail to find a face as well. Lower it if you are having trouble
   * finding a face in the image.
   *
   */
  face_id_det_size?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use.Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Height
   *
   *
   * The height of the generated image.
   *
   */
  height?: number
  /**
   * Num Samples
   *
   *
   * The number of samples for face id. The more samples the better the image will
   * be but it will also take longer to generate. Default is 4.
   *
   */
  num_samples?: number
  /**
   * Base Sdxl Model Repo
   *
   * The URL to the base SDXL model. Default is SG161222/RealVisXL_V3.0
   */
  base_sdxl_model_repo?: string
  /**
   * Base 1 5 Model Repo
   *
   * The URL to the base 1.5 model. Default is SG161222/Realistic_Vision_V4.0_noVAE
   */
  base_1_5_model_repo?: string
  /**
   * Num Inference Steps
   *
   *
   * The number of inference steps to use for generating the image. The more steps
   * the better the image will be but it will also take longer to generate.
   *
   */
  num_inference_steps?: number
  /**
   * Model Type
   *
   * The model type to use. 1_5 is the default and is recommended for most use cases.
   */
  model_type?:
    | '1_5-v1'
    | '1_5-v1-plus'
    | '1_5-v2-plus'
    | 'SDXL-v1'
    | 'SDXL-v2-plus'
    | '1_5-auraface-v1'
  /**
   * Face Images Data Url
   *
   *
   * URL to zip archive with images of faces. The images embedding will be averaged to
   * create a more accurate face id.
   *
   */
  face_images_data_url?: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * OmniZeroOutput
 */
export type SchemaOmniZeroOutput = {
  /**
   * Image
   *
   * The generated image.
   */
  image: SchemaImage
}

/**
 * OmniZeroInput
 */
export type SchemaOmniZeroInput = {
  /**
   * Prompt
   *
   * Prompt to guide the image generation.
   */
  prompt: string
  /**
   * Identity Image Url
   *
   * Identity image url.
   */
  identity_image_url: string
  /**
   * Identity Strength
   *
   * Identity strength.
   */
  identity_strength?: number
  /**
   * Number Of Images
   *
   * Number of images.
   */
  number_of_images?: number
  /**
   * Guidance Scale
   *
   * Guidance scale.
   */
  guidance_scale?: number
  /**
   * Image Strength
   *
   * Image strength.
   */
  image_strength?: number
  /**
   * Negative Prompt
   *
   * Negative prompt to guide the image generation.
   */
  negative_prompt?: string
  /**
   * Composition Image Url
   *
   * Composition image url.
   */
  composition_image_url: string
  /**
   * Depth Strength
   *
   * Depth strength.
   */
  depth_strength?: number
  /**
   * Composition Strength
   *
   * Composition strength.
   */
  composition_strength?: number
  /**
   * Image Url
   *
   * Input image url.
   */
  image_url: string
  /**
   * Style Image Url
   *
   * Style image url.
   */
  style_image_url: string
  /**
   * Face Strength
   *
   * Face strength.
   */
  face_strength?: number
  /**
   * Style Strength
   *
   * Style strength.
   */
  style_strength?: number
  /**
   * Seed
   *
   * Seed.
   */
  seed?: number
}

/**
 * CCSROutput
 */
export type SchemaCcsrOutput = {
  /**
   * Image
   *
   * The generated image file info.
   */
  image: SchemaImage
  /**
   * Seed
   *
   * The seed used for the generation.
   */
  seed: number
}

/**
 * CCSRInput
 */
export type SchemaCcsrInput = {
  /**
   * Color Fix Type
   *
   * Type of color correction for samples.
   */
  color_fix_type?: 'none' | 'wavelet' | 'adain'
  /**
   * Tile Diffusion Size
   *
   * Size of patch.
   */
  tile_diffusion_size?: number
  /**
   * Tile Vae Decoder Size
   *
   * Size of VAE patch.
   */
  tile_vae_decoder_size?: number
  /**
   * Tile Vae Encoder Size
   *
   * Size of latent image
   */
  tile_vae_encoder_size?: number
  /**
   * T Min
   *
   * The starting point of uniform sampling strategy.
   */
  t_min?: number
  /**
   * Image Url
   *
   * The URL or data URI of the image to upscale.
   */
  image_url: string
  /**
   * Tile Diffusion Stride
   *
   * Stride of sliding patch.
   */
  tile_diffusion_stride?: number
  /**
   * Tile Vae
   *
   * If specified, a patch-based sampling strategy will be used for VAE decoding.
   */
  tile_vae?: boolean
  /**
   * Scale
   *
   * The scale of the output image. The higher the scale, the bigger the output image will be.
   */
  scale?: number
  /**
   * Seed
   *
   * Seed for reproducibility. Different seeds will make slightly different results.
   */
  seed?: number
  /**
   * T Max
   *
   * The ending point of uniform sampling strategy.
   */
  t_max?: number
  /**
   * Steps
   *
   * The number of steps to run the model for. The higher the number the better the quality and longer it will take to generate.
   */
  steps?: number
  /**
   * Tile Diffusion
   *
   * If specified, a patch-based sampling strategy will be used for sampling.
   */
  tile_diffusion?: 'none' | 'mix' | 'gaussian'
}

/**
 * Output
 */
export type SchemaSd15DepthControlnetOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageControlNetInput
 */
export type SchemaSd15DepthControlnetInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image. Leave it none to automatically infer from the control image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | null
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Loras
   *
   * The list of LoRA weights to use.
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Controlnet Conditioning Scale
   *
   * The scale of the controlnet conditioning.
   */
  controlnet_conditioning_scale?: number
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Control Image Url
   *
   * The URL of the control image.
   */
  control_image_url: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Deep Cache
   *
   *
   * If set to true, DeepCache will be enabled. TBD
   *
   */
  enable_deep_cache?: boolean
}

/**
 * DWPoseOutput
 */
export type SchemaDwposeOutput = {
  /**
   * Image
   *
   * The predicted pose image
   */
  image: SchemaImage
}

/**
 * DWPoseInput
 */
export type SchemaDwposeInput = {
  /**
   * Draw Mode
   *
   * Mode of drawing the pose on the image. Options are: 'full-pose', 'body-pose', 'face-pose', 'hand-pose', 'face-hand-mask', 'face-mask', 'hand-mask'.
   */
  draw_mode?:
    | 'full-pose'
    | 'body-pose'
    | 'face-pose'
    | 'hand-pose'
    | 'face-hand-mask'
    | 'face-mask'
    | 'hand-mask'
  /**
   * Image Url
   *
   * URL of the image to be processed
   */
  image_url: string
}

/**
 * SD3Output
 */
export type SchemaStableDiffusionV3MediumImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Number of Images
   *
   * The number of images generated.
   */
  num_images: number
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * ImageToImageInput
 */
export type SchemaStableDiffusionV3MediumImageToImageInput = {
  /**
   * Enhance Prompt
   *
   * If set to true, prompt will be upsampled with more details.
   */
  prompt_expansion?: boolean
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. Defaults to the conditioning image's size.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | null
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Image URL
   *
   * The image URL to generate an image from.
   */
  image_url: string
  /**
   * Strength
   *
   * The strength of the image-to-image transformation.
   */
  strength?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Negative Prompt
   *
   * The negative prompt to generate an image from.
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Region
 */
export type SchemaRegion = {
  /**
   * Y1
   *
   * Y-coordinate of the top-left corner
   */
  y1: number
  /**
   * X2
   *
   * X-coordinate of the bottom-right corner
   */
  x2: number
  /**
   * X1
   *
   * X-coordinate of the top-left corner
   */
  x1: number
  /**
   * Y2
   *
   * Y-coordinate of the bottom-right corner
   */
  y2: number
}

/**
 * PolygonOutputWithLabels
 */
export type SchemaFlorence2LargeRegionToSegmentationOutput = {
  /**
   * Image
   *
   * Processed image
   */
  image?: SchemaImage
  /**
   * Results
   *
   * Results from the model
   */
  results: SchemaPolygonOutput
}

/**
 * Polygon
 */
export type SchemaPolygon = {
  /**
   * Points
   *
   * List of points
   */
  points: Array<{
    [key: string]: number
  }>
  /**
   * Label
   *
   * Label of the polygon
   */
  label: string
}

/**
 * PolygonOutput
 */
export type SchemaPolygonOutput = {
  /**
   * Polygons
   *
   * List of polygons
   */
  polygons: Array<SchemaPolygon>
}

/**
 * ImageWithUserCoordinatesInput
 */
export type SchemaFlorence2LargeRegionToSegmentationInput = {
  /**
   * Region
   *
   * The user input coordinates
   */
  region: SchemaRegion
  /**
   * Image Url
   *
   * The URL of the image to be processed.
   */
  image_url: string
}

/**
 * OCRBoundingBoxSingle
 */
export type SchemaOcrBoundingBoxSingle = {
  /**
   * Y
   *
   * Y-coordinate of the top-left corner
   */
  y: number
  /**
   * Label
   *
   * Label of the bounding box
   */
  label: string
  /**
   * H
   *
   * Height of the bounding box
   */
  h: number
  /**
   * W
   *
   * Width of the bounding box
   */
  w: number
  /**
   * X
   *
   * X-coordinate of the top-left corner
   */
  x: number
}

/**
 * OCRBoundingBox
 */
export type SchemaOcrBoundingBox = {
  /**
   * Quad Boxes
   *
   * List of quadrilateral boxes
   */
  quad_boxes: Array<SchemaOcrBoundingBoxSingle>
}

/**
 * OCRBoundingBoxOutputWithLabels
 */
export type SchemaFlorence2LargeOcrWithRegionOutput = {
  /**
   * Image
   *
   * Processed image
   */
  image?: SchemaImage
  /**
   * Results
   *
   * Results from the model
   */
  results: SchemaOcrBoundingBox
}

/**
 * ImageInput
 */
export type SchemaFlorence2LargeOcrWithRegionInput = {
  /**
   * Image Url
   *
   * The URL of the image to be processed.
   */
  image_url: string
}

/**
 * BoundingBoxOutputWithLabels
 */
export type SchemaFlorence2LargeRegionProposalOutput = {
  /**
   * Image
   *
   * Processed image
   */
  image?: SchemaImage
  /**
   * Results
   *
   * Results from the model
   */
  results: SchemaBoundingBoxes
}

/**
 * BoundingBox
 */
export type SchemaBoundingBox = {
  /**
   * Y
   *
   * Y-coordinate of the top-left corner
   */
  y: number
  /**
   * Label
   *
   * Label of the bounding box
   */
  label: string
  /**
   * H
   *
   * Height of the bounding box
   */
  h: number
  /**
   * W
   *
   * Width of the bounding box
   */
  w: number
  /**
   * X
   *
   * X-coordinate of the top-left corner
   */
  x: number
}

/**
 * BoundingBoxes
 */
export type SchemaBoundingBoxes = {
  /**
   * Bboxes
   *
   * List of bounding boxes
   */
  bboxes: Array<SchemaBoundingBox>
}

/**
 * ImageInput
 */
export type SchemaFlorence2LargeRegionProposalInput = {
  /**
   * Image Url
   *
   * The URL of the image to be processed.
   */
  image_url: string
}

/**
 * BoundingBoxOutputWithLabels
 */
export type SchemaFlorence2LargeCaptionToPhraseGroundingOutput = {
  /**
   * Image
   *
   * Processed image
   */
  image?: SchemaImage
  /**
   * Results
   *
   * Results from the model
   */
  results: SchemaBoundingBoxes
}

/**
 * ImageWithTextInput
 */
export type SchemaFlorence2LargeCaptionToPhraseGroundingInput = {
  /**
   * Text Input
   *
   * Text input for the task
   */
  text_input: string
  /**
   * Image Url
   *
   * The URL of the image to be processed.
   */
  image_url: string
}

/**
 * BoundingBoxOutputWithLabels
 */
export type SchemaFlorence2LargeOpenVocabularyDetectionOutput = {
  /**
   * Image
   *
   * Processed image
   */
  image?: SchemaImage
  /**
   * Results
   *
   * Results from the model
   */
  results: SchemaBoundingBoxes
}

/**
 * ImageWithTextInput
 */
export type SchemaFlorence2LargeOpenVocabularyDetectionInput = {
  /**
   * Text Input
   *
   * Text input for the task
   */
  text_input: string
  /**
   * Image Url
   *
   * The URL of the image to be processed.
   */
  image_url: string
}

/**
 * BoundingBoxOutputWithLabels
 */
export type SchemaFlorence2LargeObjectDetectionOutput = {
  /**
   * Image
   *
   * Processed image
   */
  image?: SchemaImage
  /**
   * Results
   *
   * Results from the model
   */
  results: SchemaBoundingBoxes
}

/**
 * ImageInput
 */
export type SchemaFlorence2LargeObjectDetectionInput = {
  /**
   * Image Url
   *
   * The URL of the image to be processed.
   */
  image_url: string
}

/**
 * PolygonOutputWithLabels
 */
export type SchemaFlorence2LargeReferringExpressionSegmentationOutput = {
  /**
   * Image
   *
   * Processed image
   */
  image?: SchemaImage
  /**
   * Results
   *
   * Results from the model
   */
  results: SchemaPolygonOutput
}

/**
 * ImageWithTextInput
 */
export type SchemaFlorence2LargeReferringExpressionSegmentationInput = {
  /**
   * Text Input
   *
   * Text input for the task
   */
  text_input: string
  /**
   * Image Url
   *
   * The URL of the image to be processed.
   */
  image_url: string
}

/**
 * BoundingBoxOutputWithLabels
 */
export type SchemaFlorence2LargeDenseRegionCaptionOutput = {
  /**
   * Image
   *
   * Processed image
   */
  image?: SchemaImage
  /**
   * Results
   *
   * Results from the model
   */
  results: SchemaBoundingBoxes
}

/**
 * ImageInput
 */
export type SchemaFlorence2LargeDenseRegionCaptionInput = {
  /**
   * Image Url
   *
   * The URL of the image to be processed.
   */
  image_url: string
}

/**
 * Era3DOutput
 */
export type SchemaEra3dOutput = {
  /**
   * Images
   *
   * Images with background removed
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * Seed used for random number generation
   */
  seed: number
  /**
   * Normal Images
   *
   * Normal images with background removed
   */
  normal_images: Array<SchemaImage>
}

/**
 * Era3DInput
 */
export type SchemaEra3dInput = {
  /**
   * Cfg
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  cfg?: number
  /**
   * Background Removal
   *
   * Background removal
   */
  background_removal?: boolean
  /**
   * Steps
   *
   * Number of steps to run the model for
   */
  steps?: number
  /**
   * Crop Size
   *
   * Size of the image to crop to
   */
  crop_size?: number
  /**
   * Seed
   *
   * Seed for random number generation
   */
  seed?: number
  /**
   * Image Url
   *
   * URL of the image to remove background from
   */
  image_url: string
}

/**
 * Output
 */
export type SchemaSdxlControlnetUnionImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * ImageToImageControlNetUnionInput
 */
export type SchemaSdxlControlnetUnionImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Depth Preprocess
   *
   * Whether to preprocess the depth image.
   */
  depth_preprocess?: boolean
  /**
   * Image Size
   *
   * The size of the generated image. Leave it none to automatically infer from the control image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | null
  /**
   * Normal Image Url
   *
   * The URL of the control image.
   */
  normal_image_url?: string
  /**
   * Embeddings
   *
   * The list of embeddings to use.
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Teed Image Url
   *
   * The URL of the control image.
   */
  teed_image_url?: string
  /**
   * Loras
   *
   * The list of LoRA weights to use.
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Canny Image Url
   *
   * The URL of the control image.
   */
  canny_image_url?: string
  /**
   * Segmentation Preprocess
   *
   * Whether to preprocess the segmentation image.
   */
  segmentation_preprocess?: boolean
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Image Url
   *
   * The URL of the image to use as a starting point for the generation.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Segmentation Image Url
   *
   * The URL of the control image.
   */
  segmentation_image_url?: string
  /**
   * Openpose Image Url
   *
   * The URL of the control image.
   */
  openpose_image_url?: string
  /**
   * Canny Preprocess
   *
   * Whether to preprocess the canny image.
   */
  canny_preprocess?: boolean
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Depth Image Url
   *
   * The URL of the control image.
   */
  depth_image_url?: string
  /**
   * Normal Preprocess
   *
   * Whether to preprocess the normal image.
   */
  normal_preprocess?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Preserve Aspect Ratio
   *
   *
   * If set to true, the aspect ratio of the generated image will be preserved even
   * if the image size is too large. However, if the image is not a multiple of 32
   * in width or height, it will be resized to the nearest multiple of 32. By default,
   * this snapping to the nearest multiple of 32 will not preserve the aspect ratio.
   * Set crop_output to True, to crop the output to the proper aspect ratio
   * after generating.
   *
   */
  preserve_aspect_ratio?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use.Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Crop Output
   *
   *
   * If set to true, the output cropped to the proper aspect ratio after generating.
   *
   */
  crop_output?: boolean
  /**
   * Teed Preprocess
   *
   * Whether to preprocess the teed image.
   */
  teed_preprocess?: boolean
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Controlnet Conditioning Scale
   *
   * The scale of the controlnet conditioning.
   */
  controlnet_conditioning_scale?: number
  /**
   * Strength
   *
   * determines how much the generated image resembles the initial image
   */
  strength?: number
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Openpose Preprocess
   *
   * Whether to preprocess the openpose image.
   */
  openpose_preprocess?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * Output
 */
export type SchemaSdxlControlnetUnionInpaintingOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * InpaintingControlNetUnionInput
 */
export type SchemaSdxlControlnetUnionInpaintingInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Depth Preprocess
   *
   * Whether to preprocess the depth image.
   */
  depth_preprocess?: boolean
  /**
   * Image Size
   *
   * The size of the generated image. Leave it none to automatically infer from the control image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | null
  /**
   * Normal Image Url
   *
   * The URL of the control image.
   */
  normal_image_url?: string
  /**
   * Embeddings
   *
   * The list of embeddings to use.
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Teed Image Url
   *
   * The URL of the control image.
   */
  teed_image_url?: string
  /**
   * Loras
   *
   * The list of LoRA weights to use.
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Canny Image Url
   *
   * The URL of the control image.
   */
  canny_image_url?: string
  /**
   * Segmentation Preprocess
   *
   * Whether to preprocess the segmentation image.
   */
  segmentation_preprocess?: boolean
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Image Url
   *
   * The URL of the image to use as a starting point for the generation.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Mask Url
   *
   * The URL of the mask to use for inpainting.
   */
  mask_url: string
  /**
   * Segmentation Image Url
   *
   * The URL of the control image.
   */
  segmentation_image_url?: string
  /**
   * Openpose Image Url
   *
   * The URL of the control image.
   */
  openpose_image_url?: string
  /**
   * Canny Preprocess
   *
   * Whether to preprocess the canny image.
   */
  canny_preprocess?: boolean
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Depth Image Url
   *
   * The URL of the control image.
   */
  depth_image_url?: string
  /**
   * Normal Preprocess
   *
   * Whether to preprocess the normal image.
   */
  normal_preprocess?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use.Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Teed Preprocess
   *
   * Whether to preprocess the teed image.
   */
  teed_preprocess?: boolean
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Controlnet Conditioning Scale
   *
   * The scale of the controlnet conditioning.
   */
  controlnet_conditioning_scale?: number
  /**
   * Strength
   *
   * determines how much the generated image resembles the initial image
   */
  strength?: number
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Openpose Preprocess
   *
   * Whether to preprocess the openpose image.
   */
  openpose_preprocess?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * Output
 */
export type SchemaFluxLoraImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * ImageToImageInput
 */
export type SchemaFluxLoraImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate. This is always set to 1 for streaming output.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image Url
   *
   * URL of image to use for inpainting. or img2img
   */
  image_url: string
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.
   */
  strength?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaFluxGeneralDifferentialDiffusionOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * DifferentialDiffusionInput
 */
export type SchemaFluxGeneralDifferentialDiffusionInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Proportion of steps to apply NAG
   *
   *
   * The proportion of steps to apply NAG. After the specified proportion
   * of steps has been iterated, the remaining steps will use original
   * attention processors in FLUX.
   *
   */
  nag_end?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Control Loras
   *
   *
   * The LoRAs to use for the image generation which use a control image. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  control_loras?: Array<SchemaControlLoraWeight>
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Scheduler
   *
   * Scheduler for the denoising process.
   */
  scheduler?: 'euler' | 'dpmpp_2m'
  /**
   * Easycontrols
   *
   *
   * EasyControl Inputs to use for image generation.
   *
   */
  easycontrols?: Array<SchemaEasyControlWeight>
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Real CFG scale
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  real_cfg_scale?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Use CFG-Zero-Init
   *
   *
   * Uses CFG-zero init sampling as in https://arxiv.org/abs/2503.18886.
   *
   */
  use_cfg_zero?: boolean
  /**
   * Fill Image
   *
   * Use an image input to influence the generation. Can be used to fill images in masked areas.
   */
  fill_image?: SchemaImageFillInput
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Sigma Schedule
   *
   * Sigmas schedule for the denoising process.
   */
  sigma_schedule?: 'sgm_uniform'
  /**
   * Reference End
   *
   *
   * The percentage of the total timesteps when the reference guidance is to be ended.
   *
   */
  reference_end?: number
  /**
   * Reference Strength
   *
   * Strength of reference_only generation. Only used if a reference image is provided.
   */
  reference_strength?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Image URL
   *
   * URL of image to use as initial image.
   */
  image_url: string
  /**
   * NAG scale
   *
   *
   * The scale for NAG. Higher values will result in a image that is more distant
   * to the negative prompt.
   *
   */
  nag_scale?: number
  /**
   * Reference Image Url
   *
   * URL of Image for Reference-Only
   */
  reference_image_url?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Controlnet Unions
   *
   *
   * The controlnet unions to use for the image generation. Only one controlnet is supported at the moment.
   *
   */
  controlnet_unions?: Array<SchemaControlNetUnion>
  /**
   * Negative Prompt
   *
   *
   * Negative prompt to steer the image generation away from unwanted features.
   * By default, we will be using NAG for processing the negative prompt.
   *
   */
  negative_prompt?: string
  /**
   * NAG Tau
   *
   *
   * The tau for NAG. Controls the normalization of the hidden state.
   * Higher values will result in a less aggressive normalization,
   * but may also lead to unexpected changes with respect to the original image.
   * Not recommended to change this value.
   *
   */
  nag_tau?: number
  /**
   * Change Map URL
   *
   * URL of change map.
   */
  change_map_image_url: string
  /**
   * Num Images
   *
   * The number of images to generate. This is always set to 1 for streaming output.
   */
  num_images?: number
  /**
   * Use Beta Schedule
   *
   * Specifies whether beta sigmas ought to be used.
   */
  use_beta_schedule?: boolean
  /**
   * Ip Adapters
   *
   *
   * IP-Adapter to use for image generation.
   *
   */
  ip_adapters?: Array<SchemaIpAdapter>
  /**
   * Base Shift
   *
   * Base shift for the scheduled timesteps
   */
  base_shift?: number
  /**
   * NAG alpha
   *
   *
   * The alpha value for NAG. This value is used as a final weighting
   * factor for steering the normalized guidance (positive and negative prompts)
   * in the direction of the positive prompt. Higher values will result in less
   * steering on the normalized guidance where lower values will result in
   * considering the positive prompt guidance more.
   *
   */
  nag_alpha?: number
  /**
   * Strength
   *
   * The strength to use for differential diffusion. 1.0 is completely remakes the image while 0.0 preserves the original.
   */
  strength?: number
  /**
   * Max Shift
   *
   * Max shift for the scheduled timesteps
   */
  max_shift?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Controlnets
   *
   *
   * The controlnets to use for the image generation. Only one controlnet is supported at the moment.
   *
   */
  controlnets?: Array<SchemaControlNet>
  /**
   * Reference Start
   *
   *
   * The percentage of the total timesteps when the reference guidance is to bestarted.
   *
   */
  reference_start?: number
  /**
   * Use Real CFG
   *
   *
   * Uses classical CFG as in SD1.5, SDXL, etc. Increases generation times and price when set to be true.
   * If using XLabs IP-Adapter v1, this will be turned on!.
   *
   */
  use_real_cfg?: boolean
}

/**
 * ControlNetUnionInput
 */
export type SchemaControlNetUnionInput = {
  /**
   * Conditioning Scale
   *
   *
   * The scale of the control net weight. This is used to scale the control net weight
   * before merging it with the base model.
   *
   */
  conditioning_scale?: number
  /**
   * Mask Threshold
   *
   * Threshold for mask.
   */
  mask_threshold?: number
  /**
   * End Percentage
   *
   *
   * The percentage of the image to end applying the controlnet in terms of the total timesteps.
   *
   */
  end_percentage?: number
  /**
   * Mask Image Url
   *
   * URL of the mask for the control image.
   */
  mask_image_url?: string | null
  /**
   * Control Image Url
   *
   * URL of the image to be used as the control image.
   */
  control_image_url: string
  /**
   * Control Mode
   *
   * Control Mode for Flux Controlnet Union. Supported values are:
   * - canny: Uses the edges for guided generation.
   * - tile: Uses the tiles for guided generation.
   * - depth: Utilizes a grayscale depth map for guided generation.
   * - blur: Adds a blur to the image.
   * - pose: Uses the pose of the image for guided generation.
   * - gray: Converts the image to grayscale.
   * - low-quality: Converts the image to a low-quality image.
   */
  control_mode:
    | 'canny'
    | 'tile'
    | 'depth'
    | 'blur'
    | 'pose'
    | 'gray'
    | 'low-quality'
  /**
   * Start Percentage
   *
   *
   * The percentage of the image to start applying the controlnet in terms of the total timesteps.
   *
   */
  start_percentage?: number
}

/**
 * ControlNetUnion
 */
export type SchemaControlNetUnion = {
  /**
   * Controls
   *
   * The control images and modes to use for the control net.
   */
  controls: Array<SchemaControlNetUnionInput>
  /**
   * Path
   *
   * URL or the path to the control net weights.
   */
  path: string
  /**
   * Variant
   *
   * The optional variant if a Hugging Face repo key is used.
   */
  variant?: string
  /**
   * Config Url
   *
   * optional URL to the controlnet config.json file.
   */
  config_url?: string
}

/**
 * ImageFillInput
 */
export type SchemaImageFillInput = {
  /**
   * Fill Image Url
   *
   * URLs of images to be filled for redux prompting
   */
  fill_image_url?: string | Array<string>
}

/**
 * EasyControlWeight
 */
export type SchemaEasyControlWeight = {
  /**
   * Scale
   *
   * Scale for the control method.
   */
  scale?: number
  /**
   * Image Control Type
   *
   * Control type of the image. Must be one of `spatial` or `subject`.
   */
  image_control_type: 'subject' | 'spatial'
  /**
   * Control Method Url
   *
   * URL to safetensor weights of control method to be applied. Can also be one of `canny`, `depth`, `hedsketch`, `inpainting`, `pose`, `seg`, `subject`, `ghibli`
   */
  control_method_url: string
  /**
   * Image Url
   *
   * URL of an image to use as a control
   */
  image_url: string
}

/**
 * ControlLoraWeight
 */
export type SchemaControlLoraWeight = {
  /**
   * Path
   *
   * URL or the path to the LoRA weights.
   */
  path: string
  /**
   * Scale
   *
   *
   * The scale of the LoRA weight. This is used to scale the LoRA weight
   * before merging it with the base model. Providing a dictionary as {"layer_name":layer_scale} allows per-layer lora scale settings. Layers with no scale provided will have scale 1.0.
   *
   */
  scale?:
    | {
        [key: string]: unknown
      }
    | number
  /**
   * Control Image Url
   *
   * URL of the image to be used as the control image.
   */
  control_image_url: string
  /**
   * Preprocess
   *
   * Type of preprocessing to apply to the input image.
   */
  preprocess?: 'canny' | 'depth' | 'None'
}

/**
 * Output
 */
export type SchemaFluxGeneralInpaintingOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * InpaintInput
 */
export type SchemaFluxGeneralInpaintingInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Proportion of steps to apply NAG
   *
   *
   * The proportion of steps to apply NAG. After the specified proportion
   * of steps has been iterated, the remaining steps will use original
   * attention processors in FLUX.
   *
   */
  nag_end?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Control Loras
   *
   *
   * The LoRAs to use for the image generation which use a control image. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  control_loras?: Array<SchemaControlLoraWeight>
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Scheduler
   *
   * Scheduler for the denoising process.
   */
  scheduler?: 'euler' | 'dpmpp_2m'
  /**
   * Easycontrols
   *
   *
   * EasyControl Inputs to use for image generation.
   *
   */
  easycontrols?: Array<SchemaEasyControlWeight>
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Real CFG scale
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  real_cfg_scale?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Use CFG-Zero-Init
   *
   *
   * Uses CFG-zero init sampling as in https://arxiv.org/abs/2503.18886.
   *
   */
  use_cfg_zero?: boolean
  /**
   * Fill Image
   *
   * Use an image input to influence the generation. Can be used to fill images in masked areas.
   */
  fill_image?: SchemaImageFillInput
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Sigma Schedule
   *
   * Sigmas schedule for the denoising process.
   */
  sigma_schedule?: 'sgm_uniform'
  /**
   * Reference End
   *
   *
   * The percentage of the total timesteps when the reference guidance is to be ended.
   *
   */
  reference_end?: number
  /**
   * Reference Strength
   *
   * Strength of reference_only generation. Only used if a reference image is provided.
   */
  reference_strength?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Mask Url
   *
   *
   * The mask to area to Inpaint in.
   *
   */
  mask_url: string
  /**
   * Image Url
   *
   * URL of image to use for inpainting. or img2img
   */
  image_url: string
  /**
   * NAG scale
   *
   *
   * The scale for NAG. Higher values will result in a image that is more distant
   * to the negative prompt.
   *
   */
  nag_scale?: number
  /**
   * Reference Image Url
   *
   * URL of Image for Reference-Only
   */
  reference_image_url?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Controlnet Unions
   *
   *
   * The controlnet unions to use for the image generation. Only one controlnet is supported at the moment.
   *
   */
  controlnet_unions?: Array<SchemaControlNetUnion>
  /**
   * Negative Prompt
   *
   *
   * Negative prompt to steer the image generation away from unwanted features.
   * By default, we will be using NAG for processing the negative prompt.
   *
   */
  negative_prompt?: string
  /**
   * NAG Tau
   *
   *
   * The tau for NAG. Controls the normalization of the hidden state.
   * Higher values will result in a less aggressive normalization,
   * but may also lead to unexpected changes with respect to the original image.
   * Not recommended to change this value.
   *
   */
  nag_tau?: number
  /**
   * Num Images
   *
   * The number of images to generate. This is always set to 1 for streaming output.
   */
  num_images?: number
  /**
   * Use Beta Schedule
   *
   * Specifies whether beta sigmas ought to be used.
   */
  use_beta_schedule?: boolean
  /**
   * Ip Adapters
   *
   *
   * IP-Adapter to use for image generation.
   *
   */
  ip_adapters?: Array<SchemaIpAdapter>
  /**
   * Base Shift
   *
   * Base shift for the scheduled timesteps
   */
  base_shift?: number
  /**
   * NAG alpha
   *
   *
   * The alpha value for NAG. This value is used as a final weighting
   * factor for steering the normalized guidance (positive and negative prompts)
   * in the direction of the positive prompt. Higher values will result in less
   * steering on the normalized guidance where lower values will result in
   * considering the positive prompt guidance more.
   *
   */
  nag_alpha?: number
  /**
   * Strength
   *
   * The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.
   */
  strength?: number
  /**
   * Max Shift
   *
   * Max shift for the scheduled timesteps
   */
  max_shift?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Controlnets
   *
   *
   * The controlnets to use for the image generation. Only one controlnet is supported at the moment.
   *
   */
  controlnets?: Array<SchemaControlNet>
  /**
   * Reference Start
   *
   *
   * The percentage of the total timesteps when the reference guidance is to bestarted.
   *
   */
  reference_start?: number
  /**
   * Use Real CFG
   *
   *
   * Uses classical CFG as in SD1.5, SDXL, etc. Increases generation times and price when set to be true.
   * If using XLabs IP-Adapter v1, this will be turned on!.
   *
   */
  use_real_cfg?: boolean
}

/**
 * Output
 */
export type SchemaFluxGeneralImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * ImageToImageInput
 */
export type SchemaFluxGeneralImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Proportion of steps to apply NAG
   *
   *
   * The proportion of steps to apply NAG. After the specified proportion
   * of steps has been iterated, the remaining steps will use original
   * attention processors in FLUX.
   *
   */
  nag_end?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Control Loras
   *
   *
   * The LoRAs to use for the image generation which use a control image. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  control_loras?: Array<SchemaControlLoraWeight>
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Scheduler
   *
   * Scheduler for the denoising process.
   */
  scheduler?: 'euler' | 'dpmpp_2m'
  /**
   * Easycontrols
   *
   *
   * EasyControl Inputs to use for image generation.
   *
   */
  easycontrols?: Array<SchemaEasyControlWeight>
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Real CFG scale
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  real_cfg_scale?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Use CFG-Zero-Init
   *
   *
   * Uses CFG-zero init sampling as in https://arxiv.org/abs/2503.18886.
   *
   */
  use_cfg_zero?: boolean
  /**
   * Fill Image
   *
   * Use an image input to influence the generation. Can be used to fill images in masked areas.
   */
  fill_image?: SchemaImageFillInput
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Sigma Schedule
   *
   * Sigmas schedule for the denoising process.
   */
  sigma_schedule?: 'sgm_uniform'
  /**
   * Reference End
   *
   *
   * The percentage of the total timesteps when the reference guidance is to be ended.
   *
   */
  reference_end?: number
  /**
   * Reference Strength
   *
   * Strength of reference_only generation. Only used if a reference image is provided.
   */
  reference_strength?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Image Url
   *
   * URL of image to use for inpainting. or img2img
   */
  image_url: string
  /**
   * NAG scale
   *
   *
   * The scale for NAG. Higher values will result in a image that is more distant
   * to the negative prompt.
   *
   */
  nag_scale?: number
  /**
   * Reference Image Url
   *
   * URL of Image for Reference-Only
   */
  reference_image_url?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Controlnet Unions
   *
   *
   * The controlnet unions to use for the image generation. Only one controlnet is supported at the moment.
   *
   */
  controlnet_unions?: Array<SchemaControlNetUnion>
  /**
   * Negative Prompt
   *
   *
   * Negative prompt to steer the image generation away from unwanted features.
   * By default, we will be using NAG for processing the negative prompt.
   *
   */
  negative_prompt?: string
  /**
   * NAG Tau
   *
   *
   * The tau for NAG. Controls the normalization of the hidden state.
   * Higher values will result in a less aggressive normalization,
   * but may also lead to unexpected changes with respect to the original image.
   * Not recommended to change this value.
   *
   */
  nag_tau?: number
  /**
   * Num Images
   *
   * The number of images to generate. This is always set to 1 for streaming output.
   */
  num_images?: number
  /**
   * Use Beta Schedule
   *
   * Specifies whether beta sigmas ought to be used.
   */
  use_beta_schedule?: boolean
  /**
   * Ip Adapters
   *
   *
   * IP-Adapter to use for image generation.
   *
   */
  ip_adapters?: Array<SchemaIpAdapter>
  /**
   * Base Shift
   *
   * Base shift for the scheduled timesteps
   */
  base_shift?: number
  /**
   * NAG alpha
   *
   *
   * The alpha value for NAG. This value is used as a final weighting
   * factor for steering the normalized guidance (positive and negative prompts)
   * in the direction of the positive prompt. Higher values will result in less
   * steering on the normalized guidance where lower values will result in
   * considering the positive prompt guidance more.
   *
   */
  nag_alpha?: number
  /**
   * Strength
   *
   * The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.
   */
  strength?: number
  /**
   * Max Shift
   *
   * Max shift for the scheduled timesteps
   */
  max_shift?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Controlnets
   *
   *
   * The controlnets to use for the image generation. Only one controlnet is supported at the moment.
   *
   */
  controlnets?: Array<SchemaControlNet>
  /**
   * Reference Start
   *
   *
   * The percentage of the total timesteps when the reference guidance is to bestarted.
   *
   */
  reference_start?: number
  /**
   * Use Real CFG
   *
   *
   * Uses classical CFG as in SD1.5, SDXL, etc. Increases generation times and price when set to be true.
   * If using XLabs IP-Adapter v1, this will be turned on!.
   *
   */
  use_real_cfg?: boolean
}

/**
 * SAM2ImageOutput
 */
export type SchemaSam2ImageOutput = {
  /**
   * Image
   *
   * Segmented image.
   */
  image: SchemaImage
}

/**
 * SAM2ImageInput
 */
export type SchemaSam2ImageInput = {
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Prompts
   *
   * List of prompts to segment the image
   */
  prompts?: Array<SchemaPointPrompt>
  /**
   * Box Prompts
   *
   * Coordinates for boxes
   */
  box_prompts?: Array<SchemaBoxPrompt>
  /**
   * Apply Mask
   *
   * Apply the mask on the image.
   */
  apply_mask?: boolean
  /**
   * Image Url
   *
   * URL of the image to be segmented
   */
  image_url: string
}

/**
 * BoxPrompt
 */
export type SchemaBoxPrompt = {
  /**
   * Y Min
   *
   * Y Min Coordinate of the box
   */
  y_min?: number
  /**
   * Frame Index
   *
   * The frame index to interact with.
   */
  frame_index?: number
  /**
   * X Max
   *
   * X Max Coordinate of the prompt
   */
  x_max?: number
  /**
   * X Min
   *
   * X Min Coordinate of the box
   */
  x_min?: number
  /**
   * Y Max
   *
   * Y Max Coordinate of the prompt
   */
  y_max?: number
}

/**
 * PointPrompt
 */
export type SchemaPointPrompt = {
  /**
   * Y
   *
   * Y Coordinate of the prompt
   */
  y?: number
  /**
   * Label
   *
   * Label of the prompt. 1 for foreground, 0 for background
   */
  label?: 0 | 1
  /**
   * Frame Index
   *
   * The frame index to interact with.
   */
  frame_index?: number
  /**
   * X
   *
   * X Coordinate of the prompt
   */
  x?: number
}

/**
 * PiDiOutput
 */
export type SchemaImagePreprocessorsPidiOutput = {
  image: SchemaImage
}

/**
 * PiDiInput
 */
export type SchemaImagePreprocessorsPidiInput = {
  /**
   * Safe
   *
   * Whether to use the safe version of the Pidi detector
   */
  safe?: boolean
  /**
   * Apply Filter
   *
   * Whether to apply the filter to the image.
   */
  apply_filter?: boolean
  /**
   * Scribble
   *
   * Whether to use the scribble version of the Pidi detector
   */
  scribble?: boolean
  /**
   * Image Url
   *
   * URL of the image to process
   */
  image_url: string
}

/**
 * ZoeOutput
 */
export type SchemaImagePreprocessorsZoeOutput = {
  image: SchemaImage
}

/**
 * ZoeInput
 */
export type SchemaImagePreprocessorsZoeInput = {
  /**
   * Image Url
   *
   * URL of the image to process
   */
  image_url: string
}

/**
 * LineartOutput
 */
export type SchemaImagePreprocessorsLineartOutput = {
  image: SchemaImage
}

/**
 * LineartInput
 */
export type SchemaImagePreprocessorsLineartInput = {
  /**
   * Coarse
   *
   * Whether to use the coarse model
   */
  coarse?: boolean
  /**
   * Image Url
   *
   * URL of the image to process
   */
  image_url: string
}

/**
 * TeeDOutput
 */
export type SchemaImagePreprocessorsTeedOutput = {
  image: SchemaImage
}

/**
 * TeeDInput
 */
export type SchemaImagePreprocessorsTeedInput = {
  /**
   * Image Url
   *
   * URL of the image to process
   */
  image_url: string
}

/**
 * MiDaSOutput
 */
export type SchemaImagePreprocessorsMidasOutput = {
  normal_map: SchemaImage
  depth_map: SchemaImage
}

/**
 * MiDaSInput
 */
export type SchemaImagePreprocessorsMidasInput = {
  /**
   * A
   *
   * A parameter for the MiDaS detector
   */
  a?: number
  /**
   * Background Threshold
   *
   * Background threshold for the MiDaS detector
   */
  background_threshold?: number
  /**
   * Image Url
   *
   * URL of the image to process
   */
  image_url: string
}

/**
 * SamOutput
 */
export type SchemaImagePreprocessorsSamOutput = {
  image: SchemaImage
}

/**
 * SamInput
 */
export type SchemaImagePreprocessorsSamInput = {
  /**
   * Image Url
   *
   * URL of the image to process
   */
  image_url: string
}

/**
 * MLSDOutput
 */
export type SchemaImagePreprocessorsMlsdOutput = {
  image: SchemaImage
}

/**
 * MLSDInput
 */
export type SchemaImagePreprocessorsMlsdInput = {
  /**
   * Distance Threshold
   *
   * Distance threshold for the MLSD detector
   */
  distance_threshold?: number
  /**
   * Score Threshold
   *
   * Score threshold for the MLSD detector
   */
  score_threshold?: number
  /**
   * Image Url
   *
   * URL of the image to process
   */
  image_url: string
}

/**
 * ScribbleOutput
 */
export type SchemaImagePreprocessorsScribbleOutput = {
  image: SchemaImage
}

/**
 * ScribbleInput
 */
export type SchemaImagePreprocessorsScribbleInput = {
  /**
   * Model
   *
   * The model to use for the Scribble detector
   */
  model?: 'HED' | 'PiDi'
  /**
   * Safe
   *
   * Whether to use the safe version of the Scribble detector
   */
  safe?: boolean
  /**
   * Image Url
   *
   * URL of the image to process
   */
  image_url: string
}

/**
 * DepthAnythingV2Output
 */
export type SchemaImagePreprocessorsDepthAnythingV2Output = {
  image: SchemaImage
}

/**
 * DepthAnythingV2Input
 */
export type SchemaImagePreprocessorsDepthAnythingV2Input = {
  /**
   * Image Url
   *
   * URL of the image to process
   */
  image_url: string
}

/**
 * HEDOutput
 */
export type SchemaImagePreprocessorsHedOutput = {
  image: SchemaImage
}

/**
 * HEDInput
 */
export type SchemaImagePreprocessorsHedInput = {
  /**
   * Safe
   *
   * Whether to use the safe version of the HED detector
   */
  safe?: boolean
  /**
   * Scribble
   *
   * Whether to use the scribble version of the HED detector
   */
  scribble?: boolean
  /**
   * Image Url
   *
   * URL of the image to process
   */
  image_url: string
}

/**
 * Output
 */
export type SchemaFluxGeneralRfInversionOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * RFInversionInput
 */
export type SchemaFluxGeneralRfInversionInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image with
   */
  prompt: string
  /**
   * Proportion of steps to apply NAG
   *
   *
   * The proportion of steps to apply NAG. After the specified proportion
   * of steps has been iterated, the remaining steps will use original
   * attention processors in FLUX.
   *
   */
  nag_end?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | null
  /**
   * Control Loras
   *
   *
   * The LoRAs to use for the image generation which use a control image. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  control_loras?: Array<SchemaControlLoraWeight>
  /**
   * Controller Guidance Reverse
   *
   * The controller guidance (eta) used in the denoising process.Using values closer to 1 will result in an image closer to input.
   */
  controller_guidance_reverse?: number
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Reverse Guidance Start
   *
   * Timestep to start guidance during reverse process.
   */
  reverse_guidance_start?: number
  /**
   * Easycontrols
   *
   *
   * EasyControl Inputs to use for image generation.
   *
   */
  easycontrols?: Array<SchemaEasyControlWeight>
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Scheduler
   *
   * Scheduler for the denoising process.
   */
  scheduler?: 'euler' | 'dpmpp_2m'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Use CFG-Zero-Init
   *
   *
   * Uses CFG-zero init sampling as in https://arxiv.org/abs/2503.18886.
   *
   */
  use_cfg_zero?: boolean
  /**
   * Reference Strength
   *
   * Strength of reference_only generation. Only used if a reference image is provided.
   */
  reference_strength?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Sigma Schedule
   *
   * Sigmas schedule for the denoising process.
   */
  sigma_schedule?: 'sgm_uniform'
  /**
   * Reference End
   *
   *
   * The percentage of the total timesteps when the reference guidance is to be ended.
   *
   */
  reference_end?: number
  /**
   * Controller Guidance Forward
   *
   * The controller guidance (gamma) used in the creation of structured noise.
   */
  controller_guidance_forward?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Image Url
   *
   * URL of image to be edited
   */
  image_url: string
  /**
   * Fill Image
   *
   * Use an image input to influence the generation. Can be used to fill images in masked areas.
   */
  fill_image?: SchemaImageFillInput
  /**
   * NAG scale
   *
   *
   * The scale for NAG. Higher values will result in a image that is more distant
   * to the negative prompt.
   *
   */
  nag_scale?: number
  /**
   * Reverse Guidance Schedule
   *
   * Scheduler for applying reverse guidance.
   */
  reverse_guidance_schedule?: 'constant' | 'linear_increase' | 'linear_decrease'
  /**
   * Reference Image Url
   *
   * URL of Image for Reference-Only
   */
  reference_image_url?: string
  /**
   * Reverse Guidance End
   *
   * Timestep to stop guidance during reverse process.
   */
  reverse_guidance_end?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Controlnet Unions
   *
   *
   * The controlnet unions to use for the image generation. Only one controlnet is supported at the moment.
   *
   */
  controlnet_unions?: Array<SchemaControlNetUnion>
  /**
   * Negative Prompt
   *
   *
   * Negative prompt to steer the image generation away from unwanted features.
   * By default, we will be using NAG for processing the negative prompt.
   *
   */
  negative_prompt?: string
  /**
   * NAG Tau
   *
   *
   * The tau for NAG. Controls the normalization of the hidden state.
   * Higher values will result in a less aggressive normalization,
   * but may also lead to unexpected changes with respect to the original image.
   * Not recommended to change this value.
   *
   */
  nag_tau?: number
  /**
   * Num Images
   *
   * The number of images to generate. This is always set to 1 for streaming output.
   */
  num_images?: number
  /**
   * Use Beta Schedule
   *
   * Specifies whether beta sigmas ought to be used.
   */
  use_beta_schedule?: boolean
  /**
   * NAG alpha
   *
   *
   * The alpha value for NAG. This value is used as a final weighting
   * factor for steering the normalized guidance (positive and negative prompts)
   * in the direction of the positive prompt. Higher values will result in less
   * steering on the normalized guidance where lower values will result in
   * considering the positive prompt guidance more.
   *
   */
  nag_alpha?: number
  /**
   * Base Shift
   *
   * Base shift for the scheduled timesteps
   */
  base_shift?: number
  /**
   * Max Shift
   *
   * Max shift for the scheduled timesteps
   */
  max_shift?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Reference Start
   *
   *
   * The percentage of the total timesteps when the reference guidance is to bestarted.
   *
   */
  reference_start?: number
  /**
   * Controlnets
   *
   *
   * The controlnets to use for the image generation. Only one controlnet is supported at the moment.
   *
   */
  controlnets?: Array<SchemaControlNet>
}

/**
 * LivePortraitImageOutput
 */
export type SchemaLivePortraitImageOutput = {
  /**
   * Image
   *
   * The generated image file.
   */
  image: SchemaImage
}

/**
 * LivePortraitImageInput
 */
export type SchemaLivePortraitImageInput = {
  /**
   * Smile
   *
   * Amount to smile
   */
  smile?: number
  /**
   * Eyebrow
   *
   * Amount to raise or lower eyebrows
   */
  eyebrow?: number
  /**
   * Rotate Roll
   *
   * Amount to rotate the face in roll
   */
  rotate_roll?: number
  /**
   * Wink
   *
   * Amount to wink
   */
  wink?: number
  /**
   * Rotate Pitch
   *
   * Amount to rotate the face in pitch
   */
  rotate_pitch?: number
  /**
   * Blink
   *
   * Amount to blink the eyes
   */
  blink?: number
  /**
   * Dsize
   *
   * Size of the output image.
   */
  dsize?: number
  /**
   * Vy Ratio
   *
   * Vertical offset ratio for face crop. Positive values move up, negative values move down.
   */
  vy_ratio?: number
  /**
   * Scale
   *
   * Scaling factor for the face crop.
   */
  scale?: number
  /**
   * Pupil X
   *
   * Amount to move pupils horizontally
   */
  pupil_x?: number
  /**
   * Flag Pasteback
   *
   * Whether to paste-back/stitch the animated face cropping from the face-cropping space to the original image space.
   */
  flag_pasteback?: boolean
  /**
   * Eee
   *
   * Amount to shape mouth in 'eee' position
   */
  eee?: number
  /**
   * Enable Safety Checker
   *
   *
   * Whether to enable the safety checker. If enabled, the model will check if the input image contains a face before processing it.
   * The safety checker will process the input image
   *
   */
  enable_safety_checker?: boolean
  /**
   * Vx Ratio
   *
   * Horizontal offset ratio for face crop.
   */
  vx_ratio?: number
  /**
   * Pupil Y
   *
   * Amount to move pupils vertically
   */
  pupil_y?: number
  /**
   * Output Format
   *
   * Output format
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Rotate Yaw
   *
   * Amount to rotate the face in yaw
   */
  rotate_yaw?: number
  /**
   * Flag Do Rot
   *
   * Whether to conduct the rotation when flag_do_crop is True.
   */
  flag_do_rot?: boolean
  /**
   * Woo
   *
   * Amount to shape mouth in 'woo' position
   */
  woo?: number
  /**
   * Aaa
   *
   * Amount to open mouth in 'aaa' shape
   */
  aaa?: number
  /**
   * Image Url
   *
   * URL of the image to be animated
   */
  image_url: string
  /**
   * Flag Do Crop
   *
   * Whether to crop the source portrait to the face-cropping space.
   */
  flag_do_crop?: boolean
  /**
   * Flag Lip Zero
   *
   * Whether to set the lip to closed state before animation. Only takes effect when flag_eye_retargeting and flag_lip_retargeting are False.
   */
  flag_lip_zero?: boolean
}

/**
 * Output
 */
export type SchemaBirefnetV2Output = {
  /**
   * Image
   *
   * Image with background removed
   */
  image: SchemaImageFile
  /**
   * Mask Image
   *
   * Mask used to remove the background
   */
  mask_image?: SchemaImageFile
}

/**
 * InputV2
 */
export type SchemaBirefnetV2Input = {
  /**
   * Operating Resolution
   *
   * The resolution to operate on. The higher the resolution, the more accurate the output will be for high res input images. The '2304x2304' option is only available for the 'General Use (Dynamic)' model.
   */
  operating_resolution?: '1024x1024' | '2048x2048' | '2304x2304'
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'webp' | 'png' | 'gif'
  /**
   * Image Url
   *
   * URL of the image to remove background from
   */
  image_url: string
  /**
   * Model
   *
   *
   * Model to use for background removal.
   * The 'General Use (Light)' model is the original model used in the BiRefNet repository.
   * The 'General Use (Light 2K)' model is the original model used in the BiRefNet repository but trained with 2K images.
   * The 'General Use (Heavy)' model is a slower but more accurate model.
   * The 'Matting' model is a model trained specifically for matting images.
   * The 'Portrait' model is a model trained specifically for portrait images.
   * The 'General Use (Dynamic)' model supports dynamic resolutions from 256x256 to 2304x2304.
   * The 'General Use (Light)' model is recommended for most use cases.
   *
   * The corresponding models are as follows:
   * - 'General Use (Light)': BiRefNet
   * - 'General Use (Light 2K)': BiRefNet_lite-2K
   * - 'General Use (Heavy)': BiRefNet_lite
   * - 'Matting': BiRefNet-matting
   * - 'Portrait': BiRefNet-portrait
   * - 'General Use (Dynamic)': BiRefNet_dynamic
   *
   */
  model?:
    | 'General Use (Light)'
    | 'General Use (Light 2K)'
    | 'General Use (Heavy)'
    | 'Matting'
    | 'Portrait'
    | 'General Use (Dynamic)'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Output Mask
   *
   * Whether to output the mask used to remove the background
   */
  output_mask?: boolean
  /**
   * Refine Foreground
   *
   * Whether to refine the foreground using the estimated mask
   */
  refine_foreground?: boolean
}

/**
 * Output
 */
export type SchemaFluxPulidOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * FluxPulidInput
 */
export type SchemaFluxPulidInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Id Weight
   *
   * The weight of the ID loss.
   */
  id_weight?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Start Step
   *
   * The number of steps to start the CFG from.
   */
  start_step?: number
  /**
   * Reference Image URL
   *
   * URL of image to use for inpainting.
   */
  reference_image_url: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Max Sequence Length
   *
   * The maximum sequence length for the model.
   */
  max_sequence_length?: '128' | '256' | '512'
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * The prompt to generate an image from.
   */
  negative_prompt?: string
  /**
   * True Cfg
   *
   * The weight of the CFG loss.
   */
  true_cfg?: number
}

/**
 * Output
 */
export type SchemaFluxDifferentialDiffusionOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * DiffInput
 */
export type SchemaFluxDifferentialDiffusionInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image URL
   *
   * URL of image to use as initial image.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * The strength to use for image-to-image. 1.0 is completely remakes the image while 0.0 preserves the original.
   */
  strength?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Change Map URL
   *
   * URL of change map.
   */
  change_map_image_url: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * Output
 */
export type SchemaIclightV2Output = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseInput
 */
export type SchemaIclightV2Input = {
  /**
   * Initial Latent
   *
   *
   * Provide lighting conditions for the model
   *
   */
  initial_latent?: 'None' | 'Left' | 'Right' | 'Top' | 'Bottom'
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Background Threshold
   *
   * Threshold for the background removal algorithm. A high threshold will produce sharper masks. Note: This parameter is currently deprecated and has no effect on the output.
   */
  background_threshold?: number
  /**
   * Mask Image Url
   *
   * URL of mask to be used for ic-light conditioning image
   */
  mask_image_url?: string
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Lowres Denoise
   *
   * Strength for low-resolution pass.
   */
  lowres_denoise?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   * Negative Prompt for the image
   */
  negative_prompt?: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Hr Downscale
   */
  hr_downscale?: number
  /**
   * Image Url
   *
   * URL of image to be used for relighting
   */
  image_url: string
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Highres Denoise
   *
   * Strength for high-resolution pass. Only used if enable_hr_fix is True.
   */
  highres_denoise?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Hr Fix
   *
   * Use HR fix
   */
  enable_hr_fix?: boolean
  /**
   * Cfg
   *
   * The real classifier-free-guidance scale for the generation.
   */
  cfg?: number
}

/**
 * Output
 */
export type SchemaKolorsImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * KolorsImg2ImgInput
 */
export type SchemaKolorsImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image Url
   *
   * URL of image to use for image to image
   */
  image_url: string
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and
   * uploaded before returning the response. This will increase the latency of
   * the function but it allows you to get the image directly in the response
   * without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Scheduler
   *
   * The scheduler to use for the model.
   */
  scheduler?:
    | 'EulerDiscreteScheduler'
    | 'EulerAncestralDiscreteScheduler'
    | 'DPMSolverMultistepScheduler'
    | 'DPMSolverMultistepScheduler_SDE_karras'
    | 'UniPCMultistepScheduler'
    | 'DEISMultistepScheduler'
  /**
   * Strength
   *
   * The strength to use for image-to-image. 1.0 is completely remakes the image while 0.0 preserves the original.
   */
  strength?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show
   * you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * Seed
   */
  seed?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small
   * details (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * Enable safety checker.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaFluxProV1FillOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaRegistryImageFastSdxlModelsImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * Image
 */
export type SchemaRegistryImageFastSdxlModelsImage = {
  /**
   * Height
   */
  height: number
  /**
   * Content Type
   */
  content_type?: string
  /**
   * Url
   */
  url: string
  /**
   * Width
   */
  width: number
}

/**
 * FluxProFillInput
 */
export type SchemaFluxProV1FillInput = {
  /**
   * Prompt
   *
   * The prompt to fill the masked part of the image.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The image URL to generate an image from. Needs to match the dimensions of the mask.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Mask URL
   *
   * The mask URL to inpaint the image. Needs to match the dimensions of the input image.
   */
  mask_url: string
  /**
   * Enhance Prompt
   *
   * Whether to enhance the prompt for better results.
   */
  enhance_prompt?: boolean
}

/**
 * Output
 */
export type SchemaFluxLoraDepthOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * DepthInput
 */
export type SchemaFluxLoraDepthInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate. This is always set to 1 for streaming output.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image Url
   *
   * URL of image to use for depth input
   */
  image_url: string
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaFluxProV11UltraReduxOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaRegistryImageFastSdxlModelsImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * FluxProUltraTextToImageInputRedux
 */
export type SchemaFluxProV11UltraReduxInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt?: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
    | string
  /**
   * Enhance Prompt
   *
   * Whether to enhance the prompt for better results.
   */
  enhance_prompt?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The image URL to generate an image from. Needs to match the dimensions of the mask.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Image Prompt Strength
   *
   * The strength of the image prompt, between 0 and 1.
   */
  image_prompt_strength?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Raw
   *
   * Generate less processed, more natural-looking images.
   */
  raw?: boolean
}

/**
 * Output
 */
export type SchemaFluxDevReduxOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseReduxInput
 */
export type SchemaFluxDevReduxInput = {
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to generate an image from.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * Output
 */
export type SchemaFluxProV11ReduxOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaRegistryImageFastSdxlModelsImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * FluxProRedux
 */
export type SchemaFluxProV11ReduxInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt?: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The image URL to generate an image from. Needs to match the dimensions of the mask.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enhance Prompt
   *
   * Whether to enhance the prompt for better results.
   */
  enhance_prompt?: boolean
}

/**
 * Output
 */
export type SchemaFluxSchnellReduxOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * SchnellReduxInput
 */
export type SchemaFluxSchnellReduxInput = {
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to generate an image from.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * Output
 */
export type SchemaIdeogramV2RemixOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for the random number generator
   */
  seed: number
}

/**
 * RemixImageInput
 */
export type SchemaIdeogramV2RemixInput = {
  /**
   * Prompt
   *
   * The prompt to remix the image with
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image
   */
  aspect_ratio?:
    | '10:16'
    | '16:10'
    | '9:16'
    | '16:9'
    | '4:3'
    | '3:4'
    | '1:1'
    | '1:3'
    | '3:1'
    | '3:2'
    | '2:3'
  /**
   * Style
   *
   * The style of the generated image
   */
  style?: 'auto' | 'general' | 'realistic' | 'design' | 'render_3D' | 'anime'
  /**
   * Expand Prompt
   *
   * Whether to expand the prompt with MagicPrompt functionality.
   */
  expand_prompt?: boolean
  /**
   * Image URL
   *
   * The image URL to remix
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * Strength of the input image in the remix
   */
  strength?: number
  /**
   * Seed
   *
   * Seed for the random number generator
   */
  seed?: number | unknown
}

/**
 * Output
 */
export type SchemaIdeogramV2TurboRemixOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for the random number generator
   */
  seed: number
}

/**
 * RemixImageInput
 */
export type SchemaIdeogramV2TurboRemixInput = {
  /**
   * Prompt
   *
   * The prompt to remix the image with
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image
   */
  aspect_ratio?:
    | '10:16'
    | '16:10'
    | '9:16'
    | '16:9'
    | '4:3'
    | '3:4'
    | '1:1'
    | '1:3'
    | '3:1'
    | '3:2'
    | '2:3'
  /**
   * Style
   *
   * The style of the generated image
   */
  style?: 'auto' | 'general' | 'realistic' | 'design' | 'render_3D' | 'anime'
  /**
   * Expand Prompt
   *
   * Whether to expand the prompt with MagicPrompt functionality.
   */
  expand_prompt?: boolean
  /**
   * Image URL
   *
   * The image URL to remix
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * Strength of the input image in the remix
   */
  strength?: number
  /**
   * Seed
   *
   * Seed for the random number generator
   */
  seed?: number | unknown
}

/**
 * Output
 */
export type SchemaIdeogramV2TurboEditOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for the random number generator
   */
  seed: number
}

/**
 * EditImageInput
 */
export type SchemaIdeogramV2TurboEditInput = {
  /**
   * Prompt
   *
   * The prompt to fill the masked part of the image.
   */
  prompt: string
  /**
   * Style
   *
   * The style of the generated image
   */
  style?: 'auto' | 'general' | 'realistic' | 'design' | 'render_3D' | 'anime'
  /**
   * Expand Prompt
   *
   * Whether to expand the prompt with MagicPrompt functionality.
   */
  expand_prompt?: boolean
  /**
   * Image URL
   *
   * The image URL to generate an image from. Needs to match the dimensions of the mask.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Seed
   *
   * Seed for the random number generator
   */
  seed?: number | unknown
  /**
   * Mask URL
   *
   * The mask URL to inpaint the image. Needs to match the dimensions of the input image.
   */
  mask_url: string
}

/**
 * Output
 */
export type SchemaIdeogramV2EditOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for the random number generator
   */
  seed: number
}

/**
 * EditImageInput
 */
export type SchemaIdeogramV2EditInput = {
  /**
   * Prompt
   *
   * The prompt to fill the masked part of the image.
   */
  prompt: string
  /**
   * Style
   *
   * The style of the generated image
   */
  style?: 'auto' | 'general' | 'realistic' | 'design' | 'render_3D' | 'anime'
  /**
   * Expand Prompt
   *
   * Whether to expand the prompt with MagicPrompt functionality.
   */
  expand_prompt?: boolean
  /**
   * Image URL
   *
   * The image URL to generate an image from. Needs to match the dimensions of the mask.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Seed
   *
   * Seed for the random number generator
   */
  seed?: number | unknown
  /**
   * Mask URL
   *
   * The mask URL to inpaint the image. Needs to match the dimensions of the input image.
   */
  mask_url: string
}

/**
 * VTONOutput
 */
export type SchemaLeffaVirtualTryonOutput = {
  /**
   * Image
   *
   * The output image.
   */
  image: SchemaImage
  /**
   * Seed
   *
   * The seed for the inference.
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the image contains NSFW concepts.
   */
  has_nsfw_concepts: boolean
}

/**
 * VTONInput
 */
export type SchemaLeffaVirtualTryonInput = {
  /**
   * Garment Image Url
   *
   * Url to the garment image.
   */
  garment_image_url: string
  /**
   * Human Image Url
   *
   * Url for the human image.
   */
  human_image_url: string
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Garment Type
   *
   * The type of the garment used for virtual try-on.
   */
  garment_type: 'upper_body' | 'lower_body' | 'dresses'
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your input when generating the image.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same input given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * PoseTransferOutput
 */
export type SchemaLeffaPoseTransferOutput = {
  /**
   * Image
   *
   * The output image.
   */
  image: SchemaImage
  /**
   * Seed
   *
   * The seed for the inference.
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the image contains NSFW concepts.
   */
  has_nsfw_concepts: boolean
}

/**
 * PoseTransferInput
 */
export type SchemaLeffaPoseTransferInput = {
  /**
   * Pose Image Url
   *
   * Url for the human image.
   */
  pose_image_url: string
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your input when generating the image.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same input given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Person Image Url
   *
   * Url to the garment image.
   */
  person_image_url: string
}

/**
 * CATVTONOutput
 */
export type SchemaCatVtonOutput = {
  /**
   * Image
   *
   * The output image.
   */
  image: SchemaImage
}

/**
 * CATVTONInput
 */
export type SchemaCatVtonInput = {
  /**
   * Garment Image Url
   *
   * Url to the garment image.
   */
  garment_image_url: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Human Image Url
   *
   * Url for the human image.
   */
  human_image_url: string
  /**
   * Cloth Type
   *
   *
   * Type of the Cloth to be tried on.
   *
   * Options:
   * upper: Upper body cloth
   * lower: Lower body cloth
   * overall: Full body cloth
   * inner: Inner cloth, like T-shirt inside a jacket
   * outer: Outer cloth, like a jacket over a T-shirt
   *
   */
  cloth_type: 'upper' | 'lower' | 'overall' | 'inner' | 'outer'
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same input given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * BGRemoveOutput
 */
export type SchemaBriaBackgroundRemoveOutput = {
  /**
   * Image
   *
   * The generated image
   */
  image: SchemaImage
}

/**
 * BGRemoveInput
 */
export type SchemaBriaBackgroundRemoveInput = {
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Image Url
   *
   * Input Image to erase from
   */
  image_url: string
}

/**
 * ProductShotOutput
 */
export type SchemaBriaProductShotOutput = {
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImage>
}

/**
 * ProductShotInput
 */
export type SchemaBriaProductShotInput = {
  /**
   * Ref Image Url
   *
   * The URL of the reference image to be used for generating the new scene or background for the product shot. Use "" to leave empty.Either ref_image_url or scene_description has to be provided but not both. If both ref_image_url and ref_image_file are provided, ref_image_url will be used. Accepted formats are jpeg, jpg, png, webp.
   */
  ref_image_url?: string
  /**
   * Manual Placement Selection
   *
   * If you've selected placement_type=manual_placement, you should use this parameter to specify which placements/positions you would like to use from the list. You can select more than one placement in one request.
   */
  manual_placement_selection?:
    | 'upper_left'
    | 'upper_right'
    | 'bottom_left'
    | 'bottom_right'
    | 'right_center'
    | 'left_center'
    | 'upper_center'
    | 'bottom_center'
    | 'center_vertical'
    | 'center_horizontal'
  /**
   * Num Results
   *
   * The number of lifestyle product shots you would like to generate. You will get num_results x 10 results when placement_type=automatic and according to the number of required placements x num_results if placement_type=manual_placement.
   */
  num_results?: number
  /**
   * Padding Values
   *
   * The desired padding in pixels around the product, when using placement_type=manual_padding. The order of the values is [left, right, top, bottom]. For optimal results, the total number of pixels, including padding, should be around 1,000,000. It is recommended to first use the product cutout API, get the cutout and understand the size of the result, and then define the required padding and use the cutout as an input for this API.
   */
  padding_values?: Array<number>
  /**
   * Shot Size
   *
   * The desired size of the final product shot. For optimal results, the total number of pixels should be around 1,000,000. This parameter is only relevant when placement_type=automatic or placement_type=manual_placement.
   */
  shot_size?: Array<number>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Placement Type
   *
   * This parameter allows you to control the positioning of the product in the image. Choosing 'original' will preserve the original position of the product in the image. Choosing 'automatic' will generate results with the 10 recommended positions for the product. Choosing 'manual_placement' will allow you to select predefined positions (using the parameter 'manual_placement_selection'). Selecting 'manual_padding' will allow you to control the position and size of the image by defining the desired padding in pixels around the product.
   */
  placement_type?:
    | 'original'
    | 'automatic'
    | 'manual_placement'
    | 'manual_padding'
  /**
   * Original Quality
   *
   * This flag is only relevant when placement_type=original. If true, the output image retains the original input image's size; otherwise, the image is scaled to 1 megapixel (1MP) while preserving its aspect ratio.
   */
  original_quality?: boolean
  /**
   * Fast
   *
   * Whether to use the fast model
   */
  fast?: boolean
  /**
   * Optimize Description
   *
   * Whether to optimize the scene description
   */
  optimize_description?: boolean
  /**
   * Scene Description
   *
   * Text description of the new scene or background for the provided product shot. Bria currently supports prompts in English only, excluding special characters.
   */
  scene_description?: string
  /**
   * Image Url
   *
   * The URL of the product shot to be placed in a lifestyle shot. If both image_url and image_file are provided, image_url will be used. Accepted formats are jpeg, jpg, png, webp. Maximum file size 12MB.
   */
  image_url: string
}

/**
 * EraserOutput
 */
export type SchemaBriaEraserOutput = {
  /**
   * Image
   *
   * The generated image
   */
  image: SchemaImage
}

/**
 * EraserInput
 */
export type SchemaBriaEraserInput = {
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Preserve Alpha
   *
   *
   * If set to true, attempts to preserve the alpha channel of the input image.
   *
   */
  preserve_alpha?: boolean
  /**
   * Mask Url
   *
   * The URL of the binary mask image that represents the area that will be cleaned.
   */
  mask_url: string
  /**
   * Mask Type
   *
   * You can use this parameter to specify the type of the input mask from the list. 'manual' opttion should be used in cases in which the mask had been generated by a user (e.g. with a brush tool), and 'automatic' mask type should be used when mask had been generated by an algorithm like 'SAM'.
   */
  mask_type?: 'manual' | 'automatic'
  /**
   * Image Url
   *
   * Input Image to erase from
   */
  image_url: string
}

/**
 * BGReplaceOutput
 */
export type SchemaBriaBackgroundReplaceOutput = {
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * Seed value used for generation.
   */
  seed: number
}

/**
 * BGReplaceInput
 */
export type SchemaBriaBackgroundReplaceInput = {
  /**
   * Prompt
   *
   * The prompt you would like to use to generate images.
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of Images to generate.
   */
  num_images?: number
  /**
   * Ref Image Url
   *
   * The URL of the reference image to be used for generating the new background. Use "" to leave empty. Either ref_image_url or bg_prompt has to be provided but not both. If both ref_image_url and ref_image_file are provided, ref_image_url will be used. Accepted formats are jpeg, jpg, png, webp.
   */
  ref_image_url?: string
  /**
   * Refine Prompt
   *
   * Whether to refine prompt
   */
  refine_prompt?: boolean
  /**
   * Image Url
   *
   * Input Image to erase from
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Fast
   *
   * Whether to use the fast model
   */
  fast?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * The negative prompt you would like to use to generate images.
   */
  negative_prompt?: string
}

/**
 * Output
 */
export type SchemaFluxLoraFillOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * FillInput
 */
export type SchemaFluxLoraFillInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt?: string
  /**
   * Resize To Original
   *
   * Resizes the image back to the original size. Use when you wish to preserve the exact image size as the originally provided image.
   */
  resize_to_original?: boolean
  /**
   * Paste Back
   *
   * Specifies whether to paste-back the original image onto to the non-inpainted areas of the output
   */
  paste_back?: boolean
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Images
   *
   * The number of images to generate. This is always set to 1 for streaming output.
   */
  num_images?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image Url
   *
   * URL of image to use for fill operation
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Fill Image
   *
   * Use an image fill input to fill in particular images into the masked area.
   */
  fill_image?: SchemaImageFillInput
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Mask Url
   *
   *
   * The mask to area to Inpaint in.
   *
   */
  mask_url: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * GenFillOutput
 */
export type SchemaBriaGenfillOutput = {
  /**
   * Images
   *
   * Generated Images
   */
  images: Array<SchemaImage>
}

/**
 * GenFillInput
 */
export type SchemaBriaGenfillInput = {
  /**
   * Prompt
   *
   * The prompt you would like to use to generate images.
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of Images to generate.
   */
  num_images?: number
  /**
   * Image Url
   *
   * Input Image to erase from
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Mask Url
   *
   * The URL of the binary mask image that represents the area that will be cleaned.
   */
  mask_url: string
  /**
   * Negative Prompt
   *
   * The negative prompt you would like to use to generate images.
   */
  negative_prompt?: string
}

/**
 * ImageExpansionOutput
 */
export type SchemaBriaExpandOutput = {
  /**
   * Image
   *
   * The generated image
   */
  image: SchemaImage
  /**
   * Seed
   *
   * Seed value used for generation.
   */
  seed: number
}

/**
 * ImageExpansionInput
 */
export type SchemaBriaExpandInput = {
  /**
   * Prompt
   *
   * Text on which you wish to base the image expansion. This parameter is optional. Bria currently supports prompts in English only, excluding special characters.
   */
  prompt?: string
  /**
   * Aspect Ratio
   *
   * The desired aspect ratio of the final image. Will be used over original_image_size and original_image_location if provided.
   */
  aspect_ratio?:
    | '1:1'
    | '2:3'
    | '3:2'
    | '3:4'
    | '4:3'
    | '4:5'
    | '5:4'
    | '9:16'
    | '16:9'
  /**
   * Original Image Location
   *
   * The desired location of the original image, inside the full canvas. Provide the location of the upper left corner of the original image. The location can also be outside the canvas (the original image will be cropped). Will be ignored if aspect_ratio is provided.
   */
  original_image_location?: Array<number>
  /**
   * Image Url
   *
   * The URL of the input image.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Original Image Size
   *
   * The desired size of the original image, inside the full canvas. Ensure that the ratio of input image foreground or main subject to the canvas area is greater than 15% to achieve optimal results. Will be ignored if aspect_ratio is provided.
   */
  original_image_size?: Array<number>
  /**
   * Canvas Size
   *
   * The desired size of the final image, after the expansion. should have an area of less than 5000x5000 pixels.
   */
  canvas_size: Array<number>
  /**
   * Seed
   *
   * You can choose whether you want your generated expension to be random or predictable. You can recreate the same result in the future by using the seed value of a result from the response. You can exclude this parameter if you are not interested in recreating your results. This parameter is optional.
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * The negative prompt you would like to use to generate images.
   */
  negative_prompt?: string
}

/**
 * DetectionOutput
 */
export type SchemaMoondreamNextDetectionOutput = {
  /**
   * Output Image
   *
   * Output image with detection visualization
   */
  image?: SchemaImage
  /**
   * Text Output
   *
   * Detection results as text
   */
  text_output: string
}

/**
 * DetectionInput
 */
export type SchemaMoondreamNextDetectionInput = {
  /**
   * Detection Prompt
   *
   * Text description of what to detect
   */
  detection_prompt: string
  /**
   * Use Ensemble
   *
   * Whether to use ensemble for gaze detection
   */
  use_ensemble?: boolean
  /**
   * Task Type
   *
   * Type of detection to perform
   */
  task_type: 'bbox_detection' | 'point_detection' | 'gaze_detection'
  /**
   * Show Visualization
   *
   * Whether to show visualization for detection
   */
  show_visualization?: boolean
  /**
   * Combine Points
   *
   * Whether to combine points into a single point for point detection. This has no effect for bbox detection or gaze detection.
   */
  combine_points?: boolean
  /**
   * Image URL
   *
   * Image URL to be processed
   */
  image_url: string
}

/**
 * Output
 */
export type SchemaFluxProV1FillFinetunedOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaRegistryImageFastSdxlModelsImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * FluxProFillFinetunedInput
 */
export type SchemaFluxProV1FillFinetunedInput = {
  /**
   * Prompt
   *
   * The prompt to fill the masked part of the image.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Fine-tune Strength
   *
   *
   * Controls finetune influence.
   * Increase this value if your target concept isn't showing up strongly enough.
   * The optimal setting depends on your finetune and prompt
   *
   */
  finetune_strength: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Fine-tune ID
   *
   * References your specific model
   */
  finetune_id: string
  /**
   * Image URL
   *
   * The image URL to generate an image from. Needs to match the dimensions of the mask.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Mask URL
   *
   * The mask URL to inpaint the image. Needs to match the dimensions of the input image.
   */
  mask_url: string
  /**
   * Enhance Prompt
   *
   * Whether to enhance the prompt for better results.
   */
  enhance_prompt?: boolean
}

/**
 * Output
 */
export type SchemaFluxLoraCannyOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * CannyInput
 */
export type SchemaFluxLoraCannyInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image Url
   *
   * URL of image to use for canny input
   */
  image_url: string
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * TryOnOutput
 */
export type SchemaKlingV15KolorsVirtualTryOnOutput = {
  /**
   * Image
   *
   * The output image.
   */
  image: SchemaImage
}

/**
 * TryOnRequest
 */
export type SchemaKlingV15KolorsVirtualTryOnInput = {
  /**
   * Garment Image Url
   *
   * Url to the garment image.
   */
  garment_image_url: string
  /**
   * Sync Mode
   *
   * If true, the function will return the image in the response.
   */
  sync_mode?: boolean
  /**
   * Human Image Url
   *
   * Url for the human image.
   */
  human_image_url: string
}

/**
 * ConformerOutput
 */
export type SchemaCodeformerOutput = {
  /**
   * Image
   *
   * The generated image file info.
   */
  image: SchemaImage
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * CodeformerInput
 */
export type SchemaCodeformerInput = {
  /**
   * Aligned
   *
   * Should faces etc should be aligned.
   */
  aligned?: boolean
  /**
   * Image Url
   *
   * URL of image to be used for relighting
   */
  image_url: string
  /**
   * Upscale Factor
   *
   * Upscaling factor
   */
  upscale_factor?: number
  /**
   * Fidelity
   *
   * Weight of the fidelity factor.
   */
  fidelity?: number
  /**
   * Face Upscale
   *
   * Should faces be upscaled
   */
  face_upscale?: boolean
  /**
   * Only Center Face
   *
   * Should only center face be restored
   */
  only_center_face?: boolean
  /**
   * Seed
   *
   * Random seed for reproducible generation.
   */
  seed?: number
}

/**
 * UpscaleOutput
 */
export type SchemaIdeogramUpscaleOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for the random number generator
   */
  seed: number
}

/**
 * UpscaleImageInput
 */
export type SchemaIdeogramUpscaleInput = {
  /**
   * Prompt
   *
   * The prompt to upscale the image with
   */
  prompt?: string | unknown
  /**
   * Detail
   *
   * The detail of the upscaled image
   */
  detail?: number
  /**
   * Resemblance
   *
   * The resemblance of the upscaled image to the original image
   */
  resemblance?: number
  /**
   * Expand Prompt
   *
   * Whether to expand the prompt with MagicPrompt functionality.
   */
  expand_prompt?: boolean
  /**
   * Image URL
   *
   * The image URL to upscale
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Seed
   *
   * Seed for the random number generator
   */
  seed?: number | unknown
}

/**
 * Output
 */
export type SchemaFluxControlLoraCannyImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * ImageToImageInput
 */
export type SchemaFluxControlLoraCannyImageToImageInput = {
  /**
   * Control Lora Strength
   *
   * The strength of the control lora.
   */
  control_lora_strength?: number
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image Url
   *
   * URL of image to use for inpainting. or img2img
   */
  image_url: string
  /**
   * Strength
   *
   * The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.
   */
  strength?: number
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Control Lora Image Url
   *
   *
   * The image to use for control lora. This is used to control the style of the generated image.
   *
   */
  control_lora_image_url?: string
}

/**
 * Ben2OutputImage
 */
export type SchemaBenV2ImageOutput = {
  /**
   * Image
   *
   * The output image after background removal.
   */
  image: SchemaImage
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * Ben2InputImage
 */
export type SchemaBenV2ImageInput = {
  /**
   * Seed
   *
   * Random seed for reproducible generation.
   */
  seed?: number
  /**
   * Image Url
   *
   * URL of image to be used for background removal
   */
  image_url: string
}

/**
 * Output
 */
export type SchemaFluxControlLoraDepthImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * ImageToImageInput
 */
export type SchemaFluxControlLoraDepthImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Control Lora Strength
   *
   * The strength of the control lora.
   */
  control_lora_strength?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image Url
   *
   * URL of image to use for inpainting. or img2img
   */
  image_url: string
  /**
   * Strength
   *
   * The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.
   */
  strength?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Control Lora Image Url
   *
   *
   * The image to use for control lora. This is used to control the style of the generated image.
   *
   */
  control_lora_image_url: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * FlowEditOutput
 */
export type SchemaFloweditOutput = {
  /**
   * Image
   *
   * The generated image file info.
   */
  image: SchemaImage
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * FlowEditInput
 */
export type SchemaFloweditInput = {
  /**
   * Source Guidance scale (CFG)
   *
   * Guidance scale for the source.
   */
  src_guidance_scale?: number
  /**
   * N Min
   *
   * Minimum step for improved style edits
   */
  n_min?: number
  /**
   * N Max
   *
   * Control the strength of the edit
   */
  n_max?: number
  /**
   * Image Url
   *
   * URL of image to be used for relighting
   */
  image_url: string
  /**
   * Source Prompt
   *
   * Prompt of the image to be used.
   */
  source_prompt: string
  /**
   * Target Guidance scale (CFG)
   *
   * Guidance scale for target.
   */
  tar_guidance_scale?: number
  /**
   * Target Prompt
   *
   * Prompt of the image to be made.
   */
  target_prompt: string
  /**
   * Seed
   *
   * Random seed for reproducible generation. If set none, a random seed will be used.
   */
  seed?: number
  /**
   * Steps
   *
   * Steps for which the model should run.
   */
  num_inference_steps?: number
  /**
   * N Avg
   *
   * Average step count
   */
  n_avg?: number
}

/**
 * ProcessedOutput
 */
export type SchemaPostProcessingOutput = {
  /**
   * Images
   *
   * The processed images
   */
  images: Array<SchemaImage>
}

/**
 * ImageProcessingInput
 */
export type SchemaPostProcessingInput = {
  /**
   * Blue Shift
   *
   * Blue channel shift amount
   */
  blue_shift?: number
  /**
   * Vertex Y
   *
   * Vertex Y position
   */
  vertex_y?: number
  /**
   * Green Direction
   *
   * Green channel shift direction
   */
  green_direction?: 'horizontal' | 'vertical'
  /**
   * Enable Glow
   *
   * Enable glow effect
   */
  enable_glow?: boolean
  /**
   * Dodge Burn Mode
   *
   * Dodge and burn mode
   */
  dodge_burn_mode?:
    | 'dodge'
    | 'burn'
    | 'dodge_and_burn'
    | 'burn_and_dodge'
    | 'color_dodge'
    | 'color_burn'
    | 'linear_dodge'
    | 'linear_burn'
  /**
   * Glow Intensity
   *
   * Glow intensity
   */
  glow_intensity?: number
  /**
   * Blur Sigma
   *
   * Sigma for Gaussian blur
   */
  blur_sigma?: number
  /**
   * Desaturate Method
   *
   * Desaturation method
   */
  desaturate_method?:
    | 'luminance (Rec.709)'
    | 'luminance (Rec.601)'
    | 'average'
    | 'lightness'
  /**
   * Enable Blur
   *
   * Enable blur effect
   */
  enable_blur?: boolean
  /**
   * Blur Radius
   *
   * Blur radius
   */
  blur_radius?: number
  /**
   * Grain Style
   *
   * Style of film grain to apply
   */
  grain_style?:
    | 'modern'
    | 'analog'
    | 'kodak'
    | 'fuji'
    | 'cinematic'
    | 'newspaper'
  /**
   * Cas Amount
   *
   * CAS sharpening amount
   */
  cas_amount?: number
  /**
   * Gamma
   *
   * Gamma adjustment
   */
  gamma?: number
  /**
   * Tint Mode
   *
   * Tint color mode
   */
  tint_mode?:
    | 'sepia'
    | 'red'
    | 'green'
    | 'blue'
    | 'cyan'
    | 'magenta'
    | 'yellow'
    | 'purple'
    | 'orange'
    | 'warm'
    | 'cool'
    | 'lime'
    | 'navy'
    | 'vintage'
    | 'rose'
    | 'teal'
    | 'maroon'
    | 'peach'
    | 'lavender'
    | 'olive'
  /**
   * Blur Type
   *
   * Type of blur to apply
   */
  blur_type?: 'gaussian' | 'kuwahara'
  /**
   * Enable Vignette
   *
   * Enable vignette effect
   */
  enable_vignette?: boolean
  /**
   * Dissolve Image Url
   *
   * URL of second image for dissolve
   */
  dissolve_image_url?: string
  /**
   * Red Shift
   *
   * Red channel shift amount
   */
  red_shift?: number
  /**
   * Enable Desaturate
   *
   * Enable desaturation effect
   */
  enable_desaturate?: boolean
  /**
   * Grain Intensity
   *
   * Film grain intensity (when enabled)
   */
  grain_intensity?: number
  /**
   * Dodge Burn Intensity
   *
   * Dodge and burn intensity
   */
  dodge_burn_intensity?: number
  /**
   * Smart Sharpen Strength
   *
   * Smart sharpen strength
   */
  smart_sharpen_strength?: number
  /**
   * Red Direction
   *
   * Red channel shift direction
   */
  red_direction?: 'horizontal' | 'vertical'
  /**
   * Image Url
   *
   * URL of image to process
   */
  image_url: string
  /**
   * Vertex X
   *
   * Vertex X position
   */
  vertex_x?: number
  /**
   * Tint Strength
   *
   * Tint strength
   */
  tint_strength?: number
  /**
   * Enable Dissolve
   *
   * Enable dissolve effect
   */
  enable_dissolve?: boolean
  /**
   * Enable Parabolize
   *
   * Enable parabolize effect
   */
  enable_parabolize?: boolean
  /**
   * Enable Grain
   *
   * Enable film grain effect
   */
  enable_grain?: boolean
  /**
   * Solarize Threshold
   *
   * Solarize threshold
   */
  solarize_threshold?: number
  /**
   * Enable Sharpen
   *
   * Enable sharpen effect
   */
  enable_sharpen?: boolean
  /**
   * Enable Dodge Burn
   *
   * Enable dodge and burn effect
   */
  enable_dodge_burn?: boolean
  /**
   * Glow Radius
   *
   * Glow blur radius
   */
  glow_radius?: number
  /**
   * Sharpen Alpha
   *
   * Sharpen strength (for basic mode)
   */
  sharpen_alpha?: number
  /**
   * Enable Color Correction
   *
   * Enable color correction
   */
  enable_color_correction?: boolean
  /**
   * Contrast
   *
   * Contrast adjustment
   */
  contrast?: number
  /**
   * Enable Solarize
   *
   * Enable solarize effect
   */
  enable_solarize?: boolean
  /**
   * Noise Radius
   *
   * Noise radius for smart sharpen
   */
  noise_radius?: number
  /**
   * Grain Scale
   *
   * Film grain scale (when enabled)
   */
  grain_scale?: number
  /**
   * Temperature
   *
   * Color temperature adjustment
   */
  temperature?: number
  /**
   * Brightness
   *
   * Brightness adjustment
   */
  brightness?: number
  /**
   * Blue Direction
   *
   * Blue channel shift direction
   */
  blue_direction?: 'horizontal' | 'vertical'
  /**
   * Dissolve Factor
   *
   * Dissolve blend factor
   */
  dissolve_factor?: number
  /**
   * Sharpen Mode
   *
   * Type of sharpening to apply
   */
  sharpen_mode?: 'basic' | 'smart' | 'cas'
  /**
   * Vignette Strength
   *
   * Vignette strength (when enabled)
   */
  vignette_strength?: number
  /**
   * Sharpen Radius
   *
   * Sharpen radius (for basic mode)
   */
  sharpen_radius?: number
  /**
   * Parabolize Coeff
   *
   * Parabolize coefficient
   */
  parabolize_coeff?: number
  /**
   * Saturation
   *
   * Saturation adjustment
   */
  saturation?: number
  /**
   * Enable Tint
   *
   * Enable color tint effect
   */
  enable_tint?: boolean
  /**
   * Green Shift
   *
   * Green channel shift amount
   */
  green_shift?: number
  /**
   * Preserve Edges
   *
   * Edge preservation factor
   */
  preserve_edges?: number
  /**
   * Desaturate Factor
   *
   * Desaturation factor
   */
  desaturate_factor?: number
  /**
   * Smart Sharpen Ratio
   *
   * Smart sharpen blend ratio
   */
  smart_sharpen_ratio?: number
  /**
   * Enable Chromatic
   *
   * Enable chromatic aberration
   */
  enable_chromatic?: boolean
}

/**
 * NafnetOutputDenoise
 */
export type SchemaNafnetDenoiseOutput = {
  /**
   * Image
   *
   * The generated image file info.
   */
  image: SchemaImage
}

/**
 * NafnetInputDenoise
 */
export type SchemaNafnetDenoiseInput = {
  /**
   * Seed
   *
   * seed to be used for generation
   */
  seed?: number
  /**
   * Image Url
   *
   * URL of image to be used for relighting
   */
  image_url: string
}

/**
 * NafnetOutput
 */
export type SchemaNafnetDeblurOutput = {
  /**
   * Image
   *
   * The generated image file info.
   */
  image: SchemaImage
}

/**
 * NafnetInput
 */
export type SchemaNafnetDeblurInput = {
  /**
   * Seed
   *
   * seed to be used for generation
   */
  seed?: number
  /**
   * Image Url
   *
   * URL of image to be used for relighting
   */
  image_url: string
}

/**
 * Output
 */
export type SchemaDrctSuperResolutionOutput = {
  /**
   * Image
   *
   * Upscaled image
   */
  image: SchemaImage
}

/**
 * Input
 */
export type SchemaDrctSuperResolutionInput = {
  /**
   * Upscaling Factor (Xs)
   *
   * Upscaling factor.
   */
  upscale_factor?: 4
  /**
   * Image URL
   *
   * URL of the image to upscale.
   */
  image_url: string
}

/**
 * SAM2AutomaticSegmentationOutput
 */
export type SchemaSam2AutoSegmentOutput = {
  /**
   * Combined Mask
   *
   * Combined segmentation mask.
   */
  combined_mask: SchemaImage
  /**
   * Individual Masks
   *
   * Individual segmentation masks.
   */
  individual_masks: Array<SchemaImage>
}

/**
 * SAM2AutomaticSegmentationInput
 */
export type SchemaSam2AutoSegmentInput = {
  /**
   * Points Per Side
   *
   * Number of points to sample along each side of the image.
   */
  points_per_side?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Min Mask Region Area
   *
   * Minimum area of a mask region.
   */
  min_mask_region_area?: number
  /**
   * Image Url
   *
   * URL of the image to be automatically segmented
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Pred Iou Thresh
   *
   * Threshold for predicted IOU score.
   */
  pred_iou_thresh?: number
  /**
   * Stability Score Thresh
   *
   * Threshold for stability score.
   */
  stability_score_thresh?: number
}

/**
 * DDColorOutput
 */
export type SchemaDdcolorOutput = {
  /**
   * Image
   *
   * The generated image file info.
   */
  image: SchemaImage
}

/**
 * DDColorInput
 */
export type SchemaDdcolorInput = {
  /**
   * Seed
   *
   * seed to be used for generation
   */
  seed?: number
  /**
   * Image Url
   *
   * URL of image to be used for relighting
   */
  image_url: string
}

/**
 * ImageOutput
 */
export type SchemaEvfSamOutput = {
  /**
   * Image
   *
   * The segmented output image
   */
  image: SchemaFile
}

/**
 * ImageInput
 */
export type SchemaEvfSamInput = {
  /**
   * Prompt
   *
   * The prompt to generate segmentation from.
   */
  prompt: string
  /**
   * Use Grounding Dino
   *
   * Use GroundingDINO instead of SAM for segmentation
   */
  use_grounding_dino?: boolean
  /**
   * Semantic Type
   *
   * Enable semantic level segmentation for body parts, background or multi objects
   */
  semantic_type?: boolean
  /**
   * Fill Holes
   *
   * Fill holes in the mask using morphological operations
   */
  fill_holes?: boolean
  /**
   * Expand Mask
   *
   * Expand/dilate the mask by specified pixels
   */
  expand_mask?: number
  /**
   * Mask Only
   *
   * Output only the binary mask instead of masked image
   */
  mask_only?: boolean
  /**
   * Revert Mask
   *
   * Invert the mask (background becomes foreground and vice versa)
   */
  revert_mask?: boolean
  /**
   * Blur Mask
   *
   * Apply Gaussian blur to the mask. Value determines kernel size (must be odd number)
   */
  blur_mask?: number
  /**
   * Negative Prompt
   *
   * Areas to exclude from segmentation (will be subtracted from prompt results)
   */
  negative_prompt?: string
  /**
   * Image Url
   *
   * URL of the input image
   */
  image_url: string
}

/**
 * Output
 */
export type SchemaIdeogramV2aTurboRemixOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for the random number generator
   */
  seed: number
}

/**
 * RemixImageInput
 */
export type SchemaIdeogramV2aTurboRemixInput = {
  /**
   * Prompt
   *
   * The prompt to remix the image with
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image
   */
  aspect_ratio?:
    | '10:16'
    | '16:10'
    | '9:16'
    | '16:9'
    | '4:3'
    | '3:4'
    | '1:1'
    | '1:3'
    | '3:1'
    | '3:2'
    | '2:3'
  /**
   * Style
   *
   * The style of the generated image
   */
  style?: 'auto' | 'general' | 'realistic' | 'design' | 'render_3D' | 'anime'
  /**
   * Expand Prompt
   *
   * Whether to expand the prompt with MagicPrompt functionality.
   */
  expand_prompt?: boolean
  /**
   * Image URL
   *
   * The image URL to remix
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * Strength of the input image in the remix
   */
  strength?: number
  /**
   * Seed
   *
   * Seed for the random number generator
   */
  seed?: number | unknown
}

/**
 * Output
 */
export type SchemaIdeogramV2aRemixOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for the random number generator
   */
  seed: number
}

/**
 * RemixImageInput
 */
export type SchemaIdeogramV2aRemixInput = {
  /**
   * Prompt
   *
   * The prompt to remix the image with
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image
   */
  aspect_ratio?:
    | '10:16'
    | '16:10'
    | '9:16'
    | '16:9'
    | '4:3'
    | '3:4'
    | '1:1'
    | '1:3'
    | '3:1'
    | '3:2'
    | '2:3'
  /**
   * Style
   *
   * The style of the generated image
   */
  style?: 'auto' | 'general' | 'realistic' | 'design' | 'render_3D' | 'anime'
  /**
   * Expand Prompt
   *
   * Whether to expand the prompt with MagicPrompt functionality.
   */
  expand_prompt?: boolean
  /**
   * Image URL
   *
   * The image URL to remix
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * Strength of the input image in the remix
   */
  strength?: number
  /**
   * Seed
   *
   * Seed for the random number generator
   */
  seed?: number | unknown
}

/**
 * SwinSrOutput
 */
export type SchemaSwin2SrOutput = {
  /**
   * Image
   *
   * The generated image file info.
   */
  image: SchemaImage
}

/**
 * SwinSrInput
 */
export type SchemaSwin2SrInput = {
  /**
   * Task
   *
   * Task to perform
   */
  task?: 'classical_sr' | 'compressed_sr' | 'real_sr'
  /**
   * Seed
   *
   * seed to be used for generation
   */
  seed?: number
  /**
   * Image Url
   *
   * URL of image to be used for image enhancement
   */
  image_url: string
}

/**
 * DocResOutput
 */
export type SchemaDocresOutput = {
  /**
   * Image
   *
   * The generated image file info.
   */
  image: SchemaImage
}

/**
 * DocResInput
 */
export type SchemaDocresInput = {
  /**
   * Task
   *
   * Task to perform
   */
  task: 'deshadowing' | 'appearance' | 'deblurring' | 'binarization'
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Image Url
   *
   * URL of image to be used for relighting
   */
  image_url: string
}

/**
 * DocResOutput
 */
export type SchemaDocresDewarpOutput = {
  /**
   * Image
   *
   * The generated image file info.
   */
  image: SchemaImage
}

/**
 * DocResInputDewarp
 */
export type SchemaDocresDewarpInput = {
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Image Url
   *
   * URL of image to be used for relighting
   */
  image_url: string
}

/**
 * Output
 */
export type SchemaJuggernautFluxBaseImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * DevImageToImageInput
 */
export type SchemaJuggernautFluxBaseImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to generate an image from.
   */
  image_url: string
  /**
   * Strength
   *
   * The strength of the initial image. Higher strength values are better for this model.
   */
  strength?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaJuggernautFluxProImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * DevImageToImageInput
 */
export type SchemaJuggernautFluxProImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to generate an image from.
   */
  image_url: string
  /**
   * Strength
   *
   * The strength of the initial image. Higher strength values are better for this model.
   */
  strength?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * WatermarkOutput
 */
export type SchemaInvisibleWatermarkOutput = {
  /**
   * Image
   *
   * The watermarked image file info (when encoding)
   */
  image?: SchemaImage
  /**
   * Extracted Watermark
   *
   * The extracted watermark text (when decoding)
   */
  extracted_watermark?: string
  /**
   * Length
   *
   * Length of the watermark bits used (helpful for future decoding)
   */
  length?: number
}

/**
 * WatermarkInput
 */
export type SchemaInvisibleWatermarkInput = {
  /**
   * Decode
   *
   * Whether to decode a watermark from the image instead of encoding
   */
  decode?: boolean
  /**
   * Watermark
   *
   * Text to use as watermark (for encoding only)
   */
  watermark?: string
  /**
   * Length
   *
   * Length of watermark bits to decode (required when decode=True)
   */
  length?: number
  /**
   * Image Url
   *
   * URL of image to be watermarked or decoded
   */
  image_url: string
}

/**
 * GeminiImageOutput
 */
export type SchemaGeminiFlashEditOutput = {
  /**
   * Description
   *
   * Text description or response from Gemini
   */
  description: string
  image: SchemaImage
}

/**
 * GeminiImageRequest
 */
export type SchemaGeminiFlashEditInput = {
  /**
   * Prompt
   *
   * The prompt for image generation or editing
   */
  prompt: string
  /**
   * Image Url
   *
   * Optional URL of an input image for editing. If not provided, generates a new image.
   */
  image_url: string
}

/**
 * GeminiImageOutput
 */
export type SchemaGeminiFlashEditMultiOutput = {
  /**
   * Description
   *
   * Text description or response from Gemini
   */
  description: string
  image: SchemaImage
}

/**
 * GeminiMultiImageRequest
 */
export type SchemaGeminiFlashEditMultiInput = {
  /**
   * Prompt
   *
   * The prompt for image generation or editing
   */
  prompt: string
  /**
   * Input Image Urls
   *
   * List of URLs of input images for editing
   */
  input_image_urls: Array<string>
}

/**
 * MixDehazeNetOutput
 */
export type SchemaMixDehazeNetOutput = {
  /**
   * Image
   *
   * The generated image file info.
   */
  image: SchemaImage
}

/**
 * MixDehazeNetInput
 */
export type SchemaMixDehazeNetInput = {
  /**
   * Model
   *
   * Model to be used for dehazing
   */
  model?: 'indoor' | 'outdoor'
  /**
   * Seed
   *
   * seed to be used for generation
   */
  seed?: number
  /**
   * Image Url
   *
   * URL of image to be used for image enhancement
   */
  image_url: string
}

/**
 * TheraOutput
 */
export type SchemaTheraOutput = {
  /**
   * Image
   *
   * The generated image file info.
   */
  image: SchemaImage
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TheraInput
 */
export type SchemaTheraInput = {
  /**
   * Upscale Factor
   *
   * The upscaling factor for the image.
   */
  upscale_factor?: number
  /**
   * Seed
   *
   * Random seed for reproducible generation.
   */
  seed?: number
  /**
   * Backbone
   *
   * Backbone to use for upscaling
   */
  backbone: 'edsr' | 'rdn'
  /**
   * Image Url
   *
   * URL of image to be used for upscaling
   */
  image_url: string
}

/**
 * Output
 */
export type SchemaGhiblifyOutput = {
  /**
   * The URL of the generated image.
   */
  image: SchemaImage
}

/**
 * Input
 */
export type SchemaGhiblifyInput = {
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * The seed to use for the upscale. If not provided, a random seed will be used.
   */
  seed?: number | unknown
  /**
   * Image Url
   *
   * The URL of the image to upscale.
   */
  image_url: string
}

/**
 * StarVectorOutput
 */
export type SchemaStarVectorOutput = {
  image: SchemaFile
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * StarVectorInput
 */
export type SchemaStarVectorInput = {
  /**
   * Seed
   *
   * seed to be used for generation
   */
  seed?: number
  /**
   * Image Url
   *
   * URL of image to be used for relighting
   */
  image_url: string
}

/**
 * EraseOutput
 */
export type SchemaFinegrainEraserOutput = {
  /**
   * Image
   *
   * The edited image with content erased
   */
  image: SchemaFile
  /**
   * Used Seed
   *
   * Seed used for generation
   */
  used_seed: number
}

/**
 * PromptEraseRequest
 */
export type SchemaFinegrainEraserInput = {
  /**
   * Prompt
   *
   * Text description of what to erase
   */
  prompt: string
  /**
   * Mode
   *
   * Erase quality mode
   */
  mode?: 'express' | 'standard' | 'premium'
  /**
   * Seed
   *
   * Random seed for reproducible generation
   */
  seed?: number
  /**
   * Image Url
   *
   * URL of the image to edit
   */
  image_url: string
}

/**
 * BoxPromptBase
 */
export type SchemaBoxPromptBase = {
  /**
   * Y Min
   *
   * Y Min Coordinate of the box
   */
  y_min?: number
  /**
   * X Max
   *
   * X Max Coordinate of the prompt
   */
  x_max?: number
  /**
   * X Min
   *
   * X Min Coordinate of the box
   */
  x_min?: number
  /**
   * Y Max
   *
   * Y Max Coordinate of the prompt
   */
  y_max?: number
}

/**
 * EraseOutput
 */
export type SchemaFinegrainEraserBboxOutput = {
  /**
   * Image
   *
   * The edited image with content erased
   */
  image: SchemaFile
  /**
   * Used Seed
   *
   * Seed used for generation
   */
  used_seed: number
}

/**
 * BBoxEraseRequest
 */
export type SchemaFinegrainEraserBboxInput = {
  /**
   * Mode
   *
   * Erase quality mode
   */
  mode?: 'express' | 'standard' | 'premium'
  /**
   * Seed
   *
   * Random seed for reproducible generation
   */
  seed?: number
  /**
   * Box Prompts
   *
   * List of bounding box coordinates to erase (only one box prompt is supported)
   */
  box_prompts: Array<SchemaBoxPromptBase>
  /**
   * Image Url
   *
   * URL of the image to edit
   */
  image_url: string
}

/**
 * EraseOutput
 */
export type SchemaFinegrainEraserMaskOutput = {
  /**
   * Image
   *
   * The edited image with content erased
   */
  image: SchemaFile
  /**
   * Used Seed
   *
   * Seed used for generation
   */
  used_seed: number
}

/**
 * MaskEraseRequest
 */
export type SchemaFinegrainEraserMaskInput = {
  /**
   * Mode
   *
   * Erase quality mode
   */
  mode?: 'express' | 'standard' | 'premium'
  /**
   * Seed
   *
   * Random seed for reproducible generation
   */
  seed?: number
  /**
   * Mask Url
   *
   * URL of the mask image. Should be a binary mask where white (255) indicates areas to erase
   */
  mask_url: string
  /**
   * Image Url
   *
   * URL of the image to edit
   */
  image_url: string
}

/**
 * Output
 */
export type SchemaCartoonifyOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * CartoonifyInput
 */
export type SchemaCartoonifyInput = {
  /**
   * Use Cfg Zero
   *
   * Whether to use CFG zero
   */
  use_cfg_zero?: boolean
  /**
   * Image Url
   *
   * URL of the image to apply Pixar style to
   */
  image_url: string
  /**
   * Guidance Scale
   *
   * Guidance scale for the generation
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps
   */
  num_inference_steps?: number
  /**
   * Scale
   *
   * Scale factor for the Pixar effect
   */
  scale?: number
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * The seed for image generation. Same seed with same parameters will generate same image.
   */
  seed?: number
}

/**
 * ImageOutput
 */
export type SchemaInstantCharacterOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaInstantCharacterInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Scale
   *
   * The scale of the subject image. Higher values will make the subject image more prominent in the generated image.
   */
  scale?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The image URL to generate an image from. Needs to match the dimensions of the mask.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaPlushifyOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * PlushifyInput
 */
export type SchemaPlushifyInput = {
  /**
   * Prompt
   *
   * Prompt for the generation. Default is empty which is usually best, but sometimes it can help to add a description of the subject.
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Use Cfg Zero
   *
   * Whether to use CFG zero
   */
  use_cfg_zero?: boolean
  /**
   * Image Url
   *
   * URL of the image to apply cartoon style to
   */
  image_url: string
  /**
   * Scale
   *
   * Scale factor for the Cartoon effect
   */
  scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps
   */
  num_inference_steps?: number
  /**
   * Guidance Scale
   *
   * Guidance scale for the generation
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * The seed for image generation. Same seed with same parameters will generate same image.
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaFashnTryonV15Output = {
  /**
   * Images
   */
  images: Array<SchemaFile>
}

/**
 * Input
 */
export type SchemaFashnTryonV15Input = {
  /**
   * Model Image
   *
   * URL or base64 of the model image
   */
  model_image: string
  /**
   * Moderation Level
   *
   * Content moderation level for garment images. 'none' disables moderation, 'permissive' blocks only explicit content, 'conservative' also blocks underwear and swimwear.
   */
  moderation_level?: 'none' | 'permissive' | 'conservative'
  /**
   * Garment Photo Type
   *
   * Specifies the type of garment photo to optimize internal parameters for better performance. 'model' is for photos of garments on a model, 'flat-lay' is for flat-lay or ghost mannequin images, and 'auto' attempts to automatically detect the photo type.
   */
  garment_photo_type?: 'auto' | 'model' | 'flat-lay'
  /**
   * Garment Image
   *
   * URL or base64 of the garment image
   */
  garment_image: string
  /**
   * Category
   *
   * Category of the garment to try-on. 'auto' will attempt to automatically detect the category of the garment.
   */
  category?: 'tops' | 'bottoms' | 'one-pieces' | 'auto'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Segmentation Free
   *
   * Disables human parsing on the model image.
   */
  segmentation_free?: boolean
  /**
   * Num Samples
   *
   * Number of images to generate in a single run. Image generation has a random element in it, so trying multiple images at once increases the chances of getting a good result.
   */
  num_samples?: number
  /**
   * Mode
   *
   * Specifies the mode of operation. 'performance' mode is faster but may sacrifice quality, 'balanced' mode is a balance between speed and quality, and 'quality' mode is slower but produces higher quality results.
   */
  mode?: 'performance' | 'balanced' | 'quality'
  /**
   * Seed
   *
   * Sets random operations to a fixed state. Use the same seed to reproduce results with the same inputs, or different seed to force different results.
   */
  seed?: number
  /**
   * Output Format
   *
   * Output format of the generated images. 'png' is highest quality, while 'jpeg' is faster
   */
  output_format?: 'png' | 'jpeg'
}

/**
 * Output
 */
export type SchemaJuggernautFluxLoraInpaintingOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * InpaintInput
 */
export type SchemaJuggernautFluxLoraInpaintingInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image Url
   *
   * URL of image to use for inpainting. or img2img
   */
  image_url: string
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.
   */
  strength?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Mask Url
   *
   *
   * The mask to area to Inpaint in.
   *
   */
  mask_url: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * EditImageResponse
 */
export type SchemaGptImage1EditImageOutput = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImageFile>
}

/**
 * EditImageRequest
 */
export type SchemaGptImage1EditImageInput = {
  /**
   * Prompt
   *
   * The prompt for image generation
   */
  prompt: string
  /**
   * Number of Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * Aspect ratio for the generated image
   */
  image_size?: 'auto' | '1024x1024' | '1536x1024' | '1024x1536'
  /**
   * Background
   *
   * Background for the generated image
   */
  background?: 'auto' | 'transparent' | 'opaque'
  /**
   * Quality
   *
   * Quality for the generated image
   */
  quality?: 'auto' | 'low' | 'medium' | 'high'
  /**
   * Output Format
   *
   * Output format for the images
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Input Fidelity
   *
   * Input fidelity for the generated image
   */
  input_fidelity?: 'low' | 'high'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Image URLs
   *
   * The URLs of the images to use as a reference for the generation.
   */
  image_urls: Array<string>
}

/**
 * UNOOutput
 */
export type SchemaUnoOutput = {
  /**
   * Prompt
   *
   * The prompt used to generate the image.
   */
  prompt: string
  /**
   * Images
   *
   * The URLs of the generated images.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * UNOInput
 */
export type SchemaUnoInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   *
   * The size of the generated image. You can choose between some presets or custom height and width
   * that **must be multiples of 8**.
   *
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Input Image Urls
   *
   * URL of images to use while generating the image.
   */
  input_image_urls: Array<string>
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * Random seed for reproducible generation. If set none, a random seed will be used.
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Image2SVGOutput
 */
export type SchemaImage2SvgOutput = {
  /**
   * Images
   *
   * The converted SVG file
   */
  images: Array<SchemaFile>
}

/**
 * Image2SVGInput
 */
export type SchemaImage2SvgInput = {
  /**
   * Splice Threshold
   *
   * Splice threshold for joining paths
   */
  splice_threshold?: number
  /**
   * Hierarchical
   *
   * Hierarchical mode: stacked or cutout
   */
  hierarchical?: 'stacked' | 'cutout'
  /**
   * Color Precision
   *
   * Color quantization level
   */
  color_precision?: number
  /**
   * Colormode
   *
   * Choose between color or binary (black and white) output
   */
  colormode?: 'color' | 'binary'
  /**
   * Max Iterations
   *
   * Maximum number of iterations for optimization
   */
  max_iterations?: number
  /**
   * Length Threshold
   *
   * Length threshold for curves/lines
   */
  length_threshold?: number
  /**
   * Image Url
   *
   * The image to convert to SVG
   */
  image_url: string
  /**
   * Mode
   *
   * Mode: spline (curved) or polygon (straight lines)
   */
  mode?: 'spline' | 'polygon'
  /**
   * Corner Threshold
   *
   * Corner detection threshold in degrees
   */
  corner_threshold?: number
  /**
   * Path Precision
   *
   * Decimal precision for path coordinates
   */
  path_precision?: number
  /**
   * Filter Speckle
   *
   * Filter out small speckles and noise
   */
  filter_speckle?: number
  /**
   * Layer Difference
   *
   * Layer difference threshold for hierarchical mode
   */
  layer_difference?: number
}

/**
 * ImageOutput
 */
export type SchemaStep1xEditOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaStep1xEditInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The image URL to generate an image from. Needs to match the dimensions of the mask.
   */
  image_url: string
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * EditOutputV3
 */
export type SchemaIdeogramV3EditOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for the random number generator
   */
  seed: number
}

/**
 * EditImageInputV3
 */
export type SchemaIdeogramV3EditInput = {
  /**
   * Prompt
   *
   * The prompt to fill the masked part of the image.
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of images to generate.
   */
  num_images?: number
  /**
   * Style Preset
   *
   * Style preset for generation. The chosen style preset will guide the generation.
   */
  style_preset?:
    | '80S_ILLUSTRATION'
    | '90S_NOSTALGIA'
    | 'ABSTRACT_ORGANIC'
    | 'ANALOG_NOSTALGIA'
    | 'ART_BRUT'
    | 'ART_DECO'
    | 'ART_POSTER'
    | 'AURA'
    | 'AVANT_GARDE'
    | 'BAUHAUS'
    | 'BLUEPRINT'
    | 'BLURRY_MOTION'
    | 'BRIGHT_ART'
    | 'C4D_CARTOON'
    | 'CHILDRENS_BOOK'
    | 'COLLAGE'
    | 'COLORING_BOOK_I'
    | 'COLORING_BOOK_II'
    | 'CUBISM'
    | 'DARK_AURA'
    | 'DOODLE'
    | 'DOUBLE_EXPOSURE'
    | 'DRAMATIC_CINEMA'
    | 'EDITORIAL'
    | 'EMOTIONAL_MINIMAL'
    | 'ETHEREAL_PARTY'
    | 'EXPIRED_FILM'
    | 'FLAT_ART'
    | 'FLAT_VECTOR'
    | 'FOREST_REVERIE'
    | 'GEO_MINIMALIST'
    | 'GLASS_PRISM'
    | 'GOLDEN_HOUR'
    | 'GRAFFITI_I'
    | 'GRAFFITI_II'
    | 'HALFTONE_PRINT'
    | 'HIGH_CONTRAST'
    | 'HIPPIE_ERA'
    | 'ICONIC'
    | 'JAPANDI_FUSION'
    | 'JAZZY'
    | 'LONG_EXPOSURE'
    | 'MAGAZINE_EDITORIAL'
    | 'MINIMAL_ILLUSTRATION'
    | 'MIXED_MEDIA'
    | 'MONOCHROME'
    | 'NIGHTLIFE'
    | 'OIL_PAINTING'
    | 'OLD_CARTOONS'
    | 'PAINT_GESTURE'
    | 'POP_ART'
    | 'RETRO_ETCHING'
    | 'RIVIERA_POP'
    | 'SPOTLIGHT_80S'
    | 'STYLIZED_RED'
    | 'SURREAL_COLLAGE'
    | 'TRAVEL_POSTER'
    | 'VINTAGE_GEO'
    | 'VINTAGE_POSTER'
    | 'WATERCOLOR'
    | 'WEIRD'
    | 'WOODBLOCK_PRINT'
    | unknown
  /**
   * Expand Prompt
   *
   * Determine if MagicPrompt should be used in generating the request or not.
   */
  expand_prompt?: boolean
  /**
   * Rendering Speed
   *
   * The rendering speed to use.
   */
  rendering_speed?: 'TURBO' | 'BALANCED' | 'QUALITY'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * A color palette for generation, must EITHER be specified via one of the presets (name) or explicitly via hexadecimal representations of the color with optional weights (members)
   */
  color_palette?: SchemaColorPalette | unknown
  /**
   * Style Codes
   *
   * A list of 8 character hexadecimal codes representing the style of the image. Cannot be used in conjunction with style_reference_images or style
   */
  style_codes?: Array<string> | unknown
  /**
   * Image URL
   *
   * The image URL to generate an image from. MUST have the exact same dimensions (width and height) as the mask image.
   */
  image_url: string
  /**
   * Seed
   *
   * Seed for the random number generator
   */
  seed?: number | unknown
  /**
   * Image Urls
   *
   * A set of images to use as style references (maximum total size 10MB across all style references). The images should be in JPEG, PNG or WebP format
   */
  image_urls?: Array<string> | unknown
  /**
   * Mask URL
   *
   * The mask URL to inpaint the image. MUST have the exact same dimensions (width and height) as the input image.
   */
  mask_url: string
}

/**
 * RGBColor
 */
export type SchemaRgbColor = {
  /**
   * R
   *
   * Red color value
   */
  r?: number
  /**
   * B
   *
   * Blue color value
   */
  b?: number
  /**
   * G
   *
   * Green color value
   */
  g?: number
}

/**
 * ColorPaletteMember
 */
export type SchemaColorPaletteMember = {
  /**
   * Color Weight
   *
   * The weight of the color in the color palette
   */
  color_weight?: number | unknown
  rgb: SchemaRgbColor
}

/**
 * ColorPalette
 */
export type SchemaColorPalette = {
  /**
   * Members
   *
   * A list of color palette members that define the color palette
   */
  members?: Array<SchemaColorPaletteMember> | unknown
  /**
   * Name
   *
   * A color palette preset value
   */
  name?:
    | 'EMBER'
    | 'FRESH'
    | 'JUNGLE'
    | 'MAGIC'
    | 'MELON'
    | 'MOSAIC'
    | 'PASTEL'
    | 'ULTRAMARINE'
    | unknown
}

/**
 * RemixOutputV3
 */
export type SchemaIdeogramV3RemixOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for the random number generator
   */
  seed: number
}

/**
 * RemixImageInputV3
 */
export type SchemaIdeogramV3RemixInput = {
  /**
   * Prompt
   *
   * The prompt to remix the image with
   */
  prompt: string
  /**
   * Image Size
   *
   * The resolution of the generated image
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Style
   *
   * The style type to generate with. Cannot be used with style_codes.
   */
  style?: 'AUTO' | 'GENERAL' | 'REALISTIC' | 'DESIGN' | unknown
  /**
   * Expand Prompt
   *
   * Determine if MagicPrompt should be used in generating the request or not.
   */
  expand_prompt?: boolean
  /**
   * Rendering Speed
   *
   * The rendering speed to use.
   */
  rendering_speed?: 'TURBO' | 'BALANCED' | 'QUALITY'
  /**
   * Image Urls
   *
   * A set of images to use as style references (maximum total size 10MB across all style references). The images should be in JPEG, PNG or WebP format
   */
  image_urls?: Array<string> | unknown
  /**
   * Negative Prompt
   *
   * Description of what to exclude from an image. Descriptions in the prompt take precedence to descriptions in the negative prompt.
   */
  negative_prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate.
   */
  num_images?: number
  /**
   * Image URL
   *
   * The image URL to remix
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * A color palette for generation, must EITHER be specified via one of the presets (name) or explicitly via hexadecimal representations of the color with optional weights (members)
   */
  color_palette?: SchemaColorPalette | unknown
  /**
   * Strength
   *
   * Strength of the input image in the remix
   */
  strength?: number
  /**
   * Style Codes
   *
   * A list of 8 character hexadecimal codes representing the style of the image. Cannot be used in conjunction with style_reference_images or style
   */
  style_codes?: Array<string> | unknown
  /**
   * Seed
   *
   * Seed for the random number generator
   */
  seed?: number | unknown
}

/**
 * ReplaceBackgroundOutputV3
 */
export type SchemaIdeogramV3ReplaceBackgroundOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for the random number generator
   */
  seed: number
}

/**
 * ReplaceBackgroundInputV3
 */
export type SchemaIdeogramV3ReplaceBackgroundInput = {
  /**
   * Prompt
   *
   * Cyber punk city with neon lights and skyscrappers
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of images to generate.
   */
  num_images?: number
  /**
   * Style
   *
   * The style type to generate with. Cannot be used with style_codes.
   */
  style?: 'AUTO' | 'GENERAL' | 'REALISTIC' | 'DESIGN' | unknown
  /**
   * Style Preset
   *
   * Style preset for generation. The chosen style preset will guide the generation.
   */
  style_preset?:
    | '80S_ILLUSTRATION'
    | '90S_NOSTALGIA'
    | 'ABSTRACT_ORGANIC'
    | 'ANALOG_NOSTALGIA'
    | 'ART_BRUT'
    | 'ART_DECO'
    | 'ART_POSTER'
    | 'AURA'
    | 'AVANT_GARDE'
    | 'BAUHAUS'
    | 'BLUEPRINT'
    | 'BLURRY_MOTION'
    | 'BRIGHT_ART'
    | 'C4D_CARTOON'
    | 'CHILDRENS_BOOK'
    | 'COLLAGE'
    | 'COLORING_BOOK_I'
    | 'COLORING_BOOK_II'
    | 'CUBISM'
    | 'DARK_AURA'
    | 'DOODLE'
    | 'DOUBLE_EXPOSURE'
    | 'DRAMATIC_CINEMA'
    | 'EDITORIAL'
    | 'EMOTIONAL_MINIMAL'
    | 'ETHEREAL_PARTY'
    | 'EXPIRED_FILM'
    | 'FLAT_ART'
    | 'FLAT_VECTOR'
    | 'FOREST_REVERIE'
    | 'GEO_MINIMALIST'
    | 'GLASS_PRISM'
    | 'GOLDEN_HOUR'
    | 'GRAFFITI_I'
    | 'GRAFFITI_II'
    | 'HALFTONE_PRINT'
    | 'HIGH_CONTRAST'
    | 'HIPPIE_ERA'
    | 'ICONIC'
    | 'JAPANDI_FUSION'
    | 'JAZZY'
    | 'LONG_EXPOSURE'
    | 'MAGAZINE_EDITORIAL'
    | 'MINIMAL_ILLUSTRATION'
    | 'MIXED_MEDIA'
    | 'MONOCHROME'
    | 'NIGHTLIFE'
    | 'OIL_PAINTING'
    | 'OLD_CARTOONS'
    | 'PAINT_GESTURE'
    | 'POP_ART'
    | 'RETRO_ETCHING'
    | 'RIVIERA_POP'
    | 'SPOTLIGHT_80S'
    | 'STYLIZED_RED'
    | 'SURREAL_COLLAGE'
    | 'TRAVEL_POSTER'
    | 'VINTAGE_GEO'
    | 'VINTAGE_POSTER'
    | 'WATERCOLOR'
    | 'WEIRD'
    | 'WOODBLOCK_PRINT'
    | unknown
  /**
   * Expand Prompt
   *
   * Determine if MagicPrompt should be used in generating the request or not.
   */
  expand_prompt?: boolean
  /**
   * Rendering Speed
   *
   * The rendering speed to use.
   */
  rendering_speed?: 'TURBO' | 'BALANCED' | 'QUALITY'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * A color palette for generation, must EITHER be specified via one of the presets (name) or explicitly via hexadecimal representations of the color with optional weights (members)
   */
  color_palette?: SchemaColorPalette | unknown
  /**
   * Style Codes
   *
   * A list of 8 character hexadecimal codes representing the style of the image. Cannot be used in conjunction with style_reference_images or style
   */
  style_codes?: Array<string> | unknown
  /**
   * Image URL
   *
   * The image URL whose background needs to be replaced
   */
  image_url: string
  /**
   * Seed
   *
   * Seed for the random number generator
   */
  seed?: number | unknown
  /**
   * Image Urls
   *
   * A set of images to use as style references (maximum total size 10MB across all style references). The images should be in JPEG, PNG or WebP format
   */
  image_urls?: Array<string> | unknown
}

/**
 * ReframeOutputV3
 */
export type SchemaIdeogramV3ReframeOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for the random number generator
   */
  seed: number
}

/**
 * ReframeImageInputV3
 */
export type SchemaIdeogramV3ReframeInput = {
  /**
   * Num Images
   *
   * Number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The resolution for the reframed output image
   */
  image_size:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Style
   *
   * The style type to generate with. Cannot be used with style_codes.
   */
  style?: 'AUTO' | 'GENERAL' | 'REALISTIC' | 'DESIGN' | unknown
  /**
   * Style Preset
   *
   * Style preset for generation. The chosen style preset will guide the generation.
   */
  style_preset?:
    | '80S_ILLUSTRATION'
    | '90S_NOSTALGIA'
    | 'ABSTRACT_ORGANIC'
    | 'ANALOG_NOSTALGIA'
    | 'ART_BRUT'
    | 'ART_DECO'
    | 'ART_POSTER'
    | 'AURA'
    | 'AVANT_GARDE'
    | 'BAUHAUS'
    | 'BLUEPRINT'
    | 'BLURRY_MOTION'
    | 'BRIGHT_ART'
    | 'C4D_CARTOON'
    | 'CHILDRENS_BOOK'
    | 'COLLAGE'
    | 'COLORING_BOOK_I'
    | 'COLORING_BOOK_II'
    | 'CUBISM'
    | 'DARK_AURA'
    | 'DOODLE'
    | 'DOUBLE_EXPOSURE'
    | 'DRAMATIC_CINEMA'
    | 'EDITORIAL'
    | 'EMOTIONAL_MINIMAL'
    | 'ETHEREAL_PARTY'
    | 'EXPIRED_FILM'
    | 'FLAT_ART'
    | 'FLAT_VECTOR'
    | 'FOREST_REVERIE'
    | 'GEO_MINIMALIST'
    | 'GLASS_PRISM'
    | 'GOLDEN_HOUR'
    | 'GRAFFITI_I'
    | 'GRAFFITI_II'
    | 'HALFTONE_PRINT'
    | 'HIGH_CONTRAST'
    | 'HIPPIE_ERA'
    | 'ICONIC'
    | 'JAPANDI_FUSION'
    | 'JAZZY'
    | 'LONG_EXPOSURE'
    | 'MAGAZINE_EDITORIAL'
    | 'MINIMAL_ILLUSTRATION'
    | 'MIXED_MEDIA'
    | 'MONOCHROME'
    | 'NIGHTLIFE'
    | 'OIL_PAINTING'
    | 'OLD_CARTOONS'
    | 'PAINT_GESTURE'
    | 'POP_ART'
    | 'RETRO_ETCHING'
    | 'RIVIERA_POP'
    | 'SPOTLIGHT_80S'
    | 'STYLIZED_RED'
    | 'SURREAL_COLLAGE'
    | 'TRAVEL_POSTER'
    | 'VINTAGE_GEO'
    | 'VINTAGE_POSTER'
    | 'WATERCOLOR'
    | 'WEIRD'
    | 'WOODBLOCK_PRINT'
    | unknown
  /**
   * Rendering Speed
   *
   * The rendering speed to use.
   */
  rendering_speed?: 'TURBO' | 'BALANCED' | 'QUALITY'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * A color palette for generation, must EITHER be specified via one of the presets (name) or explicitly via hexadecimal representations of the color with optional weights (members)
   */
  color_palette?: SchemaColorPalette | unknown
  /**
   * Style Codes
   *
   * A list of 8 character hexadecimal codes representing the style of the image. Cannot be used in conjunction with style_reference_images or style
   */
  style_codes?: Array<string> | unknown
  /**
   * Image URL
   *
   * The image URL to reframe
   */
  image_url: string
  /**
   * Seed
   *
   * Seed for the random number generator
   */
  seed?: number | unknown
  /**
   * Image Urls
   *
   * A set of images to use as style references (maximum total size 10MB across all style references). The images should be in JPEG, PNG or WebP format
   */
  image_urls?: Array<string> | unknown
}

/**
 * Img2ImgOutput
 */
export type SchemaHidreamI1FullImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * ImageToImageInput
 */
export type SchemaHidreamI1FullImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. Setting to None uses the input image's size.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The image URL to generate an image from.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Loras
   *
   * A list of LoRAs to apply to the model. Each LoRA specifies its path, scale, and optional weight name.
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Strength
   *
   * Denoising strength for image-to-image generation.
   */
  strength?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * MiniMaxTextToImageWithReferenceOutput
 */
export type SchemaMinimaxImage01SubjectReferenceOutput = {
  /**
   * Images
   *
   * Generated images
   */
  images: Array<SchemaFile>
}

/**
 * MiniMaxTextToImageWithReferenceRequest
 */
export type SchemaMinimaxImage01SubjectReferenceInput = {
  /**
   * Prompt Optimizer
   *
   * Whether to enable automatic prompt optimization
   */
  prompt_optimizer?: boolean
  /**
   * Aspect Ratio
   *
   * Aspect ratio of the generated image
   */
  aspect_ratio?:
    | '1:1'
    | '16:9'
    | '4:3'
    | '3:2'
    | '2:3'
    | '3:4'
    | '9:16'
    | '21:9'
  /**
   * Num Images
   *
   * Number of images to generate (1-9)
   */
  num_images?: number
  /**
   * Prompt
   *
   * Text prompt for image generation (max 1500 characters)
   */
  prompt: string
  /**
   * Image Url
   *
   * URL of the subject reference image to use for consistent character appearance
   */
  image_url: string
}

/**
 * ImageToImageOutput
 */
export type SchemaRecraftV3ImageToImageOutput = {
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaFile>
}

/**
 * ImageToImageInput
 */
export type SchemaRecraftV3ImageToImageInput = {
  /**
   * Prompt
   *
   * A text description of areas to change.
   */
  prompt: string
  /**
   * Style
   *
   * The style of the generated images. Vector images cost 2X as much.
   */
  style?:
    | 'any'
    | 'realistic_image'
    | 'digital_illustration'
    | 'vector_illustration'
    | 'realistic_image/b_and_w'
    | 'realistic_image/hard_flash'
    | 'realistic_image/hdr'
    | 'realistic_image/natural_light'
    | 'realistic_image/studio_portrait'
    | 'realistic_image/enterprise'
    | 'realistic_image/motion_blur'
    | 'realistic_image/evening_light'
    | 'realistic_image/faded_nostalgia'
    | 'realistic_image/forest_life'
    | 'realistic_image/mystic_naturalism'
    | 'realistic_image/natural_tones'
    | 'realistic_image/organic_calm'
    | 'realistic_image/real_life_glow'
    | 'realistic_image/retro_realism'
    | 'realistic_image/retro_snapshot'
    | 'realistic_image/urban_drama'
    | 'realistic_image/village_realism'
    | 'realistic_image/warm_folk'
    | 'digital_illustration/pixel_art'
    | 'digital_illustration/hand_drawn'
    | 'digital_illustration/grain'
    | 'digital_illustration/infantile_sketch'
    | 'digital_illustration/2d_art_poster'
    | 'digital_illustration/handmade_3d'
    | 'digital_illustration/hand_drawn_outline'
    | 'digital_illustration/engraving_color'
    | 'digital_illustration/2d_art_poster_2'
    | 'digital_illustration/antiquarian'
    | 'digital_illustration/bold_fantasy'
    | 'digital_illustration/child_book'
    | 'digital_illustration/child_books'
    | 'digital_illustration/cover'
    | 'digital_illustration/crosshatch'
    | 'digital_illustration/digital_engraving'
    | 'digital_illustration/expressionism'
    | 'digital_illustration/freehand_details'
    | 'digital_illustration/grain_20'
    | 'digital_illustration/graphic_intensity'
    | 'digital_illustration/hard_comics'
    | 'digital_illustration/long_shadow'
    | 'digital_illustration/modern_folk'
    | 'digital_illustration/multicolor'
    | 'digital_illustration/neon_calm'
    | 'digital_illustration/noir'
    | 'digital_illustration/nostalgic_pastel'
    | 'digital_illustration/outline_details'
    | 'digital_illustration/pastel_gradient'
    | 'digital_illustration/pastel_sketch'
    | 'digital_illustration/pop_art'
    | 'digital_illustration/pop_renaissance'
    | 'digital_illustration/street_art'
    | 'digital_illustration/tablet_sketch'
    | 'digital_illustration/urban_glow'
    | 'digital_illustration/urban_sketching'
    | 'digital_illustration/vanilla_dreams'
    | 'digital_illustration/young_adult_book'
    | 'digital_illustration/young_adult_book_2'
    | 'vector_illustration/bold_stroke'
    | 'vector_illustration/chemistry'
    | 'vector_illustration/colored_stencil'
    | 'vector_illustration/contour_pop_art'
    | 'vector_illustration/cosmics'
    | 'vector_illustration/cutout'
    | 'vector_illustration/depressive'
    | 'vector_illustration/editorial'
    | 'vector_illustration/emotional_flat'
    | 'vector_illustration/infographical'
    | 'vector_illustration/marker_outline'
    | 'vector_illustration/mosaic'
    | 'vector_illustration/naivector'
    | 'vector_illustration/roundish_flat'
    | 'vector_illustration/segmented_colors'
    | 'vector_illustration/sharp_contrast'
    | 'vector_illustration/thin'
    | 'vector_illustration/vector_photo'
    | 'vector_illustration/vivid_shapes'
    | 'vector_illustration/engraving'
    | 'vector_illustration/line_art'
    | 'vector_illustration/line_circuit'
    | 'vector_illustration/linocut'
  /**
   * Style Id
   *
   * The ID of the custom style reference (optional)
   */
  style_id?: string
  /**
   * Image Url
   *
   * The URL of the image to modify. Must be less than 5 MB in size, have resolution less than 16 MP and max dimension less than 4096 pixels.
   */
  image_url: string
  /**
   * Strength
   *
   * Defines the difference with the original image, should lie in [0, 1], where 0 means almost identical, and 1 means miserable similarity
   */
  strength?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Colors
   *
   * An array of preferable colors
   */
  colors?: Array<SchemaRgbColor>
  /**
   * Negative Prompt
   *
   * A text description of undesired elements on an image
   */
  negative_prompt?: string
}

/**
 * UpscaleOutput
 */
export type SchemaRecraftUpscaleCrispOutput = {
  /**
   * Image
   *
   * The upscaled image.
   */
  image: SchemaFile
}

/**
 * UpscaleInput
 */
export type SchemaRecraftUpscaleCrispInput = {
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Image Url
   *
   * The URL of the image to be upscaled. Must be in PNG format.
   */
  image_url: string
}

/**
 * UpscaleOutput
 */
export type SchemaRecraftUpscaleCreativeOutput = {
  /**
   * Image
   *
   * The upscaled image.
   */
  image: SchemaFile
}

/**
 * UpscaleInput
 */
export type SchemaRecraftUpscaleCreativeInput = {
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Image Url
   *
   * The URL of the image to be upscaled. Must be in PNG format.
   */
  image_url: string
}

/**
 * ImageOutput
 */
export type SchemaRembgEnhanceOutput = {
  image: SchemaFile
}

/**
 * ImageInput
 */
export type SchemaRembgEnhanceInput = {
  /**
   * Image Url
   *
   * URL of the input image
   */
  image_url: string
}

/**
 * ImageEditOutput
 */
export type SchemaBagelEditOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The edited images.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * ImageEditInput
 */
export type SchemaBagelEditInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image with.
   */
  prompt: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * The seed to use for the generation.
   */
  seed?: number
  /**
   * Use Thought
   *
   * Whether to use thought tokens for generation. If set to true, the model will "think" to potentially improve generation quality. Increases generation time and increases the cost by 20%.
   */
  use_thought?: boolean
  /**
   * Image Url
   *
   * The image to edit.
   */
  image_url: string
}

/**
 * KontextEditOutput
 */
export type SchemaFluxKontextDevOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * BaseKontextEditInput
 */
export type SchemaFluxKontextDevInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image.
   */
  prompt: string
  /**
   * Resolution Mode
   *
   *
   * Determines how the output resolution is set for image editing.
   * - `auto`: The model selects an optimal resolution from a predefined set that best matches the input image's aspect ratio. This is the recommended setting for most use cases as it's what the model was trained on.
   * - `match_input`: The model will attempt to use the same resolution as the input image. The resolution will be adjusted to be compatible with the model's requirements (e.g. dimensions must be multiples of 16 and within supported limits).
   * Apart from these, a few aspect ratios are also supported.
   *
   */
  resolution_mode?:
    | 'auto'
    | 'match_input'
    | '1:1'
    | '16:9'
    | '21:9'
    | '3:2'
    | '2:3'
    | '4:5'
    | '5:4'
    | '3:4'
    | '4:3'
    | '9:16'
    | '9:21'
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Output Format
   *
   * Output format
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to edit.
   */
  image_url: string
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * FluxKontextOutput
 */
export type SchemaFluxProKontextMaxOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaFalToolkitImageImageImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * Image
 *
 * Represents an image file.
 */
export type SchemaFalToolkitImageImageImage = {
  /**
   * File Size
   *
   * The size of the file in bytes.
   */
  file_size?: number
  /**
   * Height
   *
   * The height of the image in pixels.
   */
  height?: number
  /**
   * Url
   *
   * The URL where the file can be downloaded from.
   */
  url: string
  /**
   * Width
   *
   * The width of the image in pixels.
   */
  width?: number
  /**
   * File Name
   *
   * The name of the file. It will be auto-generated if not provided.
   */
  file_name?: string
  /**
   * Content Type
   *
   * The mime type of the file.
   */
  content_type?: string
  /**
   * File Data
   *
   * File data
   */
  file_data?: Blob | File
}

/**
 * FluxKontextInput
 */
export type SchemaFluxProKontextMaxInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * Image prompt for the omni model.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enhance Prompt
   *
   * Whether to enhance the prompt for better results.
   */
  enhance_prompt?: boolean
}

/**
 * Output
 */
export type SchemaFluxProKontextMultiOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaRegistryImageFastSdxlModelsImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * FluxKontextMultiInput
 */
export type SchemaFluxProKontextMultiInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Image URL
   *
   * Image prompt for the omni model.
   */
  image_urls: Array<string>
  /**
   * Enhance Prompt
   *
   * Whether to enhance the prompt for better results.
   */
  enhance_prompt?: boolean
}

/**
 * Output
 */
export type SchemaFluxProKontextMaxMultiOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaRegistryImageFastSdxlModelsImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * FluxKontextMultiInput
 */
export type SchemaFluxProKontextMaxMultiInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Image URL
   *
   * Image prompt for the omni model.
   */
  image_urls: Array<string>
  /**
   * Enhance Prompt
   *
   * Whether to enhance the prompt for better results.
   */
  enhance_prompt?: boolean
}

/**
 * AgeProgressionOutput
 */
export type SchemaImageEditingAgeProgressionOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * AgeProgressionInput
 */
export type SchemaImageEditingAgeProgressionInput = {
  /**
   * Age Change
   *
   * The age change to apply.
   */
  prompt?: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * Image prompt for the omni model.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
}

/**
 * BackgroundChangeOutput
 */
export type SchemaImageEditingBackgroundChangeOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * BackgroundChangeInput
 */
export type SchemaImageEditingBackgroundChangeInput = {
  /**
   * Background Prompt
   *
   * The desired background to apply.
   */
  prompt?: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * Image prompt for the omni model.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
}

/**
 * CartoonifyOutput
 */
export type SchemaImageEditingCartoonifyOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * BaseInput
 */
export type SchemaImageEditingCartoonifyInput = {
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * Image prompt for the omni model.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
}

/**
 * ColorCorrectionOutput
 */
export type SchemaImageEditingColorCorrectionOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * BaseInput
 */
export type SchemaImageEditingColorCorrectionInput = {
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * Image prompt for the omni model.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
}

/**
 * ExpressionChangeOutput
 */
export type SchemaImageEditingExpressionChangeOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * ExpressionChangeInput
 */
export type SchemaImageEditingExpressionChangeInput = {
  /**
   * Expression Prompt
   *
   * The desired facial expression to apply.
   */
  prompt?: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * Image prompt for the omni model.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
}

/**
 * FaceEnhancementOutput
 */
export type SchemaImageEditingFaceEnhancementOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * BaseInput
 */
export type SchemaImageEditingFaceEnhancementInput = {
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * Image prompt for the omni model.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
}

/**
 * HairChangeOutput
 */
export type SchemaImageEditingHairChangeOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * HairChangeInput
 */
export type SchemaImageEditingHairChangeInput = {
  /**
   * Hair Style Prompt
   *
   * The desired hair style to apply.
   */
  prompt?: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * Image prompt for the omni model.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
}

/**
 * ObjectRemovalOutput
 */
export type SchemaImageEditingObjectRemovalOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * ObjectRemovalInput
 */
export type SchemaImageEditingObjectRemovalInput = {
  /**
   * Objects to Remove
   *
   * Specify which objects to remove from the image.
   */
  prompt?: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * Image prompt for the omni model.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
}

/**
 * ProfessionalPhotoOutput
 */
export type SchemaImageEditingProfessionalPhotoOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * BaseInput
 */
export type SchemaImageEditingProfessionalPhotoInput = {
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * Image prompt for the omni model.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
}

/**
 * SceneCompositionOutput
 */
export type SchemaImageEditingSceneCompositionOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * SceneCompositionInput
 */
export type SchemaImageEditingSceneCompositionInput = {
  /**
   * Scene Description
   *
   * Describe the scene where you want to place the subject.
   */
  prompt?: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * Image prompt for the omni model.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
}

/**
 * StyleTransferOutput
 */
export type SchemaImageEditingStyleTransferOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * StyleTransferInput
 */
export type SchemaImageEditingStyleTransferInput = {
  /**
   * Style Prompt
   *
   * The artistic style to apply.
   */
  prompt?: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * Image prompt for the omni model.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
}

/**
 * TimeOfDayOutput
 */
export type SchemaImageEditingTimeOfDayOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * TimeOfDayInput
 */
export type SchemaImageEditingTimeOfDayInput = {
  /**
   * Time of Day
   *
   * The time of day to transform the scene to.
   */
  prompt?: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * Image prompt for the omni model.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
}

/**
 * WeatherEffectOutput
 */
export type SchemaImageEditingWeatherEffectOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * WeatherEffectInput
 */
export type SchemaImageEditingWeatherEffectInput = {
  /**
   * Weather Effect
   *
   * The weather effect to apply.
   */
  prompt?: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * Image prompt for the omni model.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
}

/**
 * PhotoRestorationOutput
 */
export type SchemaImageEditingPhotoRestorationOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * PhotoRestorationInput
 *
 * Input model for photo restoration endpoint.
 */
export type SchemaImageEditingPhotoRestorationInput = {
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * URL of the old or damaged photo to restore.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
}

/**
 * TextRemovalOutput
 */
export type SchemaImageEditingTextRemovalOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * TextRemovalInput
 *
 * Input model for text removal endpoint.
 */
export type SchemaImageEditingTextRemovalInput = {
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * URL of the image containing text to be removed.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaFlux1DevImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseFlux1ImageToInput
 */
export type SchemaFlux1DevImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to generate an image from.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * The strength of the initial image. Higher strength values are better for this model.
   */
  strength?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
}

/**
 * Output
 */
export type SchemaFlux1DevReduxOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseFlux1ReduxInput
 */
export type SchemaFlux1DevReduxInput = {
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to generate an image from.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
}

/**
 * Output
 */
export type SchemaFlux1SchnellReduxOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * SchnellFlux1ReduxInput
 */
export type SchemaFlux1SchnellReduxInput = {
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to generate an image from.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
}

/**
 * T2IOutput
 */
export type SchemaLumaPhotonReframeOutput = {
  /**
   * Images
   *
   * The generated image
   */
  images: Array<SchemaFile>
}

/**
 * ReframeImageRequest
 */
export type SchemaLumaPhotonReframeInput = {
  /**
   * Prompt
   *
   * Optional prompt for reframing
   */
  prompt?: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the reframed image
   */
  aspect_ratio: '1:1' | '16:9' | '9:16' | '4:3' | '3:4' | '21:9' | '9:21'
  /**
   * Y Start
   *
   * Start Y coordinate for reframing
   */
  y_start?: number
  /**
   * X End
   *
   * End X coordinate for reframing
   */
  x_end?: number
  /**
   * Y End
   *
   * End Y coordinate for reframing
   */
  y_end?: number
  /**
   * Grid Position Y
   *
   * Y position of the grid for reframing
   */
  grid_position_y?: number
  /**
   * Image Url
   *
   * URL of the input image to reframe
   */
  image_url: string
  /**
   * Grid Position X
   *
   * X position of the grid for reframing
   */
  grid_position_x?: number
  /**
   * X Start
   *
   * Start X coordinate for reframing
   */
  x_start?: number
}

/**
 * T2IOutput
 */
export type SchemaLumaPhotonFlashReframeOutput = {
  /**
   * Images
   *
   * The generated image
   */
  images: Array<SchemaFile>
}

/**
 * ReframeImageRequest
 */
export type SchemaLumaPhotonFlashReframeInput = {
  /**
   * Prompt
   *
   * Optional prompt for reframing
   */
  prompt?: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the reframed image
   */
  aspect_ratio: '1:1' | '16:9' | '9:16' | '4:3' | '3:4' | '21:9' | '9:21'
  /**
   * Y Start
   *
   * Start Y coordinate for reframing
   */
  y_start?: number
  /**
   * X End
   *
   * End X coordinate for reframing
   */
  x_end?: number
  /**
   * Y End
   *
   * End Y coordinate for reframing
   */
  y_end?: number
  /**
   * Grid Position Y
   *
   * Y position of the grid for reframing
   */
  grid_position_y?: number
  /**
   * Image Url
   *
   * URL of the input image to reframe
   */
  image_url: string
  /**
   * Grid Position X
   *
   * X position of the grid for reframing
   */
  grid_position_x?: number
  /**
   * X Start
   *
   * Start X coordinate for reframing
   */
  x_start?: number
}

/**
 * BabyVersionOutput
 */
export type SchemaImageEditingBabyVersionOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * BabyVersionInput
 *
 * Input model for baby version endpoint.
 */
export type SchemaImageEditingBabyVersionInput = {
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * URL of the image to transform into a baby version.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
}

/**
 * ReframeOutput
 */
export type SchemaImageEditingReframeOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * ReframeInput
 */
export type SchemaImageEditingReframeInput = {
  /**
   * Aspect Ratio
   *
   * The desired aspect ratio for the reframed image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * URL of the old or damaged photo to restore.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
}

/**
 * T2IOutput
 */
export type SchemaLumaPhotonModifyOutput = {
  /**
   * Images
   *
   * The generated image
   */
  images: Array<SchemaFile>
}

/**
 * ModifyImageRequest
 */
export type SchemaLumaPhotonModifyInput = {
  /**
   * Prompt
   *
   * Instruction for modifying the image
   */
  prompt?: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the reframed image
   */
  aspect_ratio: '1:1' | '16:9' | '9:16' | '4:3' | '3:4' | '21:9' | '9:21'
  /**
   * Strength
   *
   * The strength of the initial image. Higher strength values are corresponding to more influence of the initial image on the output.
   */
  strength: number
  /**
   * Image Url
   *
   * URL of the input image to reframe
   */
  image_url: string
}

/**
 * T2IOutput
 */
export type SchemaLumaPhotonFlashModifyOutput = {
  /**
   * Images
   *
   * The generated image
   */
  images: Array<SchemaFile>
}

/**
 * ModifyImageRequest
 */
export type SchemaLumaPhotonFlashModifyInput = {
  /**
   * Prompt
   *
   * Instruction for modifying the image
   */
  prompt?: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the reframed image
   */
  aspect_ratio: '1:1' | '16:9' | '9:16' | '4:3' | '3:4' | '21:9' | '9:21'
  /**
   * Strength
   *
   * The strength of the initial image. Higher strength values are corresponding to more influence of the initial image on the output.
   */
  strength: number
  /**
   * Image Url
   *
   * URL of the input image to reframe
   */
  image_url: string
}

/**
 * FrameOutput
 */
export type SchemaFfmpegApiExtractFrameOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
}

/**
 * FrameInput
 */
export type SchemaFfmpegApiExtractFrameInput = {
  /**
   * Video Url
   *
   * URL of the video file to use as the video track
   */
  video_url: string
  /**
   * Frame Type
   *
   * Type of frame to extract: first, middle, or last frame of the video
   */
  frame_type?: 'first' | 'middle' | 'last'
}

/**
 * VectorizeOutput
 */
export type SchemaRecraftVectorizeOutput = {
  /**
   * Image
   *
   * The vectorized image.
   */
  image: SchemaFile
}

/**
 * VectorizeInput
 */
export type SchemaRecraftVectorizeInput = {
  /**
   * Image Url
   *
   * The URL of the image to be vectorized. Must be in PNG, JPG or WEBP format, less than 5 MB in size, have resolution less than 16 MP and max dimension less than 4096 pixels, min dimension more than 256 pixels.
   */
  image_url: string
}

/**
 * Output
 */
export type SchemaObjectRemovalOutput = {
  /**
   * Images
   *
   * The generated images with objects removed.
   */
  images: Array<SchemaImage>
}

/**
 * PromptInput
 */
export type SchemaObjectRemovalInput = {
  /**
   * Prompt
   *
   * Text description of the object to remove.
   */
  prompt: string
  /**
   * Mask Expansion
   *
   * Amount of pixels to expand the mask by. Range: 0-50
   */
  mask_expansion?: number
  /**
   * Model
   */
  model?: 'low_quality' | 'medium_quality' | 'high_quality' | 'best_quality'
  /**
   * Image Url
   *
   * The URL of the image to remove objects from.
   */
  image_url: string
}

/**
 * Output
 */
export type SchemaObjectRemovalMaskOutput = {
  /**
   * Images
   *
   * The generated images with objects removed.
   */
  images: Array<SchemaImage>
}

/**
 * MaskInput
 */
export type SchemaObjectRemovalMaskInput = {
  /**
   * Model
   */
  model?: 'low_quality' | 'medium_quality' | 'high_quality' | 'best_quality'
  /**
   * Mask Expansion
   *
   * Amount of pixels to expand the mask by. Range: 0-50
   */
  mask_expansion?: number
  /**
   * Mask Url
   *
   * The URL of the mask image. White pixels (255) indicate areas to remove.
   */
  mask_url: string
  /**
   * Image Url
   *
   * The URL of the image to remove objects from.
   */
  image_url: string
}

/**
 * BBoxPromptBase
 */
export type SchemaBBoxPromptBase = {
  /**
   * Y Min
   *
   * Y Min Coordinate of the box (0-1)
   */
  y_min?: number
  /**
   * X Max
   *
   * X Max Coordinate of the prompt (0-1)
   */
  x_max?: number
  /**
   * X Min
   *
   * X Min Coordinate of the box (0-1)
   */
  x_min?: number
  /**
   * Y Max
   *
   * Y Max Coordinate of the prompt (0-1)
   */
  y_max?: number
}

/**
 * Output
 */
export type SchemaObjectRemovalBboxOutput = {
  /**
   * Images
   *
   * The generated images with objects removed.
   */
  images: Array<SchemaImage>
}

/**
 * BboxInput
 */
export type SchemaObjectRemovalBboxInput = {
  /**
   * Model
   */
  model?: 'low_quality' | 'medium_quality' | 'high_quality' | 'best_quality'
  /**
   * Mask Expansion
   *
   * Amount of pixels to expand the mask by. Range: 0-50
   */
  mask_expansion?: number
  /**
   * Box Prompts
   *
   * List of bounding box coordinates to erase (only one box prompt is supported)
   */
  box_prompts?: Array<SchemaBBoxPromptBase>
  /**
   * Image Url
   *
   * The URL of the image to remove objects from.
   */
  image_url: string
}

/**
 * Output
 */
export type SchemaPasdOutput = {
  /**
   * Images
   *
   * The generated super-resolved images
   */
  images: Array<SchemaImage>
  /**
   * Timings
   *
   * Timing information for different processing stages
   */
  timings?: {
    [key: string]: number
  }
}

/**
 * Input
 */
export type SchemaPasdInput = {
  /**
   * Conditioning Scale
   *
   * ControlNet conditioning scale (0.1-1.0)
   */
  conditioning_scale?: number
  /**
   * Prompt
   *
   * Additional prompt to guide super-resolution
   */
  prompt?: string
  /**
   * Image Url
   *
   * Input image to super-resolve
   */
  image_url: string
  /**
   * Steps
   *
   * Number of inference steps (10-50)
   */
  steps?: number
  /**
   * Scale
   *
   * Upscaling factor (1-4x)
   */
  scale?: number
  /**
   * Guidance Scale
   *
   * Guidance scale for diffusion (1.0-20.0)
   */
  guidance_scale?: number
  /**
   * Negative Prompt
   *
   * Negative prompt to avoid unwanted artifacts
   */
  negative_prompt?: string
}

/**
 * Output
 */
export type SchemaChainOfZoomOutput = {
  /**
   * Images
   *
   * List of intermediate images
   */
  images: Array<SchemaImage>
  /**
   * Zoom Center
   *
   * Center coordinates used for zoom
   */
  zoom_center: Array<number>
  /**
   * Scale
   *
   * Actual linear zoom scale applied
   */
  scale: number
}

/**
 * Input
 */
export type SchemaChainOfZoomInput = {
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Center Y
   *
   * Y coordinate of zoom center (0-1)
   */
  center_y?: number
  /**
   * Scale
   *
   * Zoom scale in powers of 2
   */
  scale?: number
  /**
   * Center X
   *
   * X coordinate of zoom center (0-1)
   */
  center_x?: number
  /**
   * User Prompt
   *
   * Additional prompt text to guide the zoom enhancement
   */
  user_prompt?: string
  /**
   * Image Url
   *
   * Input image to zoom into
   */
  image_url: string
}

/**
 * V16Output
 */
export type SchemaFashnTryonV16Output = {
  /**
   * Images
   */
  images: Array<SchemaFile>
}

/**
 * V16Input
 */
export type SchemaFashnTryonV16Input = {
  /**
   * Model Image
   *
   * URL or base64 of the model image
   */
  model_image: string
  /**
   * Moderation Level
   *
   * Content moderation level for garment images. 'none' disables moderation, 'permissive' blocks only explicit content, 'conservative' also blocks underwear and swimwear.
   */
  moderation_level?: 'none' | 'permissive' | 'conservative'
  /**
   * Garment Photo Type
   *
   * Specifies the type of garment photo to optimize internal parameters for better performance. 'model' is for photos of garments on a model, 'flat-lay' is for flat-lay or ghost mannequin images, and 'auto' attempts to automatically detect the photo type.
   */
  garment_photo_type?: 'auto' | 'model' | 'flat-lay'
  /**
   * Garment Image
   *
   * URL or base64 of the garment image
   */
  garment_image: string
  /**
   * Category
   *
   * Category of the garment to try-on. 'auto' will attempt to automatically detect the category of the garment.
   */
  category?: 'tops' | 'bottoms' | 'one-pieces' | 'auto'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Segmentation Free
   *
   * Disables human parsing on the model image.
   */
  segmentation_free?: boolean
  /**
   * Num Samples
   *
   * Number of images to generate in a single run. Image generation has a random element in it, so trying multiple images at once increases the chances of getting a good result.
   */
  num_samples?: number
  /**
   * Mode
   *
   * Specifies the mode of operation. 'performance' mode is faster but may sacrifice quality, 'balanced' mode is a balance between speed and quality, and 'quality' mode is slower but produces higher quality results.
   */
  mode?: 'performance' | 'balanced' | 'quality'
  /**
   * Seed
   *
   * Sets random operations to a fixed state. Use the same seed to reproduce results with the same inputs, or different seed to force different results.
   */
  seed?: number
  /**
   * Output Format
   *
   * Output format of the generated images. 'png' is highest quality, while 'jpeg' is faster
   */
  output_format?: 'png' | 'jpeg'
}

/**
 * KontextEditOutput
 */
export type SchemaFluxKontextLoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseKontextEditInput
 */
export type SchemaFluxKontextLoraInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Resolution Mode
   *
   *
   * Determines how the output resolution is set for image editing.
   * - `auto`: The model selects an optimal resolution from a predefined set that best matches the input image's aspect ratio. This is the recommended setting for most use cases as it's what the model was trained on.
   * - `match_input`: The model will attempt to use the same resolution as the input image. The resolution will be adjusted to be compatible with the model's requirements (e.g. dimensions must be multiples of 16 and within supported limits).
   * Apart from these, a few aspect ratios are also supported.
   *
   */
  resolution_mode?:
    | 'auto'
    | 'match_input'
    | '1:1'
    | '16:9'
    | '21:9'
    | '3:2'
    | '2:3'
    | '4:5'
    | '5:4'
    | '3:4'
    | '4:3'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to edit.
   *
   * Max width: 14142px, Max height: 14142px, Timeout: 20s
   */
  image_url: string
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * PlushieStyleOutput
 */
export type SchemaImageEditingPlushieStyleOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * PlushieStyleInput
 *
 * Input model for plushie style endpoint.
 */
export type SchemaImageEditingPlushieStyleInput = {
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Image URL
   *
   * URL of the image to convert to plushie style.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
}

/**
 * WojakStyleOutput
 */
export type SchemaImageEditingWojakStyleOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * WojakStyleInput
 *
 * Input model for wojak style endpoint.
 */
export type SchemaImageEditingWojakStyleInput = {
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Image URL
   *
   * URL of the image to convert to wojak style.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
}

/**
 * BroccoliHaircutOutput
 */
export type SchemaImageEditingBroccoliHaircutOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * BroccoliHaircutInput
 *
 * Input model for broccoli haircut endpoint.
 */
export type SchemaImageEditingBroccoliHaircutInput = {
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Image URL
   *
   * URL of the image to apply broccoli haircut style.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
}

/**
 * ImageUpscaleOutput
 */
export type SchemaTopazUpscaleImageOutput = {
  /**
   * Image
   *
   * The upscaled image.
   */
  image: SchemaFile
}

/**
 * ImageUpscaleRequest
 */
export type SchemaTopazUpscaleImageInput = {
  /**
   * Face Enhancement Creativity
   *
   * Creativity level for face enhancement. 0.0 means no creativity, 1.0 means maximum creativity. Ignored if face ehnancement is disabled.
   */
  face_enhancement_creativity?: number
  /**
   * Face Enhancement Strength
   *
   * Strength of the face enhancement. 0.0 means no enhancement, 1.0 means maximum enhancement. Ignored if face ehnancement is disabled.
   */
  face_enhancement_strength?: number
  /**
   * Output Format
   *
   * Output format of the upscaled image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Face Enhancement
   *
   * Whether to apply face enhancement to the image.
   */
  face_enhancement?: boolean
  /**
   * Subject Detection
   *
   * Subject detection mode for the image enhancement.
   */
  subject_detection?: 'All' | 'Foreground' | 'Background'
  /**
   * Model
   *
   * Model to use for image enhancement.
   */
  model?:
    | 'Low Resolution V2'
    | 'Standard V2'
    | 'CGI'
    | 'High Fidelity V2'
    | 'Text Refine'
    | 'Recovery'
    | 'Redefine'
    | 'Recovery V2'
  /**
   * Image Url
   *
   * Url of the image to be upscaled
   */
  image_url: string
  /**
   * Upscale Factor
   *
   * Factor to upscale the video by (e.g. 2.0 doubles width and height)
   */
  upscale_factor?: number
  /**
   * Crop To Fill
   */
  crop_to_fill?: boolean
}

/**
 * YouTubeThumbnailsOutput
 */
export type SchemaImageEditingYoutubeThumbnailsOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * YouTubeThumbnailsInput
 *
 * Input model for YouTube thumbnails endpoint.
 */
export type SchemaImageEditingYoutubeThumbnailsInput = {
  /**
   * Thumbnail Text
   *
   * The text to include in the YouTube thumbnail.
   */
  prompt?: string
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Image URL
   *
   * URL of the image to convert to YouTube thumbnail style.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
}

/**
 * BlurOutput
 */
export type SchemaPostProcessingBlurOutput = {
  /**
   * Images
   *
   * The processed images with blur effect
   */
  images: Array<SchemaImage>
}

/**
 * BlurInput
 */
export type SchemaPostProcessingBlurInput = {
  /**
   * Blur Sigma
   *
   * Sigma for Gaussian blur
   */
  blur_sigma?: number
  /**
   * Blur Radius
   *
   * Blur radius
   */
  blur_radius?: number
  /**
   * Blur Type
   *
   * Type of blur to apply
   */
  blur_type?: 'gaussian' | 'kuwahara'
  /**
   * Image Url
   *
   * URL of image to process
   */
  image_url: string
}

/**
 * ChromaticAberrationOutput
 */
export type SchemaPostProcessingChromaticAberrationOutput = {
  /**
   * Images
   *
   * The processed images with chromatic aberration effect
   */
  images: Array<SchemaImage>
}

/**
 * ChromaticAberrationInput
 */
export type SchemaPostProcessingChromaticAberrationInput = {
  /**
   * Blue Shift
   *
   * Blue channel shift amount
   */
  blue_shift?: number
  /**
   * Red Shift
   *
   * Red channel shift amount
   */
  red_shift?: number
  /**
   * Green Direction
   *
   * Green channel shift direction
   */
  green_direction?: 'horizontal' | 'vertical'
  /**
   * Blue Direction
   *
   * Blue channel shift direction
   */
  blue_direction?: 'horizontal' | 'vertical'
  /**
   * Red Direction
   *
   * Red channel shift direction
   */
  red_direction?: 'horizontal' | 'vertical'
  /**
   * Image Url
   *
   * URL of image to process
   */
  image_url: string
  /**
   * Green Shift
   *
   * Green channel shift amount
   */
  green_shift?: number
}

/**
 * ColorCorrectionOutput
 */
export type SchemaPostProcessingColorCorrectionOutput = {
  /**
   * Images
   *
   * The processed images with color correction
   */
  images: Array<SchemaImage>
}

/**
 * ColorCorrectionInput
 */
export type SchemaPostProcessingColorCorrectionInput = {
  /**
   * Gamma
   *
   * Gamma adjustment
   */
  gamma?: number
  /**
   * Saturation
   *
   * Saturation adjustment
   */
  saturation?: number
  /**
   * Temperature
   *
   * Color temperature adjustment
   */
  temperature?: number
  /**
   * Brightness
   *
   * Brightness adjustment
   */
  brightness?: number
  /**
   * Contrast
   *
   * Contrast adjustment
   */
  contrast?: number
  /**
   * Image Url
   *
   * URL of image to process
   */
  image_url: string
}

/**
 * ColorTintOutput
 */
export type SchemaPostProcessingColorTintOutput = {
  /**
   * Images
   *
   * The processed images with color tint effect
   */
  images: Array<SchemaImage>
}

/**
 * ColorTintInput
 */
export type SchemaPostProcessingColorTintInput = {
  /**
   * Tint Strength
   *
   * Tint strength
   */
  tint_strength?: number
  /**
   * Tint Mode
   *
   * Tint color mode
   */
  tint_mode?:
    | 'sepia'
    | 'red'
    | 'green'
    | 'blue'
    | 'cyan'
    | 'magenta'
    | 'yellow'
    | 'purple'
    | 'orange'
    | 'warm'
    | 'cool'
    | 'lime'
    | 'navy'
    | 'vintage'
    | 'rose'
    | 'teal'
    | 'maroon'
    | 'peach'
    | 'lavender'
    | 'olive'
  /**
   * Image Url
   *
   * URL of image to process
   */
  image_url: string
}

/**
 * DesaturateOutput
 */
export type SchemaPostProcessingDesaturateOutput = {
  /**
   * Images
   *
   * The processed images with desaturation effect
   */
  images: Array<SchemaImage>
}

/**
 * DesaturateInput
 */
export type SchemaPostProcessingDesaturateInput = {
  /**
   * Desaturate Method
   *
   * Desaturation method
   */
  desaturate_method?:
    | 'luminance (Rec.709)'
    | 'luminance (Rec.601)'
    | 'average'
    | 'lightness'
  /**
   * Desaturate Factor
   *
   * Desaturation factor
   */
  desaturate_factor?: number
  /**
   * Image Url
   *
   * URL of image to process
   */
  image_url: string
}

/**
 * DissolveOutput
 */
export type SchemaPostProcessingDissolveOutput = {
  /**
   * Images
   *
   * The processed images with dissolve effect
   */
  images: Array<SchemaImage>
}

/**
 * DissolveInput
 */
export type SchemaPostProcessingDissolveInput = {
  /**
   * Dissolve Factor
   *
   * Dissolve blend factor
   */
  dissolve_factor?: number
  /**
   * Dissolve Image Url
   *
   * URL of second image for dissolve
   */
  dissolve_image_url: string
  /**
   * Image Url
   *
   * URL of image to process
   */
  image_url: string
}

/**
 * DodgeBurnOutput
 */
export type SchemaPostProcessingDodgeBurnOutput = {
  /**
   * Images
   *
   * The processed images with dodge and burn effect
   */
  images: Array<SchemaImage>
}

/**
 * DodgeBurnInput
 */
export type SchemaPostProcessingDodgeBurnInput = {
  /**
   * Dodge Burn Mode
   *
   * Dodge and burn mode
   */
  dodge_burn_mode?:
    | 'dodge'
    | 'burn'
    | 'dodge_and_burn'
    | 'burn_and_dodge'
    | 'color_dodge'
    | 'color_burn'
    | 'linear_dodge'
    | 'linear_burn'
  /**
   * Dodge Burn Intensity
   *
   * Dodge and burn intensity
   */
  dodge_burn_intensity?: number
  /**
   * Image Url
   *
   * URL of image to process
   */
  image_url: string
}

/**
 * GrainOutput
 */
export type SchemaPostProcessingGrainOutput = {
  /**
   * Images
   *
   * The processed images with grain effect
   */
  images: Array<SchemaImage>
}

/**
 * GrainInput
 */
export type SchemaPostProcessingGrainInput = {
  /**
   * Grain Style
   *
   * Style of film grain to apply
   */
  grain_style?:
    | 'modern'
    | 'analog'
    | 'kodak'
    | 'fuji'
    | 'cinematic'
    | 'newspaper'
  /**
   * Grain Intensity
   *
   * Film grain intensity
   */
  grain_intensity?: number
  /**
   * Grain Scale
   *
   * Film grain scale
   */
  grain_scale?: number
  /**
   * Image Url
   *
   * URL of image to process
   */
  image_url: string
}

/**
 * ParabolizeOutput
 */
export type SchemaPostProcessingParabolizeOutput = {
  /**
   * Images
   *
   * The processed images with parabolize effect
   */
  images: Array<SchemaImage>
}

/**
 * ParabolizeInput
 */
export type SchemaPostProcessingParabolizeInput = {
  /**
   * Parabolize Coeff
   *
   * Parabolize coefficient
   */
  parabolize_coeff?: number
  /**
   * Vertex Y
   *
   * Vertex Y position
   */
  vertex_y?: number
  /**
   * Vertex X
   *
   * Vertex X position
   */
  vertex_x?: number
  /**
   * Image Url
   *
   * URL of image to process
   */
  image_url: string
}

/**
 * SharpenOutput
 */
export type SchemaPostProcessingSharpenOutput = {
  /**
   * Images
   *
   * The processed images with sharpen effect
   */
  images: Array<SchemaImage>
}

/**
 * SharpenInput
 */
export type SchemaPostProcessingSharpenInput = {
  /**
   * Sharpen Mode
   *
   * Type of sharpening to apply
   */
  sharpen_mode?: 'basic' | 'smart' | 'cas'
  /**
   * Sharpen Alpha
   *
   * Sharpen strength (for basic mode)
   */
  sharpen_alpha?: number
  /**
   * Noise Radius
   *
   * Noise radius for smart sharpen
   */
  noise_radius?: number
  /**
   * Sharpen Radius
   *
   * Sharpen radius (for basic mode)
   */
  sharpen_radius?: number
  /**
   * Image Url
   *
   * URL of image to process
   */
  image_url: string
  /**
   * Smart Sharpen Strength
   *
   * Smart sharpen strength
   */
  smart_sharpen_strength?: number
  /**
   * Cas Amount
   *
   * CAS sharpening amount
   */
  cas_amount?: number
  /**
   * Preserve Edges
   *
   * Edge preservation factor
   */
  preserve_edges?: number
  /**
   * Smart Sharpen Ratio
   *
   * Smart sharpen blend ratio
   */
  smart_sharpen_ratio?: number
}

/**
 * SolarizeOutput
 */
export type SchemaPostProcessingSolarizeOutput = {
  /**
   * Images
   *
   * The processed images with solarize effect
   */
  images: Array<SchemaImage>
}

/**
 * SolarizeInput
 */
export type SchemaPostProcessingSolarizeInput = {
  /**
   * Solarize Threshold
   *
   * Solarize threshold
   */
  solarize_threshold?: number
  /**
   * Image Url
   *
   * URL of image to process
   */
  image_url: string
}

/**
 * VignetteOutput
 */
export type SchemaPostProcessingVignetteOutput = {
  /**
   * Images
   *
   * The processed images with vignette effect
   */
  images: Array<SchemaImage>
}

/**
 * VignetteInput
 */
export type SchemaPostProcessingVignetteInput = {
  /**
   * Vignette Strength
   *
   * Vignette strength
   */
  vignette_strength?: number
  /**
   * Image Url
   *
   * URL of image to process
   */
  image_url: string
}

/**
 * RealismOutput
 */
export type SchemaImageEditingRealismOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * RealismInput
 *
 * Input model for realism enhancement endpoint.
 */
export type SchemaImageEditingRealismInput = {
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Image URL
   *
   * URL of the image to enhance with realism details.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
}

/**
 * ReimagineOutput
 */
export type SchemaBriaReimagineOutput = {
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * Seed value used for generation.
   */
  seed: number
}

/**
 * ReimagineInput
 */
export type SchemaBriaReimagineInput = {
  /**
   * Prompt
   *
   * The prompt you would like to use to generate images.
   */
  prompt: string
  /**
   * Num Results
   *
   * How many images you would like to generate. When using any Guidance Method, Value is set to 1.
   */
  num_results?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Structure Ref Influence
   *
   * The influence of the structure reference on the generated image.
   */
  structure_ref_influence?: number
  /**
   * Fast
   *
   * Whether to use the fast model
   */
  fast?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Num Inference Steps
   *
   * The number of iterations the model goes through to refine the generated image. This parameter is optional.
   */
  num_inference_steps?: number
  /**
   * Structure Image Url
   *
   * The URL of the structure reference image. Use "" to leave empty. Accepted formats are jpeg, jpg, png, webp.
   */
  structure_image_url?: string
}

/**
 * Output
 */
export type SchemaCalligrapherOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
}

/**
 * Input
 */
export type SchemaCalligrapherInput = {
  /**
   * Use Context
   *
   * Whether to prepend context reference to the input
   */
  use_context?: boolean
  /**
   * Num Images
   *
   * How many images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * Target image size for generation
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Auto Mask Generation
   *
   * Whether to automatically generate mask from detected text
   */
  auto_mask_generation?: boolean
  /**
   * Reference Image Url
   *
   * Optional base64 reference image for style
   */
  reference_image_url?: string
  /**
   * Source Image Url
   *
   * Base64-encoded source image with drawn mask layers
   */
  source_image_url: string
  /**
   * Prompt
   *
   * Text prompt to inpaint or customize
   */
  prompt: string
  /**
   * Mask Image Url
   *
   * Base64-encoded mask image (optional if using auto_mask_generation)
   */
  mask_image_url?: string
  /**
   * Source Text
   *
   * Source text to replace (if empty, masks all detected text)
   */
  source_text?: string
  /**
   * Num Inference Steps
   *
   * Number of inference steps (1-100)
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * Random seed for reproducibility
   */
  seed?: number
  /**
   * Cfg Scale
   *
   * Guidance or strength scale for the model
   */
  cfg_scale?: number
}

/**
 * VideoFile
 */
export type SchemaVideoFile = {
  /**
   * File Size
   *
   * The size of the file in bytes.
   */
  file_size?: number
  /**
   * Duration
   *
   * The duration of the video
   */
  duration?: number
  /**
   * Height
   *
   * The height of the video
   */
  height?: number
  /**
   * Url
   *
   * The URL where the file can be downloaded from.
   */
  url: string
  /**
   * Width
   *
   * The width of the video
   */
  width?: number
  /**
   * Fps
   *
   * The FPS of the video
   */
  fps?: number
  /**
   * File Name
   *
   * The name of the file. It will be auto-generated if not provided.
   */
  file_name?: string
  /**
   * Content Type
   *
   * The mime type of the file.
   */
  content_type?: string
  /**
   * Num Frames
   *
   * The number of frames in the video
   */
  num_frames?: number
  /**
   * File Data
   *
   * File data
   */
  file_data?: Blob | File
}

/**
 * FILMImageOutput
 */
export type SchemaFilmOutput = {
  /**
   * Images
   *
   * The generated frames as individual images.
   */
  images?: Array<SchemaImageFile>
  /**
   * Video
   *
   * The generated video file, if output_type is 'video'.
   */
  video?: SchemaVideoFile
}

/**
 * FILMImageInput
 */
export type SchemaFilmInput = {
  /**
   * Video Write Mode
   *
   * The write mode of the output video. Only applicable if output_type is 'video'.
   */
  video_write_mode?: 'fast' | 'balanced' | 'small'
  /**
   * Number of Frames
   *
   * The number of frames to generate between the input images.
   */
  num_frames?: number
  /**
   * Include Start
   *
   * Whether to include the start image in the output.
   */
  include_start?: boolean
  /**
   * Video Quality
   *
   * The quality of the output video. Only applicable if output_type is 'video'.
   */
  video_quality?: 'low' | 'medium' | 'high' | 'maximum'
  /**
   * Include End
   *
   * Whether to include the end image in the output.
   */
  include_end?: boolean
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Frames Per Second
   *
   * Frames per second for the output video. Only applicable if output_type is 'video'.
   */
  fps?: number
  /**
   * Start Image URL
   *
   * The URL of the first image to use as the starting point for interpolation.
   */
  start_image_url: string
  /**
   * End Image URL
   *
   * The URL of the second image to use as the ending point for interpolation.
   */
  end_image_url: string
  /**
   * Image Format
   *
   * The format of the output images. Only applicable if output_type is 'images'.
   */
  image_format?: 'png' | 'jpeg'
  /**
   * Output Type
   *
   * The type of output to generate; either individual images or a video.
   */
  output_type?: 'images' | 'video'
}

/**
 * RIFEImageOutput
 */
export type SchemaRifeOutput = {
  /**
   * Images
   *
   * The generated frames as individual images.
   */
  images?: Array<SchemaImage>
  /**
   * Video
   *
   * The generated video file, if output_type is 'video'.
   */
  video?: SchemaFile
}

/**
 * RIFEImageInput
 */
export type SchemaRifeInput = {
  /**
   * Output Format
   *
   * The format of the output images. Only applicable if output_type is 'images'.
   */
  output_format?: 'png' | 'jpeg'
  /**
   * Frames Per Second
   *
   * Frames per second for the output video. Only applicable if output_type is 'video'.
   */
  fps?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Include End
   *
   * Whether to include the end image in the output.
   */
  include_end?: boolean
  /**
   * Include Start
   *
   * Whether to include the start image in the output.
   */
  include_start?: boolean
  /**
   * Number of Frames
   *
   * The number of frames to generate between the input images.
   */
  num_frames?: number
  /**
   * End Image URL
   *
   * The URL of the second image to use as the ending point for interpolation.
   */
  end_image_url: string
  /**
   * Output Type
   *
   * The type of output to generate; either individual images or a video.
   */
  output_type?: 'images' | 'video'
  /**
   * Start Image URL
   *
   * The URL of the first image to use as the starting point for interpolation.
   */
  start_image_url: string
}

/**
 * Output
 */
export type SchemaHidreamE11Output = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseInput
 */
export type SchemaHidreamE11Input = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt?: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Guidance Scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your initial image when looking for a related image to show you.
   *
   */
  image_guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * URL of an input image to edit.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Target Image Description
   *
   * The description of the target image after your edits have been made. Leave this blank to allow the model to use its own imagination.
   */
  target_image_description?: string
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * RetouchOutput
 */
export type SchemaImageEditingRetouchOutput = {
  /**
   * Images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   */
  seed: number
}

/**
 * RetouchInput
 *
 * Input model for retouch endpoint.
 */
export type SchemaImageEditingRetouchInput = {
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Image URL
   *
   * URL of the image to retouch.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
}

/**
 * ImageToPanoramaResponse
 */
export type SchemaHunyuanWorldOutput = {
  /**
   * Image
   *
   * The generated panorama image.
   */
  image: SchemaImage
}

/**
 * ImageToPanoramaRequest
 */
export type SchemaHunyuanWorldInput = {
  /**
   * Prompt
   *
   * The prompt to use for the panorama generation.
   */
  prompt: string
  /**
   * Image Url
   *
   * The URL of the image to convert to a panorama.
   */
  image_url: string
}

/**
 * KontextInpaintOutput
 */
export type SchemaFluxKontextLoraInpaintOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseKontextInpaintInput
 */
export type SchemaFluxKontextLoraInpaintInput = {
  /**
   * Prompt
   *
   * The prompt for the image to image task.
   */
  prompt: string
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Reference Image URL
   *
   * The URL of the reference image for inpainting.
   */
  reference_image_url: string
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to be inpainted.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * The strength of the initial image. Higher strength values are better for this model.
   */
  strength?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Image URL
   *
   * The URL of the mask for inpainting.
   */
  mask_url: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * KreaReduxOutput
 */
export type SchemaFlux1KreaReduxOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseKreaFlux1ReduxInput
 */
export type SchemaFlux1KreaReduxInput = {
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to generate an image from.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
}

/**
 * KreaOutput
 */
export type SchemaFlux1KreaImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseKreaFlux1ImageToInput
 */
export type SchemaFlux1KreaImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to generate an image from.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * The strength of the initial image. Higher strength values are better for this model.
   */
  strength?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
}

/**
 * KreaReduxOutput
 */
export type SchemaFluxKreaReduxOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseKreaReduxInput
 */
export type SchemaFluxKreaReduxInput = {
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to generate an image from.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * Output
 */
export type SchemaFluxKreaImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseKreaImageToInput
 */
export type SchemaFluxKreaImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to generate an image from.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * The strength of the initial image. Higher strength values are better for this model.
   */
  strength?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * Output
 */
export type SchemaFluxKreaLoraImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * ImageToImageInput
 */
export type SchemaFluxKreaLoraImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate. This is always set to 1 for streaming output.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image Url
   *
   * URL of image to use for inpainting. or img2img
   */
  image_url: string
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.
   */
  strength?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaFluxKreaLoraInpaintingOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * InpaintInput
 */
export type SchemaFluxKreaLoraInpaintingInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate. This is always set to 1 for streaming output.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image Url
   *
   * URL of image to use for inpainting. or img2img
   */
  image_url: string
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.
   */
  strength?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Mask Url
   *
   *
   * The mask to area to Inpaint in.
   *
   */
  mask_url: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * CharacterRemixOutputV3
 */
export type SchemaIdeogramCharacterRemixOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for the random number generator
   */
  seed: number
}

/**
 * CharacterRemixInputV3
 */
export type SchemaIdeogramCharacterRemixInput = {
  /**
   * Prompt
   *
   * The prompt to remix the image with
   */
  prompt: string
  /**
   * Image Size
   *
   * The resolution of the generated image
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Style
   *
   * The style type to generate with. Cannot be used with style_codes.
   */
  style?: 'AUTO' | 'REALISTIC' | 'FICTION'
  /**
   * Expand Prompt
   *
   * Determine if MagicPrompt should be used in generating the request or not.
   */
  expand_prompt?: boolean
  /**
   * Rendering Speed
   *
   * The rendering speed to use.
   */
  rendering_speed?: 'TURBO' | 'BALANCED' | 'QUALITY'
  /**
   * Reference Mask Urls
   *
   * A set of masks to apply to the character references. Currently only 1 mask is supported, rest will be ignored. (maximum total size 10MB across all character references). The masks should be in JPEG, PNG or WebP format
   */
  reference_mask_urls?: Array<string>
  /**
   * Reference Image Urls
   *
   * A set of images to use as character references. Currently only 1 image is supported, rest will be ignored. (maximum total size 10MB across all character references). The images should be in JPEG, PNG or WebP format
   */
  reference_image_urls: Array<string>
  /**
   * Image Urls
   *
   * A set of images to use as style references (maximum total size 10MB across all style references). The images should be in JPEG, PNG or WebP format
   */
  image_urls?: Array<string> | unknown
  /**
   * Negative Prompt
   *
   * Description of what to exclude from an image. Descriptions in the prompt take precedence to descriptions in the negative prompt.
   */
  negative_prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate.
   */
  num_images?: number
  /**
   * Image URL
   *
   * The image URL to remix
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * A color palette for generation, must EITHER be specified via one of the presets (name) or explicitly via hexadecimal representations of the color with optional weights (members)
   */
  color_palette?: SchemaColorPalette | unknown
  /**
   * Style Codes
   *
   * A list of 8 character hexadecimal codes representing the style of the image. Cannot be used in conjunction with style_reference_images or style
   */
  style_codes?: Array<string> | unknown
  /**
   * Strength
   *
   * Strength of the input image in the remix
   */
  strength?: number
  /**
   * Seed
   *
   * Seed for the random number generator
   */
  seed?: number | unknown
}

/**
 * CharacterOutputV3
 */
export type SchemaIdeogramCharacterOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for the random number generator
   */
  seed: number
}

/**
 * BaseCharacterInputV3
 */
export type SchemaIdeogramCharacterInput = {
  /**
   * Prompt
   *
   * The prompt to fill the masked part of the image.
   */
  prompt: string
  /**
   * Image Size
   *
   * The resolution of the generated image
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Style
   *
   * The style type to generate with. Cannot be used with style_codes.
   */
  style?: 'AUTO' | 'REALISTIC' | 'FICTION'
  /**
   * Expand Prompt
   *
   * Determine if MagicPrompt should be used in generating the request or not.
   */
  expand_prompt?: boolean
  /**
   * Rendering Speed
   *
   * The rendering speed to use.
   */
  rendering_speed?: 'TURBO' | 'BALANCED' | 'QUALITY'
  /**
   * Reference Mask Urls
   *
   * A set of masks to apply to the character references. Currently only 1 mask is supported, rest will be ignored. (maximum total size 10MB across all character references). The masks should be in JPEG, PNG or WebP format
   */
  reference_mask_urls?: Array<string>
  /**
   * Reference Image Urls
   *
   * A set of images to use as character references. Currently only 1 image is supported, rest will be ignored. (maximum total size 10MB across all character references). The images should be in JPEG, PNG or WebP format
   */
  reference_image_urls: Array<string>
  /**
   * Image Urls
   *
   * A set of images to use as style references (maximum total size 10MB across all style references). The images should be in JPEG, PNG or WebP format
   */
  image_urls?: Array<string> | unknown
  /**
   * Negative Prompt
   *
   * Description of what to exclude from an image. Descriptions in the prompt take precedence to descriptions in the negative prompt.
   */
  negative_prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate.
   */
  num_images?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * A color palette for generation, must EITHER be specified via one of the presets (name) or explicitly via hexadecimal representations of the color with optional weights (members)
   */
  color_palette?: SchemaColorPalette | unknown
  /**
   * Style Codes
   *
   * A list of 8 character hexadecimal codes representing the style of the image. Cannot be used in conjunction with style_reference_images or style
   */
  style_codes?: Array<string> | unknown
  /**
   * Seed
   *
   * Seed for the random number generator
   */
  seed?: number | unknown
}

/**
 * CharacterEditOutputV3
 */
export type SchemaIdeogramCharacterEditOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for the random number generator
   */
  seed: number
}

/**
 * CharacterEditInputV3
 */
export type SchemaIdeogramCharacterEditInput = {
  /**
   * Prompt
   *
   * The prompt to fill the masked part of the image.
   */
  prompt: string
  /**
   * Style
   *
   * The style type to generate with. Cannot be used with style_codes.
   */
  style?: 'AUTO' | 'REALISTIC' | 'FICTION'
  /**
   * Expand Prompt
   *
   * Determine if MagicPrompt should be used in generating the request or not.
   */
  expand_prompt?: boolean
  /**
   * Rendering Speed
   *
   * The rendering speed to use.
   */
  rendering_speed?: 'TURBO' | 'BALANCED' | 'QUALITY'
  /**
   * Reference Mask Urls
   *
   * A set of masks to apply to the character references. Currently only 1 mask is supported, rest will be ignored. (maximum total size 10MB across all character references). The masks should be in JPEG, PNG or WebP format
   */
  reference_mask_urls?: Array<string>
  /**
   * Reference Image Urls
   *
   * A set of images to use as character references. Currently only 1 image is supported, rest will be ignored. (maximum total size 10MB across all character references). The images should be in JPEG, PNG or WebP format
   */
  reference_image_urls: Array<string>
  /**
   * Image Urls
   *
   * A set of images to use as style references (maximum total size 10MB across all style references). The images should be in JPEG, PNG or WebP format
   */
  image_urls?: Array<string> | unknown
  /**
   * Num Images
   *
   * Number of images to generate.
   */
  num_images?: number
  /**
   * Image URL
   *
   * The image URL to generate an image from. MUST have the exact same dimensions (width and height) as the mask image.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * A color palette for generation, must EITHER be specified via one of the presets (name) or explicitly via hexadecimal representations of the color with optional weights (members)
   */
  color_palette?: SchemaColorPalette | unknown
  /**
   * Style Codes
   *
   * A list of 8 character hexadecimal codes representing the style of the image. Cannot be used in conjunction with style_reference_images or style
   */
  style_codes?: Array<string> | unknown
  /**
   * Seed
   *
   * Seed for the random number generator
   */
  seed?: number | unknown
  /**
   * Mask URL
   *
   * The mask URL to inpaint the image. MUST have the exact same dimensions (width and height) as the input image.
   */
  mask_url: string
}

/**
 * QwenImageOutput
 */
export type SchemaQwenImageEditOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseQwenEditImageInput
 */
export type SchemaQwenImageEditInput = {
  /**
   * Prompt
   *
   * The prompt to generate the image with
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to edit.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * NextStepResponse
 */
export type SchemaNextstep1Output = {
  /**
   * Image
   *
   * Generated image
   */
  image: {
    /**
     * File Size
     *
     * The size of the file in bytes.
     */
    file_size?: number | unknown
    /**
     * Height
     *
     * The height of the image in pixels.
     */
    height?: number | unknown
    /**
     * File Name
     *
     * The name of the file. It will be auto-generated if not provided.
     */
    file_name?: string | unknown
    /**
     * Content Type
     *
     * The mime type of the file.
     */
    content_type?: string | unknown
    /**
     * Url
     *
     * The URL where the file can be downloaded from.
     */
    url: string
    /**
     * Width
     *
     * The width of the image in pixels.
     */
    width?: number | unknown
  }
  /**
   * Seed
   *
   * Seed used for random number generation
   */
  seed: number
}

/**
 * NextStepEditRequest
 */
export type SchemaNextstep1Input = {
  /**
   * Prompt
   *
   * The prompt to edit the image.
   */
  prompt: string
  /**
   * Negative Prompt
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   *
   */
  negative_prompt: string
  /**
   * Image URL
   *
   * The URL of the image to edit.
   */
  image_url: string
}

/**
 * NanoBananaImageToImageOutput
 */
export type SchemaNanoBananaEditOutput = {
  /**
   * Images
   *
   * The edited images.
   */
  images: Array<SchemaImageFile>
  /**
   * Description
   *
   * The description of the generated images.
   */
  description: string
}

/**
 * NanoBananaImageToImageInput
 */
export type SchemaNanoBananaEditInput = {
  /**
   * Prompt
   *
   * The prompt for image editing.
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | 'auto'
    | '21:9'
    | '16:9'
    | '3:2'
    | '4:3'
    | '5:4'
    | '1:1'
    | '4:5'
    | '3:4'
    | '2:3'
    | '9:16'
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Image URLs
   *
   * The URLs of the images to use for image-to-image generation or image editing.
   */
  image_urls: Array<string>
  /**
   * Limit Generations
   *
   * Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.
   */
  limit_generations?: boolean
}

/**
 * OutputModel
 */
export type SchemaReimagine32Output = {
  image: SchemaImage
}

/**
 * InputModel
 */
export type SchemaReimagine32Input = {
  /**
   * Prompt
   *
   * Prompt for image generation.
   */
  prompt: string
  /**
   * Depth Preprocess
   *
   * Depth image preprocess.
   */
  depth_preprocess?: boolean
  /**
   * Canny Preprocess
   *
   * Canny image preprocess.
   */
  canny_preprocess?: boolean
  /**
   * Depth Image Url
   *
   * Depth control image (file or URL).
   */
  depth_image_url?: string | unknown
  /**
   * Guidance Scale
   *
   * Guidance scale for text.
   */
  guidance_scale?: number
  /**
   * Canny Image Url
   *
   * Canny edge control image (file or URL).
   */
  canny_image_url?: string | unknown
  /**
   * Negative Prompt
   *
   * Negative prompt for image generation.
   */
  negative_prompt?: string
  /**
   * Depth Scale
   *
   * Depth control strength (0.0 to 1.0).
   */
  depth_scale?: number
  /**
   * Aspect Ratio
   *
   * Aspect ratio. Options: 1:1, 2:3, 3:2, 3:4, 4:3, 4:5, 5:4, 9:16, 16:9
   */
  aspect_ratio?:
    | '1:1'
    | '2:3'
    | '3:2'
    | '3:4'
    | '4:3'
    | '4:5'
    | '5:4'
    | '9:16'
    | '16:9'
  /**
   * Sync Mode
   *
   * If true, returns the image directly in the response (increases latency).
   */
  sync_mode?: boolean
  /**
   * Prompt Enhancer
   *
   * Whether to improve the prompt.
   */
  prompt_enhancer?: boolean
  /**
   * Truncate Prompt
   *
   * Whether to truncate the prompt.
   */
  truncate_prompt?: boolean
  /**
   * Seed
   *
   * Random seed for reproducibility.
   */
  seed?: number
  /**
   * Canny Scale
   *
   * Canny edge control strength (0.0 to 1.0).
   */
  canny_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps.
   */
  num_inference_steps?: number
}

/**
 * QwenImageI2IOutput
 */
export type SchemaQwenImageImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * QwenImageI2IInput
 */
export type SchemaQwenImageImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate the image with
   */
  prompt: string
  /**
   * Acceleration
   *
   * Acceleration level for image generation. Options: 'none', 'regular', 'high'. Higher acceleration increases speed. 'regular' balances speed and quality. 'high' is recommended for images without text.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Image Size
   *
   * The size of the generated image. By default, we will use the provided image for determining the image_size.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use up to 3 LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Guidance scale
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Use Turbo
   *
   * Enable turbo mode for faster generation with high quality. When enabled, uses optimized settings (10 steps, CFG=1.2).
   */
  use_turbo?: boolean
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image Url
   *
   * The reference image to guide the generation.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * Denoising strength. 1.0 = fully remake; 0.0 = preserve original.
   */
  strength?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * NanoBananaImageToImageOutput
 */
export type SchemaGemini25FlashImageEditOutput = {
  /**
   * Images
   *
   * The edited images.
   */
  images: Array<SchemaImageFile>
  /**
   * Description
   *
   * The description of the generated images.
   */
  description: string
}

/**
 * NanoBananaImageToImageInput
 */
export type SchemaGemini25FlashImageEditInput = {
  /**
   * Prompt
   *
   * The prompt for image editing.
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | 'auto'
    | '21:9'
    | '16:9'
    | '3:2'
    | '4:3'
    | '5:4'
    | '1:1'
    | '4:5'
    | '3:4'
    | '2:3'
    | '9:16'
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Image URLs
   *
   * The URLs of the images to use for image-to-image generation or image editing.
   */
  image_urls: Array<string>
  /**
   * Limit Generations
   *
   * Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.
   */
  limit_generations?: boolean
}

/**
 * USOOutputImage
 */
export type SchemaUsoOutput = {
  /**
   * Prompt
   *
   * The prompt used for generation
   */
  prompt: string
  /**
   * Images
   *
   * The generated images with applied style and/or subject customization
   */
  images: Array<SchemaImage>
  /**
   * Timings
   *
   * Performance timings for different stages
   */
  timings: {
    [key: string]: unknown
  }
  /**
   * Has Nsfw Concepts
   *
   * NSFW detection results for each generated image
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   * Seed used for generation
   */
  seed: number
}

/**
 * USOInputImage
 */
export type SchemaUsoInput = {
  /**
   * Prompt
   *
   * Text prompt for generation. Can be empty for pure style transfer.
   */
  prompt?: string
  /**
   * Number of Images
   *
   * Number of images to generate in parallel.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * Output image format. PNG preserves transparency, JPEG is smaller.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Keep Input Size
   *
   * Preserve the layout and dimensions of the input content image. Useful for style transfer.
   */
  keep_size?: boolean
  /**
   * Reference Images
   *
   * List of image URLs in order: [content_image, style_image, extra_style_image].
   */
  input_image_urls: Array<string>
  /**
   * Sync Mode
   *
   * If true, wait for generation and upload before returning. Increases latency but provides immediate access to images.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale (CFG)
   *
   * How closely to follow the prompt. Higher values stick closer to the prompt.
   */
  guidance_scale?: number
  /**
   * Inference Steps
   *
   * Number of denoising steps. More steps can improve quality but increase generation time.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * Random seed for reproducible generation. Use same seed for consistent results.
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * What you don't want in the image. Use it to exclude unwanted elements, styles, or artifacts.
   */
  negative_prompt?: string
  /**
   * Safety Checker
   *
   * Enable NSFW content detection and filtering.
   */
  enable_safety_checker?: boolean
}

/**
 * WanI2IResponse
 */
export type SchemaWanV22A14bImageToImageOutput = {
  /**
   * Prompt
   *
   * The text prompt used for image generation.
   */
  prompt?: string
  /**
   * Image
   *
   * The generated image file.
   */
  image: SchemaFile
  /**
   * Seed
   *
   * The seed used for generation.
   */
  seed: number
}

/**
 * WanI2IRequest
 */
export type SchemaWanV22A14bImageToImageInput = {
  /**
   * Prompt
   *
   * The text prompt to guide image generation.
   */
  prompt: string
  /**
   * Shift
   */
  shift?: number
  /**
   * Image Size
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * Acceleration level to use. The more acceleration, the faster the generation, but with lower quality. The recommended value is 'regular'.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Enable Safety Checker
   *
   * If set to true, input data will be checked for safety before processing.
   */
  enable_safety_checker?: boolean
  /**
   * Guidance Scale
   *
   * Classifier-free guidance scale.
   */
  guidance_scale?: number
  /**
   * Image Format
   *
   * The format of the output image.
   */
  image_format?: 'png' | 'jpeg'
  /**
   * Negative Prompt
   *
   * Negative prompt for video generation.
   */
  negative_prompt?: string
  /**
   * Aspect Ratio
   *
   * Aspect ratio of the generated image. If 'auto', the aspect ratio will be determined automatically based on the input image.
   */
  aspect_ratio?: 'auto' | '16:9' | '9:16' | '1:1'
  /**
   * Enable Output Safety Checker
   *
   * If set to true, output video will be checked for safety after generation.
   */
  enable_output_safety_checker?: boolean
  /**
   * Image URL
   *
   * URL of the input image.
   */
  image_url: string
  /**
   * Strength
   *
   * Denoising strength. 1.0 = fully remake; 0.0 = preserve original.
   */
  strength?: number
  /**
   * Guidance Scale (2nd Stage)
   *
   * Guidance scale for the second stage of the model. This is used to control the adherence to the prompt in the second stage of the model.
   */
  guidance_scale_2?: number
  /**
   * Enable Prompt Expansion
   *
   * Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.
   */
  enable_prompt_expansion?: boolean
  /**
   * Number of Inference Steps
   *
   * Number of inference steps for sampling. Higher values give better quality but take longer.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. If None, a random seed is chosen.
   */
  seed?: number
}

/**
 * SeedDream4EditOutput
 */
export type SchemaBytedanceSeedreamV4EditOutput = {
  /**
   * Images
   *
   * Generated images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * Seed used for generation
   */
  seed: number
}

/**
 * SeedDream4EditInput
 */
export type SchemaBytedanceSeedreamV4EditInput = {
  /**
   * Prompt
   *
   * The text prompt used to edit the image
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of separate model generations to be run with the prompt.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. The minimum total image area is 921600 pixels. Failing this, the image size will be adjusted to by scaling it up, while maintaining the aspect ratio.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | 'auto'
    | 'auto_2K'
    | 'auto_4K'
  /**
   * Enhance Prompt Mode
   *
   * The mode to use for enhancing prompt enhancement. Standard mode provides higher quality results but takes longer to generate. Fast mode provides average quality results but takes less time to generate.
   */
  enhance_prompt_mode?: 'standard' | 'fast'
  /**
   * Max Images
   *
   * If set to a number greater than one, enables multi-image generation. The model will potentially return up to `max_images` images every generation, and in total, `num_images` generations will be carried out. In total, the number of images generated will be between `num_images` and `max_images*num_images`. The total number of images (image inputs + image outputs) must not exceed 15
   */
  max_images?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * Random seed to control the stochasticity of image generation.
   */
  seed?: number
  /**
   * Image URLs
   *
   * List of URLs of input images for editing. Presently, up to 10 image inputs are allowed. If over 10 images are sent, only the last 10 will be used.
   */
  image_urls: Array<string>
}

/**
 * ReferenceToImageOutput
 */
export type SchemaViduReferenceToImageOutput = {
  /**
   * Image
   *
   * The edited image
   */
  image: SchemaImage
}

/**
 * ReferenceToImageRequest
 */
export type SchemaViduReferenceToImageInput = {
  /**
   * Prompt
   *
   * Text prompt for video generation, max 1500 characters
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the output video
   */
  aspect_ratio?: '16:9' | '9:16' | '1:1'
  /**
   * Reference Image Urls
   *
   * URLs of the reference images to use for consistent subject appearance
   */
  reference_image_urls: Array<string>
  /**
   * Seed
   *
   * Random seed for generation
   */
  seed?: number
}

/**
 * QwenImageOutput
 */
export type SchemaQwenImageEditLoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseQwenEditImageLoRAInput
 */
export type SchemaQwenImageEditLoraInput = {
  /**
   * Prompt
   *
   * The prompt to generate the image with
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to edit.
   */
  image_url: string
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use up to 3 LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Guidance scale
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaFlux1SrpoImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseSRPOFlux1ImageToInput
 */
export type SchemaFlux1SrpoImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to generate an image from.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * The strength of the initial image. Higher strength values are better for this model.
   */
  strength?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
}

/**
 * Output
 */
export type SchemaFluxSrpoImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseSRPOImageToInput
 */
export type SchemaFluxSrpoImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to generate an image from.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * The strength of the initial image. Higher strength values are better for this model.
   */
  strength?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * QwenImageInpaintOutput
 */
export type SchemaQwenImageEditInpaintOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseQwenEditInpaintImageInput
 */
export type SchemaQwenImageEditInpaintInput = {
  /**
   * Prompt
   *
   * The prompt to generate the image with
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Guidance scale
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to edit.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * Strength of noising process for inpainting
   */
  strength?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Mask URL
   *
   * The URL of the mask for inpainting
   */
  mask_url: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * MakeupApplicationOutput
 */
export type SchemaImageAppsV2MakeupApplicationOutput = {
  /**
   * Images
   *
   * Portrait with applied makeup
   */
  images: Array<SchemaImage>
  /**
   * Inference Time Ms
   *
   * Total inference time in milliseconds
   */
  inference_time_ms: number
}

/**
 * MakeupApplicationInput
 */
export type SchemaImageAppsV2MakeupApplicationInput = {
  aspect_ratio?: SchemaAspectRatio
  /**
   * Intensity
   */
  intensity?: 'light' | 'medium' | 'heavy' | 'dramatic'
  /**
   * Makeup Style
   */
  makeup_style?:
    | 'natural'
    | 'glamorous'
    | 'smoky_eyes'
    | 'bold_lips'
    | 'no_makeup'
    | 'remove_makeup'
    | 'dramatic'
    | 'bridal'
    | 'professional'
    | 'korean_style'
    | 'artistic'
  /**
   * Image Url
   *
   * Portrait image URL for makeup application
   */
  image_url: string
}

/**
 * AspectRatio
 *
 * Aspect ratio model that calculates 4K resolution dimensions
 */
export type SchemaAspectRatio = {
  /**
   * Ratio
   *
   * Aspect ratio for 4K resolution output
   */
  ratio?: '1:1' | '16:9' | '9:16' | '4:3' | '3:4'
}

/**
 * AgeModifyOutput
 */
export type SchemaImageAppsV2AgeModifyOutput = {
  /**
   * Images
   *
   * Portrait with modified age
   */
  images: Array<SchemaImage>
  /**
   * Inference Time Ms
   *
   * Total inference time in milliseconds
   */
  inference_time_ms: number
}

/**
 * AgeModifyInput
 */
export type SchemaImageAppsV2AgeModifyInput = {
  /**
   * Image Url
   *
   * Portrait image URL for age modification
   */
  image_url: string
  aspect_ratio?: SchemaAspectRatio
  /**
   * Preserve Identity
   */
  preserve_identity?: boolean
  /**
   * Target Age
   */
  target_age?: number
}

/**
 * CityTeleportOutput
 */
export type SchemaImageAppsV2CityTeleportOutput = {
  /**
   * Images
   *
   * Person teleported to city location
   */
  images: Array<SchemaImage>
  /**
   * Inference Time Ms
   *
   * Total inference time in milliseconds
   */
  inference_time_ms: number
}

/**
 * CityTeleportInput
 */
export type SchemaImageAppsV2CityTeleportInput = {
  /**
   * City Image Url
   *
   * Optional city background image URL. When provided, the person will be blended into this custom scene.
   */
  city_image_url?: string | unknown
  aspect_ratio?: SchemaAspectRatio
  /**
   * City Name
   *
   * City name (used when city_image_url is not provided)
   */
  city_name: string
  /**
   * Photo Shot
   *
   * Type of photo shot
   */
  photo_shot?:
    | 'extreme_close_up'
    | 'close_up'
    | 'medium_close_up'
    | 'medium_shot'
    | 'medium_long_shot'
    | 'long_shot'
    | 'extreme_long_shot'
    | 'full_body'
  /**
   * Camera Angle
   *
   * Camera angle for the shot
   */
  camera_angle?:
    | 'eye_level'
    | 'low_angle'
    | 'high_angle'
    | 'dutch_angle'
    | 'birds_eye_view'
    | 'worms_eye_view'
    | 'overhead'
    | 'side_angle'
  /**
   * Person Image Url
   *
   * Person photo URL
   */
  person_image_url: string
}

/**
 * ExpressionChangeOutput
 */
export type SchemaImageAppsV2ExpressionChangeOutput = {
  /**
   * Images
   *
   * Portrait with changed expression
   */
  images: Array<SchemaImage>
  /**
   * Inference Time Ms
   *
   * Total inference time in milliseconds
   */
  inference_time_ms: number
}

/**
 * ExpressionChangeInput
 */
export type SchemaImageAppsV2ExpressionChangeInput = {
  aspect_ratio?: SchemaAspectRatio
  /**
   * Target Expression
   */
  target_expression?:
    | 'smile'
    | 'surprise'
    | 'glare'
    | 'panic'
    | 'shyness'
    | 'laugh'
    | 'cry'
    | 'angry'
    | 'sad'
    | 'happy'
    | 'excited'
    | 'shocked'
    | 'confused'
    | 'focused'
    | 'dreamy'
    | 'serious'
    | 'playful'
    | 'mysterious'
    | 'confident'
    | 'thoughtful'
  /**
   * Image Url
   *
   * Portrait image URL for expression change
   */
  image_url: string
}

/**
 * HairChangeOutput
 */
export type SchemaImageAppsV2HairChangeOutput = {
  /**
   * Images
   *
   * Portrait with changed hair
   */
  images: Array<SchemaImage>
  /**
   * Inference Time Ms
   *
   * Total inference time in milliseconds
   */
  inference_time_ms: number
}

/**
 * HairChangeInput
 */
export type SchemaImageAppsV2HairChangeInput = {
  /**
   * Target Hairstyle
   */
  target_hairstyle?:
    | 'short_hair'
    | 'medium_long_hair'
    | 'long_hair'
    | 'curly_hair'
    | 'wavy_hair'
    | 'high_ponytail'
    | 'bun'
    | 'bob_cut'
    | 'pixie_cut'
    | 'braids'
    | 'straight_hair'
    | 'afro'
    | 'dreadlocks'
    | 'buzz_cut'
    | 'mohawk'
    | 'bangs'
    | 'side_part'
    | 'middle_part'
  aspect_ratio?: SchemaAspectRatio
  /**
   * Hair Color
   */
  hair_color?:
    | 'black'
    | 'dark_brown'
    | 'light_brown'
    | 'blonde'
    | 'platinum_blonde'
    | 'red'
    | 'auburn'
    | 'gray'
    | 'silver'
    | 'blue'
    | 'green'
    | 'purple'
    | 'pink'
    | 'rainbow'
    | 'natural'
    | 'highlights'
    | 'ombre'
    | 'balayage'
  /**
   * Image Url
   *
   * Portrait image URL for hair change
   */
  image_url: string
}

/**
 * HeadshotOutput
 */
export type SchemaImageAppsV2HeadshotPhotoOutput = {
  /**
   * Images
   *
   * Professional headshot image
   */
  images: Array<SchemaImage>
  /**
   * Inference Time Ms
   *
   * Total inference time in milliseconds
   */
  inference_time_ms: number
}

/**
 * HeadshotInput
 */
export type SchemaImageAppsV2HeadshotPhotoInput = {
  aspect_ratio?: SchemaAspectRatio
  /**
   * Background Style
   */
  background_style?: 'professional' | 'corporate' | 'clean' | 'gradient'
  /**
   * Image Url
   *
   * Portrait image URL to convert to professional headshot
   */
  image_url: string
}

/**
 * ObjectRemovalOutput
 */
export type SchemaImageAppsV2ObjectRemovalOutput = {
  /**
   * Images
   *
   * Image with object removed
   */
  images: Array<SchemaImage>
  /**
   * Inference Time Ms
   *
   * Total inference time in milliseconds
   */
  inference_time_ms: number
}

/**
 * ObjectRemovalInput
 */
export type SchemaImageAppsV2ObjectRemovalInput = {
  aspect_ratio?: SchemaAspectRatio
  /**
   * Object To Remove
   *
   * Object to remove
   */
  object_to_remove: string
  /**
   * Image Url
   *
   * Image URL containing object to remove
   */
  image_url: string
}

/**
 * PerspectiveOutput
 */
export type SchemaImageAppsV2PerspectiveOutput = {
  /**
   * Images
   *
   * Image with changed perspective
   */
  images: Array<SchemaImage>
  /**
   * Inference Time Ms
   *
   * Total inference time in milliseconds
   */
  inference_time_ms: number
}

/**
 * PerspectiveInput
 */
export type SchemaImageAppsV2PerspectiveInput = {
  aspect_ratio?: SchemaAspectRatio
  /**
   * Target Perspective
   */
  target_perspective?:
    | 'front'
    | 'left_side'
    | 'right_side'
    | 'back'
    | 'top_down'
    | 'bottom_up'
    | 'birds_eye'
    | 'three_quarter_left'
    | 'three_quarter_right'
  /**
   * Image Url
   *
   * Image URL for perspective change
   */
  image_url: string
}

/**
 * PhotographyEffectsOutput
 */
export type SchemaImageAppsV2PhotographyEffectsOutput = {
  /**
   * Images
   *
   * Image with photography effects
   */
  images: Array<SchemaImage>
  /**
   * Inference Time Ms
   *
   * Total inference time in milliseconds
   */
  inference_time_ms: number
}

/**
 * PhotographyEffectsInput
 */
export type SchemaImageAppsV2PhotographyEffectsInput = {
  /**
   * Effect Type
   */
  effect_type?:
    | 'film'
    | 'vintage_film'
    | 'portrait_photography'
    | 'fashion_photography'
    | 'street_photography'
    | 'sepia_tone'
    | 'film_grain'
    | 'light_leaks'
    | 'vignette_effect'
    | 'instant_camera'
    | 'golden_hour'
    | 'dramatic_lighting'
    | 'soft_focus'
    | 'bokeh_effect'
    | 'high_contrast'
    | 'double_exposure'
  aspect_ratio?: SchemaAspectRatio
  /**
   * Image Url
   *
   * Image URL for photography effects
   */
  image_url: string
}

/**
 * PortraitOutput
 */
export type SchemaImageAppsV2PortraitEnhanceOutput = {
  /**
   * Images
   *
   * Enhanced portrait
   */
  images: Array<SchemaImage>
  /**
   * Inference Time Ms
   *
   * Total inference time in milliseconds
   */
  inference_time_ms: number
}

/**
 * PortraitInput
 */
export type SchemaImageAppsV2PortraitEnhanceInput = {
  aspect_ratio?: SchemaAspectRatio
  /**
   * Image Url
   *
   * Portrait image URL to enhance
   */
  image_url: string
}

/**
 * PhotoRestorationOutput
 */
export type SchemaImageAppsV2PhotoRestorationOutput = {
  /**
   * Images
   *
   * Restored photo
   */
  images: Array<SchemaImage>
  /**
   * Inference Time Ms
   *
   * Total inference time in milliseconds
   */
  inference_time_ms: number
}

/**
 * PhotoRestorationInput
 */
export type SchemaImageAppsV2PhotoRestorationInput = {
  /**
   * Enhance Resolution
   */
  enhance_resolution?: boolean
  aspect_ratio?: SchemaAspectRatio
  /**
   * Remove Scratches
   */
  remove_scratches?: boolean
  /**
   * Fix Colors
   */
  fix_colors?: boolean
  /**
   * Image Url
   *
   * Old or damaged photo URL to restore
   */
  image_url: string
}

/**
 * StyleTransferOutput
 */
export type SchemaImageAppsV2StyleTransferOutput = {
  /**
   * Images
   *
   * Image with transferred style
   */
  images: Array<SchemaImage>
  /**
   * Inference Time Ms
   *
   * Total inference time in milliseconds
   */
  inference_time_ms: number
}

/**
 * StyleTransferInput
 */
export type SchemaImageAppsV2StyleTransferInput = {
  /**
   * Target Style
   */
  target_style?:
    | 'anime_character'
    | 'cartoon_3d'
    | 'hand_drawn_animation'
    | 'cyberpunk_future'
    | 'anime_game_style'
    | 'comic_book_animation'
    | 'animated_series'
    | 'cartoon_animation'
    | 'lofi_aesthetic'
    | 'cottagecore'
    | 'dark_academia'
    | 'y2k'
    | 'vaporwave'
    | 'liminal_space'
    | 'weirdcore'
    | 'dreamcore'
    | 'synthwave'
    | 'outrun'
    | 'photorealistic'
    | 'hyperrealistic'
    | 'digital_art'
    | 'concept_art'
    | 'impressionist'
    | 'anime'
    | 'pixel_art'
    | 'claymation'
  aspect_ratio?: SchemaAspectRatio
  /**
   * Style Reference Image Url
   *
   * Optional reference image URL. When provided, the style will be inferred from this image instead of the selected preset style.
   */
  style_reference_image_url?: string | unknown
  /**
   * Image Url
   *
   * Image URL for style transfer
   */
  image_url: string
}

/**
 * RelightingOutput
 */
export type SchemaImageAppsV2RelightingOutput = {
  /**
   * Images
   *
   * Image with new lighting
   */
  images: Array<SchemaImage>
  /**
   * Inference Time Ms
   *
   * Total inference time in milliseconds
   */
  inference_time_ms: number
}

/**
 * RelightingInput
 */
export type SchemaImageAppsV2RelightingInput = {
  aspect_ratio?: SchemaAspectRatio
  /**
   * Lighting Style
   */
  lighting_style?:
    | 'natural'
    | 'studio'
    | 'golden_hour'
    | 'blue_hour'
    | 'dramatic'
    | 'soft'
    | 'hard'
    | 'backlight'
    | 'side_light'
    | 'front_light'
    | 'rim_light'
    | 'sunset'
    | 'sunrise'
    | 'neon'
    | 'candlelight'
    | 'moonlight'
    | 'spotlight'
    | 'ambient'
  /**
   * Image Url
   *
   * Image URL for relighting
   */
  image_url: string
}

/**
 * TextureTransformOutput
 */
export type SchemaImageAppsV2TextureTransformOutput = {
  /**
   * Images
   *
   * Image with transformed texture
   */
  images: Array<SchemaImage>
  /**
   * Inference Time Ms
   *
   * Total inference time in milliseconds
   */
  inference_time_ms: number
}

/**
 * TextureTransformInput
 */
export type SchemaImageAppsV2TextureTransformInput = {
  /**
   * Target Texture
   */
  target_texture?:
    | 'cotton'
    | 'denim'
    | 'wool'
    | 'felt'
    | 'wood'
    | 'leather'
    | 'velvet'
    | 'stone'
    | 'marble'
    | 'ceramic'
    | 'concrete'
    | 'brick'
    | 'clay'
    | 'foam'
    | 'glass'
    | 'metal'
    | 'silk'
    | 'fabric'
    | 'crystal'
    | 'rubber'
    | 'plastic'
    | 'lace'
  aspect_ratio?: SchemaAspectRatio
  /**
   * Image Url
   *
   * Image URL for texture transformation
   */
  image_url: string
}

/**
 * VirtualTryOnOutput
 */
export type SchemaImageAppsV2VirtualTryOnOutput = {
  /**
   * Images
   *
   * Person wearing the virtual clothing
   */
  images: Array<SchemaImage>
  /**
   * Inference Time Ms
   *
   * Total inference time in milliseconds
   */
  inference_time_ms: number
}

/**
 * VirtualTryOnInput
 */
export type SchemaImageAppsV2VirtualTryOnInput = {
  /**
   * Preserve Pose
   */
  preserve_pose?: boolean
  aspect_ratio?: SchemaAspectRatio
  /**
   * Clothing Image Url
   *
   * Clothing photo URL
   */
  clothing_image_url: string
  /**
   * Person Image Url
   *
   * Person photo URL
   */
  person_image_url: string
}

/**
 * ProductPhotographyOutput
 */
export type SchemaImageAppsV2ProductPhotographyOutput = {
  /**
   * Images
   *
   * Professional studio product photography
   */
  images: Array<SchemaImage>
  /**
   * Inference Time Ms
   *
   * Total inference time in milliseconds
   */
  inference_time_ms: number
}

/**
 * ProductPhotographyInput
 */
export type SchemaImageAppsV2ProductPhotographyInput = {
  aspect_ratio?: SchemaAspectRatio
  /**
   * Product Image Url
   *
   * Image URL of the product to create professional studio photography
   */
  product_image_url: string
}

/**
 * ProductHoldingOutput
 */
export type SchemaImageAppsV2ProductHoldingOutput = {
  /**
   * Images
   *
   * Person holding the product naturally
   */
  images: Array<SchemaImage>
  /**
   * Inference Time Ms
   *
   * Total inference time in milliseconds
   */
  inference_time_ms: number
}

/**
 * ProductHoldingInput
 */
export type SchemaImageAppsV2ProductHoldingInput = {
  aspect_ratio?: SchemaAspectRatio
  /**
   * Product Image Url
   *
   * Image URL of the product to be held by the person
   */
  product_image_url: string
  /**
   * Person Image Url
   *
   * Image URL of the person who will hold the product
   */
  person_image_url: string
}

/**
 * SeedVRImageOutput
 */
export type SchemaSeedvrUpscaleImageOutput = {
  image: SchemaImageFile
  /**
   * Seed
   *
   * The random seed used for the generation process.
   */
  seed: number
}

/**
 * SeedVRImageInput
 */
export type SchemaSeedvrUpscaleImageInput = {
  /**
   * Upscale Mode
   *
   * The mode to use for the upscale. If 'target', the upscale factor will be calculated based on the target resolution. If 'factor', the upscale factor will be used directly.
   */
  upscale_mode?: 'target' | 'factor'
  /**
   * Noise Scale
   *
   * The noise scale to use for the generation process.
   */
  noise_scale?: number
  /**
   * Output Format
   *
   * The format of the output image.
   */
  output_format?: 'png' | 'jpg' | 'webp'
  /**
   * Target Resolution
   *
   * The target resolution to upscale to when `upscale_mode` is `target`.
   */
  target_resolution?: '720p' | '1080p' | '1440p' | '2160p'
  /**
   * Image Url
   *
   * The input image to be processed
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Upscale Factor
   *
   * Upscaling factor to be used. Will multiply the dimensions with this factor when `upscale_mode` is `factor`.
   */
  upscale_factor?: number
  /**
   * Seed
   *
   * The random seed used for the generation process.
   */
  seed?: number | unknown
}

/**
 * QwenImageOutput
 */
export type SchemaQwenImageEditPlusOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * BaseQwenEditImagePlusInput
 */
export type SchemaQwenImageEditPlusInput = {
  /**
   * Prompt
   *
   * The prompt to generate the image with
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Image URLs
   *
   * The URLs of the images to edit.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * ImageToImageOutput
 *
 * Output for image editing
 */
export type SchemaWan25PreviewImageToImageOutput = {
  /**
   * Images
   *
   * The edited images
   */
  images: Array<SchemaImageFile>
  /**
   * Seeds
   *
   * The seeds used for each generated image
   */
  seeds: Array<number>
  /**
   * Actual Prompt
   *
   * The original prompt (prompt expansion is not available for image editing)
   */
  actual_prompt?: string
}

/**
 * ImageToImageInput
 *
 * Input for image editing
 */
export type SchemaWan25PreviewImageToImageInput = {
  /**
   * Prompt
   *
   * The text prompt describing how to edit the image. Max 2000 characters.
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of images to generate. Values from 1 to 4.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. Width and height must be between 384 and 1440 pixels.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * Random seed for reproducibility. If None, a random seed is chosen.
   */
  seed?: number
  /**
   * Image Urls
   *
   * URLs of images to edit. For single-image editing, provide 1 URL. For multi-reference generation, provide up to 2 URLs. If more than 2 URLs are provided, only the first 2 will be used.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * Negative prompt to describe content to avoid. Max 500 characters.
   */
  negative_prompt?: string
}

/**
 * QwenImageOutput
 */
export type SchemaQwenImageEditImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseQwenEditImg2ImgInput
 */
export type SchemaQwenImageEditImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate the image with
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to edit.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * Strength of the image-to-image transformation. Lower values preserve more of the original image.
   */
  strength?: number
  /**
   * Guidance scale
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * LucidFluxResponse
 */
export type SchemaLucidfluxOutput = {
  /**
   * Image
   *
   * Generated image
   */
  image: SchemaImage
  /**
   * Seed
   *
   * Seed used for random number generation
   */
  seed: number
}

/**
 * LucidFluxRequest
 */
export type SchemaLucidfluxInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image.
   */
  prompt: string
  /**
   * Guidance
   *
   * The guidance to use for the diffusion process.
   */
  guidance?: number
  /**
   * Target Height
   *
   * The height of the output image.
   */
  target_height?: number
  /**
   * Image URL
   *
   * The URL of the image to edit.
   */
  image_url: string
  /**
   * Target Width
   *
   * The width of the output image.
   */
  target_width?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling. Higher values give better quality but take longer.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * Seed used for random number generation
   */
  seed?: number
}

/**
 * QwenImageOutput
 */
export type SchemaQwenImageEditPlusLoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * BaseQwenEditImagePlusLoRAInput
 */
export type SchemaQwenImageEditPlusLoraInput = {
  /**
   * Prompt
   *
   * The prompt to generate the image with
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used to calculate the size of the output image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use up to 3 LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Image URLs
   *
   * The URLs of the images to edit.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * DreamOmni2Response
 */
export type SchemaDreamomni2EditOutput = {
  /**
   * Image
   *
   * Generated image
   */
  image: SchemaImage
}

/**
 * DreamOmni2Request
 */
export type SchemaDreamomni2EditInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image.
   */
  prompt: string
  /**
   * You can use only with to 2 images.
   *
   * List of URLs of input images for editing.
   */
  image_urls: Array<string>
}

/**
 * Image2PixelOutput
 */
export type SchemaImage2PixelOutput = {
  /**
   * Images
   *
   * The processed pixel-art image (PNG) and the scaled image (PNG).
   */
  images: Array<SchemaImageFile>
  /**
   * Num Colors
   *
   * The number of colors in the processed media.
   */
  num_colors: number
  /**
   * Palette
   *
   * The palette of the processed media.
   */
  palette: Array<string>
  /**
   * Pixel Scale
   *
   * The detected pixel scale of the input.
   */
  pixel_scale: number
}

/**
 * Image2PixelInput
 */
export type SchemaImage2PixelInput = {
  /**
   * Cleanup Morph
   *
   * Apply morphological operations to remove noise.
   */
  cleanup_morph?: boolean
  /**
   * Auto Color Detect
   *
   * Enable automatic detection of optimal number of colors.
   */
  auto_color_detect?: boolean
  /**
   * Alpha Threshold
   *
   * Alpha binarization threshold (0-255).
   */
  alpha_threshold?: number
  /**
   * Snap Grid
   *
   * Align output to the pixel grid.
   */
  snap_grid?: boolean
  /**
   * Fixed Palette
   *
   * Optional fixed color palette as hex strings (e.g., ['#000000', '#ffffff']).
   */
  fixed_palette?: Array<string>
  /**
   * Scale
   *
   * Force a specific pixel scale. If None, auto-detect.
   */
  scale?: number
  /**
   * Cleanup Jaggy
   *
   * Remove isolated diagonal pixels (jaggy edge cleanup).
   */
  cleanup_jaggy?: boolean
  /**
   * Trim Borders
   *
   * Trim borders of the image.
   */
  trim_borders?: boolean
  /**
   * Background Tolerance
   *
   * Background tolerance (0-255).
   */
  background_tolerance?: number
  /**
   * Detect Method
   *
   * Scale detection method to use.
   */
  detect_method?: 'auto' | 'runs' | 'edge'
  /**
   * Transparent Background
   *
   * Remove background of the image. This will check for contiguous color regions from the edges after correction and make them transparent.
   */
  transparent_background?: boolean
  /**
   * Downscale Method
   *
   * Downscaling method to produce the pixel-art output.
   */
  downscale_method?:
    | 'dominant'
    | 'median'
    | 'mode'
    | 'mean'
    | 'content-adaptive'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Image Url
   *
   * The image URL to process into improved pixel art
   */
  image_url: string
  /**
   * Background Mode
   *
   * Controls where to flood-fill from when removing the background.
   */
  background_mode?: 'edges' | 'corners' | 'midpoints'
  /**
   * Max Colors
   *
   * Maximum number of colors in the output palette. Set None to disable limit.
   */
  max_colors?: number
  /**
   * Dominant Color Threshold
   *
   * Dominant color threshold (0.0-1.0).
   */
  dominant_color_threshold?: number
}

/**
 * ReveEditOutput
 *
 * Output for Reve image editing
 */
export type SchemaReveEditOutput = {
  /**
   * Images
   *
   * The edited images
   */
  images: Array<SchemaImage>
}

/**
 * ReveEditInput
 *
 * Input for Reve image editing
 */
export type SchemaReveEditInput = {
  /**
   * Prompt
   *
   * The text description of how to edit the provided image.
   */
  prompt: string
  /**
   * Number of Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Output Format
   *
   * Output format for the generated image.
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Reference Image URL
   *
   * URL of the reference image to edit. Must be publicly accessible or base64 data URI. Supports PNG, JPEG, WebP, AVIF, and HEIF formats.
   */
  image_url: string
}

/**
 * ReveRemixOutput
 *
 * Output for Reve image remixing
 */
export type SchemaReveRemixOutput = {
  /**
   * Images
   *
   * The remixed images
   */
  images: Array<SchemaImage>
}

/**
 * ReveRemixInput
 *
 * Input for Reve image remixing
 */
export type SchemaReveRemixInput = {
  /**
   * Prompt
   *
   * The text description of the desired image. May include XML img tags like <img>0</img> to refer to specific images by their index in the image_urls list.
   */
  prompt: string
  /**
   * Number of Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Aspect Ratio
   *
   * The desired aspect ratio of the generated image. If not provided, will be smartly chosen by the model.
   */
  aspect_ratio?: '16:9' | '9:16' | '3:2' | '2:3' | '4:3' | '3:4' | '1:1'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Reference Image URLs
   *
   * List of URLs of reference images. Must provide between 1 and 6 images (inclusive). Each image must be less than 10 MB. Supports PNG, JPEG, WebP, AVIF, and HEIF formats.
   */
  image_urls: Array<string>
  /**
   * Output Format
   *
   * Output format for the generated image.
   */
  output_format?: 'png' | 'jpeg' | 'webp'
}

/**
 * EditImageResponseMini
 */
export type SchemaGptImage1MiniEditOutput = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImageFile>
}

/**
 * EditImageRequestMini
 */
export type SchemaGptImage1MiniEditInput = {
  /**
   * Prompt
   *
   * The prompt for image generation
   */
  prompt: string
  /**
   * Number of Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * Aspect ratio for the generated image
   */
  image_size?: 'auto' | '1024x1024' | '1536x1024' | '1024x1536'
  /**
   * Background
   *
   * Background for the generated image
   */
  background?: 'auto' | 'transparent' | 'opaque'
  /**
   * Quality
   *
   * Quality for the generated image
   */
  quality?: 'auto' | 'low' | 'medium' | 'high'
  /**
   * Output Format
   *
   * Output format for the images
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Image URLs
   *
   * The URLs of the images to use as a reference for the generation.
   */
  image_urls: Array<string>
}

/**
 * ChronoEditOutput
 *
 * Unified output model for all ChronoEdit operations
 */
export type SchemaChronoEditOutput = {
  /**
   * Prompt
   *
   * The prompt used for the inference.
   */
  prompt: string
  /**
   * Images
   *
   * The edited image.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * The seed for the inference.
   */
  seed: number
}

/**
 * ChronoEditInput
 *
 * Input model for ChronoEdit standard editing operations
 */
export type SchemaChronoEditInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image.
   */
  prompt: string
  /**
   * Resolution
   *
   * The resolution of the output image.
   */
  resolution?: '480p' | '720p'
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker.
   */
  enable_safety_checker?: boolean
  /**
   * Output Format
   *
   * The format of the output image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Image URL
   *
   * The image to edit.
   */
  image_url: string
  /**
   * Turbo Mode
   *
   * Enable turbo mode to use for faster inference.
   */
  turbo_mode?: boolean
  /**
   * Number of Temporal Reasoning Steps
   *
   * The number of temporal reasoning steps to perform.
   */
  num_temporal_reasoning_steps?: number
  /**
   * Sync Mode
   *
   * Whether to return the image in sync mode.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The guidance scale for the inference.
   */
  guidance_scale?: number
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Enable Temporal Reasoning
   *
   * Whether to enable temporal reasoning.
   */
  enable_temporal_reasoning?: boolean
  /**
   * Enable Prompt Expansion
   *
   * Whether to enable prompt expansion.
   */
  enable_prompt_expansion?: boolean
  /**
   * Seed
   *
   * The seed for the inference.
   */
  seed?: number
}

/**
 * Emu35EditOutput
 */
export type SchemaEmu35ImageEditImageOutput = {
  /**
   * Images
   *
   * The edited image.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * The seed for the inference.
   */
  seed: number
}

/**
 * Emu35ImageEditInput
 */
export type SchemaEmu35ImageEditImageInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image.
   */
  prompt: string
  /**
   * Resolution
   *
   * The resolution of the output image.
   */
  resolution?: '480p' | '720p'
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the output image.
   */
  aspect_ratio?:
    | 'auto'
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the output image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Image URL
   *
   * The image to edit.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * Whether to return the image in sync mode.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * The seed for the inference.
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaFluxVisionUpscalerOutput = {
  /**
   * The URL of the generated image.
   */
  image: SchemaImage
  /**
   * Caption
   *
   * The VLM-generated caption describing the upscaled image.
   */
  caption: string
  /**
   * Seed
   *
   * The seed used to generate the image.
   */
  seed: number
  /**
   * Timings
   *
   * The timings of the different steps in the workflow.
   */
  timings: {
    [key: string]: number
  }
}

/**
 * Input
 */
export type SchemaFluxVisionUpscalerInput = {
  /**
   * Guidance
   *
   * CFG/guidance scale (1-4). Controls how closely the model follows the prompt.
   */
  guidance?: number
  /**
   * Creativity
   *
   * The creativity of the model. The higher the creativity, the more the model will deviate from the original. Refers to the denoise strength of the sampling.
   */
  creativity?: number
  /**
   * Image Url
   *
   * The URL of the image to upscale.
   */
  image_url: string
  /**
   * Upscale Factor
   *
   * The upscale factor (1-4x).
   */
  upscale_factor?: number
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * The seed to use for the upscale. If not provided, a random seed will be used.
   */
  seed?: number | unknown
  /**
   * Steps
   *
   * Number of inference steps (4-50).
   */
  steps?: number
}

/**
 * OutpaintOutput
 */
export type SchemaImageAppsV2OutpaintOutput = {
  /**
   * Images
   *
   * Outpainted image with extended scene
   */
  images: Array<SchemaImage>
}

/**
 * OutpaintInput
 */
export type SchemaImageAppsV2OutpaintInput = {
  /**
   * Prompt
   *
   * Optional prompt to guide the outpainting. If provided, it will be appended to the base outpaint instruction. Example: 'with a beautiful sunset in the background'
   */
  prompt?: string
  /**
   * Expand Right
   *
   * Number of pixels to add as black margin on the right side (0-700).
   */
  expand_right?: number
  /**
   * Num Images
   *
   * Number of images to generate.
   */
  num_images?: number
  /**
   * Zoom Out Percentage
   *
   * Percentage to zoom out the image. If set, the image will be scaled down by this percentage and black margins will be added to maintain original size. Example: 50 means the image will be 50% of original size with black margins filling the rest.
   */
  zoom_out_percentage?: number
  /**
   * Output Format
   *
   * The format of the output image.
   */
  output_format?: 'png' | 'jpeg' | 'jpg' | 'webp'
  /**
   * Image Url
   *
   * Image URL to outpaint
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If True, the function will wait for the image to be generated and uploaded before returning the response. If False, the function will return immediately and the image will be generated asynchronously.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Expand Left
   *
   * Number of pixels to add as black margin on the left side (0-700).
   */
  expand_left?: number
  /**
   * Expand Bottom
   *
   * Number of pixels to add as black margin on the bottom side (0-700).
   */
  expand_bottom?: number
  /**
   * Expand Top
   *
   * Number of pixels to add as black margin on the top side (0-700).
   */
  expand_top?: number
}

/**
 * ReveFastEditOutput
 *
 * Output for Reve fast image editing
 */
export type SchemaReveFastEditOutput = {
  /**
   * Images
   *
   * The edited images
   */
  images: Array<SchemaImage>
}

/**
 * ReveFastEditInput
 *
 * Input for Reve fast image editing
 */
export type SchemaReveFastEditInput = {
  /**
   * Prompt
   *
   * The text description of how to edit the provided image.
   */
  prompt: string
  /**
   * Number of Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Output Format
   *
   * Output format for the generated image.
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Reference Image URL
   *
   * URL of the reference image to edit. Must be publicly accessible or base64 data URI. Supports PNG, JPEG, WebP, AVIF, and HEIF formats.
   */
  image_url: string
}

/**
 * ReveRemixOutput
 *
 * Output for Reve image remixing
 */
export type SchemaReveFastRemixOutput = {
  /**
   * Images
   *
   * The remixed images
   */
  images: Array<SchemaImage>
}

/**
 * ReveRemixInput
 *
 * Input for Reve image remixing
 */
export type SchemaReveFastRemixInput = {
  /**
   * Prompt
   *
   * The text description of the desired image. May include XML img tags like <img>0</img> to refer to specific images by their index in the image_urls list.
   */
  prompt: string
  /**
   * Number of Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Aspect Ratio
   *
   * The desired aspect ratio of the generated image. If not provided, will be smartly chosen by the model.
   */
  aspect_ratio?: '16:9' | '9:16' | '3:2' | '2:3' | '4:3' | '3:4' | '1:1'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Reference Image URLs
   *
   * List of URLs of reference images. Must provide between 1 and 6 images (inclusive). Each image must be less than 10 MB. Supports PNG, JPEG, WebP, AVIF, and HEIF formats.
   */
  image_urls: Array<string>
  /**
   * Output Format
   *
   * Output format for the generated image.
   */
  output_format?: 'png' | 'jpeg' | 'webp'
}

/**
 * AddBackgroundOutput
 */
export type SchemaQwenImageEditPlusLoraGalleryAddBackgroundOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * AddBackgroundInput
 *
 * Input model for Add Background endpoint - Remove white background and add a realistic scene
 */
export type SchemaQwenImageEditPlusLoraGalleryAddBackgroundInput = {
  /**
   * Prompt
   *
   * Describe the background/scene you want to add behind the object. The model will remove the white background and add the specified environment.
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URLs of the images to edit. Provide an image with a white or clean background.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * FaceToFullPortraitOutput
 */
export type SchemaQwenImageEditPlusLoraGalleryFaceToFullPortraitOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * FaceToFullPortraitInput
 *
 * Input model for Face to Full Portrait endpoint - Generate full portrait from a cropped face image
 */
export type SchemaQwenImageEditPlusLoraGalleryFaceToFullPortraitInput = {
  /**
   * Prompt
   *
   * Describe the full portrait you want to generate from the face. Include clothing, setting, pose, and style details.
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URL of the cropped face image. Provide a close-up face photo.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * GroupPhotoOutput
 */
export type SchemaQwenImageEditPlusLoraGalleryGroupPhotoOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * GroupPhotoInput
 *
 * Input model for Group Photo endpoint - Create composite group photos with vintage/retro style
 */
export type SchemaQwenImageEditPlusLoraGalleryGroupPhotoInput = {
  /**
   * Prompt
   *
   * Describe the group photo scene, setting, and style. The model will maintain character consistency and add vintage effects like grain, blur, and retro filters.
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URLs of the images to combine into a group photo. Provide 2 or more individual portrait images.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * IntegrateProductOutput
 */
export type SchemaQwenImageEditPlusLoraGalleryIntegrateProductOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * IntegrateProductInput
 *
 * Input model for Integrate Product endpoint - Blend and integrate products/elements into backgrounds
 */
export type SchemaQwenImageEditPlusLoraGalleryIntegrateProductInput = {
  /**
   * Prompt
   *
   * Describe how to blend and integrate the product/element into the background. The model will automatically correct perspective, lighting and shadows for natural integration.
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URL of the image with product to integrate into background.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * NextSceneOutput
 */
export type SchemaQwenImageEditPlusLoraGalleryNextSceneOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * NextSceneInput
 *
 * Input model for Next Scene endpoint - Create cinematic shot progressions and scene transitions
 */
export type SchemaQwenImageEditPlusLoraGalleryNextSceneInput = {
  /**
   * Prompt
   *
   * Describe the camera movement, framing change, or scene transition. Start with 'Next Scene:' for best results. Examples: camera movements (dolly, push-in, pull-back), framing changes (wide to close-up), new elements entering frame.
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URL of the image to create the next scene from.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * RemoveElementOutput
 */
export type SchemaQwenImageEditPlusLoraGalleryRemoveElementOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * RemoveElementInput
 *
 * Input model for Remove Element endpoint - Remove/delete elements (objects, people, text) from the image
 */
export type SchemaQwenImageEditPlusLoraGalleryRemoveElementInput = {
  /**
   * Prompt
   *
   * Specify what element(s) to remove from the image (objects, people, text, etc.). The model will cleanly remove the element while maintaining consistency of the rest of the image.
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URL of the image containing elements to remove.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * RemoveLightingOutput
 */
export type SchemaQwenImageEditPlusLoraGalleryRemoveLightingOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * RemoveLightingInput
 *
 * Input model for Remove Lighting endpoint - Remove existing lighting and apply soft even lighting
 */
export type SchemaQwenImageEditPlusLoraGalleryRemoveLightingInput = {
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URL of the image with lighting/shadows to remove.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * ShirtDesignOutput
 */
export type SchemaQwenImageEditPlusLoraGalleryShirtDesignOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * ShirtDesignInput
 *
 * Input model for Shirt Design endpoint - Put designs/graphics on people's shirts
 */
export type SchemaQwenImageEditPlusLoraGalleryShirtDesignInput = {
  /**
   * Prompt
   *
   * Describe what design to put on the shirt. The model will apply the design from your input image onto the person's shirt.
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URLs of the images: first image is the person wearing a shirt, second image is the design/logo to put on the shirt.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * MultipleAnglesOutput
 */
export type SchemaQwenImageEditPlusLoraGalleryMultipleAnglesOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * MultipleAnglesInput
 *
 * Input model for Multiple Angles endpoint - Camera control with precise adjustments
 */
export type SchemaQwenImageEditPlusLoraGalleryMultipleAnglesInput = {
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Wide-Angle Lens
   *
   * Enable wide-angle lens effect
   */
  wide_angle_lens?: boolean
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Image URLs
   *
   * The URL of the image to adjust camera angle for.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Vertical Angle (Bird  Worm)
   *
   * Adjust vertical camera angle (-1=bird's-eye view/looking down, 0=neutral, 1=worm's-eye view/looking up)
   */
  vertical_angle?: number
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Move Forward  Close-Up
   *
   * Move camera forward (0=no movement, 10=close-up)
   */
  move_forward?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Rotate Right-Left (degrees )
   *
   * Rotate camera left (positive) or right (negative) in degrees. Positive values rotate left, negative values rotate right.
   */
  rotate_right_left?: number
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the camera control effect.
   */
  lora_scale?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * NanoBananaImageToImageOutput
 */
export type SchemaNanoBananaProEditOutput = {
  /**
   * Images
   *
   * The edited images.
   */
  images: Array<SchemaImageFile>
  /**
   * Description
   *
   * The description of the generated images.
   */
  description: string
}

/**
 * NanoBananaImageToImageInput
 */
export type SchemaNanoBananaProEditInput = {
  /**
   * Prompt
   *
   * The prompt for image editing.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Enable Web Search
   *
   * Enable web search for the image generation task. This will allow the model to use the latest information from the web to generate the image.
   */
  enable_web_search?: boolean
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | 'auto'
    | '21:9'
    | '16:9'
    | '3:2'
    | '4:3'
    | '5:4'
    | '1:1'
    | '4:5'
    | '3:4'
    | '2:3'
    | '9:16'
  /**
   * Resolution
   *
   * The resolution of the image to generate.
   */
  resolution?: '1K' | '2K' | '4K'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Seed
   *
   * The seed for the random number generator.
   */
  seed?: number
  /**
   * Image URLs
   *
   * The URLs of the images to use for image-to-image generation or image editing.
   */
  image_urls: Array<string>
  /**
   * Limit Generations
   *
   * Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.
   */
  limit_generations?: boolean
}

/**
 * NanoBananaImageToImageOutput
 */
export type SchemaGemini3ProImagePreviewEditOutput = {
  /**
   * Images
   *
   * The edited images.
   */
  images: Array<SchemaImageFile>
  /**
   * Description
   *
   * The description of the generated images.
   */
  description: string
}

/**
 * NanoBananaImageToImageInput
 */
export type SchemaGemini3ProImagePreviewEditInput = {
  /**
   * Prompt
   *
   * The prompt for image editing.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Enable Web Search
   *
   * Enable web search for the image generation task. This will allow the model to use the latest information from the web to generate the image.
   */
  enable_web_search?: boolean
  /**
   * Resolution
   *
   * The resolution of the image to generate.
   */
  resolution?: '1K' | '2K' | '4K'
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | 'auto'
    | '21:9'
    | '16:9'
    | '3:2'
    | '4:3'
    | '5:4'
    | '1:1'
    | '4:5'
    | '3:4'
    | '2:3'
    | '9:16'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Seed
   *
   * The seed for the random number generator.
   */
  seed?: number
  /**
   * Image URLs
   *
   * The URLs of the images to use for image-to-image generation or image editing.
   */
  image_urls: Array<string>
  /**
   * Limit Generations
   *
   * Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.
   */
  limit_generations?: boolean
}

/**
 * SAM3ImageOutput
 */
export type SchemaSam3ImageOutput = {
  /**
   * Image
   *
   * Primary segmented mask preview.
   */
  image?: SchemaImage
  /**
   * Metadata
   *
   * Per-mask metadata including scores and boxes.
   */
  metadata?: Array<SchemaMaskMetadata>
  /**
   * Masks
   *
   * Segmented mask images.
   */
  masks: Array<SchemaImage>
  /**
   * Scores
   *
   * Per-mask confidence scores when requested.
   */
  scores?: Array<number>
  /**
   * Boxes
   *
   * Per-mask normalized bounding boxes [cx, cy, w, h] when requested.
   */
  boxes?: Array<Array<number>>
}

/**
 * MaskMetadata
 */
export type SchemaMaskMetadata = {
  /**
   * Box
   *
   * Bounding box for the mask in normalized cxcywh coordinates.
   */
  box?: Array<number>
  /**
   * Score
   *
   * Score for this mask.
   */
  score?: number
  /**
   * Index
   *
   * Index of the mask inside the model output.
   */
  index: number
}

/**
 * SAM3ImageInput
 */
export type SchemaSam3ImageInput = {
  /**
   * Prompt
   *
   * Text prompt for segmentation
   */
  prompt?: string
  /**
   * Include Boxes
   *
   * Whether to include bounding boxes for each mask (when available).
   */
  include_boxes?: boolean
  /**
   * Box Prompts
   *
   * Box prompt coordinates (x_min, y_min, x_max, y_max). Multiple boxes supported - use object_id to group boxes for the same object or leave empty for separate objects.
   */
  box_prompts?: Array<SchemaBoxPrompt>
  /**
   * Return Multiple Masks
   *
   * If True, upload and return multiple generated masks as defined by `max_masks`.
   */
  return_multiple_masks?: boolean
  /**
   * Image Url
   *
   * URL of the image to be segmented
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If True, the media will be returned as a data URI.
   */
  sync_mode?: boolean
  /**
   * Point Prompts
   *
   * List of point prompts
   */
  point_prompts?: Array<SchemaPointPrompt>
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Max Masks
   *
   * Maximum number of masks to return when `return_multiple_masks` is enabled.
   */
  max_masks?: number
  /**
   * Include Scores
   *
   * Whether to include mask confidence scores.
   */
  include_scores?: boolean
  /**
   * Apply Mask
   *
   * Apply the mask on the image.
   */
  apply_mask?: boolean
  /**
   * Text Prompt
   *
   * [DEPRECATED] Use 'prompt' instead. Kept for backward compatibility.
   *
   * @deprecated
   */
  text_prompt?: string
}

/**
 * SAM3RLEOutput
 */
export type SchemaSam3ImageRleOutput = {
  /**
   * Rle
   *
   * Run Length Encoding of the mask.
   */
  rle: string | Array<string>
  /**
   * Metadata
   *
   * Per-mask metadata when multiple RLEs are returned.
   */
  metadata?: Array<SchemaMaskMetadata>
  /**
   * Scores
   *
   * Per-mask confidence scores when requested.
   */
  scores?: Array<number>
  /**
   * Boundingbox Frames Zip
   *
   * Zip file containing per-frame bounding box overlays.
   */
  boundingbox_frames_zip?: SchemaFile
  /**
   * Boxes
   *
   * Per-mask normalized bounding boxes [cx, cy, w, h] when requested.
   */
  boxes?: Array<Array<number>>
}

/**
 * SAM3ImageInput
 */
export type SchemaSam3ImageRleInput = {
  /**
   * Prompt
   *
   * Text prompt for segmentation
   */
  prompt?: string
  /**
   * Include Boxes
   *
   * Whether to include bounding boxes for each mask (when available).
   */
  include_boxes?: boolean
  /**
   * Box Prompts
   *
   * Box prompt coordinates (x_min, y_min, x_max, y_max). Multiple boxes supported - use object_id to group boxes for the same object or leave empty for separate objects.
   */
  box_prompts?: Array<SchemaBoxPrompt>
  /**
   * Return Multiple Masks
   *
   * If True, upload and return multiple generated masks as defined by `max_masks`.
   */
  return_multiple_masks?: boolean
  /**
   * Image Url
   *
   * URL of the image to be segmented
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If True, the media will be returned as a data URI.
   */
  sync_mode?: boolean
  /**
   * Point Prompts
   *
   * List of point prompts
   */
  point_prompts?: Array<SchemaPointPrompt>
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Max Masks
   *
   * Maximum number of masks to return when `return_multiple_masks` is enabled.
   */
  max_masks?: number
  /**
   * Include Scores
   *
   * Whether to include mask confidence scores.
   */
  include_scores?: boolean
  /**
   * Apply Mask
   *
   * Apply the mask on the image.
   */
  apply_mask?: boolean
  /**
   * Text Prompt
   *
   * [DEPRECATED] Use 'prompt' instead. Kept for backward compatibility.
   *
   * @deprecated
   */
  text_prompt?: string
}

/**
 * ChronoEditOutput
 *
 * Unified output model for all ChronoEdit operations
 */
export type SchemaChronoEditLoraGalleryUpscalerOutput = {
  /**
   * Prompt
   *
   * The prompt used for the inference.
   */
  prompt: string
  /**
   * Images
   *
   * The edited image.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * The seed for the inference.
   */
  seed: number
}

/**
 * ChronoEditUpscalerInput
 *
 * Input for upscaler mode
 */
export type SchemaChronoEditLoraGalleryUpscalerInput = {
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA adapter.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Image Url
   *
   * The image to upscale.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * Whether to return the image in sync mode.
   */
  sync_mode?: boolean
  /**
   * Loras
   *
   * Optional additional LoRAs to merge (max 3).
   */
  loras?: Array<SchemaChronoLoraWeight>
  /**
   * Upscale Factor
   *
   * Target scale factor for the output resolution.
   */
  upscale_factor?: number
  /**
   * Guidance Scale
   *
   * The guidance scale for the inference.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps for the upscaling pass.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The seed for the inference.
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker.
   */
  enable_safety_checker?: boolean
}

/**
 * ChronoLoraWeight
 */
export type SchemaChronoLoraWeight = {
  /**
   * Path
   *
   * URL or path to the LoRA weights (Safetensors).
   */
  path: string
  /**
   * Scale
   *
   * Scale factor controlling LoRA strength.
   */
  scale?: number
}

/**
 * ChronoEditOutput
 *
 * Unified output model for all ChronoEdit operations
 */
export type SchemaChronoEditLoraGalleryPaintbrushOutput = {
  /**
   * Prompt
   *
   * The prompt used for the inference.
   */
  prompt: string
  /**
   * Images
   *
   * The edited image.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * The seed for the inference.
   */
  seed: number
}

/**
 * ChronoEditPaintBrushInput
 *
 * Input for paintbrush mode
 */
export type SchemaChronoEditLoraGalleryPaintbrushInput = {
  /**
   * Prompt
   *
   * Describe how to transform the sketched regions.
   */
  prompt: string
  /**
   * Resolution
   *
   * The resolution of the output image.
   */
  resolution?: '480p' | '720p'
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA adapter.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Image Url
   *
   * The image to edit.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * Whether to return the image in sync mode.
   */
  sync_mode?: boolean
  /**
   * Turbo Mode
   *
   * Enable turbo mode to use faster inference.
   */
  turbo_mode?: boolean
  /**
   * Loras
   *
   * Optional additional LoRAs to merge (max 3).
   */
  loras?: Array<SchemaChronoLoraWeight>
  /**
   * Guidance Scale
   *
   * Classifier-free guidance scale.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of denoising steps to run.
   */
  num_inference_steps?: number
  /**
   * Mask Url
   *
   * Optional mask image where black areas indicate regions to sketch/paint.
   */
  mask_url?: string
  /**
   * Seed
   *
   * The seed for the inference.
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker.
   */
  enable_safety_checker?: boolean
}

/**
 * ChronoEditOutput
 *
 * Unified output model for all ChronoEdit operations
 */
export type SchemaChronoEditLoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for the inference.
   */
  prompt: string
  /**
   * Images
   *
   * The edited image.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * The seed for the inference.
   */
  seed: number
}

/**
 * ChronoEditLoRAInput
 *
 * ChronoEdit input with optional custom LoRAs.
 */
export type SchemaChronoEditLoraInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image.
   */
  prompt: string
  /**
   * Loras
   *
   * Optional additional LoRAs to merge for this request (max 3).
   */
  loras?: Array<SchemaChronoLoraWeight>
  /**
   * Turbo Mode
   *
   * Enable turbo mode to use for faster inference.
   */
  turbo_mode?: boolean
  /**
   * Enable Temporal Reasoning
   *
   * Whether to enable temporal reasoning.
   */
  enable_temporal_reasoning?: boolean
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker.
   */
  enable_safety_checker?: boolean
  /**
   * Guidance Scale
   *
   * The guidance scale for the inference.
   */
  guidance_scale?: number
  /**
   * Resolution
   *
   * The resolution of the output image.
   */
  resolution?: '480p' | '720p'
  /**
   * Output Format
   *
   * The format of the output image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Number of Temporal Reasoning Steps
   *
   * The number of temporal reasoning steps to perform.
   */
  num_temporal_reasoning_steps?: number
  /**
   * Sync Mode
   *
   * Whether to return the image in sync mode.
   */
  sync_mode?: boolean
  /**
   * Image URL
   *
   * The image to edit.
   */
  image_url: string
  /**
   * Enable Prompt Expansion
   *
   * Whether to enable prompt expansion.
   */
  enable_prompt_expansion?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The seed for the inference.
   */
  seed?: number
}

/**
 * Flux2FlexEditOutput
 */
export type SchemaFlux2FlexEditOutput = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * The seed used for the generation.
   */
  seed: number
}

/**
 * Flux2FlexImageEditInput
 */
export type SchemaFlux2FlexEditInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Guidance Scale
   *
   * The guidance scale to use for the generation.
   */
  guidance_scale?: number
  /**
   * Image Size
   *
   * The size of the generated image. If `auto`, the size will be determined by the model.
   */
  image_size?:
    | SchemaImageSize
    | 'auto'
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5'
  /**
   * Enable Prompt Expansion
   *
   * Whether to expand the prompt using the model's own knowledge.
   */
  enable_prompt_expansion?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Image URLs
   *
   * List of URLs of input images for editing
   */
  image_urls: Array<string>
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * The seed to use for the generation.
   */
  seed?: number
}

/**
 * CrystalUpscaleOutput
 */
export type SchemaCrystalUpscalerOutput = {
  /**
   * Images
   *
   * List of upscaled images
   */
  images: Array<SchemaImage>
}

/**
 * CrystalUpscaleInput
 */
export type SchemaCrystalUpscalerInput = {
  /**
   * Creativity
   *
   * Creativity level for upscaling
   */
  creativity?: number
  /**
   * Scale Factor
   *
   * Scale factor
   */
  scale_factor?: number
  /**
   * Image Url
   *
   * URL to the input image
   */
  image_url: string
}

/**
 * AddBackgroundOutput
 */
export type SchemaFlux2LoraGalleryAddBackgroundOutput = {
  /**
   * Prompt
   *
   * The prompt used for generation
   */
  prompt: string
  /**
   * Images
   *
   * The generated images with added background
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * AddBackgroundInput
 *
 * Input model for Add Background endpoint - Add background to images
 */
export type SchemaFlux2LoraGalleryAddBackgroundInput = {
  /**
   * Prompt
   *
   * The prompt describing the background to add. Must start with 'Add Background' followed by your description.
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The strength of the add background effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URLs of the images. Provide an image with a white or clean background.
   */
  image_urls: Array<string>
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * ApartmentStagingOutput
 */
export type SchemaFlux2LoraGalleryApartmentStagingOutput = {
  /**
   * Prompt
   *
   * The prompt used for generation
   */
  prompt: string
  /**
   * Images
   *
   * The generated furnished room images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * ApartmentStagingInput
 *
 * Input model for Apartment Staging endpoint - Furnish rooms
 */
export type SchemaFlux2LoraGalleryApartmentStagingInput = {
  /**
   * Prompt
   *
   * The prompt to generate a furnished room. Use 'furnish this room' for best results.
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The strength of the apartment staging effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URL of the empty room image to furnish.
   */
  image_urls: Array<string>
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * FaceToFullPortraitOutput
 */
export type SchemaFlux2LoraGalleryFaceToFullPortraitOutput = {
  /**
   * Prompt
   *
   * The prompt used for generation
   */
  prompt: string
  /**
   * Images
   *
   * The generated full portrait images from face
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * FaceToFullPortraitInput
 *
 * Input model for Face to Full Portrait endpoint - Generate full portrait from face
 */
export type SchemaFlux2LoraGalleryFaceToFullPortraitInput = {
  /**
   * Prompt
   *
   * The prompt describing the full portrait to generate from the face.
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The strength of the face to full portrait effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URL of the cropped face image.
   */
  image_urls: Array<string>
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * MultipleAnglesOutput
 */
export type SchemaFlux2LoraGalleryMultipleAnglesOutput = {
  /**
   * Prompt
   *
   * The prompt used for generation
   */
  prompt: string
  /**
   * Images
   *
   * The generated images with multiple camera angles
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * MultipleAnglesInput
 *
 * Input model for Multiple Angles endpoint - Camera control with precise adjustments using <sks> trigger word. Prompt is built automatically from slider values.
 */
export type SchemaFlux2LoraGalleryMultipleAnglesInput = {
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Horizontal Angle (Azimuth )
   *
   * Horizontal rotation angle around the object in degrees. 0=front view, 90=right side, 180=back view, 270=left side, 360=front view again.
   */
  horizontal_angle?: number
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale.
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker.
   */
  enable_safety_checker?: boolean
  /**
   * Image URLs
   *
   * The URL of the image to adjust camera angle for.
   */
  image_urls: Array<string>
  /**
   * Zoom (Distance)
   *
   * Camera zoom/distance. 0=wide shot (far away), 5=medium shot (normal), 10=close-up (very close).
   */
  zoom?: number
  /**
   * Vertical Angle (Elevation )
   *
   * Vertical camera angle in degrees. 0=eye-level shot, 30=elevated shot, 60=high-angle shot (looking down from above).
   */
  vertical_angle?: number
  /**
   * Num Images
   *
   * Number of images to generate.
   */
  num_images?: number
  /**
   * Lora Scale
   *
   * The strength of the multiple angles effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image.
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Sync Mode
   *
   * If True, the media will be returned as a data URI.
   */
  sync_mode?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * Random seed for reproducibility.
   */
  seed?: number | unknown
}

/**
 * VirtualTryonOutput
 */
export type SchemaFlux2LoraGalleryVirtualTryonOutput = {
  /**
   * Prompt
   *
   * The prompt used for generation
   */
  prompt: string
  /**
   * Images
   *
   * The generated virtual try-on images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * VirtualTryonInput
 *
 * Input model for Virtual Try-on endpoint - Generate virtual try-on images
 */
export type SchemaFlux2LoraGalleryVirtualTryonInput = {
  /**
   * Prompt
   *
   * The prompt to generate a virtual try-on image.
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The strength of the virtual try-on effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URLs of the images for virtual try-on. Provide person image and clothing image.
   */
  image_urls: Array<string>
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * OmniImageElementInput
 */
export type SchemaOmniImageElementInput = {
  /**
   * Reference Image Urls
   *
   * Additional reference images from different angles. 1-3 images supported. At least one image is required.
   */
  reference_image_urls?: Array<string>
  /**
   * Frontal Image Url
   *
   * The frontal image of the element (main view).
   */
  frontal_image_url: string
}

/**
 * OmniImageOutput
 */
export type SchemaKlingImageO1Output = {
  /**
   * Images
   *
   * Generated images
   */
  images: Array<SchemaImage>
}

/**
 * OmniImageRequest
 */
export type SchemaKlingImageO1Input = {
  /**
   * Prompt
   *
   * Text prompt for image generation. Reference images using @Image1, @Image2, etc. (or @Image if only one image). Max 2500 characters.
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * Aspect ratio of generated images. 'auto' intelligently determines based on input content.
   */
  aspect_ratio?:
    | 'auto'
    | '16:9'
    | '9:16'
    | '1:1'
    | '4:3'
    | '3:4'
    | '3:2'
    | '2:3'
    | '21:9'
  /**
   * Num Images
   *
   * Number of images to generate (1-9).
   */
  num_images?: number
  /**
   * Resolution
   *
   * Image generation resolution. 1K: standard, 2K: high-res.
   */
  resolution?: '1K' | '2K'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Elements
   *
   * Elements (characters/objects) to include in the image. Reference in prompt as @Element1, @Element2, etc. Maximum 10 total (elements + reference images).
   */
  elements?: Array<SchemaOmniImageElementInput>
  /**
   * Image Urls
   *
   * List of reference images. Reference images in prompt using @Image1, @Image2, etc. (1-indexed). Max 10 images.
   */
  image_urls: Array<string>
}

/**
 * ReferenceToImageOutput
 */
export type SchemaViduQ2ReferenceToImageOutput = {
  /**
   * Image
   *
   * The edited image
   */
  image: SchemaImage
}

/**
 * ReferenceToImageRequest
 */
export type SchemaViduQ2ReferenceToImageInput = {
  /**
   * Prompt
   *
   * Text prompt for video generation, max 1500 characters
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the output video
   */
  aspect_ratio?: '16:9' | '9:16' | '1:1'
  /**
   * Reference Image Urls
   *
   * URLs of the reference images to use for consistent subject appearance
   */
  reference_image_urls: Array<string>
  /**
   * Seed
   *
   * Random seed for generation
   */
  seed?: number
}

/**
 * SeedDream45EditOutput
 */
export type SchemaBytedanceSeedreamV45EditOutput = {
  /**
   * Images
   *
   * Generated images
   */
  images: Array<SchemaImage>
}

/**
 * SeedDream45EditInput
 */
export type SchemaBytedanceSeedreamV45EditInput = {
  /**
   * Prompt
   *
   * The text prompt used to edit the image
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of separate model generations to be run with the prompt.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. Width and height must be between 1920 and 4096, or total number of pixels must be between 2560*1440 and 4096*4096.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | 'auto_2K'
    | 'auto_4K'
  /**
   * Max Images
   *
   * If set to a number greater than one, enables multi-image generation. The model will potentially return up to `max_images` images every generation, and in total, `num_images` generations will be carried out. In total, the number of images generated will be between `num_images` and `max_images*num_images`. The total number of images (image inputs + image outputs) must not exceed 15
   */
  max_images?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * Random seed to control the stochasticity of image generation.
   */
  seed?: number
  /**
   * Image URLs
   *
   * List of URLs of input images for editing. Presently, up to 10 image inputs are allowed. If over 10 images are sent, only the last 10 will be used.
   */
  image_urls: Array<string>
}

/**
 * ImageToImageOutput
 */
export type SchemaLongcatImageEditOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * EditImageInput
 */
export type SchemaLongcatImageEditInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image with.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Acceleration
   *
   * The acceleration level to use.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Image URL
   *
   * The URL of the image to edit.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Guidance Scale
   *
   * The guidance scale to use for the image generation.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * ZImageTurboImageToImageOutput
 */
export type SchemaZImageTurboImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   *
   * The timings of the generation process.
   */
  timings: {
    [key: string]: number
  }
}

/**
 * ZImageTurboImageToImageInput
 */
export type SchemaZImageTurboImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | 'auto'
  /**
   * Acceleration
   *
   * The acceleration level to use.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Image URL
   *
   * URL of Image for Image-to-Image generation.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * The strength of the image-to-image conditioning.
   */
  strength?: number
  /**
   * Enable Prompt Expansion
   *
   * Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.
   */
  enable_prompt_expansion?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * ZImageTurboImageToImageOutput
 */
export type SchemaZImageTurboImageToImageLoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   *
   * The timings of the generation process.
   */
  timings: {
    [key: string]: number
  }
}

/**
 * ZImageTurboImageToImageLoRAInput
 */
export type SchemaZImageTurboImageToImageLoraInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | 'auto'
  /**
   * Acceleration
   *
   * The acceleration level to use.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Image URL
   *
   * URL of Image for Image-to-Image generation.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Loras
   *
   * List of LoRA weights to apply (maximum 3).
   */
  loras?: Array<SchemaLoRaInput>
  /**
   * Strength
   *
   * The strength of the image-to-image conditioning.
   */
  strength?: number
  /**
   * Enable Prompt Expansion
   *
   * Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.
   */
  enable_prompt_expansion?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * LoRAInput
 *
 * LoRA weight configuration.
 */
export type SchemaLoRaInput = {
  /**
   * Path
   *
   * URL, HuggingFace repo ID (owner/repo) to lora weights.
   */
  path: string
  /**
   * Scale
   *
   * Scale factor for LoRA application (0.0 to 4.0).
   */
  scale?: number
}

/**
 * ZImageTurboControlNetOutput
 */
export type SchemaZImageTurboControlnetOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   *
   * The timings of the generation process.
   */
  timings: {
    [key: string]: number
  }
}

/**
 * ZImageTurboControlNetInput
 */
export type SchemaZImageTurboControlnetInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Acceleration
   *
   * The acceleration level to use.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | 'auto'
  /**
   * Control End
   *
   * The end of the controlnet conditioning.
   */
  control_end?: number
  /**
   * Control Start
   *
   * The start of the controlnet conditioning.
   */
  control_start?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Image URL
   *
   * URL of Image for ControlNet generation.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Control Scale
   *
   * The scale of the controlnet conditioning.
   */
  control_scale?: number
  /**
   * Enable Prompt Expansion
   *
   * Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.
   */
  enable_prompt_expansion?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Preprocess
   *
   * What kind of preprocessing to apply to the image, if any.
   */
  preprocess?: 'none' | 'canny' | 'depth' | 'pose'
}

/**
 * ZImageTurboControlNetOutput
 */
export type SchemaZImageTurboControlnetLoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   *
   * The timings of the generation process.
   */
  timings: {
    [key: string]: number
  }
}

/**
 * ZImageTurboControlNetLoRAInput
 */
export type SchemaZImageTurboControlnetLoraInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Acceleration
   *
   * The acceleration level to use.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | 'auto'
  /**
   * Loras
   *
   * List of LoRA weights to apply (maximum 3).
   */
  loras?: Array<SchemaLoRaInput>
  /**
   * Control End
   *
   * The end of the controlnet conditioning.
   */
  control_end?: number
  /**
   * Control Start
   *
   * The start of the controlnet conditioning.
   */
  control_start?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Image URL
   *
   * URL of Image for ControlNet generation.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Control Scale
   *
   * The scale of the controlnet conditioning.
   */
  control_scale?: number
  /**
   * Enable Prompt Expansion
   *
   * Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.
   */
  enable_prompt_expansion?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Preprocess
   *
   * What kind of preprocessing to apply to the image, if any.
   */
  preprocess?: 'none' | 'canny' | 'depth' | 'pose'
}

/**
 * ImageOutput
 */
export type SchemaStepxEdit2Output = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Best Info
   *
   * Reflection analysis (only available when reflection mode is enabled).
   */
  best_info?: Array<{
    [key: string]: unknown
  }>
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Reformat Prompt
   *
   * The model's interpretation of your instruction (only available when thinking mode is enabled).
   */
  reformat_prompt?: string
  /**
   * Think Info
   *
   * Reasoning process details (only available when thinking mode is enabled).
   */
  think_info?: Array<string>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * ImageToImageInput
 */
export type SchemaStepxEdit2Input = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Reflection Mode
   *
   * Enable reflection mode. Reviews outputs, corrects unintended changes, and determines when editing is complete.
   */
  enable_reflection_mode?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The image URL to generate an image from. Needs to match the dimensions of the mask.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * True CFG scale
   *
   *
   * The true CFG scale. Controls how closely the model follows the prompt.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform. Recommended: 50.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Enable Thinking Mode
   *
   * Enable thinking mode. Uses multimodal language model knowledge to interpret abstract editing instructions.
   */
  enable_thinking_mode?: boolean
}

/**
 * Schema referenced but not defined by fal.ai (missing from source OpenAPI spec)
 */
export type SchemaPoint = {
  [key: string]: unknown
}

/**
 * UsageInfo
 */
export type SchemaUsageInfo = {
  /**
   * Output Tokens
   *
   * Number of output tokens generated
   */
  output_tokens: number
  /**
   * Decode Time Ms
   *
   * Time taken for decoding in milliseconds
   */
  decode_time_ms: number
  /**
   * Input Tokens
   *
   * Number of input tokens processed
   */
  input_tokens: number
  /**
   * Ttft Ms
   *
   * Time to first token in milliseconds
   */
  ttft_ms: number
  /**
   * Prefill Time Ms
   *
   * Time taken for prefill in milliseconds
   */
  prefill_time_ms: number
}

/**
 * Object
 */
export type SchemaObject = {
  /**
   * Y Min
   *
   * Top boundary of detection box in normalized format (0 to 1)
   */
  y_min: number
  /**
   * X Max
   *
   * Right boundary of detection box in normalized format (0 to 1)
   */
  x_max: number
  /**
   * X Min
   *
   * Left boundary of detection box in normalized format (0 to 1)
   */
  x_min: number
  /**
   * Y Max
   *
   * Bottom boundary of detection box in normalized format (0 to 1)
   */
  y_max: number
}

/**
 * SegmentSamplingSettings
 */
export type SchemaSegmentSamplingSettings = {
  /**
   * Top P
   *
   * Nucleus sampling probability mass to use, between 0 and 1.
   */
  top_p?: number
  /**
   * Max Tokens
   *
   * Maximum number of tokens to generate.
   */
  max_tokens?: number
  /**
   * Temperature
   *
   * Sampling temperature to use. Higher values will make the output more random, while lower values will make it more focused and deterministic.
   */
  temperature?: number
}

/**
 * MoondreamSegementationOutput
 */
export type SchemaMoondream3PreviewSegmentOutput = {
  /**
   * Finish Reason
   *
   * Reason for finishing the output generation
   */
  finish_reason: string
  /**
   * Image
   *
   * Segmentation mask image. If no object detected or preview not requested, will be null.
   */
  image?: SchemaImageFile
  /**
   * Bbox
   *
   * Bounding box of the segmented object. If not detected, will be null.
   */
  bbox?: SchemaObject
  /**
   * Path
   *
   * SVG path data representing the segmentation mask. If not detected, will be null.
   */
  path?: string
  /**
   * Usage Info
   *
   * Usage information for the request
   */
  usage_info: SchemaUsageInfo
}

/**
 * MoondreamSegementationInput
 */
export type SchemaMoondream3PreviewSegmentInput = {
  /**
   * Spatial References
   *
   * Spatial references to guide the segmentation. By feeding in references you can help the segmentation process. Must be either list of Point object with x and y members, or list of arrays containing either 2 floats (x,y) or 4 floats (x1,y1,x2,y2).
   * **NOTE**: You can also use the [**point endpoint**](https://fal.ai/models/fal-ai/moondream3-preview/point) to get points for the objects, and pass them in here.
   */
  spatial_references?: Array<SchemaPoint | Array<number>>
  /**
   * Settings
   *
   * Sampling settings for the segmentation model
   */
  settings?: SchemaSegmentSamplingSettings
  /**
   * Object
   *
   * Object to be segmented in the image
   */
  object: string
  /**
   * Preview
   *
   * Whether to preview the output and return a binary mask of the image
   */
  preview?: boolean
  /**
   * Image URL
   *
   * URL of the image to be processed
   *
   * Max width: 7000px, Max height: 7000px, Timeout: 20.0s
   */
  image_url: string
}

/**
 * LightingRestorationOutput
 */
export type SchemaQwenImageEditPlusLoraGalleryLightingRestorationOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * LightingRestorationInput
 *
 * Input model for Lighting Restoration endpoint - Restore natural lighting by removing harsh shadows and light spots
 */
export type SchemaQwenImageEditPlusLoraGalleryLightingRestorationInput = {
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URL of the image to restore lighting for.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * QwenImageOutput
 */
export type SchemaQwenImageEdit2509Output = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * BaseQwenEditImagePlusInput
 */
export type SchemaQwenImageEdit2509Input = {
  /**
   * Prompt
   *
   * The prompt to generate the image with
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Image URLs
   *
   * The URLs of the images to edit.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * QwenImageOutput
 */
export type SchemaQwenImageEdit2509LoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * BaseQwenEditImagePlusLoRAInput
 */
export type SchemaQwenImageEdit2509LoraInput = {
  /**
   * Prompt
   *
   * The prompt to generate the image with
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used to calculate the size of the output image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use up to 3 LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Image URLs
   *
   * The URLs of the images to edit.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * MultipleAnglesOutput
 */
export type SchemaQwenImageEdit2509LoraGalleryMultipleAnglesOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * MultipleAnglesInput
 *
 * Input model for Multiple Angles endpoint - Camera control with precise adjustments
 */
export type SchemaQwenImageEdit2509LoraGalleryMultipleAnglesInput = {
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Wide-Angle Lens
   *
   * Enable wide-angle lens effect
   */
  wide_angle_lens?: boolean
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Image URLs
   *
   * The URL of the image to adjust camera angle for.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Vertical Angle (Bird  Worm)
   *
   * Adjust vertical camera angle (-1=bird's-eye view/looking down, 0=neutral, 1=worm's-eye view/looking up)
   */
  vertical_angle?: number
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Move Forward  Close-Up
   *
   * Move camera forward (0=no movement, 10=close-up)
   */
  move_forward?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Rotate Right-Left (degrees )
   *
   * Rotate camera left (positive) or right (negative) in degrees. Positive values rotate left, negative values rotate right.
   */
  rotate_right_left?: number
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the camera control effect.
   */
  lora_scale?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * NextSceneOutput
 */
export type SchemaQwenImageEdit2509LoraGalleryNextSceneOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * NextSceneInput
 *
 * Input model for Next Scene endpoint - Create cinematic shot progressions and scene transitions
 */
export type SchemaQwenImageEdit2509LoraGalleryNextSceneInput = {
  /**
   * Prompt
   *
   * Describe the camera movement, framing change, or scene transition. Start with 'Next Scene:' for best results. Examples: camera movements (dolly, push-in, pull-back), framing changes (wide to close-up), new elements entering frame.
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URL of the image to create the next scene from.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * AddBackgroundOutput
 */
export type SchemaQwenImageEdit2509LoraGalleryAddBackgroundOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * AddBackgroundInput
 *
 * Input model for Add Background endpoint - Remove white background and add a realistic scene
 */
export type SchemaQwenImageEdit2509LoraGalleryAddBackgroundInput = {
  /**
   * Prompt
   *
   * Describe the background/scene you want to add behind the object. The model will remove the white background and add the specified environment.
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URLs of the images to edit. Provide an image with a white or clean background.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * FaceToFullPortraitOutput
 */
export type SchemaQwenImageEdit2509LoraGalleryFaceToFullPortraitOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * FaceToFullPortraitInput
 *
 * Input model for Face to Full Portrait endpoint - Generate full portrait from a cropped face image
 */
export type SchemaQwenImageEdit2509LoraGalleryFaceToFullPortraitInput = {
  /**
   * Prompt
   *
   * Describe the full portrait you want to generate from the face. Include clothing, setting, pose, and style details.
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URL of the cropped face image. Provide a close-up face photo.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * GroupPhotoOutput
 */
export type SchemaQwenImageEdit2509LoraGalleryGroupPhotoOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * GroupPhotoInput
 *
 * Input model for Group Photo endpoint - Create composite group photos with vintage/retro style
 */
export type SchemaQwenImageEdit2509LoraGalleryGroupPhotoInput = {
  /**
   * Prompt
   *
   * Describe the group photo scene, setting, and style. The model will maintain character consistency and add vintage effects like grain, blur, and retro filters.
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URLs of the images to combine into a group photo. Provide 2 or more individual portrait images.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * IntegrateProductOutput
 */
export type SchemaQwenImageEdit2509LoraGalleryIntegrateProductOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * IntegrateProductInput
 *
 * Input model for Integrate Product endpoint - Blend and integrate products/elements into backgrounds
 */
export type SchemaQwenImageEdit2509LoraGalleryIntegrateProductInput = {
  /**
   * Prompt
   *
   * Describe how to blend and integrate the product/element into the background. The model will automatically correct perspective, lighting and shadows for natural integration.
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URL of the image with product to integrate into background.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * LightingRestorationOutput
 */
export type SchemaQwenImageEdit2509LoraGalleryLightingRestorationOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * LightingRestorationInput
 *
 * Input model for Lighting Restoration endpoint - Restore natural lighting by removing harsh shadows and light spots
 */
export type SchemaQwenImageEdit2509LoraGalleryLightingRestorationInput = {
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URL of the image to restore lighting for.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * RemoveElementOutput
 */
export type SchemaQwenImageEdit2509LoraGalleryRemoveElementOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * RemoveElementInput
 *
 * Input model for Remove Element endpoint - Remove/delete elements (objects, people, text) from the image
 */
export type SchemaQwenImageEdit2509LoraGalleryRemoveElementInput = {
  /**
   * Prompt
   *
   * Specify what element(s) to remove from the image (objects, people, text, etc.). The model will cleanly remove the element while maintaining consistency of the rest of the image.
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URL of the image containing elements to remove.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * RemoveLightingOutput
 */
export type SchemaQwenImageEdit2509LoraGalleryRemoveLightingOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * RemoveLightingInput
 *
 * Input model for Remove Lighting endpoint - Remove existing lighting and apply soft even lighting
 */
export type SchemaQwenImageEdit2509LoraGalleryRemoveLightingInput = {
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URL of the image with lighting/shadows to remove.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * ShirtDesignOutput
 */
export type SchemaQwenImageEdit2509LoraGalleryShirtDesignOutput = {
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * ShirtDesignInput
 *
 * Input model for Shirt Design endpoint - Put designs/graphics on people's shirts
 */
export type SchemaQwenImageEdit2509LoraGalleryShirtDesignInput = {
  /**
   * Prompt
   *
   * Describe what design to put on the shirt. The model will apply the design from your input image onto the person's shirt.
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the final input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the LoRA effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Image URLs
   *
   * The URLs of the images: first image is the person wearing a shirt, second image is the design/logo to put on the shirt.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * FluxSingleIDOutput
 */
export type SchemaAiBabyAndAgingGeneratorSingleOutput = {
  /**
   * Prompt
   *
   * The final prompt used for generation
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * SingleFluxIDInput
 *
 * Input schema for single mode generation
 */
export type SchemaAiBabyAndAgingGeneratorSingleInput = {
  /**
   * Prompt
   *
   * Text prompt to guide the image generation
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Id Image Urls
   *
   * List of ID images for single mode (or general reference images)
   */
  id_image_urls: Array<string>
  /**
   * Output Format
   *
   * The format of the generated image. Choose from: 'jpeg' or 'png'.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Age Group
   *
   * Age group for the generated image. Choose from: 'baby' (0-12 months), 'toddler' (1-3 years), 'preschool' (3-5 years), 'gradeschooler' (6-12 years), 'teen' (13-19 years), 'adult' (20-40 years), 'mid' (40-60 years), 'senior' (60+ years).
   */
  age_group:
    | 'baby'
    | 'toddler'
    | 'preschool'
    | 'gradeschooler'
    | 'teen'
    | 'adult'
    | 'mid'
    | 'senior'
  /**
   * Gender
   *
   * Gender for the generated image. Choose from: 'male' or 'female'.
   */
  gender: 'male' | 'female'
  /**
   * Seed
   *
   * Random seed for reproducibility. If None, a random seed will be used
   */
  seed?: number | unknown
}

/**
 * FluxMultiIDOutput
 */
export type SchemaAiBabyAndAgingGeneratorMultiOutput = {
  /**
   * Prompt
   *
   * The final prompt used for generation
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * MultiFluxIDInput
 *
 * Input schema for multi mode generation
 */
export type SchemaAiBabyAndAgingGeneratorMultiInput = {
  /**
   * Prompt
   *
   * Text prompt to guide the image generation
   */
  prompt?: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Father Weight
   *
   * Weight of the father's influence in multi mode generation
   */
  father_weight?: number
  /**
   * Mother Image Urls
   *
   * List of mother images for multi mode
   */
  mother_image_urls: Array<string>
  /**
   * Output Format
   *
   * The format of the generated image. Choose from: 'jpeg' or 'png'.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Age Group
   *
   * Age group for the generated image. Choose from: 'baby' (0-12 months), 'toddler' (1-3 years), 'preschool' (3-5 years), 'gradeschooler' (6-12 years), 'teen' (13-19 years), 'adult' (20-40 years), 'mid' (40-60 years), 'senior' (60+ years).
   */
  age_group:
    | 'baby'
    | 'toddler'
    | 'preschool'
    | 'gradeschooler'
    | 'teen'
    | 'adult'
    | 'mid'
    | 'senior'
  /**
   * Gender
   *
   * Gender for the generated image. Choose from: 'male' or 'female'.
   */
  gender: 'male' | 'female'
  /**
   * Father Image Urls
   *
   * List of father images for multi mode
   */
  father_image_urls: Array<string>
  /**
   * Seed
   *
   * Random seed for reproducibility. If None, a random seed will be used
   */
  seed?: number | unknown
}

/**
 * Flux2MaxEditOutput
 */
export type SchemaFlux2MaxEditOutput = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * The seed used for the generation.
   */
  seed: number
}

/**
 * Flux2MaxImageEditInput
 */
export type SchemaFlux2MaxEditInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image. If `auto`, the size will be determined by the model.
   */
  image_size?:
    | SchemaImageSize
    | 'auto'
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5'
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * The seed to use for the generation.
   */
  seed?: number
  /**
   * Image URLs
   *
   * List of URLs of input images for editing
   */
  image_urls: Array<string>
}

/**
 * Flux2TurboEditImageOutput
 */
export type SchemaFlux2TurboEditOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The edited images
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * Flux2TurboEditImageInput
 */
export type SchemaFlux2TurboEditInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the image to generate. The width and height must be between 512 and 2048 pixels.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
  /**
   * Image URLs
   *
   * The URLs of the images for editing. A maximum of 4 images are allowed, if more are provided, only the first 4 will be used.
   */
  image_urls: Array<string>
  /**
   * Enable Prompt Expansion
   *
   * If set to true, the prompt will be expanded for better results.
   */
  enable_prompt_expansion?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * EditImageResponse
 */
export type SchemaGptImage15EditOutput = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImageFile>
}

/**
 * EditImageRequest
 */
export type SchemaGptImage15EditInput = {
  /**
   * Input Fidelity
   *
   * Input fidelity for the generated image
   */
  input_fidelity?: 'low' | 'high'
  /**
   * Number of Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * Aspect ratio for the generated image
   */
  image_size?: 'auto' | '1024x1024' | '1536x1024' | '1024x1536'
  /**
   * Prompt
   *
   * The prompt for image generation
   */
  prompt: string
  /**
   * Quality
   *
   * Quality for the generated image
   */
  quality?: 'low' | 'medium' | 'high'
  /**
   * Output Format
   *
   * Output format for the images
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Background
   *
   * Background for the generated image
   */
  background?: 'auto' | 'transparent' | 'opaque'
  /**
   * Mask Image URL
   *
   * The URL of the mask image to use for the generation. This indicates what part of the image to edit.
   */
  mask_image_url?: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Image URLs
   *
   * The URLs of the images to use as a reference for the generation.
   */
  image_urls: Array<string>
}

/**
 * Flux2FlashEditImageOutput
 */
export type SchemaFlux2FlashEditOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The edited images
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * Flux2FlashEditImageInput
 */
export type SchemaFlux2FlashEditInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the image to generate. The width and height must be between 512 and 2048 pixels.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
  /**
   * Image URLs
   *
   * The URLs of the images for editing. A maximum of 4 images are allowed, if more are provided, only the first 4 will be used.
   */
  image_urls: Array<string>
  /**
   * Enable Prompt Expansion
   *
   * If set to true, the prompt will be expanded for better results.
   */
  enable_prompt_expansion?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * ZImageTurboInpaintOutput
 */
export type SchemaZImageTurboInpaintOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   *
   * The timings of the generation process.
   */
  timings: {
    [key: string]: number
  }
}

/**
 * ZImageTurboInpaintInput
 */
export type SchemaZImageTurboInpaintInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Acceleration
   *
   * The acceleration level to use.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | 'auto'
  /**
   * Mask Image URL
   *
   * URL of Mask for Inpaint generation.
   */
  mask_image_url: string
  /**
   * Control End
   *
   * The end of the controlnet conditioning.
   */
  control_end?: number
  /**
   * Control Start
   *
   * The start of the controlnet conditioning.
   */
  control_start?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Image URL
   *
   * URL of Image for Inpaint generation.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * The strength of the inpaint conditioning.
   */
  strength?: number
  /**
   * Control Scale
   *
   * The scale of the controlnet conditioning.
   */
  control_scale?: number
  /**
   * Enable Prompt Expansion
   *
   * Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.
   */
  enable_prompt_expansion?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * ZImageTurboInpaintOutput
 */
export type SchemaZImageTurboInpaintLoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   *
   * The timings of the generation process.
   */
  timings: {
    [key: string]: number
  }
}

/**
 * ZImageTurboInpaintLoRAInput
 */
export type SchemaZImageTurboInpaintLoraInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Acceleration
   *
   * The acceleration level to use.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | 'auto'
  /**
   * Mask Image URL
   *
   * URL of Mask for Inpaint generation.
   */
  mask_image_url: string
  /**
   * Loras
   *
   * List of LoRA weights to apply (maximum 3).
   */
  loras?: Array<SchemaLoRaInput>
  /**
   * Control End
   *
   * The end of the controlnet conditioning.
   */
  control_end?: number
  /**
   * Control Start
   *
   * The start of the controlnet conditioning.
   */
  control_start?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Image URL
   *
   * URL of Image for Inpaint generation.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * The strength of the inpaint conditioning.
   */
  strength?: number
  /**
   * Control Scale
   *
   * The scale of the controlnet conditioning.
   */
  control_scale?: number
  /**
   * Enable Prompt Expansion
   *
   * Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.
   */
  enable_prompt_expansion?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * QwenImageLayeredOutput
 */
export type SchemaQwenImageLayeredOutput = {
  /**
   * Prompt
   *
   * The prompt used to generate the image.
   */
  prompt?: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImageFile>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaQwenImageLayeredInput = {
  /**
   * Prompt
   *
   * A caption for the input image.
   */
  prompt?: string
  /**
   * Acceleration
   *
   * The acceleration level to use.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Num Layers
   *
   * The number of layers to generate.
   */
  num_layers?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'png' | 'webp'
  /**
   * Image URL
   *
   * The URL of the input image.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Guidance Scale
   *
   * The guidance scale to use for the image generation.
   */
  guidance_scale?: number
  /**
   * Negative Prompt
   *
   * The negative prompt to generate an image from.
   */
  negative_prompt?: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * ImageToImageOutput
 */
export type SchemaQwenImageEdit2511Output = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * EditImageInput
 */
export type SchemaQwenImageEdit2511Input = {
  /**
   * Prompt
   *
   * The prompt to edit the image with.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If None, uses the input image dimensions.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The acceleration level to use.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The guidance scale to use for the image generation.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Image URLs
   *
   * The URLs of the images to edit.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt to generate an image from.
   */
  negative_prompt?: string
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
}

/**
 * ImageEditOutput
 *
 * Output for Wan 2.6 image editing
 */
export type SchemaV26ImageToImageOutput = {
  /**
   * Images
   *
   * Generated images in PNG format
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * ImageEditInput
 *
 * Input for Wan 2.6 image editing with reference images (enable_interleave=false)
 */
export type SchemaV26ImageToImageInput = {
  /**
   * Prompt
   *
   * Text prompt describing the desired image. Supports Chinese and English. Max 2000 characters. Example: 'Generate an image using the style of image 1 and background of image 2'.
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of images to generate (1-4). Directly affects billing cost.
   */
  num_images?: number
  /**
   * Image Size
   *
   * Output image size. Use presets like 'square_hd', 'landscape_16_9', 'portrait_9_16', or specify exact dimensions with ImageSize(width=1280, height=720). Total pixels must be between 768*768 and 1280*1280.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Enable Prompt Expansion
   *
   * Enable LLM prompt optimization. Significantly improves results for simple prompts but adds 3-4 seconds processing time.
   */
  enable_prompt_expansion?: boolean
  /**
   * Seed
   *
   * Random seed for reproducibility (0-2147483647). Same seed produces more consistent results.
   */
  seed?: number
  /**
   * Image Urls
   *
   * Reference images for editing (1-3 images required). Order matters: reference as 'image 1', 'image 2', 'image 3' in prompt. Resolution: 384-5000px each dimension. Max size: 10MB each. Formats: JPEG, JPG, PNG (no alpha), BMP, WEBP.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * Content to avoid in the generated image. Max 500 characters.
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * Enable content moderation for input and output.
   */
  enable_safety_checker?: boolean
}

/**
 * QwenImageLayeredOutput
 */
export type SchemaQwenImageLayeredLoraOutput = {
  /**
   * Prompt
   *
   * The prompt used to generate the image.
   */
  prompt?: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImageFile>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageLoRAInput
 */
export type SchemaQwenImageLayeredLoraInput = {
  /**
   * Prompt
   *
   * A caption for the input image.
   */
  prompt?: string
  /**
   * Acceleration
   *
   * The acceleration level to use.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Num Layers
   *
   * The number of layers to generate.
   */
  num_layers?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'png' | 'webp'
  /**
   * Image URL
   *
   * The URL of the input image.
   */
  image_url: string
  /**
   * Loras
   *
   * List of LoRA weights to apply (maximum 3).
   */
  loras?: Array<SchemaLoRaInput>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The guidance scale to use for the image generation.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Negative Prompt
   *
   * The negative prompt to generate an image from.
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * ArchEditOutput
 */
export type SchemaAiHomeEditOutput = {
  image: SchemaImage
  /**
   * Status
   *
   * Status message with processing details
   */
  status: string
}

/**
 * ArchEditInput
 */
export type SchemaAiHomeEditInput = {
  /**
   * Input Image Url
   *
   * URL of the image to do architectural editing
   */
  input_image_url: string
  /**
   * Editing Type
   *
   * Type of editing. Structural editing only edits structural elements such as windows, walls etc. Virtual staging edits your furniture. Both do full editing including structural and furniture
   */
  editing_type: 'structural editing' | 'virtual staging' | 'both'
  /**
   * Style
   *
   * Style for furniture and decor
   */
  style:
    | 'minimalistic-interior'
    | 'farmhouse-interior'
    | 'luxury-interior'
    | 'modern-interior'
    | 'zen-interior'
    | 'mid century-interior'
    | 'airbnb-interior'
    | 'cozy-interior'
    | 'rustic-interior'
    | 'christmas-interior'
    | 'bohemian-interior'
    | 'tropical-interior'
    | 'industrial-interior'
    | 'japanese-interior'
    | 'vintage-interior'
    | 'loft-interior'
    | 'halloween-interior'
    | 'soho-interior'
    | 'baroque-interior'
    | 'kids room-interior'
    | 'girls room-interior'
    | 'boys room-interior'
    | 'scandinavian-interior'
    | 'french country-interior'
    | 'mediterranean-interior'
    | 'cyberpunk-interior'
    | 'hot pink-interior'
    | 'biophilic-interior'
    | 'ancient egypt-interior'
    | 'pixel-interior'
    | 'art deco-interior'
    | 'modern-exterior'
    | 'minimalistic-exterior'
    | 'farmhouse-exterior'
    | 'cozy-exterior'
    | 'luxury-exterior'
    | 'colonial-exterior'
    | 'zen-exterior'
    | 'asian-exterior'
    | 'creepy-exterior'
    | 'airstone-exterior'
    | 'ancient greek-exterior'
    | 'art deco-exterior'
    | 'brutalist-exterior'
    | 'christmas lights-exterior'
    | 'contemporary-exterior'
    | 'cottage-exterior'
    | 'dutch colonial-exterior'
    | 'federal colonial-exterior'
    | 'fire-exterior'
    | 'french provincial-exterior'
    | 'full glass-exterior'
    | 'georgian colonial-exterior'
    | 'gothic-exterior'
    | 'greek revival-exterior'
    | 'ice-exterior'
    | 'italianate-exterior'
    | 'mediterranean-exterior'
    | 'midcentury-exterior'
    | 'middle eastern-exterior'
    | 'minecraft-exterior'
    | 'morocco-exterior'
    | 'neoclassical-exterior'
    | 'spanish-exterior'
    | 'tudor-exterior'
    | 'underwater-exterior'
    | 'winter-exterior'
    | 'yard lighting-exterior'
  /**
   * Additional Elements
   *
   * Additional elements to include in the options above (e.g., plants, lighting)
   */
  additional_elements?: string | unknown
  /**
   * Output Format
   *
   * The format of the generated image. Choose from: 'jpeg' or 'png'.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Architecture Type
   *
   * Type of architecture for appropriate furniture selection
   */
  architecture_type:
    | 'living room-interior'
    | 'bedroom-interior'
    | 'kitchen-interior'
    | 'dining room-interior'
    | 'bathroom-interior'
    | 'laundry room-interior'
    | 'home office-interior'
    | 'study room-interior'
    | 'dorm room-interior'
    | 'coffee shop-interior'
    | 'gaming room-interior'
    | 'restaurant-interior'
    | 'office-interior'
    | 'attic-interior'
    | 'toilet-interior'
    | 'other-interior'
    | 'house-exterior'
    | 'villa-exterior'
    | 'backyard-exterior'
    | 'courtyard-exterior'
    | 'ranch-exterior'
    | 'office-exterior'
    | 'retail-exterior'
    | 'tower-exterior'
    | 'apartment-exterior'
    | 'school-exterior'
    | 'museum-exterior'
    | 'commercial-exterior'
    | 'residential-exterior'
    | 'other-exterior'
  /**
   * Color Palette
   *
   * Color palette for furniture and decor
   */
  color_palette:
    | 'surprise me'
    | 'golden beige'
    | 'refined blues'
    | 'dusky elegance'
    | 'emerald charm'
    | 'crimson luxury'
    | 'golden sapphire'
    | 'soft pastures'
    | 'candy sky'
    | 'peach meadow'
    | 'muted sands'
    | 'ocean breeze'
    | 'frosted pastels'
    | 'spring bloom'
    | 'gentle horizon'
    | 'seaside breeze'
    | 'azure coast'
    | 'golden shore'
    | 'mediterranean gem'
    | 'ocean serenity'
    | 'serene blush'
    | 'muted horizon'
    | 'pastel shores'
    | 'dusky calm'
    | 'woodland retreat'
    | 'meadow glow'
    | 'forest canopy'
    | 'riverbank calm'
    | 'earthy tones'
    | 'earthy neutrals'
    | 'arctic mist'
    | 'aqua drift'
    | 'blush bloom'
    | 'coral haze'
    | 'retro rust'
    | 'autumn glow'
    | 'rustic charm'
    | 'vintage sage'
    | 'faded plum'
    | 'electric lime'
    | 'violet pulse'
    | 'neon sorbet'
    | 'aqua glow'
    | 'fluorescent sunset'
    | 'lavender bloom'
    | 'petal fresh'
    | 'meadow light'
    | 'sunny pastures'
    | 'frosted mauve'
    | 'snowy hearth'
    | 'icy blues'
    | 'winter twilight'
    | 'earthy hues'
    | 'stone balance'
    | 'neutral sands'
    | 'slate shades'
  /**
   * Custom Prompt
   *
   * Custom prompt for architectural editing, it overrides above options when used
   */
  custom_prompt?: string
}

/**
 * ArchStyleOutput
 */
export type SchemaAiHomeStyleOutput = {
  image: SchemaImage
  /**
   * Status
   *
   * Status message with processing details
   */
  status: string
}

/**
 * ArchStyleInput
 */
export type SchemaAiHomeStyleInput = {
  /**
   * Input Image Url
   *
   * URL of the image to do architectural styling
   */
  input_image_url: string
  /**
   * Input Image Strength
   *
   * Strength of the input image
   */
  input_image_strength?: number
  /**
   * Additional Elements
   *
   * Additional elements to include in the options above (e.g., plants, lighting)
   */
  additional_elements?: string | unknown
  /**
   * Output Format
   *
   * The format of the generated image. Choose from: 'jpeg' or 'png'.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Style
   *
   * Style for furniture and decor
   */
  style:
    | 'minimalistic-interior'
    | 'farmhouse-interior'
    | 'luxury-interior'
    | 'modern-interior'
    | 'zen-interior'
    | 'mid century-interior'
    | 'airbnb-interior'
    | 'cozy-interior'
    | 'rustic-interior'
    | 'christmas-interior'
    | 'bohemian-interior'
    | 'tropical-interior'
    | 'industrial-interior'
    | 'japanese-interior'
    | 'vintage-interior'
    | 'loft-interior'
    | 'halloween-interior'
    | 'soho-interior'
    | 'baroque-interior'
    | 'kids room-interior'
    | 'girls room-interior'
    | 'boys room-interior'
    | 'scandinavian-interior'
    | 'french country-interior'
    | 'mediterranean-interior'
    | 'cyberpunk-interior'
    | 'hot pink-interior'
    | 'biophilic-interior'
    | 'ancient egypt-interior'
    | 'pixel-interior'
    | 'art deco-interior'
    | 'modern-exterior'
    | 'minimalistic-exterior'
    | 'farmhouse-exterior'
    | 'cozy-exterior'
    | 'luxury-exterior'
    | 'colonial-exterior'
    | 'zen-exterior'
    | 'asian-exterior'
    | 'creepy-exterior'
    | 'airstone-exterior'
    | 'ancient greek-exterior'
    | 'art deco-exterior'
    | 'brutalist-exterior'
    | 'christmas lights-exterior'
    | 'contemporary-exterior'
    | 'cottage-exterior'
    | 'dutch colonial-exterior'
    | 'federal colonial-exterior'
    | 'fire-exterior'
    | 'french provincial-exterior'
    | 'full glass-exterior'
    | 'georgian colonial-exterior'
    | 'gothic-exterior'
    | 'greek revival-exterior'
    | 'ice-exterior'
    | 'italianate-exterior'
    | 'mediterranean-exterior'
    | 'midcentury-exterior'
    | 'middle eastern-exterior'
    | 'minecraft-exterior'
    | 'morocco-exterior'
    | 'neoclassical-exterior'
    | 'spanish-exterior'
    | 'tudor-exterior'
    | 'underwater-exterior'
    | 'winter-exterior'
    | 'yard lighting-exterior'
  /**
   * Architecture Type
   *
   * Type of architecture for appropriate furniture selection
   */
  architecture_type:
    | 'living room-interior'
    | 'bedroom-interior'
    | 'kitchen-interior'
    | 'dining room-interior'
    | 'bathroom-interior'
    | 'laundry room-interior'
    | 'home office-interior'
    | 'study room-interior'
    | 'dorm room-interior'
    | 'coffee shop-interior'
    | 'gaming room-interior'
    | 'restaurant-interior'
    | 'office-interior'
    | 'attic-interior'
    | 'toilet-interior'
    | 'other-interior'
    | 'house-exterior'
    | 'villa-exterior'
    | 'backyard-exterior'
    | 'courtyard-exterior'
    | 'ranch-exterior'
    | 'office-exterior'
    | 'retail-exterior'
    | 'tower-exterior'
    | 'apartment-exterior'
    | 'school-exterior'
    | 'museum-exterior'
    | 'commercial-exterior'
    | 'residential-exterior'
    | 'other-exterior'
  /**
   * Color Palette
   *
   * Color palette for furniture and decor
   */
  color_palette:
    | 'surprise me'
    | 'golden beige'
    | 'refined blues'
    | 'dusky elegance'
    | 'emerald charm'
    | 'crimson luxury'
    | 'golden sapphire'
    | 'soft pastures'
    | 'candy sky'
    | 'peach meadow'
    | 'muted sands'
    | 'ocean breeze'
    | 'frosted pastels'
    | 'spring bloom'
    | 'gentle horizon'
    | 'seaside breeze'
    | 'azure coast'
    | 'golden shore'
    | 'mediterranean gem'
    | 'ocean serenity'
    | 'serene blush'
    | 'muted horizon'
    | 'pastel shores'
    | 'dusky calm'
    | 'woodland retreat'
    | 'meadow glow'
    | 'forest canopy'
    | 'riverbank calm'
    | 'earthy tones'
    | 'earthy neutrals'
    | 'arctic mist'
    | 'aqua drift'
    | 'blush bloom'
    | 'coral haze'
    | 'retro rust'
    | 'autumn glow'
    | 'rustic charm'
    | 'vintage sage'
    | 'faded plum'
    | 'electric lime'
    | 'violet pulse'
    | 'neon sorbet'
    | 'aqua glow'
    | 'fluorescent sunset'
    | 'lavender bloom'
    | 'petal fresh'
    | 'meadow light'
    | 'sunny pastures'
    | 'frosted mauve'
    | 'snowy hearth'
    | 'icy blues'
    | 'winter twilight'
    | 'earthy hues'
    | 'stone balance'
    | 'neutral sands'
    | 'slate shades'
  /**
   * Style Image Url
   *
   * URL of the style image, optional. If given, other parameters are ignored
   */
  style_image_url?: string | unknown
  /**
   * Custom Prompt
   *
   * Custom prompt for architectural editing, it overrides above options when used
   */
  custom_prompt?: string
  /**
   * Enhanced Rendering
   *
   * It gives better rendering quality with more processing time, additional cost is 0.01 USD per image
   */
  enhanced_rendering?: boolean | unknown
}

/**
 * ImageToImageOutput
 */
export type SchemaQwenImageEdit2511LoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * EditImageLoraInput
 */
export type SchemaQwenImageEdit2511LoraInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image with.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If None, uses the input image dimensions.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The acceleration level to use.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI.
   */
  sync_mode?: boolean
  /**
   * Loras
   *
   * The LoRAs to use for the image generation. You can use up to 3 LoRAs and they will be merged together to generate the final image.
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Guidance Scale
   *
   * The guidance scale to use for the image generation.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Image URLs
   *
   * The URLs of the images to edit.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt to generate an image from.
   */
  negative_prompt?: string
  /**
   * Seed
   *
   * The same seed and the same prompt given to the same version of the model will output the same image every time.
   */
  seed?: number
}

/**
 * MultipleAnglesOutput
 *
 * Output model for Multiple Angles endpoint
 */
export type SchemaQwenImageEdit2511MultipleAnglesOutput = {
  /**
   * Prompt
   *
   * The constructed prompt used for generation
   */
  prompt: string
  /**
   * Images
   *
   * The generated/edited images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * MultipleAnglesInput
 *
 * Input model for Multiple Angles endpoint - Camera control with precise adjustments using <sks> trigger word.
 * Prompt is built automatically from slider values.
 */
export type SchemaQwenImageEdit2511MultipleAnglesInput = {
  /**
   * Acceleration
   *
   * Acceleration level for image generation.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, the size of the input image will be used.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Horizontal Angle (Azimuth )
   *
   * Horizontal rotation angle around the object in degrees. 0=front view, 90=right side, 180=back view, 270=left side, 360=front view again.
   */
  horizontal_angle?: number
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale.
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker.
   */
  enable_safety_checker?: boolean
  /**
   * Image URLs
   *
   * The URL of the image to adjust camera angle for.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Zoom (Distance)
   *
   * Camera zoom/distance. 0=wide shot (far away), 5=medium shot (normal), 10=close-up (very close).
   */
  zoom?: number
  /**
   * Vertical Angle (Elevation )
   *
   * Vertical camera angle in degrees. -30=low-angle shot (looking up), 0=eye-level, 30=elevated, 60=high-angle, 90=bird's-eye view (looking down).
   */
  vertical_angle?: number
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Lora Scale
   *
   * The scale factor for the LoRA model. Controls the strength of the camera control effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Additional Prompt
   *
   * Additional text to append to the automatically generated prompt.
   */
  additional_prompt?: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI.
   */
  sync_mode?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * Random seed for reproducibility.
   */
  seed?: number
}

/**
 * GlmImageToImageOutput
 */
export type SchemaGlmImageImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * List of URLs to the generated images.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * GlmImageToImageInput
 */
export type SchemaGlmImageImageToImageInput = {
  /**
   * Prompt
   *
   * Text prompt for image generation.
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * Output image size.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | 'portrait_3_2'
    | 'landscape_3_2'
    | 'portrait_hd'
    | 'landscape_hd'
  /**
   * Enable Safety Checker
   *
   * Enable NSFW safety checking on the generated images.
   */
  enable_safety_checker?: boolean
  /**
   * Output Format
   *
   * Output image format.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If True, the image will be returned as a base64 data URI instead of a URL.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * Classifier-free guidance scale. Higher values make the model follow the prompt more closely.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. The same seed with the same prompt will produce the same image.
   */
  seed?: number
  /**
   * Image Urls
   *
   * URL(s) of the condition image(s) for image-to-image generation. Supports up to 4 URLs for multi-image references.
   */
  image_urls: Array<string>
  /**
   * Enable Prompt Expansion
   *
   * If True, the prompt will be enhanced using an LLM for more detailed and higher quality results.
   */
  enable_prompt_expansion?: boolean
  /**
   * Num Inference Steps
   *
   * Number of diffusion denoising steps. More steps generally produce higher quality images.
   */
  num_inference_steps?: number
}

/**
 * Klein9BDistilledEditOutput
 */
export type SchemaFlux2Klein9bEditOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The edited images
   */
  images: Array<SchemaImageFile>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * Klein9BDistilledEditInput
 */
export type SchemaFlux2Klein9bEditInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, uses the input image size.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI. Output is not stored when this is True.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Image URLs
   *
   * The URLs of the images for editing. A maximum of 4 images are allowed.
   */
  image_urls: Array<string>
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
}

/**
 * Klein4BDistilledEditOutput
 */
export type SchemaFlux2Klein4bEditOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The edited images
   */
  images: Array<SchemaImageFile>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * KleinDistilledEditInput
 */
export type SchemaFlux2Klein4bEditInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, uses the input image size.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI. Output is not stored when this is True.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Image URLs
   *
   * The URLs of the images for editing. A maximum of 4 images are allowed.
   */
  image_urls: Array<string>
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
}

/**
 * Klein9BBaseEditOutput
 */
export type SchemaFlux2Klein9bBaseEditOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The edited images
   */
  images: Array<SchemaImageFile>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * Klein9BEditImageInput
 */
export type SchemaFlux2Klein9bBaseEditInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, uses the input image size.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The acceleration level to use for image generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Guidance Scale
   *
   * Guidance scale for classifier-free guidance.
   */
  guidance_scale?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI. Output is not stored when this is True.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Image URLs
   *
   * The URLs of the images for editing. A maximum of 4 images are allowed.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * Negative prompt for classifier-free guidance. Describes what to avoid in the image.
   */
  negative_prompt?: string
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
}

/**
 * Klein4BBaseEditOutput
 */
export type SchemaFlux2Klein4bBaseEditOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The edited images
   */
  images: Array<SchemaImageFile>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * Klein4BBaseEditInput
 */
export type SchemaFlux2Klein4bBaseEditInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, uses the input image size.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The acceleration level to use for image generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Guidance Scale
   *
   * Guidance scale for classifier-free guidance.
   */
  guidance_scale?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI. Output is not stored when this is True.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Image URLs
   *
   * The URLs of the images for editing. A maximum of 4 images are allowed.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * Negative prompt for classifier-free guidance. Describes what to avoid in the image.
   */
  negative_prompt?: string
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
}

/**
 * KleinT2IOutput
 */
export type SchemaFlux2Klein4bBaseEditLoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImageFile>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * KleinBaseEditLoRAInput
 */
export type SchemaFlux2Klein4bBaseEditLoraInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, uses the input image size.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The acceleration level to use for image generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Guidance Scale
   *
   * Guidance scale for classifier-free guidance.
   */
  guidance_scale?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Loras
   *
   * List of LoRA weights to apply (maximum 3).
   */
  loras?: Array<SchemaFalAiFlux2KleinLoRaInput>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI. Output is not stored when this is True.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Image URLs
   *
   * The URLs of the images for editing. A maximum of 4 images are allowed.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * Negative prompt for classifier-free guidance. Describes what to avoid in the image.
   */
  negative_prompt?: string
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
}

/**
 * LoRAInput
 */
export type SchemaFalAiFlux2KleinLoRaInput = {
  /**
   * Path
   *
   * URL, HuggingFace repo ID (owner/repo), or local path to LoRA weights.
   */
  path: string
  /**
   * Scale
   *
   * Scale factor for LoRA application (0.0 to 4.0).
   */
  scale?: number
}

/**
 * KleinT2IOutput
 */
export type SchemaFlux2Klein9bBaseEditLoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImageFile>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * KleinBaseEditLoRAInput
 */
export type SchemaFlux2Klein9bBaseEditLoraInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. If not provided, uses the input image size.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The acceleration level to use for image generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Guidance Scale
   *
   * Guidance scale for classifier-free guidance.
   */
  guidance_scale?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Loras
   *
   * List of LoRA weights to apply (maximum 3).
   */
  loras?: Array<SchemaFalAiFlux2KleinLoRaInput>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI. Output is not stored when this is True.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Image URLs
   *
   * The URLs of the images for editing. A maximum of 4 images are allowed.
   */
  image_urls: Array<string>
  /**
   * Negative Prompt
   *
   * Negative prompt for classifier-free guidance. Describes what to avoid in the image.
   */
  negative_prompt?: string
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
}

/**
 * FiboEditExtraEPOutputModel
 */
export type SchemaFiboEditColorizeOutput = {
  /**
   * Images
   *
   * Generated images.
   */
  images?: Array<SchemaImage>
  image: SchemaImage
  /**
   * Structured Instruction
   *
   * Current instruction.
   */
  structured_instruction: {
    [key: string]: unknown
  }
}

/**
 * ColorizeInput
 */
export type SchemaFiboEditColorizeInput = {
  /**
   * Color
   *
   * Select the color palette or aesthetic for the output image
   */
  color:
    | 'contemporary color'
    | 'vivid color'
    | 'black and white colors'
    | 'sepia vintage'
  /**
   * Image Url
   *
   * The source image.
   */
  image_url: string
}

/**
 * FiboEditExtraEPOutputModel
 */
export type SchemaFiboEditBlendOutput = {
  /**
   * Images
   *
   * Generated images.
   */
  images?: Array<SchemaImage>
  image: SchemaImage
  /**
   * Structured Instruction
   *
   * Current instruction.
   */
  structured_instruction: {
    [key: string]: unknown
  }
}

/**
 * BlendingInput
 */
export type SchemaFiboEditBlendInput = {
  /**
   * Instruction
   *
   * Instruct what elements you would like to blend in your image.
   */
  instruction: string
  /**
   * Image Url
   *
   * The source image.
   */
  image_url: string
}

/**
 * FiboEditExtraEPOutputModel
 */
export type SchemaFiboEditAddObjectByTextOutput = {
  /**
   * Images
   *
   * Generated images.
   */
  images?: Array<SchemaImage>
  image: SchemaImage
  /**
   * Structured Instruction
   *
   * Current instruction.
   */
  structured_instruction: {
    [key: string]: unknown
  }
}

/**
 * AddObjectByTextInput
 */
export type SchemaFiboEditAddObjectByTextInput = {
  /**
   * Instruction
   *
   * The full natural language command describing what to add and where.
   */
  instruction: string
  /**
   * Image Url
   *
   * The source image.
   */
  image_url: string
}

/**
 * Lighting
 */
export type SchemaLighting = {
  /**
   * Shadows
   *
   * The shadows in the image to be generated.
   */
  shadows?: string | unknown
  /**
   * Conditions
   *
   * The conditions of the lighting in the image to be generated.
   */
  conditions?: string | unknown
  /**
   * Direction
   *
   * The direction of the lighting in the image to be generated.
   */
  direction?: string | unknown
}

/**
 * Aesthetics
 */
export type SchemaAesthetics = {
  /**
   * Composition
   *
   * The composition of the image to be generated.
   */
  composition?: string | unknown
  /**
   * Mood Atmosphere
   *
   * The mood and atmosphere of the image to be generated.
   */
  mood_atmosphere?: string | unknown
  /**
   * Color Scheme
   *
   * The color scheme of the image to be generated.
   */
  color_scheme?: string | unknown
}

/**
 * PhotographicCharacteristics
 */
export type SchemaPhotographicCharacteristics = {
  /**
   * Focus
   *
   * The focus in the image to be generated.
   */
  focus?: string | unknown
  /**
   * Lens Focal Length
   *
   * The focal length of the lens in the image to be generated.
   */
  lens_focal_length?: string | unknown
  /**
   * Camera Angle
   *
   * The angle of the camera in the image to be generated.
   */
  camera_angle?: string | unknown
  /**
   * Depth Of Field
   *
   * The depth of field in the image to be generated.
   */
  depth_of_field?: string | unknown
}

/**
 * PromptObject
 */
export type SchemaPromptObject = {
  /**
   * Relative Size
   *
   * The relative size of the object in the image.
   */
  relative_size?: string | unknown
  /**
   * Description
   *
   * A description of the object to be generated.
   */
  description?: string | unknown
  /**
   * Skin Tone And Texture
   *
   * The skin tone and texture of the object in the image.
   */
  skin_tone_and_texture?: string | unknown
  /**
   * Appearance Details
   *
   * The appearance details of the object.
   */
  appearance_details?: string | unknown
  /**
   * Number Of Objects
   *
   * The number of objects in the image.
   */
  number_of_objects?: number | unknown
  /**
   * Expression
   *
   * The expression of the object in the image.
   */
  expression?: string | unknown
  /**
   * Pose
   *
   * The pose of the object in the image.
   */
  pose?: string | unknown
  /**
   * Shape And Color
   *
   * The shape and color of the object.
   */
  shape_and_color?: string | unknown
  /**
   * Relationship
   *
   * The relationship of the object to other objects in the image.
   */
  relationship: string
  /**
   * Texture
   *
   * The texture of the object.
   */
  texture?: string | unknown
  /**
   * Gender
   *
   * The gender of the object in the image.
   */
  gender?: string | unknown
  /**
   * Clothing
   *
   * The clothing of the object in the image.
   */
  clothing?: string | unknown
  /**
   * Location
   *
   * The location of the object in the image.
   */
  location?: string | unknown
  /**
   * Orientation
   *
   * The orientation of the object in the image.
   */
  orientation?: string | unknown
  /**
   * Action
   *
   * The action of the object in the image.
   */
  action?: string | unknown
}

/**
 * StructuredInstruction
 */
export type SchemaStructuredInstruction = {
  /**
   * Background Setting
   *
   * The background setting of the image to be generated.
   */
  background_setting?: string | unknown
  /**
   * Artistic Style
   *
   * The artistic style of the image to be generated.
   */
  artistic_style?: string | unknown
  /**
   * Style Medium
   *
   * The style medium of the image to be generated.
   */
  style_medium?: string | unknown
  /**
   * Text Render
   *
   * A list of text to be rendered in the image.
   */
  text_render?: Array<unknown> | unknown
  /**
   * Objects
   *
   * A list of objects in the image to be generated, along with their attributes and relationships to other objects in the image.
   */
  objects?: Array<SchemaPromptObject> | unknown
  /**
   * Context
   *
   * The context of the image to be generated.
   */
  context?: string | unknown
  /**
   * The photographic characteristics of the image to be generated.
   */
  photographic_characteristics?: SchemaPhotographicCharacteristics | unknown
  /**
   * The aesthetics of the image to be generated.
   */
  aesthetics?: SchemaAesthetics | unknown
  /**
   * The lighting of the image to be generated.
   */
  lighting?: SchemaLighting | unknown
  /**
   * Short Description
   *
   * A short description of the image to be generated.
   */
  short_description?: string | unknown
  /**
   * Edit Instruction
   *
   * The edit instruction for the image.
   */
  edit_instruction?: string | unknown
}

/**
 * FiboEditOutputModel
 */
export type SchemaFiboEditEditOutput = {
  /**
   * Images
   *
   * Generated images.
   */
  images?: Array<SchemaImage>
  image: SchemaImage
  /**
   * Structured Instruction
   *
   * Current instruction.
   */
  structured_instruction: {
    [key: string]: unknown
  }
}

/**
 * FiboEditInputModel
 */
export type SchemaFiboEditEditInput = {
  /**
   * Steps Num
   *
   * Number of inference steps.
   */
  steps_num?: number
  /**
   * Instruction
   *
   * Instruction for image editing.
   */
  instruction?: string | unknown
  /**
   * Image Url
   *
   * Reference image (file or URL).
   */
  image_url?: string | unknown
  /**
   * Sync Mode
   *
   * If true, returns the image directly in the response (increases latency).
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * Guidance scale for text.
   */
  guidance_scale?: number | number
  /**
   * The structured prompt to generate an image from.
   */
  structured_instruction?: SchemaStructuredInstruction | unknown
  /**
   * Mask Url
   *
   * Mask image (file or URL). Optional
   */
  mask_url?: string | unknown
  /**
   * Negative Prompt
   *
   * Negative prompt for image generation.
   */
  negative_prompt?: string
  /**
   * Seed
   *
   * Random seed for reproducibility.
   */
  seed?: number
}

/**
 * FiboEditExtraEPOutputModel
 */
export type SchemaFiboEditEraseByTextOutput = {
  /**
   * Images
   *
   * Generated images.
   */
  images?: Array<SchemaImage>
  image: SchemaImage
  /**
   * Structured Instruction
   *
   * Current instruction.
   */
  structured_instruction: {
    [key: string]: unknown
  }
}

/**
 * EraseByTextInput
 */
export type SchemaFiboEditEraseByTextInput = {
  /**
   * Object Name
   *
   * The name of the object to remove.
   */
  object_name: string
  /**
   * Image Url
   *
   * The source image.
   */
  image_url: string
}

/**
 * FiboEditExtraEPOutputModel
 */
export type SchemaFiboEditRewriteTextOutput = {
  /**
   * Images
   *
   * Generated images.
   */
  images?: Array<SchemaImage>
  image: SchemaImage
  /**
   * Structured Instruction
   *
   * Current instruction.
   */
  structured_instruction: {
    [key: string]: unknown
  }
}

/**
 * RewriteTextInput
 */
export type SchemaFiboEditRewriteTextInput = {
  /**
   * New Text
   *
   * The new text string to appear in the image.
   */
  new_text: string
  /**
   * Image Url
   *
   * The source image.
   */
  image_url: string
}

/**
 * FiboEditExtraEPOutputModel
 */
export type SchemaFiboEditRestyleOutput = {
  /**
   * Images
   *
   * Generated images.
   */
  images?: Array<SchemaImage>
  image: SchemaImage
  /**
   * Structured Instruction
   *
   * Current instruction.
   */
  structured_instruction: {
    [key: string]: unknown
  }
}

/**
 * RestyletInput
 */
export type SchemaFiboEditRestyleInput = {
  /**
   * Style
   *
   * Select the desired artistic style for the output image.
   */
  style:
    | '3D Render'
    | 'Cubism'
    | 'Oil Painting'
    | 'Anime'
    | 'Cartoon'
    | 'Coloring Book'
    | 'Retro Ad'
    | 'Pop Art Halftone'
    | 'Vector Art'
    | 'Story Board'
    | 'Art Nouveau'
    | 'Cross Etching'
    | 'Wood Cut'
  /**
   * Image Url
   *
   * The source image.
   */
  image_url: string
}

/**
 * FiboEditExtraEPOutputModel
 */
export type SchemaFiboEditRelightOutput = {
  /**
   * Images
   *
   * Generated images.
   */
  images?: Array<SchemaImage>
  image: SchemaImage
  /**
   * Structured Instruction
   *
   * Current instruction.
   */
  structured_instruction: {
    [key: string]: unknown
  }
}

/**
 * RelightInput
 */
export type SchemaFiboEditRelightInput = {
  /**
   * Light Type
   *
   * The quality/style/time of day.
   */
  light_type:
    | 'midday'
    | 'blue hour light'
    | 'low-angle sunlight'
    | 'sunrise light'
    | 'spotlight on subject'
    | 'overcast light'
    | 'soft overcast daylight lighting'
    | 'cloud-filtered lighting'
    | 'fog-diffused lighting'
    | 'moonlight lighting'
    | 'starlight nighttime'
    | 'soft bokeh lighting'
    | 'harsh studio lighting'
  /**
   * Light Direction
   *
   * Where the light comes from.
   */
  light_direction: 'front' | 'side' | 'bottom' | 'top-down' | unknown
  /**
   * Image Url
   *
   * The source image.
   */
  image_url: string
}

/**
 * FiboEditExtraEPOutputModel
 */
export type SchemaFiboEditReseasonOutput = {
  /**
   * Images
   *
   * Generated images.
   */
  images?: Array<SchemaImage>
  image: SchemaImage
  /**
   * Structured Instruction
   *
   * Current instruction.
   */
  structured_instruction: {
    [key: string]: unknown
  }
}

/**
 * ReseasonInput
 */
export type SchemaFiboEditReseasonInput = {
  /**
   * Season
   *
   * The desired season.
   */
  season: 'spring' | 'summer' | 'autumn' | 'winter'
  /**
   * Image Url
   *
   * The source image.
   */
  image_url: string
}

/**
 * FiboEditExtraEPOutputModel
 */
export type SchemaFiboEditRestoreOutput = {
  /**
   * Images
   *
   * Generated images.
   */
  images?: Array<SchemaImage>
  image: SchemaImage
  /**
   * Structured Instruction
   *
   * Current instruction.
   */
  structured_instruction: {
    [key: string]: unknown
  }
}

/**
 * RestoreInput
 */
export type SchemaFiboEditRestoreInput = {
  /**
   * Image Url
   *
   * The source image.
   */
  image_url: string
}

/**
 * FiboEditExtraEPOutputModel
 */
export type SchemaFiboEditSketchToColoredImageOutput = {
  /**
   * Images
   *
   * Generated images.
   */
  images?: Array<SchemaImage>
  image: SchemaImage
  /**
   * Structured Instruction
   *
   * Current instruction.
   */
  structured_instruction: {
    [key: string]: unknown
  }
}

/**
 * SketchColoredImageInput
 */
export type SchemaFiboEditSketchToColoredImageInput = {
  /**
   * Image Url
   *
   * The source image.
   */
  image_url: string
}

/**
 * FiboEditExtraEPOutputModel
 */
export type SchemaFiboEditReplaceObjectByTextOutput = {
  /**
   * Images
   *
   * Generated images.
   */
  images?: Array<SchemaImage>
  image: SchemaImage
  /**
   * Structured Instruction
   *
   * Current instruction.
   */
  structured_instruction: {
    [key: string]: unknown
  }
}

/**
 * ReplaceObjectInput
 */
export type SchemaFiboEditReplaceObjectByTextInput = {
  /**
   * Instruction
   *
   * The full natural language command describing what to replace.
   */
  instruction: string
  /**
   * Image Url
   *
   * The source image.
   */
  image_url: string
}

/**
 * FaceFusionImageOutput
 *
 * FaceFusion output payload when image content is generated
 */
export type SchemaAiFaceSwapFaceswapimageOutput = {
  image: SchemaImage
  /**
   * Processing Time Ms
   *
   * Optional processing duration in milliseconds
   */
  processing_time_ms?: number | unknown
}

/**
 * FaceSwapInputImage
 *
 * Input schema for image  image face swap
 */
export type SchemaAiFaceSwapFaceswapimageInput = {
  /**
   * Source Face Url
   *
   * Source face image
   */
  source_face_url: string
  /**
   * Target Image Url
   *
   * Target image URL
   */
  target_image_url: string
}

/**
 * ReplaceBackgroundOutputModel
 */
export type SchemaReplaceBackgroundOutput = {
  /**
   * Images
   *
   * Generated images.
   */
  images?: Array<{
    [key: string]: unknown
  }>
  image: SchemaImage
}

/**
 * ReplaceBackgroundInputModel
 */
export type SchemaReplaceBackgroundInput = {
  /**
   * Prompt
   *
   * Prompt for background replacement.
   */
  prompt?: string | unknown
  /**
   * Steps Num
   *
   * Number of inference steps.
   */
  steps_num?: number
  /**
   * Sync Mode
   *
   * If true, returns the image directly in the response (increases latency).
   */
  sync_mode?: boolean
  /**
   * Seed
   *
   * Random seed for reproducibility.
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * Negative prompt for background replacement.
   */
  negative_prompt?: string
  /**
   * Image Url
   *
   * Reference image (file or URL).
   */
  image_url?: string | unknown
}

/**
 * Output
 */
export type SchemaClarityUpscalerOutput = {
  /**
   * The URL of the generated image.
   */
  image: SchemaImage
  /**
   * Seed
   *
   * The seed used to generate the image.
   */
  seed: number
  /**
   * Timings
   *
   * The timings of the different steps in the workflow.
   */
  timings: {
    [key: string]: number
  }
}

/**
 * Input
 */
export type SchemaClarityUpscalerInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt?: string
  /**
   * Resemblance
   *
   *
   * The resemblance of the upscaled image to the original image. The higher the resemblance, the more the model will try to keep the original image.
   * Refers to the strength of the ControlNet.
   *
   */
  resemblance?: number
  /**
   * Creativity
   *
   *
   * The creativity of the model. The higher the creativity, the more the model will deviate from the prompt.
   * Refers to the denoise strength of the sampling.
   *
   */
  creativity?: number
  /**
   * Image Url
   *
   * The URL of the image to upscale.
   */
  image_url: string
  /**
   * Upscale Factor
   *
   * The upscale factor
   */
  upscale_factor?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Negative Prompt
   *
   * The negative prompt to use. Use it to address details that you don't want in the image.
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to false, the safety checker will be disabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaAuraSrOutput = {
  /**
   * Image
   *
   * Upscaled image
   */
  image: SchemaImage
  /**
   * Timings
   *
   * Timings for each step in the pipeline.
   */
  timings: {
    [key: string]: number
  }
}

/**
 * Input
 */
export type SchemaAuraSrInput = {
  /**
   * Overlapping Tiles
   *
   * Whether to use overlapping tiles for upscaling. Setting this to true helps remove seams but doubles the inference time.
   */
  overlapping_tiles?: boolean
  /**
   * Checkpoint
   *
   * Checkpoint to use for upscaling. More coming soon.
   */
  checkpoint?: 'v1' | 'v2'
  /**
   * Upscaling Factor (Xs)
   *
   * Upscaling factor. More coming soon.
   */
  upscaling_factor?: 4
  /**
   * Image URL
   *
   * URL of the image to upscale.
   */
  image_url: string
}

/**
 * Output
 */
export type SchemaFluxDevImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseImageToInput
 */
export type SchemaFluxDevImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The URL of the image to generate an image from.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * The strength of the initial image. Higher strength values are better for this model.
   */
  strength?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * Flux2ProEditOutput
 */
export type SchemaFlux2ProEditOutput = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * The seed used for the generation.
   */
  seed: number
}

/**
 * Flux2ProImageEditInput
 */
export type SchemaFlux2ProEditInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image. If `auto`, the size will be determined by the model.
   */
  image_size?:
    | SchemaImageSize
    | 'auto'
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5'
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * The seed to use for the generation.
   */
  seed?: number
  /**
   * Image URLs
   *
   * List of URLs of input images for editing
   */
  image_urls: Array<string>
}

/**
 * Flux2EditImageOutput
 */
export type SchemaFlux2EditOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The edited images
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * Flux2EditImageInput
 */
export type SchemaFlux2EditInput = {
  /**
   * Prompt
   *
   * The prompt to edit the image.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the image to generate. The width and height must be between 512 and 2048 pixels.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The acceleration level to use for the image generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
  /**
   * Image URLs
   *
   * The URLs of the images for editing. A maximum of 4 images are allowed, if more are provided, only the first 4 will be used.
   */
  image_urls: Array<string>
  /**
   * Enable Prompt Expansion
   *
   * If set to true, the prompt will be expanded for better results.
   */
  enable_prompt_expansion?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * Flux2EditImageLoRAOutput
 */
export type SchemaFlux2LoraEditOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The edited images
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * Flux2EditImageLoRAInput
 */
export type SchemaFlux2LoraEditInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the image to generate. The width and height must be between 512 and 2048 pixels.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The acceleration level to use for the image generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Loras
   *
   * List of LoRA weights to apply (maximum 3). Each LoRA can be a URL, HuggingFace repo ID, or local path.
   */
  loras?: Array<SchemaLoRaInput>
  /**
   * Guidance Scale
   *
   * Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
  /**
   * Image URLs
   *
   * The URsL of the images for editing. A maximum of 3 images are allowed, if more are provided, only the first 3 will be used.
   */
  image_urls: Array<string>
  /**
   * Enable Prompt Expansion
   *
   * If set to true, the prompt will be expanded for better results.
   */
  enable_prompt_expansion?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * FluxKontextOutput
 */
export type SchemaFluxProKontextOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaFalToolkitImageImageImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * FluxKontextInput
 */
export type SchemaFluxProKontextInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * Image prompt for the omni model.
   */
  image_url: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enhance Prompt
   *
   * Whether to enhance the prompt for better results.
   */
  enhance_prompt?: boolean
}

export type SchemaQueueStatus = {
  status: 'IN_QUEUE' | 'IN_PROGRESS' | 'COMPLETED'
  /**
   * The request id.
   */
  request_id: string
  /**
   * The response url.
   */
  response_url?: string
  /**
   * The status url.
   */
  status_url?: string
  /**
   * The cancel url.
   */
  cancel_url?: string
  /**
   * The logs.
   */
  logs?: {
    [key: string]: unknown
  }
  /**
   * The metrics.
   */
  metrics?: {
    [key: string]: unknown
  }
  /**
   * The queue position.
   */
  queue_position?: number
}

export type GetFalAiFluxProKontextRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-pro/kontext/requests/{request_id}/status'
}

export type GetFalAiFluxProKontextRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxProKontextRequestsByRequestIdStatusResponse =
  GetFalAiFluxProKontextRequestsByRequestIdStatusResponses[keyof GetFalAiFluxProKontextRequestsByRequestIdStatusResponses]

export type PutFalAiFluxProKontextRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/kontext/requests/{request_id}/cancel'
}

export type PutFalAiFluxProKontextRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxProKontextRequestsByRequestIdCancelResponse =
  PutFalAiFluxProKontextRequestsByRequestIdCancelResponses[keyof PutFalAiFluxProKontextRequestsByRequestIdCancelResponses]

export type PostFalAiFluxProKontextData = {
  body: SchemaFluxProKontextInput
  path?: never
  query?: never
  url: '/fal-ai/flux-pro/kontext'
}

export type PostFalAiFluxProKontextResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxProKontextResponse =
  PostFalAiFluxProKontextResponses[keyof PostFalAiFluxProKontextResponses]

export type GetFalAiFluxProKontextRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/kontext/requests/{request_id}'
}

export type GetFalAiFluxProKontextRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxProKontextOutput
}

export type GetFalAiFluxProKontextRequestsByRequestIdResponse =
  GetFalAiFluxProKontextRequestsByRequestIdResponses[keyof GetFalAiFluxProKontextRequestsByRequestIdResponses]

export type GetFalAiFlux2LoraEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/lora/edit/requests/{request_id}/status'
}

export type GetFalAiFlux2LoraEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2LoraEditRequestsByRequestIdStatusResponse =
  GetFalAiFlux2LoraEditRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2LoraEditRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2LoraEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/lora/edit/requests/{request_id}/cancel'
}

export type PutFalAiFlux2LoraEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2LoraEditRequestsByRequestIdCancelResponse =
  PutFalAiFlux2LoraEditRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2LoraEditRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2LoraEditData = {
  body: SchemaFlux2LoraEditInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2/lora/edit'
}

export type PostFalAiFlux2LoraEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2LoraEditResponse =
  PostFalAiFlux2LoraEditResponses[keyof PostFalAiFlux2LoraEditResponses]

export type GetFalAiFlux2LoraEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/lora/edit/requests/{request_id}'
}

export type GetFalAiFlux2LoraEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2LoraEditOutput
}

export type GetFalAiFlux2LoraEditRequestsByRequestIdResponse =
  GetFalAiFlux2LoraEditRequestsByRequestIdResponses[keyof GetFalAiFlux2LoraEditRequestsByRequestIdResponses]

export type GetFalAiFlux2EditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/edit/requests/{request_id}/status'
}

export type GetFalAiFlux2EditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2EditRequestsByRequestIdStatusResponse =
  GetFalAiFlux2EditRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2EditRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2EditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/edit/requests/{request_id}/cancel'
}

export type PutFalAiFlux2EditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2EditRequestsByRequestIdCancelResponse =
  PutFalAiFlux2EditRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2EditRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2EditData = {
  body: SchemaFlux2EditInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2/edit'
}

export type PostFalAiFlux2EditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2EditResponse =
  PostFalAiFlux2EditResponses[keyof PostFalAiFlux2EditResponses]

export type GetFalAiFlux2EditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/edit/requests/{request_id}'
}

export type GetFalAiFlux2EditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2EditOutput
}

export type GetFalAiFlux2EditRequestsByRequestIdResponse =
  GetFalAiFlux2EditRequestsByRequestIdResponses[keyof GetFalAiFlux2EditRequestsByRequestIdResponses]

export type GetFalAiFlux2ProEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2-pro/edit/requests/{request_id}/status'
}

export type GetFalAiFlux2ProEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2ProEditRequestsByRequestIdStatusResponse =
  GetFalAiFlux2ProEditRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2ProEditRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2ProEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-pro/edit/requests/{request_id}/cancel'
}

export type PutFalAiFlux2ProEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2ProEditRequestsByRequestIdCancelResponse =
  PutFalAiFlux2ProEditRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2ProEditRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2ProEditData = {
  body: SchemaFlux2ProEditInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2-pro/edit'
}

export type PostFalAiFlux2ProEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2ProEditResponse =
  PostFalAiFlux2ProEditResponses[keyof PostFalAiFlux2ProEditResponses]

export type GetFalAiFlux2ProEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-pro/edit/requests/{request_id}'
}

export type GetFalAiFlux2ProEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2ProEditOutput
}

export type GetFalAiFlux2ProEditRequestsByRequestIdResponse =
  GetFalAiFlux2ProEditRequestsByRequestIdResponses[keyof GetFalAiFlux2ProEditRequestsByRequestIdResponses]

export type GetFalAiFluxDevImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux/dev/image-to-image/requests/{request_id}/status'
}

export type GetFalAiFluxDevImageToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxDevImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiFluxDevImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiFluxDevImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiFluxDevImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/dev/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiFluxDevImageToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxDevImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiFluxDevImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiFluxDevImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiFluxDevImageToImageData = {
  body: SchemaFluxDevImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/flux/dev/image-to-image'
}

export type PostFalAiFluxDevImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxDevImageToImageResponse =
  PostFalAiFluxDevImageToImageResponses[keyof PostFalAiFluxDevImageToImageResponses]

export type GetFalAiFluxDevImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/dev/image-to-image/requests/{request_id}'
}

export type GetFalAiFluxDevImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxDevImageToImageOutput
}

export type GetFalAiFluxDevImageToImageRequestsByRequestIdResponse =
  GetFalAiFluxDevImageToImageRequestsByRequestIdResponses[keyof GetFalAiFluxDevImageToImageRequestsByRequestIdResponses]

export type GetFalAiAuraSrRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/aura-sr/requests/{request_id}/status'
}

export type GetFalAiAuraSrRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiAuraSrRequestsByRequestIdStatusResponse =
  GetFalAiAuraSrRequestsByRequestIdStatusResponses[keyof GetFalAiAuraSrRequestsByRequestIdStatusResponses]

export type PutFalAiAuraSrRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/aura-sr/requests/{request_id}/cancel'
}

export type PutFalAiAuraSrRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiAuraSrRequestsByRequestIdCancelResponse =
  PutFalAiAuraSrRequestsByRequestIdCancelResponses[keyof PutFalAiAuraSrRequestsByRequestIdCancelResponses]

export type PostFalAiAuraSrData = {
  body: SchemaAuraSrInput
  path?: never
  query?: never
  url: '/fal-ai/aura-sr'
}

export type PostFalAiAuraSrResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiAuraSrResponse =
  PostFalAiAuraSrResponses[keyof PostFalAiAuraSrResponses]

export type GetFalAiAuraSrRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/aura-sr/requests/{request_id}'
}

export type GetFalAiAuraSrRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaAuraSrOutput
}

export type GetFalAiAuraSrRequestsByRequestIdResponse =
  GetFalAiAuraSrRequestsByRequestIdResponses[keyof GetFalAiAuraSrRequestsByRequestIdResponses]

export type GetFalAiClarityUpscalerRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/clarity-upscaler/requests/{request_id}/status'
}

export type GetFalAiClarityUpscalerRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiClarityUpscalerRequestsByRequestIdStatusResponse =
  GetFalAiClarityUpscalerRequestsByRequestIdStatusResponses[keyof GetFalAiClarityUpscalerRequestsByRequestIdStatusResponses]

export type PutFalAiClarityUpscalerRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/clarity-upscaler/requests/{request_id}/cancel'
}

export type PutFalAiClarityUpscalerRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiClarityUpscalerRequestsByRequestIdCancelResponse =
  PutFalAiClarityUpscalerRequestsByRequestIdCancelResponses[keyof PutFalAiClarityUpscalerRequestsByRequestIdCancelResponses]

export type PostFalAiClarityUpscalerData = {
  body: SchemaClarityUpscalerInput
  path?: never
  query?: never
  url: '/fal-ai/clarity-upscaler'
}

export type PostFalAiClarityUpscalerResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiClarityUpscalerResponse =
  PostFalAiClarityUpscalerResponses[keyof PostFalAiClarityUpscalerResponses]

export type GetFalAiClarityUpscalerRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/clarity-upscaler/requests/{request_id}'
}

export type GetFalAiClarityUpscalerRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaClarityUpscalerOutput
}

export type GetFalAiClarityUpscalerRequestsByRequestIdResponse =
  GetFalAiClarityUpscalerRequestsByRequestIdResponses[keyof GetFalAiClarityUpscalerRequestsByRequestIdResponses]

export type GetBriaReplaceBackgroundRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/bria/replace-background/requests/{request_id}/status'
}

export type GetBriaReplaceBackgroundRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetBriaReplaceBackgroundRequestsByRequestIdStatusResponse =
  GetBriaReplaceBackgroundRequestsByRequestIdStatusResponses[keyof GetBriaReplaceBackgroundRequestsByRequestIdStatusResponses]

export type PutBriaReplaceBackgroundRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/replace-background/requests/{request_id}/cancel'
}

export type PutBriaReplaceBackgroundRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutBriaReplaceBackgroundRequestsByRequestIdCancelResponse =
  PutBriaReplaceBackgroundRequestsByRequestIdCancelResponses[keyof PutBriaReplaceBackgroundRequestsByRequestIdCancelResponses]

export type PostBriaReplaceBackgroundData = {
  body: SchemaReplaceBackgroundInput
  path?: never
  query?: never
  url: '/bria/replace-background'
}

export type PostBriaReplaceBackgroundResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostBriaReplaceBackgroundResponse =
  PostBriaReplaceBackgroundResponses[keyof PostBriaReplaceBackgroundResponses]

export type GetBriaReplaceBackgroundRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/replace-background/requests/{request_id}'
}

export type GetBriaReplaceBackgroundRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaReplaceBackgroundOutput
}

export type GetBriaReplaceBackgroundRequestsByRequestIdResponse =
  GetBriaReplaceBackgroundRequestsByRequestIdResponses[keyof GetBriaReplaceBackgroundRequestsByRequestIdResponses]

export type GetHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/half-moon-ai/ai-face-swap/faceswapimage/requests/{request_id}/status'
  }

export type GetHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdStatusResponse =
  GetHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdStatusResponses[keyof GetHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdStatusResponses]

export type PutHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/half-moon-ai/ai-face-swap/faceswapimage/requests/{request_id}/cancel'
  }

export type PutHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdCancelResponse =
  PutHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdCancelResponses[keyof PutHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdCancelResponses]

export type PostHalfMoonAiAiFaceSwapFaceswapimageData = {
  body: SchemaAiFaceSwapFaceswapimageInput
  path?: never
  query?: never
  url: '/half-moon-ai/ai-face-swap/faceswapimage'
}

export type PostHalfMoonAiAiFaceSwapFaceswapimageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostHalfMoonAiAiFaceSwapFaceswapimageResponse =
  PostHalfMoonAiAiFaceSwapFaceswapimageResponses[keyof PostHalfMoonAiAiFaceSwapFaceswapimageResponses]

export type GetHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/half-moon-ai/ai-face-swap/faceswapimage/requests/{request_id}'
}

export type GetHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaAiFaceSwapFaceswapimageOutput
}

export type GetHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdResponse =
  GetHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdResponses[keyof GetHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdResponses]

export type GetBriaFiboEditReplaceObjectByTextRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/bria/fibo-edit/replace_object_by_text/requests/{request_id}/status'
}

export type GetBriaFiboEditReplaceObjectByTextRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetBriaFiboEditReplaceObjectByTextRequestsByRequestIdStatusResponse =
  GetBriaFiboEditReplaceObjectByTextRequestsByRequestIdStatusResponses[keyof GetBriaFiboEditReplaceObjectByTextRequestsByRequestIdStatusResponses]

export type PutBriaFiboEditReplaceObjectByTextRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/replace_object_by_text/requests/{request_id}/cancel'
}

export type PutBriaFiboEditReplaceObjectByTextRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutBriaFiboEditReplaceObjectByTextRequestsByRequestIdCancelResponse =
  PutBriaFiboEditReplaceObjectByTextRequestsByRequestIdCancelResponses[keyof PutBriaFiboEditReplaceObjectByTextRequestsByRequestIdCancelResponses]

export type PostBriaFiboEditReplaceObjectByTextData = {
  body: SchemaFiboEditReplaceObjectByTextInput
  path?: never
  query?: never
  url: '/bria/fibo-edit/replace_object_by_text'
}

export type PostBriaFiboEditReplaceObjectByTextResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostBriaFiboEditReplaceObjectByTextResponse =
  PostBriaFiboEditReplaceObjectByTextResponses[keyof PostBriaFiboEditReplaceObjectByTextResponses]

export type GetBriaFiboEditReplaceObjectByTextRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/replace_object_by_text/requests/{request_id}'
}

export type GetBriaFiboEditReplaceObjectByTextRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFiboEditReplaceObjectByTextOutput
}

export type GetBriaFiboEditReplaceObjectByTextRequestsByRequestIdResponse =
  GetBriaFiboEditReplaceObjectByTextRequestsByRequestIdResponses[keyof GetBriaFiboEditReplaceObjectByTextRequestsByRequestIdResponses]

export type GetBriaFiboEditSketchToColoredImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/bria/fibo-edit/sketch_to_colored_image/requests/{request_id}/status'
}

export type GetBriaFiboEditSketchToColoredImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetBriaFiboEditSketchToColoredImageRequestsByRequestIdStatusResponse =
  GetBriaFiboEditSketchToColoredImageRequestsByRequestIdStatusResponses[keyof GetBriaFiboEditSketchToColoredImageRequestsByRequestIdStatusResponses]

export type PutBriaFiboEditSketchToColoredImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/sketch_to_colored_image/requests/{request_id}/cancel'
}

export type PutBriaFiboEditSketchToColoredImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutBriaFiboEditSketchToColoredImageRequestsByRequestIdCancelResponse =
  PutBriaFiboEditSketchToColoredImageRequestsByRequestIdCancelResponses[keyof PutBriaFiboEditSketchToColoredImageRequestsByRequestIdCancelResponses]

export type PostBriaFiboEditSketchToColoredImageData = {
  body: SchemaFiboEditSketchToColoredImageInput
  path?: never
  query?: never
  url: '/bria/fibo-edit/sketch_to_colored_image'
}

export type PostBriaFiboEditSketchToColoredImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostBriaFiboEditSketchToColoredImageResponse =
  PostBriaFiboEditSketchToColoredImageResponses[keyof PostBriaFiboEditSketchToColoredImageResponses]

export type GetBriaFiboEditSketchToColoredImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/sketch_to_colored_image/requests/{request_id}'
}

export type GetBriaFiboEditSketchToColoredImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFiboEditSketchToColoredImageOutput
}

export type GetBriaFiboEditSketchToColoredImageRequestsByRequestIdResponse =
  GetBriaFiboEditSketchToColoredImageRequestsByRequestIdResponses[keyof GetBriaFiboEditSketchToColoredImageRequestsByRequestIdResponses]

export type GetBriaFiboEditRestoreRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/bria/fibo-edit/restore/requests/{request_id}/status'
}

export type GetBriaFiboEditRestoreRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetBriaFiboEditRestoreRequestsByRequestIdStatusResponse =
  GetBriaFiboEditRestoreRequestsByRequestIdStatusResponses[keyof GetBriaFiboEditRestoreRequestsByRequestIdStatusResponses]

export type PutBriaFiboEditRestoreRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/restore/requests/{request_id}/cancel'
}

export type PutBriaFiboEditRestoreRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutBriaFiboEditRestoreRequestsByRequestIdCancelResponse =
  PutBriaFiboEditRestoreRequestsByRequestIdCancelResponses[keyof PutBriaFiboEditRestoreRequestsByRequestIdCancelResponses]

export type PostBriaFiboEditRestoreData = {
  body: SchemaFiboEditRestoreInput
  path?: never
  query?: never
  url: '/bria/fibo-edit/restore'
}

export type PostBriaFiboEditRestoreResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostBriaFiboEditRestoreResponse =
  PostBriaFiboEditRestoreResponses[keyof PostBriaFiboEditRestoreResponses]

export type GetBriaFiboEditRestoreRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/restore/requests/{request_id}'
}

export type GetBriaFiboEditRestoreRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFiboEditRestoreOutput
}

export type GetBriaFiboEditRestoreRequestsByRequestIdResponse =
  GetBriaFiboEditRestoreRequestsByRequestIdResponses[keyof GetBriaFiboEditRestoreRequestsByRequestIdResponses]

export type GetBriaFiboEditReseasonRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/bria/fibo-edit/reseason/requests/{request_id}/status'
}

export type GetBriaFiboEditReseasonRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetBriaFiboEditReseasonRequestsByRequestIdStatusResponse =
  GetBriaFiboEditReseasonRequestsByRequestIdStatusResponses[keyof GetBriaFiboEditReseasonRequestsByRequestIdStatusResponses]

export type PutBriaFiboEditReseasonRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/reseason/requests/{request_id}/cancel'
}

export type PutBriaFiboEditReseasonRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutBriaFiboEditReseasonRequestsByRequestIdCancelResponse =
  PutBriaFiboEditReseasonRequestsByRequestIdCancelResponses[keyof PutBriaFiboEditReseasonRequestsByRequestIdCancelResponses]

export type PostBriaFiboEditReseasonData = {
  body: SchemaFiboEditReseasonInput
  path?: never
  query?: never
  url: '/bria/fibo-edit/reseason'
}

export type PostBriaFiboEditReseasonResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostBriaFiboEditReseasonResponse =
  PostBriaFiboEditReseasonResponses[keyof PostBriaFiboEditReseasonResponses]

export type GetBriaFiboEditReseasonRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/reseason/requests/{request_id}'
}

export type GetBriaFiboEditReseasonRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFiboEditReseasonOutput
}

export type GetBriaFiboEditReseasonRequestsByRequestIdResponse =
  GetBriaFiboEditReseasonRequestsByRequestIdResponses[keyof GetBriaFiboEditReseasonRequestsByRequestIdResponses]

export type GetBriaFiboEditRelightRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/bria/fibo-edit/relight/requests/{request_id}/status'
}

export type GetBriaFiboEditRelightRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetBriaFiboEditRelightRequestsByRequestIdStatusResponse =
  GetBriaFiboEditRelightRequestsByRequestIdStatusResponses[keyof GetBriaFiboEditRelightRequestsByRequestIdStatusResponses]

export type PutBriaFiboEditRelightRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/relight/requests/{request_id}/cancel'
}

export type PutBriaFiboEditRelightRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutBriaFiboEditRelightRequestsByRequestIdCancelResponse =
  PutBriaFiboEditRelightRequestsByRequestIdCancelResponses[keyof PutBriaFiboEditRelightRequestsByRequestIdCancelResponses]

export type PostBriaFiboEditRelightData = {
  body: SchemaFiboEditRelightInput
  path?: never
  query?: never
  url: '/bria/fibo-edit/relight'
}

export type PostBriaFiboEditRelightResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostBriaFiboEditRelightResponse =
  PostBriaFiboEditRelightResponses[keyof PostBriaFiboEditRelightResponses]

export type GetBriaFiboEditRelightRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/relight/requests/{request_id}'
}

export type GetBriaFiboEditRelightRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFiboEditRelightOutput
}

export type GetBriaFiboEditRelightRequestsByRequestIdResponse =
  GetBriaFiboEditRelightRequestsByRequestIdResponses[keyof GetBriaFiboEditRelightRequestsByRequestIdResponses]

export type GetBriaFiboEditRestyleRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/bria/fibo-edit/restyle/requests/{request_id}/status'
}

export type GetBriaFiboEditRestyleRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetBriaFiboEditRestyleRequestsByRequestIdStatusResponse =
  GetBriaFiboEditRestyleRequestsByRequestIdStatusResponses[keyof GetBriaFiboEditRestyleRequestsByRequestIdStatusResponses]

export type PutBriaFiboEditRestyleRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/restyle/requests/{request_id}/cancel'
}

export type PutBriaFiboEditRestyleRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutBriaFiboEditRestyleRequestsByRequestIdCancelResponse =
  PutBriaFiboEditRestyleRequestsByRequestIdCancelResponses[keyof PutBriaFiboEditRestyleRequestsByRequestIdCancelResponses]

export type PostBriaFiboEditRestyleData = {
  body: SchemaFiboEditRestyleInput
  path?: never
  query?: never
  url: '/bria/fibo-edit/restyle'
}

export type PostBriaFiboEditRestyleResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostBriaFiboEditRestyleResponse =
  PostBriaFiboEditRestyleResponses[keyof PostBriaFiboEditRestyleResponses]

export type GetBriaFiboEditRestyleRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/restyle/requests/{request_id}'
}

export type GetBriaFiboEditRestyleRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFiboEditRestyleOutput
}

export type GetBriaFiboEditRestyleRequestsByRequestIdResponse =
  GetBriaFiboEditRestyleRequestsByRequestIdResponses[keyof GetBriaFiboEditRestyleRequestsByRequestIdResponses]

export type GetBriaFiboEditRewriteTextRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/bria/fibo-edit/rewrite_text/requests/{request_id}/status'
}

export type GetBriaFiboEditRewriteTextRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetBriaFiboEditRewriteTextRequestsByRequestIdStatusResponse =
  GetBriaFiboEditRewriteTextRequestsByRequestIdStatusResponses[keyof GetBriaFiboEditRewriteTextRequestsByRequestIdStatusResponses]

export type PutBriaFiboEditRewriteTextRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/rewrite_text/requests/{request_id}/cancel'
}

export type PutBriaFiboEditRewriteTextRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutBriaFiboEditRewriteTextRequestsByRequestIdCancelResponse =
  PutBriaFiboEditRewriteTextRequestsByRequestIdCancelResponses[keyof PutBriaFiboEditRewriteTextRequestsByRequestIdCancelResponses]

export type PostBriaFiboEditRewriteTextData = {
  body: SchemaFiboEditRewriteTextInput
  path?: never
  query?: never
  url: '/bria/fibo-edit/rewrite_text'
}

export type PostBriaFiboEditRewriteTextResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostBriaFiboEditRewriteTextResponse =
  PostBriaFiboEditRewriteTextResponses[keyof PostBriaFiboEditRewriteTextResponses]

export type GetBriaFiboEditRewriteTextRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/rewrite_text/requests/{request_id}'
}

export type GetBriaFiboEditRewriteTextRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFiboEditRewriteTextOutput
}

export type GetBriaFiboEditRewriteTextRequestsByRequestIdResponse =
  GetBriaFiboEditRewriteTextRequestsByRequestIdResponses[keyof GetBriaFiboEditRewriteTextRequestsByRequestIdResponses]

export type GetBriaFiboEditEraseByTextRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/bria/fibo-edit/erase_by_text/requests/{request_id}/status'
}

export type GetBriaFiboEditEraseByTextRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetBriaFiboEditEraseByTextRequestsByRequestIdStatusResponse =
  GetBriaFiboEditEraseByTextRequestsByRequestIdStatusResponses[keyof GetBriaFiboEditEraseByTextRequestsByRequestIdStatusResponses]

export type PutBriaFiboEditEraseByTextRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/erase_by_text/requests/{request_id}/cancel'
}

export type PutBriaFiboEditEraseByTextRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutBriaFiboEditEraseByTextRequestsByRequestIdCancelResponse =
  PutBriaFiboEditEraseByTextRequestsByRequestIdCancelResponses[keyof PutBriaFiboEditEraseByTextRequestsByRequestIdCancelResponses]

export type PostBriaFiboEditEraseByTextData = {
  body: SchemaFiboEditEraseByTextInput
  path?: never
  query?: never
  url: '/bria/fibo-edit/erase_by_text'
}

export type PostBriaFiboEditEraseByTextResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostBriaFiboEditEraseByTextResponse =
  PostBriaFiboEditEraseByTextResponses[keyof PostBriaFiboEditEraseByTextResponses]

export type GetBriaFiboEditEraseByTextRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/erase_by_text/requests/{request_id}'
}

export type GetBriaFiboEditEraseByTextRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFiboEditEraseByTextOutput
}

export type GetBriaFiboEditEraseByTextRequestsByRequestIdResponse =
  GetBriaFiboEditEraseByTextRequestsByRequestIdResponses[keyof GetBriaFiboEditEraseByTextRequestsByRequestIdResponses]

export type GetBriaFiboEditEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/bria/fibo-edit/edit/requests/{request_id}/status'
}

export type GetBriaFiboEditEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetBriaFiboEditEditRequestsByRequestIdStatusResponse =
  GetBriaFiboEditEditRequestsByRequestIdStatusResponses[keyof GetBriaFiboEditEditRequestsByRequestIdStatusResponses]

export type PutBriaFiboEditEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/edit/requests/{request_id}/cancel'
}

export type PutBriaFiboEditEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutBriaFiboEditEditRequestsByRequestIdCancelResponse =
  PutBriaFiboEditEditRequestsByRequestIdCancelResponses[keyof PutBriaFiboEditEditRequestsByRequestIdCancelResponses]

export type PostBriaFiboEditEditData = {
  body: SchemaFiboEditEditInput
  path?: never
  query?: never
  url: '/bria/fibo-edit/edit'
}

export type PostBriaFiboEditEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostBriaFiboEditEditResponse =
  PostBriaFiboEditEditResponses[keyof PostBriaFiboEditEditResponses]

export type GetBriaFiboEditEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/edit/requests/{request_id}'
}

export type GetBriaFiboEditEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFiboEditEditOutput
}

export type GetBriaFiboEditEditRequestsByRequestIdResponse =
  GetBriaFiboEditEditRequestsByRequestIdResponses[keyof GetBriaFiboEditEditRequestsByRequestIdResponses]

export type GetBriaFiboEditAddObjectByTextRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/bria/fibo-edit/add_object_by_text/requests/{request_id}/status'
}

export type GetBriaFiboEditAddObjectByTextRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetBriaFiboEditAddObjectByTextRequestsByRequestIdStatusResponse =
  GetBriaFiboEditAddObjectByTextRequestsByRequestIdStatusResponses[keyof GetBriaFiboEditAddObjectByTextRequestsByRequestIdStatusResponses]

export type PutBriaFiboEditAddObjectByTextRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/add_object_by_text/requests/{request_id}/cancel'
}

export type PutBriaFiboEditAddObjectByTextRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutBriaFiboEditAddObjectByTextRequestsByRequestIdCancelResponse =
  PutBriaFiboEditAddObjectByTextRequestsByRequestIdCancelResponses[keyof PutBriaFiboEditAddObjectByTextRequestsByRequestIdCancelResponses]

export type PostBriaFiboEditAddObjectByTextData = {
  body: SchemaFiboEditAddObjectByTextInput
  path?: never
  query?: never
  url: '/bria/fibo-edit/add_object_by_text'
}

export type PostBriaFiboEditAddObjectByTextResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostBriaFiboEditAddObjectByTextResponse =
  PostBriaFiboEditAddObjectByTextResponses[keyof PostBriaFiboEditAddObjectByTextResponses]

export type GetBriaFiboEditAddObjectByTextRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/add_object_by_text/requests/{request_id}'
}

export type GetBriaFiboEditAddObjectByTextRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFiboEditAddObjectByTextOutput
}

export type GetBriaFiboEditAddObjectByTextRequestsByRequestIdResponse =
  GetBriaFiboEditAddObjectByTextRequestsByRequestIdResponses[keyof GetBriaFiboEditAddObjectByTextRequestsByRequestIdResponses]

export type GetBriaFiboEditBlendRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/bria/fibo-edit/blend/requests/{request_id}/status'
}

export type GetBriaFiboEditBlendRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetBriaFiboEditBlendRequestsByRequestIdStatusResponse =
  GetBriaFiboEditBlendRequestsByRequestIdStatusResponses[keyof GetBriaFiboEditBlendRequestsByRequestIdStatusResponses]

export type PutBriaFiboEditBlendRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/blend/requests/{request_id}/cancel'
}

export type PutBriaFiboEditBlendRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutBriaFiboEditBlendRequestsByRequestIdCancelResponse =
  PutBriaFiboEditBlendRequestsByRequestIdCancelResponses[keyof PutBriaFiboEditBlendRequestsByRequestIdCancelResponses]

export type PostBriaFiboEditBlendData = {
  body: SchemaFiboEditBlendInput
  path?: never
  query?: never
  url: '/bria/fibo-edit/blend'
}

export type PostBriaFiboEditBlendResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostBriaFiboEditBlendResponse =
  PostBriaFiboEditBlendResponses[keyof PostBriaFiboEditBlendResponses]

export type GetBriaFiboEditBlendRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/blend/requests/{request_id}'
}

export type GetBriaFiboEditBlendRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFiboEditBlendOutput
}

export type GetBriaFiboEditBlendRequestsByRequestIdResponse =
  GetBriaFiboEditBlendRequestsByRequestIdResponses[keyof GetBriaFiboEditBlendRequestsByRequestIdResponses]

export type GetBriaFiboEditColorizeRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/bria/fibo-edit/colorize/requests/{request_id}/status'
}

export type GetBriaFiboEditColorizeRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetBriaFiboEditColorizeRequestsByRequestIdStatusResponse =
  GetBriaFiboEditColorizeRequestsByRequestIdStatusResponses[keyof GetBriaFiboEditColorizeRequestsByRequestIdStatusResponses]

export type PutBriaFiboEditColorizeRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/colorize/requests/{request_id}/cancel'
}

export type PutBriaFiboEditColorizeRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutBriaFiboEditColorizeRequestsByRequestIdCancelResponse =
  PutBriaFiboEditColorizeRequestsByRequestIdCancelResponses[keyof PutBriaFiboEditColorizeRequestsByRequestIdCancelResponses]

export type PostBriaFiboEditColorizeData = {
  body: SchemaFiboEditColorizeInput
  path?: never
  query?: never
  url: '/bria/fibo-edit/colorize'
}

export type PostBriaFiboEditColorizeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostBriaFiboEditColorizeResponse =
  PostBriaFiboEditColorizeResponses[keyof PostBriaFiboEditColorizeResponses]

export type GetBriaFiboEditColorizeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-edit/colorize/requests/{request_id}'
}

export type GetBriaFiboEditColorizeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFiboEditColorizeOutput
}

export type GetBriaFiboEditColorizeRequestsByRequestIdResponse =
  GetBriaFiboEditColorizeRequestsByRequestIdResponses[keyof GetBriaFiboEditColorizeRequestsByRequestIdResponses]

export type GetFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/klein/9b/base/edit/lora/requests/{request_id}/status'
}

export type GetFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdStatusResponse =
  GetFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/9b/base/edit/lora/requests/{request_id}/cancel'
}

export type PutFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdCancelResponse =
  PutFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2Klein9bBaseEditLoraData = {
  body: SchemaFlux2Klein9bBaseEditLoraInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2/klein/9b/base/edit/lora'
}

export type PostFalAiFlux2Klein9bBaseEditLoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2Klein9bBaseEditLoraResponse =
  PostFalAiFlux2Klein9bBaseEditLoraResponses[keyof PostFalAiFlux2Klein9bBaseEditLoraResponses]

export type GetFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/9b/base/edit/lora/requests/{request_id}'
}

export type GetFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2Klein9bBaseEditLoraOutput
}

export type GetFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdResponse =
  GetFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdResponses[keyof GetFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdResponses]

export type GetFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/klein/4b/base/edit/lora/requests/{request_id}/status'
}

export type GetFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdStatusResponse =
  GetFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/4b/base/edit/lora/requests/{request_id}/cancel'
}

export type PutFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdCancelResponse =
  PutFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2Klein4bBaseEditLoraData = {
  body: SchemaFlux2Klein4bBaseEditLoraInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2/klein/4b/base/edit/lora'
}

export type PostFalAiFlux2Klein4bBaseEditLoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2Klein4bBaseEditLoraResponse =
  PostFalAiFlux2Klein4bBaseEditLoraResponses[keyof PostFalAiFlux2Klein4bBaseEditLoraResponses]

export type GetFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/4b/base/edit/lora/requests/{request_id}'
}

export type GetFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2Klein4bBaseEditLoraOutput
}

export type GetFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdResponse =
  GetFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdResponses[keyof GetFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdResponses]

export type GetFalAiFlux2Klein4bBaseEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/klein/4b/base/edit/requests/{request_id}/status'
}

export type GetFalAiFlux2Klein4bBaseEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2Klein4bBaseEditRequestsByRequestIdStatusResponse =
  GetFalAiFlux2Klein4bBaseEditRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2Klein4bBaseEditRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2Klein4bBaseEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/4b/base/edit/requests/{request_id}/cancel'
}

export type PutFalAiFlux2Klein4bBaseEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2Klein4bBaseEditRequestsByRequestIdCancelResponse =
  PutFalAiFlux2Klein4bBaseEditRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2Klein4bBaseEditRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2Klein4bBaseEditData = {
  body: SchemaFlux2Klein4bBaseEditInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2/klein/4b/base/edit'
}

export type PostFalAiFlux2Klein4bBaseEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2Klein4bBaseEditResponse =
  PostFalAiFlux2Klein4bBaseEditResponses[keyof PostFalAiFlux2Klein4bBaseEditResponses]

export type GetFalAiFlux2Klein4bBaseEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/4b/base/edit/requests/{request_id}'
}

export type GetFalAiFlux2Klein4bBaseEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2Klein4bBaseEditOutput
}

export type GetFalAiFlux2Klein4bBaseEditRequestsByRequestIdResponse =
  GetFalAiFlux2Klein4bBaseEditRequestsByRequestIdResponses[keyof GetFalAiFlux2Klein4bBaseEditRequestsByRequestIdResponses]

export type GetFalAiFlux2Klein9bBaseEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/klein/9b/base/edit/requests/{request_id}/status'
}

export type GetFalAiFlux2Klein9bBaseEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2Klein9bBaseEditRequestsByRequestIdStatusResponse =
  GetFalAiFlux2Klein9bBaseEditRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2Klein9bBaseEditRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2Klein9bBaseEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/9b/base/edit/requests/{request_id}/cancel'
}

export type PutFalAiFlux2Klein9bBaseEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2Klein9bBaseEditRequestsByRequestIdCancelResponse =
  PutFalAiFlux2Klein9bBaseEditRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2Klein9bBaseEditRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2Klein9bBaseEditData = {
  body: SchemaFlux2Klein9bBaseEditInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2/klein/9b/base/edit'
}

export type PostFalAiFlux2Klein9bBaseEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2Klein9bBaseEditResponse =
  PostFalAiFlux2Klein9bBaseEditResponses[keyof PostFalAiFlux2Klein9bBaseEditResponses]

export type GetFalAiFlux2Klein9bBaseEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/9b/base/edit/requests/{request_id}'
}

export type GetFalAiFlux2Klein9bBaseEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2Klein9bBaseEditOutput
}

export type GetFalAiFlux2Klein9bBaseEditRequestsByRequestIdResponse =
  GetFalAiFlux2Klein9bBaseEditRequestsByRequestIdResponses[keyof GetFalAiFlux2Klein9bBaseEditRequestsByRequestIdResponses]

export type GetFalAiFlux2Klein4bEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/klein/4b/edit/requests/{request_id}/status'
}

export type GetFalAiFlux2Klein4bEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2Klein4bEditRequestsByRequestIdStatusResponse =
  GetFalAiFlux2Klein4bEditRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2Klein4bEditRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2Klein4bEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/4b/edit/requests/{request_id}/cancel'
}

export type PutFalAiFlux2Klein4bEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2Klein4bEditRequestsByRequestIdCancelResponse =
  PutFalAiFlux2Klein4bEditRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2Klein4bEditRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2Klein4bEditData = {
  body: SchemaFlux2Klein4bEditInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2/klein/4b/edit'
}

export type PostFalAiFlux2Klein4bEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2Klein4bEditResponse =
  PostFalAiFlux2Klein4bEditResponses[keyof PostFalAiFlux2Klein4bEditResponses]

export type GetFalAiFlux2Klein4bEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/4b/edit/requests/{request_id}'
}

export type GetFalAiFlux2Klein4bEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2Klein4bEditOutput
}

export type GetFalAiFlux2Klein4bEditRequestsByRequestIdResponse =
  GetFalAiFlux2Klein4bEditRequestsByRequestIdResponses[keyof GetFalAiFlux2Klein4bEditRequestsByRequestIdResponses]

export type GetFalAiFlux2Klein9bEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/klein/9b/edit/requests/{request_id}/status'
}

export type GetFalAiFlux2Klein9bEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2Klein9bEditRequestsByRequestIdStatusResponse =
  GetFalAiFlux2Klein9bEditRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2Klein9bEditRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2Klein9bEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/9b/edit/requests/{request_id}/cancel'
}

export type PutFalAiFlux2Klein9bEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2Klein9bEditRequestsByRequestIdCancelResponse =
  PutFalAiFlux2Klein9bEditRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2Klein9bEditRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2Klein9bEditData = {
  body: SchemaFlux2Klein9bEditInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2/klein/9b/edit'
}

export type PostFalAiFlux2Klein9bEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2Klein9bEditResponse =
  PostFalAiFlux2Klein9bEditResponses[keyof PostFalAiFlux2Klein9bEditResponses]

export type GetFalAiFlux2Klein9bEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/9b/edit/requests/{request_id}'
}

export type GetFalAiFlux2Klein9bEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2Klein9bEditOutput
}

export type GetFalAiFlux2Klein9bEditRequestsByRequestIdResponse =
  GetFalAiFlux2Klein9bEditRequestsByRequestIdResponses[keyof GetFalAiFlux2Klein9bEditRequestsByRequestIdResponses]

export type GetFalAiGlmImageImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/glm-image/image-to-image/requests/{request_id}/status'
}

export type GetFalAiGlmImageImageToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiGlmImageImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiGlmImageImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiGlmImageImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiGlmImageImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/glm-image/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiGlmImageImageToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiGlmImageImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiGlmImageImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiGlmImageImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiGlmImageImageToImageData = {
  body: SchemaGlmImageImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/glm-image/image-to-image'
}

export type PostFalAiGlmImageImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiGlmImageImageToImageResponse =
  PostFalAiGlmImageImageToImageResponses[keyof PostFalAiGlmImageImageToImageResponses]

export type GetFalAiGlmImageImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/glm-image/image-to-image/requests/{request_id}'
}

export type GetFalAiGlmImageImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaGlmImageImageToImageOutput
}

export type GetFalAiGlmImageImageToImageRequestsByRequestIdResponse =
  GetFalAiGlmImageImageToImageRequestsByRequestIdResponses[keyof GetFalAiGlmImageImageToImageRequestsByRequestIdResponses]

export type GetFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-2511-multiple-angles/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2511-multiple-angles/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEdit2511MultipleAnglesData = {
  body: SchemaQwenImageEdit2511MultipleAnglesInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-2511-multiple-angles'
}

export type PostFalAiQwenImageEdit2511MultipleAnglesResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEdit2511MultipleAnglesResponse =
  PostFalAiQwenImageEdit2511MultipleAnglesResponses[keyof PostFalAiQwenImageEdit2511MultipleAnglesResponses]

export type GetFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit-2511-multiple-angles/requests/{request_id}'
}

export type GetFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEdit2511MultipleAnglesOutput
  }

export type GetFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdResponse =
  GetFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdResponses[keyof GetFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdResponses]

export type GetFalAiQwenImageEdit2511LoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/qwen-image-edit-2511/lora/requests/{request_id}/status'
}

export type GetFalAiQwenImageEdit2511LoraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiQwenImageEdit2511LoraRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEdit2511LoraRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEdit2511LoraRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEdit2511LoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit-2511/lora/requests/{request_id}/cancel'
}

export type PutFalAiQwenImageEdit2511LoraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiQwenImageEdit2511LoraRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEdit2511LoraRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEdit2511LoraRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEdit2511LoraData = {
  body: SchemaQwenImageEdit2511LoraInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-2511/lora'
}

export type PostFalAiQwenImageEdit2511LoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEdit2511LoraResponse =
  PostFalAiQwenImageEdit2511LoraResponses[keyof PostFalAiQwenImageEdit2511LoraResponses]

export type GetFalAiQwenImageEdit2511LoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit-2511/lora/requests/{request_id}'
}

export type GetFalAiQwenImageEdit2511LoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaQwenImageEdit2511LoraOutput
}

export type GetFalAiQwenImageEdit2511LoraRequestsByRequestIdResponse =
  GetFalAiQwenImageEdit2511LoraRequestsByRequestIdResponses[keyof GetFalAiQwenImageEdit2511LoraRequestsByRequestIdResponses]

export type GetHalfMoonAiAiHomeStyleRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/half-moon-ai/ai-home/style/requests/{request_id}/status'
}

export type GetHalfMoonAiAiHomeStyleRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetHalfMoonAiAiHomeStyleRequestsByRequestIdStatusResponse =
  GetHalfMoonAiAiHomeStyleRequestsByRequestIdStatusResponses[keyof GetHalfMoonAiAiHomeStyleRequestsByRequestIdStatusResponses]

export type PutHalfMoonAiAiHomeStyleRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/half-moon-ai/ai-home/style/requests/{request_id}/cancel'
}

export type PutHalfMoonAiAiHomeStyleRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutHalfMoonAiAiHomeStyleRequestsByRequestIdCancelResponse =
  PutHalfMoonAiAiHomeStyleRequestsByRequestIdCancelResponses[keyof PutHalfMoonAiAiHomeStyleRequestsByRequestIdCancelResponses]

export type PostHalfMoonAiAiHomeStyleData = {
  body: SchemaAiHomeStyleInput
  path?: never
  query?: never
  url: '/half-moon-ai/ai-home/style'
}

export type PostHalfMoonAiAiHomeStyleResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostHalfMoonAiAiHomeStyleResponse =
  PostHalfMoonAiAiHomeStyleResponses[keyof PostHalfMoonAiAiHomeStyleResponses]

export type GetHalfMoonAiAiHomeStyleRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/half-moon-ai/ai-home/style/requests/{request_id}'
}

export type GetHalfMoonAiAiHomeStyleRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaAiHomeStyleOutput
}

export type GetHalfMoonAiAiHomeStyleRequestsByRequestIdResponse =
  GetHalfMoonAiAiHomeStyleRequestsByRequestIdResponses[keyof GetHalfMoonAiAiHomeStyleRequestsByRequestIdResponses]

export type GetHalfMoonAiAiHomeEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/half-moon-ai/ai-home/edit/requests/{request_id}/status'
}

export type GetHalfMoonAiAiHomeEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetHalfMoonAiAiHomeEditRequestsByRequestIdStatusResponse =
  GetHalfMoonAiAiHomeEditRequestsByRequestIdStatusResponses[keyof GetHalfMoonAiAiHomeEditRequestsByRequestIdStatusResponses]

export type PutHalfMoonAiAiHomeEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/half-moon-ai/ai-home/edit/requests/{request_id}/cancel'
}

export type PutHalfMoonAiAiHomeEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutHalfMoonAiAiHomeEditRequestsByRequestIdCancelResponse =
  PutHalfMoonAiAiHomeEditRequestsByRequestIdCancelResponses[keyof PutHalfMoonAiAiHomeEditRequestsByRequestIdCancelResponses]

export type PostHalfMoonAiAiHomeEditData = {
  body: SchemaAiHomeEditInput
  path?: never
  query?: never
  url: '/half-moon-ai/ai-home/edit'
}

export type PostHalfMoonAiAiHomeEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostHalfMoonAiAiHomeEditResponse =
  PostHalfMoonAiAiHomeEditResponses[keyof PostHalfMoonAiAiHomeEditResponses]

export type GetHalfMoonAiAiHomeEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/half-moon-ai/ai-home/edit/requests/{request_id}'
}

export type GetHalfMoonAiAiHomeEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaAiHomeEditOutput
}

export type GetHalfMoonAiAiHomeEditRequestsByRequestIdResponse =
  GetHalfMoonAiAiHomeEditRequestsByRequestIdResponses[keyof GetHalfMoonAiAiHomeEditRequestsByRequestIdResponses]

export type GetFalAiQwenImageLayeredLoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/qwen-image-layered/lora/requests/{request_id}/status'
}

export type GetFalAiQwenImageLayeredLoraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiQwenImageLayeredLoraRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageLayeredLoraRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageLayeredLoraRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageLayeredLoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-layered/lora/requests/{request_id}/cancel'
}

export type PutFalAiQwenImageLayeredLoraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiQwenImageLayeredLoraRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageLayeredLoraRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageLayeredLoraRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageLayeredLoraData = {
  body: SchemaQwenImageLayeredLoraInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-layered/lora'
}

export type PostFalAiQwenImageLayeredLoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageLayeredLoraResponse =
  PostFalAiQwenImageLayeredLoraResponses[keyof PostFalAiQwenImageLayeredLoraResponses]

export type GetFalAiQwenImageLayeredLoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-layered/lora/requests/{request_id}'
}

export type GetFalAiQwenImageLayeredLoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaQwenImageLayeredLoraOutput
}

export type GetFalAiQwenImageLayeredLoraRequestsByRequestIdResponse =
  GetFalAiQwenImageLayeredLoraRequestsByRequestIdResponses[keyof GetFalAiQwenImageLayeredLoraRequestsByRequestIdResponses]

export type GetWanV26ImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/wan/v2.6/image-to-image/requests/{request_id}/status'
}

export type GetWanV26ImageToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetWanV26ImageToImageRequestsByRequestIdStatusResponse =
  GetWanV26ImageToImageRequestsByRequestIdStatusResponses[keyof GetWanV26ImageToImageRequestsByRequestIdStatusResponses]

export type PutWanV26ImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/wan/v2.6/image-to-image/requests/{request_id}/cancel'
}

export type PutWanV26ImageToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutWanV26ImageToImageRequestsByRequestIdCancelResponse =
  PutWanV26ImageToImageRequestsByRequestIdCancelResponses[keyof PutWanV26ImageToImageRequestsByRequestIdCancelResponses]

export type PostWanV26ImageToImageData = {
  body: SchemaV26ImageToImageInput
  path?: never
  query?: never
  url: '/wan/v2.6/image-to-image'
}

export type PostWanV26ImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostWanV26ImageToImageResponse =
  PostWanV26ImageToImageResponses[keyof PostWanV26ImageToImageResponses]

export type GetWanV26ImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/wan/v2.6/image-to-image/requests/{request_id}'
}

export type GetWanV26ImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaV26ImageToImageOutput
}

export type GetWanV26ImageToImageRequestsByRequestIdResponse =
  GetWanV26ImageToImageRequestsByRequestIdResponses[keyof GetWanV26ImageToImageRequestsByRequestIdResponses]

export type GetFalAiQwenImageEdit2511RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/qwen-image-edit-2511/requests/{request_id}/status'
}

export type GetFalAiQwenImageEdit2511RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiQwenImageEdit2511RequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEdit2511RequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEdit2511RequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEdit2511RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit-2511/requests/{request_id}/cancel'
}

export type PutFalAiQwenImageEdit2511RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiQwenImageEdit2511RequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEdit2511RequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEdit2511RequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEdit2511Data = {
  body: SchemaQwenImageEdit2511Input
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-2511'
}

export type PostFalAiQwenImageEdit2511Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEdit2511Response =
  PostFalAiQwenImageEdit2511Responses[keyof PostFalAiQwenImageEdit2511Responses]

export type GetFalAiQwenImageEdit2511RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit-2511/requests/{request_id}'
}

export type GetFalAiQwenImageEdit2511RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaQwenImageEdit2511Output
}

export type GetFalAiQwenImageEdit2511RequestsByRequestIdResponse =
  GetFalAiQwenImageEdit2511RequestsByRequestIdResponses[keyof GetFalAiQwenImageEdit2511RequestsByRequestIdResponses]

export type GetFalAiQwenImageLayeredRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/qwen-image-layered/requests/{request_id}/status'
}

export type GetFalAiQwenImageLayeredRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiQwenImageLayeredRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageLayeredRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageLayeredRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageLayeredRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-layered/requests/{request_id}/cancel'
}

export type PutFalAiQwenImageLayeredRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiQwenImageLayeredRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageLayeredRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageLayeredRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageLayeredData = {
  body: SchemaQwenImageLayeredInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-layered'
}

export type PostFalAiQwenImageLayeredResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageLayeredResponse =
  PostFalAiQwenImageLayeredResponses[keyof PostFalAiQwenImageLayeredResponses]

export type GetFalAiQwenImageLayeredRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-layered/requests/{request_id}'
}

export type GetFalAiQwenImageLayeredRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaQwenImageLayeredOutput
}

export type GetFalAiQwenImageLayeredRequestsByRequestIdResponse =
  GetFalAiQwenImageLayeredRequestsByRequestIdResponses[keyof GetFalAiQwenImageLayeredRequestsByRequestIdResponses]

export type GetFalAiZImageTurboInpaintLoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/z-image/turbo/inpaint/lora/requests/{request_id}/status'
}

export type GetFalAiZImageTurboInpaintLoraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiZImageTurboInpaintLoraRequestsByRequestIdStatusResponse =
  GetFalAiZImageTurboInpaintLoraRequestsByRequestIdStatusResponses[keyof GetFalAiZImageTurboInpaintLoraRequestsByRequestIdStatusResponses]

export type PutFalAiZImageTurboInpaintLoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/turbo/inpaint/lora/requests/{request_id}/cancel'
}

export type PutFalAiZImageTurboInpaintLoraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiZImageTurboInpaintLoraRequestsByRequestIdCancelResponse =
  PutFalAiZImageTurboInpaintLoraRequestsByRequestIdCancelResponses[keyof PutFalAiZImageTurboInpaintLoraRequestsByRequestIdCancelResponses]

export type PostFalAiZImageTurboInpaintLoraData = {
  body: SchemaZImageTurboInpaintLoraInput
  path?: never
  query?: never
  url: '/fal-ai/z-image/turbo/inpaint/lora'
}

export type PostFalAiZImageTurboInpaintLoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiZImageTurboInpaintLoraResponse =
  PostFalAiZImageTurboInpaintLoraResponses[keyof PostFalAiZImageTurboInpaintLoraResponses]

export type GetFalAiZImageTurboInpaintLoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/turbo/inpaint/lora/requests/{request_id}'
}

export type GetFalAiZImageTurboInpaintLoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaZImageTurboInpaintLoraOutput
}

export type GetFalAiZImageTurboInpaintLoraRequestsByRequestIdResponse =
  GetFalAiZImageTurboInpaintLoraRequestsByRequestIdResponses[keyof GetFalAiZImageTurboInpaintLoraRequestsByRequestIdResponses]

export type GetFalAiZImageTurboInpaintRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/z-image/turbo/inpaint/requests/{request_id}/status'
}

export type GetFalAiZImageTurboInpaintRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiZImageTurboInpaintRequestsByRequestIdStatusResponse =
  GetFalAiZImageTurboInpaintRequestsByRequestIdStatusResponses[keyof GetFalAiZImageTurboInpaintRequestsByRequestIdStatusResponses]

export type PutFalAiZImageTurboInpaintRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/turbo/inpaint/requests/{request_id}/cancel'
}

export type PutFalAiZImageTurboInpaintRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiZImageTurboInpaintRequestsByRequestIdCancelResponse =
  PutFalAiZImageTurboInpaintRequestsByRequestIdCancelResponses[keyof PutFalAiZImageTurboInpaintRequestsByRequestIdCancelResponses]

export type PostFalAiZImageTurboInpaintData = {
  body: SchemaZImageTurboInpaintInput
  path?: never
  query?: never
  url: '/fal-ai/z-image/turbo/inpaint'
}

export type PostFalAiZImageTurboInpaintResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiZImageTurboInpaintResponse =
  PostFalAiZImageTurboInpaintResponses[keyof PostFalAiZImageTurboInpaintResponses]

export type GetFalAiZImageTurboInpaintRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/turbo/inpaint/requests/{request_id}'
}

export type GetFalAiZImageTurboInpaintRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaZImageTurboInpaintOutput
}

export type GetFalAiZImageTurboInpaintRequestsByRequestIdResponse =
  GetFalAiZImageTurboInpaintRequestsByRequestIdResponses[keyof GetFalAiZImageTurboInpaintRequestsByRequestIdResponses]

export type GetFalAiFlux2FlashEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/flash/edit/requests/{request_id}/status'
}

export type GetFalAiFlux2FlashEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2FlashEditRequestsByRequestIdStatusResponse =
  GetFalAiFlux2FlashEditRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2FlashEditRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2FlashEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/flash/edit/requests/{request_id}/cancel'
}

export type PutFalAiFlux2FlashEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2FlashEditRequestsByRequestIdCancelResponse =
  PutFalAiFlux2FlashEditRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2FlashEditRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2FlashEditData = {
  body: SchemaFlux2FlashEditInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2/flash/edit'
}

export type PostFalAiFlux2FlashEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2FlashEditResponse =
  PostFalAiFlux2FlashEditResponses[keyof PostFalAiFlux2FlashEditResponses]

export type GetFalAiFlux2FlashEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/flash/edit/requests/{request_id}'
}

export type GetFalAiFlux2FlashEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2FlashEditOutput
}

export type GetFalAiFlux2FlashEditRequestsByRequestIdResponse =
  GetFalAiFlux2FlashEditRequestsByRequestIdResponses[keyof GetFalAiFlux2FlashEditRequestsByRequestIdResponses]

export type GetFalAiGptImage15EditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/gpt-image-1.5/edit/requests/{request_id}/status'
}

export type GetFalAiGptImage15EditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiGptImage15EditRequestsByRequestIdStatusResponse =
  GetFalAiGptImage15EditRequestsByRequestIdStatusResponses[keyof GetFalAiGptImage15EditRequestsByRequestIdStatusResponses]

export type PutFalAiGptImage15EditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gpt-image-1.5/edit/requests/{request_id}/cancel'
}

export type PutFalAiGptImage15EditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiGptImage15EditRequestsByRequestIdCancelResponse =
  PutFalAiGptImage15EditRequestsByRequestIdCancelResponses[keyof PutFalAiGptImage15EditRequestsByRequestIdCancelResponses]

export type PostFalAiGptImage15EditData = {
  body: SchemaGptImage15EditInput
  path?: never
  query?: never
  url: '/fal-ai/gpt-image-1.5/edit'
}

export type PostFalAiGptImage15EditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiGptImage15EditResponse =
  PostFalAiGptImage15EditResponses[keyof PostFalAiGptImage15EditResponses]

export type GetFalAiGptImage15EditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gpt-image-1.5/edit/requests/{request_id}'
}

export type GetFalAiGptImage15EditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaGptImage15EditOutput
}

export type GetFalAiGptImage15EditRequestsByRequestIdResponse =
  GetFalAiGptImage15EditRequestsByRequestIdResponses[keyof GetFalAiGptImage15EditRequestsByRequestIdResponses]

export type GetFalAiFlux2TurboEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/turbo/edit/requests/{request_id}/status'
}

export type GetFalAiFlux2TurboEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2TurboEditRequestsByRequestIdStatusResponse =
  GetFalAiFlux2TurboEditRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2TurboEditRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2TurboEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/turbo/edit/requests/{request_id}/cancel'
}

export type PutFalAiFlux2TurboEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2TurboEditRequestsByRequestIdCancelResponse =
  PutFalAiFlux2TurboEditRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2TurboEditRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2TurboEditData = {
  body: SchemaFlux2TurboEditInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2/turbo/edit'
}

export type PostFalAiFlux2TurboEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2TurboEditResponse =
  PostFalAiFlux2TurboEditResponses[keyof PostFalAiFlux2TurboEditResponses]

export type GetFalAiFlux2TurboEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/turbo/edit/requests/{request_id}'
}

export type GetFalAiFlux2TurboEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2TurboEditOutput
}

export type GetFalAiFlux2TurboEditRequestsByRequestIdResponse =
  GetFalAiFlux2TurboEditRequestsByRequestIdResponses[keyof GetFalAiFlux2TurboEditRequestsByRequestIdResponses]

export type GetFalAiFlux2MaxEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2-max/edit/requests/{request_id}/status'
}

export type GetFalAiFlux2MaxEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2MaxEditRequestsByRequestIdStatusResponse =
  GetFalAiFlux2MaxEditRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2MaxEditRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2MaxEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-max/edit/requests/{request_id}/cancel'
}

export type PutFalAiFlux2MaxEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2MaxEditRequestsByRequestIdCancelResponse =
  PutFalAiFlux2MaxEditRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2MaxEditRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2MaxEditData = {
  body: SchemaFlux2MaxEditInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2-max/edit'
}

export type PostFalAiFlux2MaxEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2MaxEditResponse =
  PostFalAiFlux2MaxEditResponses[keyof PostFalAiFlux2MaxEditResponses]

export type GetFalAiFlux2MaxEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-max/edit/requests/{request_id}'
}

export type GetFalAiFlux2MaxEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2MaxEditOutput
}

export type GetFalAiFlux2MaxEditRequestsByRequestIdResponse =
  GetFalAiFlux2MaxEditRequestsByRequestIdResponses[keyof GetFalAiFlux2MaxEditRequestsByRequestIdResponses]

export type GetHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/half-moon-ai/ai-baby-and-aging-generator/multi/requests/{request_id}/status'
  }

export type GetHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdStatusResponse =
  GetHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdStatusResponses[keyof GetHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdStatusResponses]

export type PutHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/half-moon-ai/ai-baby-and-aging-generator/multi/requests/{request_id}/cancel'
  }

export type PutHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdCancelResponse =
  PutHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdCancelResponses[keyof PutHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdCancelResponses]

export type PostHalfMoonAiAiBabyAndAgingGeneratorMultiData = {
  body: SchemaAiBabyAndAgingGeneratorMultiInput
  path?: never
  query?: never
  url: '/half-moon-ai/ai-baby-and-aging-generator/multi'
}

export type PostHalfMoonAiAiBabyAndAgingGeneratorMultiResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostHalfMoonAiAiBabyAndAgingGeneratorMultiResponse =
  PostHalfMoonAiAiBabyAndAgingGeneratorMultiResponses[keyof PostHalfMoonAiAiBabyAndAgingGeneratorMultiResponses]

export type GetHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/half-moon-ai/ai-baby-and-aging-generator/multi/requests/{request_id}'
}

export type GetHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaAiBabyAndAgingGeneratorMultiOutput
  }

export type GetHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdResponse =
  GetHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdResponses[keyof GetHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdResponses]

export type GetHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/half-moon-ai/ai-baby-and-aging-generator/single/requests/{request_id}/status'
  }

export type GetHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdStatusResponse =
  GetHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdStatusResponses[keyof GetHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdStatusResponses]

export type PutHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/half-moon-ai/ai-baby-and-aging-generator/single/requests/{request_id}/cancel'
  }

export type PutHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdCancelResponse =
  PutHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdCancelResponses[keyof PutHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdCancelResponses]

export type PostHalfMoonAiAiBabyAndAgingGeneratorSingleData = {
  body: SchemaAiBabyAndAgingGeneratorSingleInput
  path?: never
  query?: never
  url: '/half-moon-ai/ai-baby-and-aging-generator/single'
}

export type PostHalfMoonAiAiBabyAndAgingGeneratorSingleResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostHalfMoonAiAiBabyAndAgingGeneratorSingleResponse =
  PostHalfMoonAiAiBabyAndAgingGeneratorSingleResponses[keyof PostHalfMoonAiAiBabyAndAgingGeneratorSingleResponses]

export type GetHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/half-moon-ai/ai-baby-and-aging-generator/single/requests/{request_id}'
  }

export type GetHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaAiBabyAndAgingGeneratorSingleOutput
  }

export type GetHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdResponse =
  GetHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdResponses[keyof GetHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/shirt-design/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/shirt-design/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEdit2509LoraGalleryShirtDesignData = {
  body: SchemaQwenImageEdit2509LoraGalleryShirtDesignInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-2509-lora-gallery/shirt-design'
}

export type PostFalAiQwenImageEdit2509LoraGalleryShirtDesignResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEdit2509LoraGalleryShirtDesignResponse =
  PostFalAiQwenImageEdit2509LoraGalleryShirtDesignResponses[keyof PostFalAiQwenImageEdit2509LoraGalleryShirtDesignResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/shirt-design/requests/{request_id}'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEdit2509LoraGalleryShirtDesignOutput
  }

export type GetFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdResponse =
  GetFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/remove-lighting/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/remove-lighting/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEdit2509LoraGalleryRemoveLightingData = {
  body: SchemaQwenImageEdit2509LoraGalleryRemoveLightingInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-2509-lora-gallery/remove-lighting'
}

export type PostFalAiQwenImageEdit2509LoraGalleryRemoveLightingResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEdit2509LoraGalleryRemoveLightingResponse =
  PostFalAiQwenImageEdit2509LoraGalleryRemoveLightingResponses[keyof PostFalAiQwenImageEdit2509LoraGalleryRemoveLightingResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/remove-lighting/requests/{request_id}'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEdit2509LoraGalleryRemoveLightingOutput
  }

export type GetFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdResponse =
  GetFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/remove-element/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/remove-element/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEdit2509LoraGalleryRemoveElementData = {
  body: SchemaQwenImageEdit2509LoraGalleryRemoveElementInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-2509-lora-gallery/remove-element'
}

export type PostFalAiQwenImageEdit2509LoraGalleryRemoveElementResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEdit2509LoraGalleryRemoveElementResponse =
  PostFalAiQwenImageEdit2509LoraGalleryRemoveElementResponses[keyof PostFalAiQwenImageEdit2509LoraGalleryRemoveElementResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/remove-element/requests/{request_id}'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEdit2509LoraGalleryRemoveElementOutput
  }

export type GetFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdResponse =
  GetFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/lighting-restoration/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/lighting-restoration/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEdit2509LoraGalleryLightingRestorationData = {
  body: SchemaQwenImageEdit2509LoraGalleryLightingRestorationInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-2509-lora-gallery/lighting-restoration'
}

export type PostFalAiQwenImageEdit2509LoraGalleryLightingRestorationResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type PostFalAiQwenImageEdit2509LoraGalleryLightingRestorationResponse =
  PostFalAiQwenImageEdit2509LoraGalleryLightingRestorationResponses[keyof PostFalAiQwenImageEdit2509LoraGalleryLightingRestorationResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/lighting-restoration/requests/{request_id}'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEdit2509LoraGalleryLightingRestorationOutput
  }

export type GetFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdResponse =
  GetFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/integrate-product/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/integrate-product/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEdit2509LoraGalleryIntegrateProductData = {
  body: SchemaQwenImageEdit2509LoraGalleryIntegrateProductInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-2509-lora-gallery/integrate-product'
}

export type PostFalAiQwenImageEdit2509LoraGalleryIntegrateProductResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEdit2509LoraGalleryIntegrateProductResponse =
  PostFalAiQwenImageEdit2509LoraGalleryIntegrateProductResponses[keyof PostFalAiQwenImageEdit2509LoraGalleryIntegrateProductResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/integrate-product/requests/{request_id}'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEdit2509LoraGalleryIntegrateProductOutput
  }

export type GetFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdResponse =
  GetFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/group-photo/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/group-photo/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEdit2509LoraGalleryGroupPhotoData = {
  body: SchemaQwenImageEdit2509LoraGalleryGroupPhotoInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-2509-lora-gallery/group-photo'
}

export type PostFalAiQwenImageEdit2509LoraGalleryGroupPhotoResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEdit2509LoraGalleryGroupPhotoResponse =
  PostFalAiQwenImageEdit2509LoraGalleryGroupPhotoResponses[keyof PostFalAiQwenImageEdit2509LoraGalleryGroupPhotoResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/group-photo/requests/{request_id}'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEdit2509LoraGalleryGroupPhotoOutput
  }

export type GetFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdResponse =
  GetFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/face-to-full-portrait/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/face-to-full-portrait/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitData = {
  body: SchemaQwenImageEdit2509LoraGalleryFaceToFullPortraitInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-2509-lora-gallery/face-to-full-portrait'
}

export type PostFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitResponse =
  PostFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitResponses[keyof PostFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/face-to-full-portrait/requests/{request_id}'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEdit2509LoraGalleryFaceToFullPortraitOutput
  }

export type GetFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdResponse =
  GetFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/add-background/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/add-background/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEdit2509LoraGalleryAddBackgroundData = {
  body: SchemaQwenImageEdit2509LoraGalleryAddBackgroundInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-2509-lora-gallery/add-background'
}

export type PostFalAiQwenImageEdit2509LoraGalleryAddBackgroundResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEdit2509LoraGalleryAddBackgroundResponse =
  PostFalAiQwenImageEdit2509LoraGalleryAddBackgroundResponses[keyof PostFalAiQwenImageEdit2509LoraGalleryAddBackgroundResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/add-background/requests/{request_id}'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEdit2509LoraGalleryAddBackgroundOutput
  }

export type GetFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdResponse =
  GetFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/next-scene/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/next-scene/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEdit2509LoraGalleryNextSceneData = {
  body: SchemaQwenImageEdit2509LoraGalleryNextSceneInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-2509-lora-gallery/next-scene'
}

export type PostFalAiQwenImageEdit2509LoraGalleryNextSceneResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEdit2509LoraGalleryNextSceneResponse =
  PostFalAiQwenImageEdit2509LoraGalleryNextSceneResponses[keyof PostFalAiQwenImageEdit2509LoraGalleryNextSceneResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/next-scene/requests/{request_id}'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEdit2509LoraGalleryNextSceneOutput
  }

export type GetFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdResponse =
  GetFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/multiple-angles/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/multiple-angles/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEdit2509LoraGalleryMultipleAnglesData = {
  body: SchemaQwenImageEdit2509LoraGalleryMultipleAnglesInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-2509-lora-gallery/multiple-angles'
}

export type PostFalAiQwenImageEdit2509LoraGalleryMultipleAnglesResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEdit2509LoraGalleryMultipleAnglesResponse =
  PostFalAiQwenImageEdit2509LoraGalleryMultipleAnglesResponses[keyof PostFalAiQwenImageEdit2509LoraGalleryMultipleAnglesResponses]

export type GetFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-2509-lora-gallery/multiple-angles/requests/{request_id}'
  }

export type GetFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEdit2509LoraGalleryMultipleAnglesOutput
  }

export type GetFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdResponse =
  GetFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdResponses[keyof GetFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdResponses]

export type GetFalAiQwenImageEdit2509LoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/qwen-image-edit-2509-lora/requests/{request_id}/status'
}

export type GetFalAiQwenImageEdit2509LoraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiQwenImageEdit2509LoraRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEdit2509LoraRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEdit2509LoraRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEdit2509LoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit-2509-lora/requests/{request_id}/cancel'
}

export type PutFalAiQwenImageEdit2509LoraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiQwenImageEdit2509LoraRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEdit2509LoraRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEdit2509LoraRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEdit2509LoraData = {
  body: SchemaQwenImageEdit2509LoraInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-2509-lora'
}

export type PostFalAiQwenImageEdit2509LoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEdit2509LoraResponse =
  PostFalAiQwenImageEdit2509LoraResponses[keyof PostFalAiQwenImageEdit2509LoraResponses]

export type GetFalAiQwenImageEdit2509LoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit-2509-lora/requests/{request_id}'
}

export type GetFalAiQwenImageEdit2509LoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaQwenImageEdit2509LoraOutput
}

export type GetFalAiQwenImageEdit2509LoraRequestsByRequestIdResponse =
  GetFalAiQwenImageEdit2509LoraRequestsByRequestIdResponses[keyof GetFalAiQwenImageEdit2509LoraRequestsByRequestIdResponses]

export type GetFalAiQwenImageEdit2509RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/qwen-image-edit-2509/requests/{request_id}/status'
}

export type GetFalAiQwenImageEdit2509RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiQwenImageEdit2509RequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEdit2509RequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEdit2509RequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEdit2509RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit-2509/requests/{request_id}/cancel'
}

export type PutFalAiQwenImageEdit2509RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiQwenImageEdit2509RequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEdit2509RequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEdit2509RequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEdit2509Data = {
  body: SchemaQwenImageEdit2509Input
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-2509'
}

export type PostFalAiQwenImageEdit2509Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEdit2509Response =
  PostFalAiQwenImageEdit2509Responses[keyof PostFalAiQwenImageEdit2509Responses]

export type GetFalAiQwenImageEdit2509RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit-2509/requests/{request_id}'
}

export type GetFalAiQwenImageEdit2509RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaQwenImageEdit2509Output
}

export type GetFalAiQwenImageEdit2509RequestsByRequestIdResponse =
  GetFalAiQwenImageEdit2509RequestsByRequestIdResponses[keyof GetFalAiQwenImageEdit2509RequestsByRequestIdResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/lighting-restoration/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/lighting-restoration/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEditPlusLoraGalleryLightingRestorationData = {
  body: SchemaQwenImageEditPlusLoraGalleryLightingRestorationInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-plus-lora-gallery/lighting-restoration'
}

export type PostFalAiQwenImageEditPlusLoraGalleryLightingRestorationResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type PostFalAiQwenImageEditPlusLoraGalleryLightingRestorationResponse =
  PostFalAiQwenImageEditPlusLoraGalleryLightingRestorationResponses[keyof PostFalAiQwenImageEditPlusLoraGalleryLightingRestorationResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/lighting-restoration/requests/{request_id}'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEditPlusLoraGalleryLightingRestorationOutput
  }

export type GetFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdResponse =
  GetFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdResponses]

export type GetFalAiMoondream3PreviewSegmentRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/moondream3-preview/segment/requests/{request_id}/status'
}

export type GetFalAiMoondream3PreviewSegmentRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiMoondream3PreviewSegmentRequestsByRequestIdStatusResponse =
  GetFalAiMoondream3PreviewSegmentRequestsByRequestIdStatusResponses[keyof GetFalAiMoondream3PreviewSegmentRequestsByRequestIdStatusResponses]

export type PutFalAiMoondream3PreviewSegmentRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/moondream3-preview/segment/requests/{request_id}/cancel'
}

export type PutFalAiMoondream3PreviewSegmentRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiMoondream3PreviewSegmentRequestsByRequestIdCancelResponse =
  PutFalAiMoondream3PreviewSegmentRequestsByRequestIdCancelResponses[keyof PutFalAiMoondream3PreviewSegmentRequestsByRequestIdCancelResponses]

export type PostFalAiMoondream3PreviewSegmentData = {
  body: SchemaMoondream3PreviewSegmentInput
  path?: never
  query?: never
  url: '/fal-ai/moondream3-preview/segment'
}

export type PostFalAiMoondream3PreviewSegmentResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiMoondream3PreviewSegmentResponse =
  PostFalAiMoondream3PreviewSegmentResponses[keyof PostFalAiMoondream3PreviewSegmentResponses]

export type GetFalAiMoondream3PreviewSegmentRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/moondream3-preview/segment/requests/{request_id}'
}

export type GetFalAiMoondream3PreviewSegmentRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaMoondream3PreviewSegmentOutput
}

export type GetFalAiMoondream3PreviewSegmentRequestsByRequestIdResponse =
  GetFalAiMoondream3PreviewSegmentRequestsByRequestIdResponses[keyof GetFalAiMoondream3PreviewSegmentRequestsByRequestIdResponses]

export type GetFalAiStepxEdit2RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/stepx-edit2/requests/{request_id}/status'
}

export type GetFalAiStepxEdit2RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiStepxEdit2RequestsByRequestIdStatusResponse =
  GetFalAiStepxEdit2RequestsByRequestIdStatusResponses[keyof GetFalAiStepxEdit2RequestsByRequestIdStatusResponses]

export type PutFalAiStepxEdit2RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/stepx-edit2/requests/{request_id}/cancel'
}

export type PutFalAiStepxEdit2RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiStepxEdit2RequestsByRequestIdCancelResponse =
  PutFalAiStepxEdit2RequestsByRequestIdCancelResponses[keyof PutFalAiStepxEdit2RequestsByRequestIdCancelResponses]

export type PostFalAiStepxEdit2Data = {
  body: SchemaStepxEdit2Input
  path?: never
  query?: never
  url: '/fal-ai/stepx-edit2'
}

export type PostFalAiStepxEdit2Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiStepxEdit2Response =
  PostFalAiStepxEdit2Responses[keyof PostFalAiStepxEdit2Responses]

export type GetFalAiStepxEdit2RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/stepx-edit2/requests/{request_id}'
}

export type GetFalAiStepxEdit2RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaStepxEdit2Output
}

export type GetFalAiStepxEdit2RequestsByRequestIdResponse =
  GetFalAiStepxEdit2RequestsByRequestIdResponses[keyof GetFalAiStepxEdit2RequestsByRequestIdResponses]

export type GetFalAiZImageTurboControlnetLoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/z-image/turbo/controlnet/lora/requests/{request_id}/status'
}

export type GetFalAiZImageTurboControlnetLoraRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiZImageTurboControlnetLoraRequestsByRequestIdStatusResponse =
  GetFalAiZImageTurboControlnetLoraRequestsByRequestIdStatusResponses[keyof GetFalAiZImageTurboControlnetLoraRequestsByRequestIdStatusResponses]

export type PutFalAiZImageTurboControlnetLoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/turbo/controlnet/lora/requests/{request_id}/cancel'
}

export type PutFalAiZImageTurboControlnetLoraRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiZImageTurboControlnetLoraRequestsByRequestIdCancelResponse =
  PutFalAiZImageTurboControlnetLoraRequestsByRequestIdCancelResponses[keyof PutFalAiZImageTurboControlnetLoraRequestsByRequestIdCancelResponses]

export type PostFalAiZImageTurboControlnetLoraData = {
  body: SchemaZImageTurboControlnetLoraInput
  path?: never
  query?: never
  url: '/fal-ai/z-image/turbo/controlnet/lora'
}

export type PostFalAiZImageTurboControlnetLoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiZImageTurboControlnetLoraResponse =
  PostFalAiZImageTurboControlnetLoraResponses[keyof PostFalAiZImageTurboControlnetLoraResponses]

export type GetFalAiZImageTurboControlnetLoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/turbo/controlnet/lora/requests/{request_id}'
}

export type GetFalAiZImageTurboControlnetLoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaZImageTurboControlnetLoraOutput
}

export type GetFalAiZImageTurboControlnetLoraRequestsByRequestIdResponse =
  GetFalAiZImageTurboControlnetLoraRequestsByRequestIdResponses[keyof GetFalAiZImageTurboControlnetLoraRequestsByRequestIdResponses]

export type GetFalAiZImageTurboControlnetRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/z-image/turbo/controlnet/requests/{request_id}/status'
}

export type GetFalAiZImageTurboControlnetRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiZImageTurboControlnetRequestsByRequestIdStatusResponse =
  GetFalAiZImageTurboControlnetRequestsByRequestIdStatusResponses[keyof GetFalAiZImageTurboControlnetRequestsByRequestIdStatusResponses]

export type PutFalAiZImageTurboControlnetRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/turbo/controlnet/requests/{request_id}/cancel'
}

export type PutFalAiZImageTurboControlnetRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiZImageTurboControlnetRequestsByRequestIdCancelResponse =
  PutFalAiZImageTurboControlnetRequestsByRequestIdCancelResponses[keyof PutFalAiZImageTurboControlnetRequestsByRequestIdCancelResponses]

export type PostFalAiZImageTurboControlnetData = {
  body: SchemaZImageTurboControlnetInput
  path?: never
  query?: never
  url: '/fal-ai/z-image/turbo/controlnet'
}

export type PostFalAiZImageTurboControlnetResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiZImageTurboControlnetResponse =
  PostFalAiZImageTurboControlnetResponses[keyof PostFalAiZImageTurboControlnetResponses]

export type GetFalAiZImageTurboControlnetRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/turbo/controlnet/requests/{request_id}'
}

export type GetFalAiZImageTurboControlnetRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaZImageTurboControlnetOutput
}

export type GetFalAiZImageTurboControlnetRequestsByRequestIdResponse =
  GetFalAiZImageTurboControlnetRequestsByRequestIdResponses[keyof GetFalAiZImageTurboControlnetRequestsByRequestIdResponses]

export type GetFalAiZImageTurboImageToImageLoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/z-image/turbo/image-to-image/lora/requests/{request_id}/status'
}

export type GetFalAiZImageTurboImageToImageLoraRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiZImageTurboImageToImageLoraRequestsByRequestIdStatusResponse =
  GetFalAiZImageTurboImageToImageLoraRequestsByRequestIdStatusResponses[keyof GetFalAiZImageTurboImageToImageLoraRequestsByRequestIdStatusResponses]

export type PutFalAiZImageTurboImageToImageLoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/turbo/image-to-image/lora/requests/{request_id}/cancel'
}

export type PutFalAiZImageTurboImageToImageLoraRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiZImageTurboImageToImageLoraRequestsByRequestIdCancelResponse =
  PutFalAiZImageTurboImageToImageLoraRequestsByRequestIdCancelResponses[keyof PutFalAiZImageTurboImageToImageLoraRequestsByRequestIdCancelResponses]

export type PostFalAiZImageTurboImageToImageLoraData = {
  body: SchemaZImageTurboImageToImageLoraInput
  path?: never
  query?: never
  url: '/fal-ai/z-image/turbo/image-to-image/lora'
}

export type PostFalAiZImageTurboImageToImageLoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiZImageTurboImageToImageLoraResponse =
  PostFalAiZImageTurboImageToImageLoraResponses[keyof PostFalAiZImageTurboImageToImageLoraResponses]

export type GetFalAiZImageTurboImageToImageLoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/turbo/image-to-image/lora/requests/{request_id}'
}

export type GetFalAiZImageTurboImageToImageLoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaZImageTurboImageToImageLoraOutput
}

export type GetFalAiZImageTurboImageToImageLoraRequestsByRequestIdResponse =
  GetFalAiZImageTurboImageToImageLoraRequestsByRequestIdResponses[keyof GetFalAiZImageTurboImageToImageLoraRequestsByRequestIdResponses]

export type GetFalAiZImageTurboImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/z-image/turbo/image-to-image/requests/{request_id}/status'
}

export type GetFalAiZImageTurboImageToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiZImageTurboImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiZImageTurboImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiZImageTurboImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiZImageTurboImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/turbo/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiZImageTurboImageToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiZImageTurboImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiZImageTurboImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiZImageTurboImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiZImageTurboImageToImageData = {
  body: SchemaZImageTurboImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/z-image/turbo/image-to-image'
}

export type PostFalAiZImageTurboImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiZImageTurboImageToImageResponse =
  PostFalAiZImageTurboImageToImageResponses[keyof PostFalAiZImageTurboImageToImageResponses]

export type GetFalAiZImageTurboImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/turbo/image-to-image/requests/{request_id}'
}

export type GetFalAiZImageTurboImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaZImageTurboImageToImageOutput
}

export type GetFalAiZImageTurboImageToImageRequestsByRequestIdResponse =
  GetFalAiZImageTurboImageToImageRequestsByRequestIdResponses[keyof GetFalAiZImageTurboImageToImageRequestsByRequestIdResponses]

export type GetFalAiLongcatImageEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/longcat-image/edit/requests/{request_id}/status'
}

export type GetFalAiLongcatImageEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLongcatImageEditRequestsByRequestIdStatusResponse =
  GetFalAiLongcatImageEditRequestsByRequestIdStatusResponses[keyof GetFalAiLongcatImageEditRequestsByRequestIdStatusResponses]

export type PutFalAiLongcatImageEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/longcat-image/edit/requests/{request_id}/cancel'
}

export type PutFalAiLongcatImageEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLongcatImageEditRequestsByRequestIdCancelResponse =
  PutFalAiLongcatImageEditRequestsByRequestIdCancelResponses[keyof PutFalAiLongcatImageEditRequestsByRequestIdCancelResponses]

export type PostFalAiLongcatImageEditData = {
  body: SchemaLongcatImageEditInput
  path?: never
  query?: never
  url: '/fal-ai/longcat-image/edit'
}

export type PostFalAiLongcatImageEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLongcatImageEditResponse =
  PostFalAiLongcatImageEditResponses[keyof PostFalAiLongcatImageEditResponses]

export type GetFalAiLongcatImageEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/longcat-image/edit/requests/{request_id}'
}

export type GetFalAiLongcatImageEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLongcatImageEditOutput
}

export type GetFalAiLongcatImageEditRequestsByRequestIdResponse =
  GetFalAiLongcatImageEditRequestsByRequestIdResponses[keyof GetFalAiLongcatImageEditRequestsByRequestIdResponses]

export type GetFalAiBytedanceSeedreamV45EditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/bytedance/seedream/v4.5/edit/requests/{request_id}/status'
}

export type GetFalAiBytedanceSeedreamV45EditRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiBytedanceSeedreamV45EditRequestsByRequestIdStatusResponse =
  GetFalAiBytedanceSeedreamV45EditRequestsByRequestIdStatusResponses[keyof GetFalAiBytedanceSeedreamV45EditRequestsByRequestIdStatusResponses]

export type PutFalAiBytedanceSeedreamV45EditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bytedance/seedream/v4.5/edit/requests/{request_id}/cancel'
}

export type PutFalAiBytedanceSeedreamV45EditRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiBytedanceSeedreamV45EditRequestsByRequestIdCancelResponse =
  PutFalAiBytedanceSeedreamV45EditRequestsByRequestIdCancelResponses[keyof PutFalAiBytedanceSeedreamV45EditRequestsByRequestIdCancelResponses]

export type PostFalAiBytedanceSeedreamV45EditData = {
  body: SchemaBytedanceSeedreamV45EditInput
  path?: never
  query?: never
  url: '/fal-ai/bytedance/seedream/v4.5/edit'
}

export type PostFalAiBytedanceSeedreamV45EditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBytedanceSeedreamV45EditResponse =
  PostFalAiBytedanceSeedreamV45EditResponses[keyof PostFalAiBytedanceSeedreamV45EditResponses]

export type GetFalAiBytedanceSeedreamV45EditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bytedance/seedream/v4.5/edit/requests/{request_id}'
}

export type GetFalAiBytedanceSeedreamV45EditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaBytedanceSeedreamV45EditOutput
}

export type GetFalAiBytedanceSeedreamV45EditRequestsByRequestIdResponse =
  GetFalAiBytedanceSeedreamV45EditRequestsByRequestIdResponses[keyof GetFalAiBytedanceSeedreamV45EditRequestsByRequestIdResponses]

export type GetFalAiViduQ2ReferenceToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/vidu/q2/reference-to-image/requests/{request_id}/status'
}

export type GetFalAiViduQ2ReferenceToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiViduQ2ReferenceToImageRequestsByRequestIdStatusResponse =
  GetFalAiViduQ2ReferenceToImageRequestsByRequestIdStatusResponses[keyof GetFalAiViduQ2ReferenceToImageRequestsByRequestIdStatusResponses]

export type PutFalAiViduQ2ReferenceToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/vidu/q2/reference-to-image/requests/{request_id}/cancel'
}

export type PutFalAiViduQ2ReferenceToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiViduQ2ReferenceToImageRequestsByRequestIdCancelResponse =
  PutFalAiViduQ2ReferenceToImageRequestsByRequestIdCancelResponses[keyof PutFalAiViduQ2ReferenceToImageRequestsByRequestIdCancelResponses]

export type PostFalAiViduQ2ReferenceToImageData = {
  body: SchemaViduQ2ReferenceToImageInput
  path?: never
  query?: never
  url: '/fal-ai/vidu/q2/reference-to-image'
}

export type PostFalAiViduQ2ReferenceToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiViduQ2ReferenceToImageResponse =
  PostFalAiViduQ2ReferenceToImageResponses[keyof PostFalAiViduQ2ReferenceToImageResponses]

export type GetFalAiViduQ2ReferenceToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/vidu/q2/reference-to-image/requests/{request_id}'
}

export type GetFalAiViduQ2ReferenceToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaViduQ2ReferenceToImageOutput
}

export type GetFalAiViduQ2ReferenceToImageRequestsByRequestIdResponse =
  GetFalAiViduQ2ReferenceToImageRequestsByRequestIdResponses[keyof GetFalAiViduQ2ReferenceToImageRequestsByRequestIdResponses]

export type GetFalAiKlingImageO1RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/kling-image/o1/requests/{request_id}/status'
}

export type GetFalAiKlingImageO1RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiKlingImageO1RequestsByRequestIdStatusResponse =
  GetFalAiKlingImageO1RequestsByRequestIdStatusResponses[keyof GetFalAiKlingImageO1RequestsByRequestIdStatusResponses]

export type PutFalAiKlingImageO1RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/kling-image/o1/requests/{request_id}/cancel'
}

export type PutFalAiKlingImageO1RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiKlingImageO1RequestsByRequestIdCancelResponse =
  PutFalAiKlingImageO1RequestsByRequestIdCancelResponses[keyof PutFalAiKlingImageO1RequestsByRequestIdCancelResponses]

export type PostFalAiKlingImageO1Data = {
  body: SchemaKlingImageO1Input
  path?: never
  query?: never
  url: '/fal-ai/kling-image/o1'
}

export type PostFalAiKlingImageO1Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiKlingImageO1Response =
  PostFalAiKlingImageO1Responses[keyof PostFalAiKlingImageO1Responses]

export type GetFalAiKlingImageO1RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/kling-image/o1/requests/{request_id}'
}

export type GetFalAiKlingImageO1RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaKlingImageO1Output
}

export type GetFalAiKlingImageO1RequestsByRequestIdResponse =
  GetFalAiKlingImageO1RequestsByRequestIdResponses[keyof GetFalAiKlingImageO1RequestsByRequestIdResponses]

export type GetFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/flux-2-lora-gallery/virtual-tryon/requests/{request_id}/status'
  }

export type GetFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdStatusResponse =
  GetFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/flux-2-lora-gallery/virtual-tryon/requests/{request_id}/cancel'
  }

export type PutFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdCancelResponse =
  PutFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2LoraGalleryVirtualTryonData = {
  body: SchemaFlux2LoraGalleryVirtualTryonInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/virtual-tryon'
}

export type PostFalAiFlux2LoraGalleryVirtualTryonResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2LoraGalleryVirtualTryonResponse =
  PostFalAiFlux2LoraGalleryVirtualTryonResponses[keyof PostFalAiFlux2LoraGalleryVirtualTryonResponses]

export type GetFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/virtual-tryon/requests/{request_id}'
}

export type GetFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2LoraGalleryVirtualTryonOutput
}

export type GetFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdResponse =
  GetFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdResponses[keyof GetFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdResponses]

export type GetFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/flux-2-lora-gallery/multiple-angles/requests/{request_id}/status'
  }

export type GetFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdStatusResponse =
  GetFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/flux-2-lora-gallery/multiple-angles/requests/{request_id}/cancel'
  }

export type PutFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdCancelResponse =
  PutFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2LoraGalleryMultipleAnglesData = {
  body: SchemaFlux2LoraGalleryMultipleAnglesInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/multiple-angles'
}

export type PostFalAiFlux2LoraGalleryMultipleAnglesResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2LoraGalleryMultipleAnglesResponse =
  PostFalAiFlux2LoraGalleryMultipleAnglesResponses[keyof PostFalAiFlux2LoraGalleryMultipleAnglesResponses]

export type GetFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/multiple-angles/requests/{request_id}'
}

export type GetFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaFlux2LoraGalleryMultipleAnglesOutput
  }

export type GetFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdResponse =
  GetFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdResponses[keyof GetFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdResponses]

export type GetFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/flux-2-lora-gallery/face-to-full-portrait/requests/{request_id}/status'
  }

export type GetFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdStatusResponse =
  GetFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/flux-2-lora-gallery/face-to-full-portrait/requests/{request_id}/cancel'
  }

export type PutFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdCancelResponse =
  PutFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2LoraGalleryFaceToFullPortraitData = {
  body: SchemaFlux2LoraGalleryFaceToFullPortraitInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/face-to-full-portrait'
}

export type PostFalAiFlux2LoraGalleryFaceToFullPortraitResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2LoraGalleryFaceToFullPortraitResponse =
  PostFalAiFlux2LoraGalleryFaceToFullPortraitResponses[keyof PostFalAiFlux2LoraGalleryFaceToFullPortraitResponses]

export type GetFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/flux-2-lora-gallery/face-to-full-portrait/requests/{request_id}'
  }

export type GetFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaFlux2LoraGalleryFaceToFullPortraitOutput
  }

export type GetFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdResponse =
  GetFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdResponses[keyof GetFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdResponses]

export type GetFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/flux-2-lora-gallery/apartment-staging/requests/{request_id}/status'
  }

export type GetFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdStatusResponse =
  GetFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/flux-2-lora-gallery/apartment-staging/requests/{request_id}/cancel'
  }

export type PutFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdCancelResponse =
  PutFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2LoraGalleryApartmentStagingData = {
  body: SchemaFlux2LoraGalleryApartmentStagingInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/apartment-staging'
}

export type PostFalAiFlux2LoraGalleryApartmentStagingResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2LoraGalleryApartmentStagingResponse =
  PostFalAiFlux2LoraGalleryApartmentStagingResponses[keyof PostFalAiFlux2LoraGalleryApartmentStagingResponses]

export type GetFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/apartment-staging/requests/{request_id}'
}

export type GetFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaFlux2LoraGalleryApartmentStagingOutput
  }

export type GetFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdResponse =
  GetFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdResponses[keyof GetFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdResponses]

export type GetFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/flux-2-lora-gallery/add-background/requests/{request_id}/status'
  }

export type GetFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdStatusResponse =
  GetFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/flux-2-lora-gallery/add-background/requests/{request_id}/cancel'
  }

export type PutFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdCancelResponse =
  PutFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2LoraGalleryAddBackgroundData = {
  body: SchemaFlux2LoraGalleryAddBackgroundInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/add-background'
}

export type PostFalAiFlux2LoraGalleryAddBackgroundResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2LoraGalleryAddBackgroundResponse =
  PostFalAiFlux2LoraGalleryAddBackgroundResponses[keyof PostFalAiFlux2LoraGalleryAddBackgroundResponses]

export type GetFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/add-background/requests/{request_id}'
}

export type GetFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaFlux2LoraGalleryAddBackgroundOutput
  }

export type GetFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdResponse =
  GetFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdResponses[keyof GetFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdResponses]

export type GetClarityaiCrystalUpscalerRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/clarityai/crystal-upscaler/requests/{request_id}/status'
}

export type GetClarityaiCrystalUpscalerRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetClarityaiCrystalUpscalerRequestsByRequestIdStatusResponse =
  GetClarityaiCrystalUpscalerRequestsByRequestIdStatusResponses[keyof GetClarityaiCrystalUpscalerRequestsByRequestIdStatusResponses]

export type PutClarityaiCrystalUpscalerRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/clarityai/crystal-upscaler/requests/{request_id}/cancel'
}

export type PutClarityaiCrystalUpscalerRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutClarityaiCrystalUpscalerRequestsByRequestIdCancelResponse =
  PutClarityaiCrystalUpscalerRequestsByRequestIdCancelResponses[keyof PutClarityaiCrystalUpscalerRequestsByRequestIdCancelResponses]

export type PostClarityaiCrystalUpscalerData = {
  body: SchemaCrystalUpscalerInput
  path?: never
  query?: never
  url: '/clarityai/crystal-upscaler'
}

export type PostClarityaiCrystalUpscalerResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostClarityaiCrystalUpscalerResponse =
  PostClarityaiCrystalUpscalerResponses[keyof PostClarityaiCrystalUpscalerResponses]

export type GetClarityaiCrystalUpscalerRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/clarityai/crystal-upscaler/requests/{request_id}'
}

export type GetClarityaiCrystalUpscalerRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaCrystalUpscalerOutput
}

export type GetClarityaiCrystalUpscalerRequestsByRequestIdResponse =
  GetClarityaiCrystalUpscalerRequestsByRequestIdResponses[keyof GetClarityaiCrystalUpscalerRequestsByRequestIdResponses]

export type GetFalAiFlux2FlexEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2-flex/edit/requests/{request_id}/status'
}

export type GetFalAiFlux2FlexEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2FlexEditRequestsByRequestIdStatusResponse =
  GetFalAiFlux2FlexEditRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2FlexEditRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2FlexEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-flex/edit/requests/{request_id}/cancel'
}

export type PutFalAiFlux2FlexEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2FlexEditRequestsByRequestIdCancelResponse =
  PutFalAiFlux2FlexEditRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2FlexEditRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2FlexEditData = {
  body: SchemaFlux2FlexEditInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2-flex/edit'
}

export type PostFalAiFlux2FlexEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2FlexEditResponse =
  PostFalAiFlux2FlexEditResponses[keyof PostFalAiFlux2FlexEditResponses]

export type GetFalAiFlux2FlexEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-flex/edit/requests/{request_id}'
}

export type GetFalAiFlux2FlexEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2FlexEditOutput
}

export type GetFalAiFlux2FlexEditRequestsByRequestIdResponse =
  GetFalAiFlux2FlexEditRequestsByRequestIdResponses[keyof GetFalAiFlux2FlexEditRequestsByRequestIdResponses]

export type GetFalAiChronoEditLoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/chrono-edit-lora/requests/{request_id}/status'
}

export type GetFalAiChronoEditLoraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiChronoEditLoraRequestsByRequestIdStatusResponse =
  GetFalAiChronoEditLoraRequestsByRequestIdStatusResponses[keyof GetFalAiChronoEditLoraRequestsByRequestIdStatusResponses]

export type PutFalAiChronoEditLoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/chrono-edit-lora/requests/{request_id}/cancel'
}

export type PutFalAiChronoEditLoraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiChronoEditLoraRequestsByRequestIdCancelResponse =
  PutFalAiChronoEditLoraRequestsByRequestIdCancelResponses[keyof PutFalAiChronoEditLoraRequestsByRequestIdCancelResponses]

export type PostFalAiChronoEditLoraData = {
  body: SchemaChronoEditLoraInput
  path?: never
  query?: never
  url: '/fal-ai/chrono-edit-lora'
}

export type PostFalAiChronoEditLoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiChronoEditLoraResponse =
  PostFalAiChronoEditLoraResponses[keyof PostFalAiChronoEditLoraResponses]

export type GetFalAiChronoEditLoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/chrono-edit-lora/requests/{request_id}'
}

export type GetFalAiChronoEditLoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaChronoEditLoraOutput
}

export type GetFalAiChronoEditLoraRequestsByRequestIdResponse =
  GetFalAiChronoEditLoraRequestsByRequestIdResponses[keyof GetFalAiChronoEditLoraRequestsByRequestIdResponses]

export type GetFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/chrono-edit-lora-gallery/paintbrush/requests/{request_id}/status'
  }

export type GetFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdStatusResponse =
  GetFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdStatusResponses[keyof GetFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdStatusResponses]

export type PutFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/chrono-edit-lora-gallery/paintbrush/requests/{request_id}/cancel'
  }

export type PutFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdCancelResponse =
  PutFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdCancelResponses[keyof PutFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdCancelResponses]

export type PostFalAiChronoEditLoraGalleryPaintbrushData = {
  body: SchemaChronoEditLoraGalleryPaintbrushInput
  path?: never
  query?: never
  url: '/fal-ai/chrono-edit-lora-gallery/paintbrush'
}

export type PostFalAiChronoEditLoraGalleryPaintbrushResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiChronoEditLoraGalleryPaintbrushResponse =
  PostFalAiChronoEditLoraGalleryPaintbrushResponses[keyof PostFalAiChronoEditLoraGalleryPaintbrushResponses]

export type GetFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/chrono-edit-lora-gallery/paintbrush/requests/{request_id}'
}

export type GetFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaChronoEditLoraGalleryPaintbrushOutput
  }

export type GetFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdResponse =
  GetFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdResponses[keyof GetFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdResponses]

export type GetFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/chrono-edit-lora-gallery/upscaler/requests/{request_id}/status'
  }

export type GetFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdStatusResponse =
  GetFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdStatusResponses[keyof GetFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdStatusResponses]

export type PutFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/chrono-edit-lora-gallery/upscaler/requests/{request_id}/cancel'
  }

export type PutFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdCancelResponse =
  PutFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdCancelResponses[keyof PutFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdCancelResponses]

export type PostFalAiChronoEditLoraGalleryUpscalerData = {
  body: SchemaChronoEditLoraGalleryUpscalerInput
  path?: never
  query?: never
  url: '/fal-ai/chrono-edit-lora-gallery/upscaler'
}

export type PostFalAiChronoEditLoraGalleryUpscalerResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiChronoEditLoraGalleryUpscalerResponse =
  PostFalAiChronoEditLoraGalleryUpscalerResponses[keyof PostFalAiChronoEditLoraGalleryUpscalerResponses]

export type GetFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/chrono-edit-lora-gallery/upscaler/requests/{request_id}'
}

export type GetFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaChronoEditLoraGalleryUpscalerOutput
  }

export type GetFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdResponse =
  GetFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdResponses[keyof GetFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdResponses]

export type GetFalAiSam3ImageRleRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/sam-3/image-rle/requests/{request_id}/status'
}

export type GetFalAiSam3ImageRleRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiSam3ImageRleRequestsByRequestIdStatusResponse =
  GetFalAiSam3ImageRleRequestsByRequestIdStatusResponses[keyof GetFalAiSam3ImageRleRequestsByRequestIdStatusResponses]

export type PutFalAiSam3ImageRleRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sam-3/image-rle/requests/{request_id}/cancel'
}

export type PutFalAiSam3ImageRleRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiSam3ImageRleRequestsByRequestIdCancelResponse =
  PutFalAiSam3ImageRleRequestsByRequestIdCancelResponses[keyof PutFalAiSam3ImageRleRequestsByRequestIdCancelResponses]

export type PostFalAiSam3ImageRleData = {
  body: SchemaSam3ImageRleInput
  path?: never
  query?: never
  url: '/fal-ai/sam-3/image-rle'
}

export type PostFalAiSam3ImageRleResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiSam3ImageRleResponse =
  PostFalAiSam3ImageRleResponses[keyof PostFalAiSam3ImageRleResponses]

export type GetFalAiSam3ImageRleRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sam-3/image-rle/requests/{request_id}'
}

export type GetFalAiSam3ImageRleRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaSam3ImageRleOutput
}

export type GetFalAiSam3ImageRleRequestsByRequestIdResponse =
  GetFalAiSam3ImageRleRequestsByRequestIdResponses[keyof GetFalAiSam3ImageRleRequestsByRequestIdResponses]

export type GetFalAiSam3ImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/sam-3/image/requests/{request_id}/status'
}

export type GetFalAiSam3ImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiSam3ImageRequestsByRequestIdStatusResponse =
  GetFalAiSam3ImageRequestsByRequestIdStatusResponses[keyof GetFalAiSam3ImageRequestsByRequestIdStatusResponses]

export type PutFalAiSam3ImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sam-3/image/requests/{request_id}/cancel'
}

export type PutFalAiSam3ImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiSam3ImageRequestsByRequestIdCancelResponse =
  PutFalAiSam3ImageRequestsByRequestIdCancelResponses[keyof PutFalAiSam3ImageRequestsByRequestIdCancelResponses]

export type PostFalAiSam3ImageData = {
  body: SchemaSam3ImageInput
  path?: never
  query?: never
  url: '/fal-ai/sam-3/image'
}

export type PostFalAiSam3ImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiSam3ImageResponse =
  PostFalAiSam3ImageResponses[keyof PostFalAiSam3ImageResponses]

export type GetFalAiSam3ImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sam-3/image/requests/{request_id}'
}

export type GetFalAiSam3ImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaSam3ImageOutput
}

export type GetFalAiSam3ImageRequestsByRequestIdResponse =
  GetFalAiSam3ImageRequestsByRequestIdResponses[keyof GetFalAiSam3ImageRequestsByRequestIdResponses]

export type GetFalAiGemini3ProImagePreviewEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/gemini-3-pro-image-preview/edit/requests/{request_id}/status'
}

export type GetFalAiGemini3ProImagePreviewEditRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiGemini3ProImagePreviewEditRequestsByRequestIdStatusResponse =
  GetFalAiGemini3ProImagePreviewEditRequestsByRequestIdStatusResponses[keyof GetFalAiGemini3ProImagePreviewEditRequestsByRequestIdStatusResponses]

export type PutFalAiGemini3ProImagePreviewEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gemini-3-pro-image-preview/edit/requests/{request_id}/cancel'
}

export type PutFalAiGemini3ProImagePreviewEditRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiGemini3ProImagePreviewEditRequestsByRequestIdCancelResponse =
  PutFalAiGemini3ProImagePreviewEditRequestsByRequestIdCancelResponses[keyof PutFalAiGemini3ProImagePreviewEditRequestsByRequestIdCancelResponses]

export type PostFalAiGemini3ProImagePreviewEditData = {
  body: SchemaGemini3ProImagePreviewEditInput
  path?: never
  query?: never
  url: '/fal-ai/gemini-3-pro-image-preview/edit'
}

export type PostFalAiGemini3ProImagePreviewEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiGemini3ProImagePreviewEditResponse =
  PostFalAiGemini3ProImagePreviewEditResponses[keyof PostFalAiGemini3ProImagePreviewEditResponses]

export type GetFalAiGemini3ProImagePreviewEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gemini-3-pro-image-preview/edit/requests/{request_id}'
}

export type GetFalAiGemini3ProImagePreviewEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaGemini3ProImagePreviewEditOutput
}

export type GetFalAiGemini3ProImagePreviewEditRequestsByRequestIdResponse =
  GetFalAiGemini3ProImagePreviewEditRequestsByRequestIdResponses[keyof GetFalAiGemini3ProImagePreviewEditRequestsByRequestIdResponses]

export type GetFalAiNanoBananaProEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/nano-banana-pro/edit/requests/{request_id}/status'
}

export type GetFalAiNanoBananaProEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiNanoBananaProEditRequestsByRequestIdStatusResponse =
  GetFalAiNanoBananaProEditRequestsByRequestIdStatusResponses[keyof GetFalAiNanoBananaProEditRequestsByRequestIdStatusResponses]

export type PutFalAiNanoBananaProEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/nano-banana-pro/edit/requests/{request_id}/cancel'
}

export type PutFalAiNanoBananaProEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiNanoBananaProEditRequestsByRequestIdCancelResponse =
  PutFalAiNanoBananaProEditRequestsByRequestIdCancelResponses[keyof PutFalAiNanoBananaProEditRequestsByRequestIdCancelResponses]

export type PostFalAiNanoBananaProEditData = {
  body: SchemaNanoBananaProEditInput
  path?: never
  query?: never
  url: '/fal-ai/nano-banana-pro/edit'
}

export type PostFalAiNanoBananaProEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiNanoBananaProEditResponse =
  PostFalAiNanoBananaProEditResponses[keyof PostFalAiNanoBananaProEditResponses]

export type GetFalAiNanoBananaProEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/nano-banana-pro/edit/requests/{request_id}'
}

export type GetFalAiNanoBananaProEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaNanoBananaProEditOutput
}

export type GetFalAiNanoBananaProEditRequestsByRequestIdResponse =
  GetFalAiNanoBananaProEditRequestsByRequestIdResponses[keyof GetFalAiNanoBananaProEditRequestsByRequestIdResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/multiple-angles/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/multiple-angles/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEditPlusLoraGalleryMultipleAnglesData = {
  body: SchemaQwenImageEditPlusLoraGalleryMultipleAnglesInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-plus-lora-gallery/multiple-angles'
}

export type PostFalAiQwenImageEditPlusLoraGalleryMultipleAnglesResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEditPlusLoraGalleryMultipleAnglesResponse =
  PostFalAiQwenImageEditPlusLoraGalleryMultipleAnglesResponses[keyof PostFalAiQwenImageEditPlusLoraGalleryMultipleAnglesResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/multiple-angles/requests/{request_id}'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEditPlusLoraGalleryMultipleAnglesOutput
  }

export type GetFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdResponse =
  GetFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/shirt-design/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/shirt-design/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEditPlusLoraGalleryShirtDesignData = {
  body: SchemaQwenImageEditPlusLoraGalleryShirtDesignInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-plus-lora-gallery/shirt-design'
}

export type PostFalAiQwenImageEditPlusLoraGalleryShirtDesignResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEditPlusLoraGalleryShirtDesignResponse =
  PostFalAiQwenImageEditPlusLoraGalleryShirtDesignResponses[keyof PostFalAiQwenImageEditPlusLoraGalleryShirtDesignResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/shirt-design/requests/{request_id}'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEditPlusLoraGalleryShirtDesignOutput
  }

export type GetFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdResponse =
  GetFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/remove-lighting/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/remove-lighting/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEditPlusLoraGalleryRemoveLightingData = {
  body: SchemaQwenImageEditPlusLoraGalleryRemoveLightingInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-plus-lora-gallery/remove-lighting'
}

export type PostFalAiQwenImageEditPlusLoraGalleryRemoveLightingResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEditPlusLoraGalleryRemoveLightingResponse =
  PostFalAiQwenImageEditPlusLoraGalleryRemoveLightingResponses[keyof PostFalAiQwenImageEditPlusLoraGalleryRemoveLightingResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/remove-lighting/requests/{request_id}'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEditPlusLoraGalleryRemoveLightingOutput
  }

export type GetFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdResponse =
  GetFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/remove-element/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/remove-element/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEditPlusLoraGalleryRemoveElementData = {
  body: SchemaQwenImageEditPlusLoraGalleryRemoveElementInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-plus-lora-gallery/remove-element'
}

export type PostFalAiQwenImageEditPlusLoraGalleryRemoveElementResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEditPlusLoraGalleryRemoveElementResponse =
  PostFalAiQwenImageEditPlusLoraGalleryRemoveElementResponses[keyof PostFalAiQwenImageEditPlusLoraGalleryRemoveElementResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/remove-element/requests/{request_id}'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEditPlusLoraGalleryRemoveElementOutput
  }

export type GetFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdResponse =
  GetFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/next-scene/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/next-scene/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEditPlusLoraGalleryNextSceneData = {
  body: SchemaQwenImageEditPlusLoraGalleryNextSceneInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-plus-lora-gallery/next-scene'
}

export type PostFalAiQwenImageEditPlusLoraGalleryNextSceneResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEditPlusLoraGalleryNextSceneResponse =
  PostFalAiQwenImageEditPlusLoraGalleryNextSceneResponses[keyof PostFalAiQwenImageEditPlusLoraGalleryNextSceneResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/next-scene/requests/{request_id}'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEditPlusLoraGalleryNextSceneOutput
  }

export type GetFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdResponse =
  GetFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/integrate-product/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/integrate-product/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEditPlusLoraGalleryIntegrateProductData = {
  body: SchemaQwenImageEditPlusLoraGalleryIntegrateProductInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-plus-lora-gallery/integrate-product'
}

export type PostFalAiQwenImageEditPlusLoraGalleryIntegrateProductResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEditPlusLoraGalleryIntegrateProductResponse =
  PostFalAiQwenImageEditPlusLoraGalleryIntegrateProductResponses[keyof PostFalAiQwenImageEditPlusLoraGalleryIntegrateProductResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/integrate-product/requests/{request_id}'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEditPlusLoraGalleryIntegrateProductOutput
  }

export type GetFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdResponse =
  GetFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/group-photo/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/group-photo/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEditPlusLoraGalleryGroupPhotoData = {
  body: SchemaQwenImageEditPlusLoraGalleryGroupPhotoInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-plus-lora-gallery/group-photo'
}

export type PostFalAiQwenImageEditPlusLoraGalleryGroupPhotoResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEditPlusLoraGalleryGroupPhotoResponse =
  PostFalAiQwenImageEditPlusLoraGalleryGroupPhotoResponses[keyof PostFalAiQwenImageEditPlusLoraGalleryGroupPhotoResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/group-photo/requests/{request_id}'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEditPlusLoraGalleryGroupPhotoOutput
  }

export type GetFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdResponse =
  GetFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/face-to-full-portrait/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/face-to-full-portrait/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitData = {
  body: SchemaQwenImageEditPlusLoraGalleryFaceToFullPortraitInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-plus-lora-gallery/face-to-full-portrait'
}

export type PostFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitResponse =
  PostFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitResponses[keyof PostFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/face-to-full-portrait/requests/{request_id}'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEditPlusLoraGalleryFaceToFullPortraitOutput
  }

export type GetFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdResponse =
  GetFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/add-background/requests/{request_id}/status'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/add-background/requests/{request_id}/cancel'
  }

export type PutFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEditPlusLoraGalleryAddBackgroundData = {
  body: SchemaQwenImageEditPlusLoraGalleryAddBackgroundInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-plus-lora-gallery/add-background'
}

export type PostFalAiQwenImageEditPlusLoraGalleryAddBackgroundResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEditPlusLoraGalleryAddBackgroundResponse =
  PostFalAiQwenImageEditPlusLoraGalleryAddBackgroundResponses[keyof PostFalAiQwenImageEditPlusLoraGalleryAddBackgroundResponses]

export type GetFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/qwen-image-edit-plus-lora-gallery/add-background/requests/{request_id}'
  }

export type GetFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaQwenImageEditPlusLoraGalleryAddBackgroundOutput
  }

export type GetFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdResponse =
  GetFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdResponses[keyof GetFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdResponses]

export type GetFalAiReveFastRemixRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/reve/fast/remix/requests/{request_id}/status'
}

export type GetFalAiReveFastRemixRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiReveFastRemixRequestsByRequestIdStatusResponse =
  GetFalAiReveFastRemixRequestsByRequestIdStatusResponses[keyof GetFalAiReveFastRemixRequestsByRequestIdStatusResponses]

export type PutFalAiReveFastRemixRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/reve/fast/remix/requests/{request_id}/cancel'
}

export type PutFalAiReveFastRemixRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiReveFastRemixRequestsByRequestIdCancelResponse =
  PutFalAiReveFastRemixRequestsByRequestIdCancelResponses[keyof PutFalAiReveFastRemixRequestsByRequestIdCancelResponses]

export type PostFalAiReveFastRemixData = {
  body: SchemaReveFastRemixInput
  path?: never
  query?: never
  url: '/fal-ai/reve/fast/remix'
}

export type PostFalAiReveFastRemixResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiReveFastRemixResponse =
  PostFalAiReveFastRemixResponses[keyof PostFalAiReveFastRemixResponses]

export type GetFalAiReveFastRemixRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/reve/fast/remix/requests/{request_id}'
}

export type GetFalAiReveFastRemixRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaReveFastRemixOutput
}

export type GetFalAiReveFastRemixRequestsByRequestIdResponse =
  GetFalAiReveFastRemixRequestsByRequestIdResponses[keyof GetFalAiReveFastRemixRequestsByRequestIdResponses]

export type GetFalAiReveFastEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/reve/fast/edit/requests/{request_id}/status'
}

export type GetFalAiReveFastEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiReveFastEditRequestsByRequestIdStatusResponse =
  GetFalAiReveFastEditRequestsByRequestIdStatusResponses[keyof GetFalAiReveFastEditRequestsByRequestIdStatusResponses]

export type PutFalAiReveFastEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/reve/fast/edit/requests/{request_id}/cancel'
}

export type PutFalAiReveFastEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiReveFastEditRequestsByRequestIdCancelResponse =
  PutFalAiReveFastEditRequestsByRequestIdCancelResponses[keyof PutFalAiReveFastEditRequestsByRequestIdCancelResponses]

export type PostFalAiReveFastEditData = {
  body: SchemaReveFastEditInput
  path?: never
  query?: never
  url: '/fal-ai/reve/fast/edit'
}

export type PostFalAiReveFastEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiReveFastEditResponse =
  PostFalAiReveFastEditResponses[keyof PostFalAiReveFastEditResponses]

export type GetFalAiReveFastEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/reve/fast/edit/requests/{request_id}'
}

export type GetFalAiReveFastEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaReveFastEditOutput
}

export type GetFalAiReveFastEditRequestsByRequestIdResponse =
  GetFalAiReveFastEditRequestsByRequestIdResponses[keyof GetFalAiReveFastEditRequestsByRequestIdResponses]

export type GetFalAiImageAppsV2OutpaintRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-apps-v2/outpaint/requests/{request_id}/status'
}

export type GetFalAiImageAppsV2OutpaintRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImageAppsV2OutpaintRequestsByRequestIdStatusResponse =
  GetFalAiImageAppsV2OutpaintRequestsByRequestIdStatusResponses[keyof GetFalAiImageAppsV2OutpaintRequestsByRequestIdStatusResponses]

export type PutFalAiImageAppsV2OutpaintRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/outpaint/requests/{request_id}/cancel'
}

export type PutFalAiImageAppsV2OutpaintRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImageAppsV2OutpaintRequestsByRequestIdCancelResponse =
  PutFalAiImageAppsV2OutpaintRequestsByRequestIdCancelResponses[keyof PutFalAiImageAppsV2OutpaintRequestsByRequestIdCancelResponses]

export type PostFalAiImageAppsV2OutpaintData = {
  body: SchemaImageAppsV2OutpaintInput
  path?: never
  query?: never
  url: '/fal-ai/image-apps-v2/outpaint'
}

export type PostFalAiImageAppsV2OutpaintResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageAppsV2OutpaintResponse =
  PostFalAiImageAppsV2OutpaintResponses[keyof PostFalAiImageAppsV2OutpaintResponses]

export type GetFalAiImageAppsV2OutpaintRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/outpaint/requests/{request_id}'
}

export type GetFalAiImageAppsV2OutpaintRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageAppsV2OutpaintOutput
}

export type GetFalAiImageAppsV2OutpaintRequestsByRequestIdResponse =
  GetFalAiImageAppsV2OutpaintRequestsByRequestIdResponses[keyof GetFalAiImageAppsV2OutpaintRequestsByRequestIdResponses]

export type GetFalAiFluxVisionUpscalerRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-vision-upscaler/requests/{request_id}/status'
}

export type GetFalAiFluxVisionUpscalerRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxVisionUpscalerRequestsByRequestIdStatusResponse =
  GetFalAiFluxVisionUpscalerRequestsByRequestIdStatusResponses[keyof GetFalAiFluxVisionUpscalerRequestsByRequestIdStatusResponses]

export type PutFalAiFluxVisionUpscalerRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-vision-upscaler/requests/{request_id}/cancel'
}

export type PutFalAiFluxVisionUpscalerRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxVisionUpscalerRequestsByRequestIdCancelResponse =
  PutFalAiFluxVisionUpscalerRequestsByRequestIdCancelResponses[keyof PutFalAiFluxVisionUpscalerRequestsByRequestIdCancelResponses]

export type PostFalAiFluxVisionUpscalerData = {
  body: SchemaFluxVisionUpscalerInput
  path?: never
  query?: never
  url: '/fal-ai/flux-vision-upscaler'
}

export type PostFalAiFluxVisionUpscalerResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxVisionUpscalerResponse =
  PostFalAiFluxVisionUpscalerResponses[keyof PostFalAiFluxVisionUpscalerResponses]

export type GetFalAiFluxVisionUpscalerRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-vision-upscaler/requests/{request_id}'
}

export type GetFalAiFluxVisionUpscalerRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxVisionUpscalerOutput
}

export type GetFalAiFluxVisionUpscalerRequestsByRequestIdResponse =
  GetFalAiFluxVisionUpscalerRequestsByRequestIdResponses[keyof GetFalAiFluxVisionUpscalerRequestsByRequestIdResponses]

export type GetFalAiEmu35ImageEditImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/emu-3.5-image/edit-image/requests/{request_id}/status'
}

export type GetFalAiEmu35ImageEditImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiEmu35ImageEditImageRequestsByRequestIdStatusResponse =
  GetFalAiEmu35ImageEditImageRequestsByRequestIdStatusResponses[keyof GetFalAiEmu35ImageEditImageRequestsByRequestIdStatusResponses]

export type PutFalAiEmu35ImageEditImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/emu-3.5-image/edit-image/requests/{request_id}/cancel'
}

export type PutFalAiEmu35ImageEditImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiEmu35ImageEditImageRequestsByRequestIdCancelResponse =
  PutFalAiEmu35ImageEditImageRequestsByRequestIdCancelResponses[keyof PutFalAiEmu35ImageEditImageRequestsByRequestIdCancelResponses]

export type PostFalAiEmu35ImageEditImageData = {
  body: SchemaEmu35ImageEditImageInput
  path?: never
  query?: never
  url: '/fal-ai/emu-3.5-image/edit-image'
}

export type PostFalAiEmu35ImageEditImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiEmu35ImageEditImageResponse =
  PostFalAiEmu35ImageEditImageResponses[keyof PostFalAiEmu35ImageEditImageResponses]

export type GetFalAiEmu35ImageEditImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/emu-3.5-image/edit-image/requests/{request_id}'
}

export type GetFalAiEmu35ImageEditImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaEmu35ImageEditImageOutput
}

export type GetFalAiEmu35ImageEditImageRequestsByRequestIdResponse =
  GetFalAiEmu35ImageEditImageRequestsByRequestIdResponses[keyof GetFalAiEmu35ImageEditImageRequestsByRequestIdResponses]

export type GetFalAiChronoEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/chrono-edit/requests/{request_id}/status'
}

export type GetFalAiChronoEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiChronoEditRequestsByRequestIdStatusResponse =
  GetFalAiChronoEditRequestsByRequestIdStatusResponses[keyof GetFalAiChronoEditRequestsByRequestIdStatusResponses]

export type PutFalAiChronoEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/chrono-edit/requests/{request_id}/cancel'
}

export type PutFalAiChronoEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiChronoEditRequestsByRequestIdCancelResponse =
  PutFalAiChronoEditRequestsByRequestIdCancelResponses[keyof PutFalAiChronoEditRequestsByRequestIdCancelResponses]

export type PostFalAiChronoEditData = {
  body: SchemaChronoEditInput
  path?: never
  query?: never
  url: '/fal-ai/chrono-edit'
}

export type PostFalAiChronoEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiChronoEditResponse =
  PostFalAiChronoEditResponses[keyof PostFalAiChronoEditResponses]

export type GetFalAiChronoEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/chrono-edit/requests/{request_id}'
}

export type GetFalAiChronoEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaChronoEditOutput
}

export type GetFalAiChronoEditRequestsByRequestIdResponse =
  GetFalAiChronoEditRequestsByRequestIdResponses[keyof GetFalAiChronoEditRequestsByRequestIdResponses]

export type GetFalAiGptImage1MiniEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/gpt-image-1-mini/edit/requests/{request_id}/status'
}

export type GetFalAiGptImage1MiniEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiGptImage1MiniEditRequestsByRequestIdStatusResponse =
  GetFalAiGptImage1MiniEditRequestsByRequestIdStatusResponses[keyof GetFalAiGptImage1MiniEditRequestsByRequestIdStatusResponses]

export type PutFalAiGptImage1MiniEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gpt-image-1-mini/edit/requests/{request_id}/cancel'
}

export type PutFalAiGptImage1MiniEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiGptImage1MiniEditRequestsByRequestIdCancelResponse =
  PutFalAiGptImage1MiniEditRequestsByRequestIdCancelResponses[keyof PutFalAiGptImage1MiniEditRequestsByRequestIdCancelResponses]

export type PostFalAiGptImage1MiniEditData = {
  body: SchemaGptImage1MiniEditInput
  path?: never
  query?: never
  url: '/fal-ai/gpt-image-1-mini/edit'
}

export type PostFalAiGptImage1MiniEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiGptImage1MiniEditResponse =
  PostFalAiGptImage1MiniEditResponses[keyof PostFalAiGptImage1MiniEditResponses]

export type GetFalAiGptImage1MiniEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gpt-image-1-mini/edit/requests/{request_id}'
}

export type GetFalAiGptImage1MiniEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaGptImage1MiniEditOutput
}

export type GetFalAiGptImage1MiniEditRequestsByRequestIdResponse =
  GetFalAiGptImage1MiniEditRequestsByRequestIdResponses[keyof GetFalAiGptImage1MiniEditRequestsByRequestIdResponses]

export type GetFalAiReveRemixRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/reve/remix/requests/{request_id}/status'
}

export type GetFalAiReveRemixRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiReveRemixRequestsByRequestIdStatusResponse =
  GetFalAiReveRemixRequestsByRequestIdStatusResponses[keyof GetFalAiReveRemixRequestsByRequestIdStatusResponses]

export type PutFalAiReveRemixRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/reve/remix/requests/{request_id}/cancel'
}

export type PutFalAiReveRemixRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiReveRemixRequestsByRequestIdCancelResponse =
  PutFalAiReveRemixRequestsByRequestIdCancelResponses[keyof PutFalAiReveRemixRequestsByRequestIdCancelResponses]

export type PostFalAiReveRemixData = {
  body: SchemaReveRemixInput
  path?: never
  query?: never
  url: '/fal-ai/reve/remix'
}

export type PostFalAiReveRemixResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiReveRemixResponse =
  PostFalAiReveRemixResponses[keyof PostFalAiReveRemixResponses]

export type GetFalAiReveRemixRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/reve/remix/requests/{request_id}'
}

export type GetFalAiReveRemixRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaReveRemixOutput
}

export type GetFalAiReveRemixRequestsByRequestIdResponse =
  GetFalAiReveRemixRequestsByRequestIdResponses[keyof GetFalAiReveRemixRequestsByRequestIdResponses]

export type GetFalAiReveEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/reve/edit/requests/{request_id}/status'
}

export type GetFalAiReveEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiReveEditRequestsByRequestIdStatusResponse =
  GetFalAiReveEditRequestsByRequestIdStatusResponses[keyof GetFalAiReveEditRequestsByRequestIdStatusResponses]

export type PutFalAiReveEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/reve/edit/requests/{request_id}/cancel'
}

export type PutFalAiReveEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiReveEditRequestsByRequestIdCancelResponse =
  PutFalAiReveEditRequestsByRequestIdCancelResponses[keyof PutFalAiReveEditRequestsByRequestIdCancelResponses]

export type PostFalAiReveEditData = {
  body: SchemaReveEditInput
  path?: never
  query?: never
  url: '/fal-ai/reve/edit'
}

export type PostFalAiReveEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiReveEditResponse =
  PostFalAiReveEditResponses[keyof PostFalAiReveEditResponses]

export type GetFalAiReveEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/reve/edit/requests/{request_id}'
}

export type GetFalAiReveEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaReveEditOutput
}

export type GetFalAiReveEditRequestsByRequestIdResponse =
  GetFalAiReveEditRequestsByRequestIdResponses[keyof GetFalAiReveEditRequestsByRequestIdResponses]

export type GetFalAiImage2PixelRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image2pixel/requests/{request_id}/status'
}

export type GetFalAiImage2PixelRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImage2PixelRequestsByRequestIdStatusResponse =
  GetFalAiImage2PixelRequestsByRequestIdStatusResponses[keyof GetFalAiImage2PixelRequestsByRequestIdStatusResponses]

export type PutFalAiImage2PixelRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image2pixel/requests/{request_id}/cancel'
}

export type PutFalAiImage2PixelRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImage2PixelRequestsByRequestIdCancelResponse =
  PutFalAiImage2PixelRequestsByRequestIdCancelResponses[keyof PutFalAiImage2PixelRequestsByRequestIdCancelResponses]

export type PostFalAiImage2PixelData = {
  body: SchemaImage2PixelInput
  path?: never
  query?: never
  url: '/fal-ai/image2pixel'
}

export type PostFalAiImage2PixelResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImage2PixelResponse =
  PostFalAiImage2PixelResponses[keyof PostFalAiImage2PixelResponses]

export type GetFalAiImage2PixelRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image2pixel/requests/{request_id}'
}

export type GetFalAiImage2PixelRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImage2PixelOutput
}

export type GetFalAiImage2PixelRequestsByRequestIdResponse =
  GetFalAiImage2PixelRequestsByRequestIdResponses[keyof GetFalAiImage2PixelRequestsByRequestIdResponses]

export type GetFalAiDreamomni2EditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/dreamomni2/edit/requests/{request_id}/status'
}

export type GetFalAiDreamomni2EditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiDreamomni2EditRequestsByRequestIdStatusResponse =
  GetFalAiDreamomni2EditRequestsByRequestIdStatusResponses[keyof GetFalAiDreamomni2EditRequestsByRequestIdStatusResponses]

export type PutFalAiDreamomni2EditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/dreamomni2/edit/requests/{request_id}/cancel'
}

export type PutFalAiDreamomni2EditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiDreamomni2EditRequestsByRequestIdCancelResponse =
  PutFalAiDreamomni2EditRequestsByRequestIdCancelResponses[keyof PutFalAiDreamomni2EditRequestsByRequestIdCancelResponses]

export type PostFalAiDreamomni2EditData = {
  body: SchemaDreamomni2EditInput
  path?: never
  query?: never
  url: '/fal-ai/dreamomni2/edit'
}

export type PostFalAiDreamomni2EditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiDreamomni2EditResponse =
  PostFalAiDreamomni2EditResponses[keyof PostFalAiDreamomni2EditResponses]

export type GetFalAiDreamomni2EditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/dreamomni2/edit/requests/{request_id}'
}

export type GetFalAiDreamomni2EditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaDreamomni2EditOutput
}

export type GetFalAiDreamomni2EditRequestsByRequestIdResponse =
  GetFalAiDreamomni2EditRequestsByRequestIdResponses[keyof GetFalAiDreamomni2EditRequestsByRequestIdResponses]

export type GetFalAiQwenImageEditPlusLoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/qwen-image-edit-plus-lora/requests/{request_id}/status'
}

export type GetFalAiQwenImageEditPlusLoraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiQwenImageEditPlusLoraRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEditPlusLoraRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEditPlusLoraRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEditPlusLoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit-plus-lora/requests/{request_id}/cancel'
}

export type PutFalAiQwenImageEditPlusLoraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiQwenImageEditPlusLoraRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEditPlusLoraRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEditPlusLoraRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEditPlusLoraData = {
  body: SchemaQwenImageEditPlusLoraInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-plus-lora'
}

export type PostFalAiQwenImageEditPlusLoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEditPlusLoraResponse =
  PostFalAiQwenImageEditPlusLoraResponses[keyof PostFalAiQwenImageEditPlusLoraResponses]

export type GetFalAiQwenImageEditPlusLoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit-plus-lora/requests/{request_id}'
}

export type GetFalAiQwenImageEditPlusLoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaQwenImageEditPlusLoraOutput
}

export type GetFalAiQwenImageEditPlusLoraRequestsByRequestIdResponse =
  GetFalAiQwenImageEditPlusLoraRequestsByRequestIdResponses[keyof GetFalAiQwenImageEditPlusLoraRequestsByRequestIdResponses]

export type GetFalAiLucidfluxRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/lucidflux/requests/{request_id}/status'
}

export type GetFalAiLucidfluxRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLucidfluxRequestsByRequestIdStatusResponse =
  GetFalAiLucidfluxRequestsByRequestIdStatusResponses[keyof GetFalAiLucidfluxRequestsByRequestIdStatusResponses]

export type PutFalAiLucidfluxRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/lucidflux/requests/{request_id}/cancel'
}

export type PutFalAiLucidfluxRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLucidfluxRequestsByRequestIdCancelResponse =
  PutFalAiLucidfluxRequestsByRequestIdCancelResponses[keyof PutFalAiLucidfluxRequestsByRequestIdCancelResponses]

export type PostFalAiLucidfluxData = {
  body: SchemaLucidfluxInput
  path?: never
  query?: never
  url: '/fal-ai/lucidflux'
}

export type PostFalAiLucidfluxResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLucidfluxResponse =
  PostFalAiLucidfluxResponses[keyof PostFalAiLucidfluxResponses]

export type GetFalAiLucidfluxRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/lucidflux/requests/{request_id}'
}

export type GetFalAiLucidfluxRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLucidfluxOutput
}

export type GetFalAiLucidfluxRequestsByRequestIdResponse =
  GetFalAiLucidfluxRequestsByRequestIdResponses[keyof GetFalAiLucidfluxRequestsByRequestIdResponses]

export type GetFalAiQwenImageEditImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/qwen-image-edit/image-to-image/requests/{request_id}/status'
}

export type GetFalAiQwenImageEditImageToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiQwenImageEditImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEditImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEditImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEditImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiQwenImageEditImageToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiQwenImageEditImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEditImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEditImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEditImageToImageData = {
  body: SchemaQwenImageEditImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit/image-to-image'
}

export type PostFalAiQwenImageEditImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEditImageToImageResponse =
  PostFalAiQwenImageEditImageToImageResponses[keyof PostFalAiQwenImageEditImageToImageResponses]

export type GetFalAiQwenImageEditImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit/image-to-image/requests/{request_id}'
}

export type GetFalAiQwenImageEditImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaQwenImageEditImageToImageOutput
}

export type GetFalAiQwenImageEditImageToImageRequestsByRequestIdResponse =
  GetFalAiQwenImageEditImageToImageRequestsByRequestIdResponses[keyof GetFalAiQwenImageEditImageToImageRequestsByRequestIdResponses]

export type GetFalAiWan25PreviewImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/wan-25-preview/image-to-image/requests/{request_id}/status'
}

export type GetFalAiWan25PreviewImageToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiWan25PreviewImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiWan25PreviewImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiWan25PreviewImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiWan25PreviewImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/wan-25-preview/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiWan25PreviewImageToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiWan25PreviewImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiWan25PreviewImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiWan25PreviewImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiWan25PreviewImageToImageData = {
  body: SchemaWan25PreviewImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/wan-25-preview/image-to-image'
}

export type PostFalAiWan25PreviewImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiWan25PreviewImageToImageResponse =
  PostFalAiWan25PreviewImageToImageResponses[keyof PostFalAiWan25PreviewImageToImageResponses]

export type GetFalAiWan25PreviewImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/wan-25-preview/image-to-image/requests/{request_id}'
}

export type GetFalAiWan25PreviewImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaWan25PreviewImageToImageOutput
}

export type GetFalAiWan25PreviewImageToImageRequestsByRequestIdResponse =
  GetFalAiWan25PreviewImageToImageRequestsByRequestIdResponses[keyof GetFalAiWan25PreviewImageToImageRequestsByRequestIdResponses]

export type GetFalAiQwenImageEditPlusRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/qwen-image-edit-plus/requests/{request_id}/status'
}

export type GetFalAiQwenImageEditPlusRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiQwenImageEditPlusRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEditPlusRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEditPlusRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEditPlusRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit-plus/requests/{request_id}/cancel'
}

export type PutFalAiQwenImageEditPlusRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiQwenImageEditPlusRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEditPlusRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEditPlusRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEditPlusData = {
  body: SchemaQwenImageEditPlusInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-plus'
}

export type PostFalAiQwenImageEditPlusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEditPlusResponse =
  PostFalAiQwenImageEditPlusResponses[keyof PostFalAiQwenImageEditPlusResponses]

export type GetFalAiQwenImageEditPlusRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit-plus/requests/{request_id}'
}

export type GetFalAiQwenImageEditPlusRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaQwenImageEditPlusOutput
}

export type GetFalAiQwenImageEditPlusRequestsByRequestIdResponse =
  GetFalAiQwenImageEditPlusRequestsByRequestIdResponses[keyof GetFalAiQwenImageEditPlusRequestsByRequestIdResponses]

export type GetFalAiSeedvrUpscaleImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/seedvr/upscale/image/requests/{request_id}/status'
}

export type GetFalAiSeedvrUpscaleImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiSeedvrUpscaleImageRequestsByRequestIdStatusResponse =
  GetFalAiSeedvrUpscaleImageRequestsByRequestIdStatusResponses[keyof GetFalAiSeedvrUpscaleImageRequestsByRequestIdStatusResponses]

export type PutFalAiSeedvrUpscaleImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/seedvr/upscale/image/requests/{request_id}/cancel'
}

export type PutFalAiSeedvrUpscaleImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiSeedvrUpscaleImageRequestsByRequestIdCancelResponse =
  PutFalAiSeedvrUpscaleImageRequestsByRequestIdCancelResponses[keyof PutFalAiSeedvrUpscaleImageRequestsByRequestIdCancelResponses]

export type PostFalAiSeedvrUpscaleImageData = {
  body: SchemaSeedvrUpscaleImageInput
  path?: never
  query?: never
  url: '/fal-ai/seedvr/upscale/image'
}

export type PostFalAiSeedvrUpscaleImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiSeedvrUpscaleImageResponse =
  PostFalAiSeedvrUpscaleImageResponses[keyof PostFalAiSeedvrUpscaleImageResponses]

export type GetFalAiSeedvrUpscaleImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/seedvr/upscale/image/requests/{request_id}'
}

export type GetFalAiSeedvrUpscaleImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaSeedvrUpscaleImageOutput
}

export type GetFalAiSeedvrUpscaleImageRequestsByRequestIdResponse =
  GetFalAiSeedvrUpscaleImageRequestsByRequestIdResponses[keyof GetFalAiSeedvrUpscaleImageRequestsByRequestIdResponses]

export type GetFalAiImageAppsV2ProductHoldingRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-apps-v2/product-holding/requests/{request_id}/status'
}

export type GetFalAiImageAppsV2ProductHoldingRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageAppsV2ProductHoldingRequestsByRequestIdStatusResponse =
  GetFalAiImageAppsV2ProductHoldingRequestsByRequestIdStatusResponses[keyof GetFalAiImageAppsV2ProductHoldingRequestsByRequestIdStatusResponses]

export type PutFalAiImageAppsV2ProductHoldingRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/product-holding/requests/{request_id}/cancel'
}

export type PutFalAiImageAppsV2ProductHoldingRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageAppsV2ProductHoldingRequestsByRequestIdCancelResponse =
  PutFalAiImageAppsV2ProductHoldingRequestsByRequestIdCancelResponses[keyof PutFalAiImageAppsV2ProductHoldingRequestsByRequestIdCancelResponses]

export type PostFalAiImageAppsV2ProductHoldingData = {
  body: SchemaImageAppsV2ProductHoldingInput
  path?: never
  query?: never
  url: '/fal-ai/image-apps-v2/product-holding'
}

export type PostFalAiImageAppsV2ProductHoldingResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageAppsV2ProductHoldingResponse =
  PostFalAiImageAppsV2ProductHoldingResponses[keyof PostFalAiImageAppsV2ProductHoldingResponses]

export type GetFalAiImageAppsV2ProductHoldingRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/product-holding/requests/{request_id}'
}

export type GetFalAiImageAppsV2ProductHoldingRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageAppsV2ProductHoldingOutput
}

export type GetFalAiImageAppsV2ProductHoldingRequestsByRequestIdResponse =
  GetFalAiImageAppsV2ProductHoldingRequestsByRequestIdResponses[keyof GetFalAiImageAppsV2ProductHoldingRequestsByRequestIdResponses]

export type GetFalAiImageAppsV2ProductPhotographyRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/image-apps-v2/product-photography/requests/{request_id}/status'
  }

export type GetFalAiImageAppsV2ProductPhotographyRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageAppsV2ProductPhotographyRequestsByRequestIdStatusResponse =
  GetFalAiImageAppsV2ProductPhotographyRequestsByRequestIdStatusResponses[keyof GetFalAiImageAppsV2ProductPhotographyRequestsByRequestIdStatusResponses]

export type PutFalAiImageAppsV2ProductPhotographyRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/image-apps-v2/product-photography/requests/{request_id}/cancel'
  }

export type PutFalAiImageAppsV2ProductPhotographyRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageAppsV2ProductPhotographyRequestsByRequestIdCancelResponse =
  PutFalAiImageAppsV2ProductPhotographyRequestsByRequestIdCancelResponses[keyof PutFalAiImageAppsV2ProductPhotographyRequestsByRequestIdCancelResponses]

export type PostFalAiImageAppsV2ProductPhotographyData = {
  body: SchemaImageAppsV2ProductPhotographyInput
  path?: never
  query?: never
  url: '/fal-ai/image-apps-v2/product-photography'
}

export type PostFalAiImageAppsV2ProductPhotographyResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageAppsV2ProductPhotographyResponse =
  PostFalAiImageAppsV2ProductPhotographyResponses[keyof PostFalAiImageAppsV2ProductPhotographyResponses]

export type GetFalAiImageAppsV2ProductPhotographyRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/product-photography/requests/{request_id}'
}

export type GetFalAiImageAppsV2ProductPhotographyRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaImageAppsV2ProductPhotographyOutput
  }

export type GetFalAiImageAppsV2ProductPhotographyRequestsByRequestIdResponse =
  GetFalAiImageAppsV2ProductPhotographyRequestsByRequestIdResponses[keyof GetFalAiImageAppsV2ProductPhotographyRequestsByRequestIdResponses]

export type GetFalAiImageAppsV2VirtualTryOnRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-apps-v2/virtual-try-on/requests/{request_id}/status'
}

export type GetFalAiImageAppsV2VirtualTryOnRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageAppsV2VirtualTryOnRequestsByRequestIdStatusResponse =
  GetFalAiImageAppsV2VirtualTryOnRequestsByRequestIdStatusResponses[keyof GetFalAiImageAppsV2VirtualTryOnRequestsByRequestIdStatusResponses]

export type PutFalAiImageAppsV2VirtualTryOnRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/virtual-try-on/requests/{request_id}/cancel'
}

export type PutFalAiImageAppsV2VirtualTryOnRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageAppsV2VirtualTryOnRequestsByRequestIdCancelResponse =
  PutFalAiImageAppsV2VirtualTryOnRequestsByRequestIdCancelResponses[keyof PutFalAiImageAppsV2VirtualTryOnRequestsByRequestIdCancelResponses]

export type PostFalAiImageAppsV2VirtualTryOnData = {
  body: SchemaImageAppsV2VirtualTryOnInput
  path?: never
  query?: never
  url: '/fal-ai/image-apps-v2/virtual-try-on'
}

export type PostFalAiImageAppsV2VirtualTryOnResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageAppsV2VirtualTryOnResponse =
  PostFalAiImageAppsV2VirtualTryOnResponses[keyof PostFalAiImageAppsV2VirtualTryOnResponses]

export type GetFalAiImageAppsV2VirtualTryOnRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/virtual-try-on/requests/{request_id}'
}

export type GetFalAiImageAppsV2VirtualTryOnRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageAppsV2VirtualTryOnOutput
}

export type GetFalAiImageAppsV2VirtualTryOnRequestsByRequestIdResponse =
  GetFalAiImageAppsV2VirtualTryOnRequestsByRequestIdResponses[keyof GetFalAiImageAppsV2VirtualTryOnRequestsByRequestIdResponses]

export type GetFalAiImageAppsV2TextureTransformRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-apps-v2/texture-transform/requests/{request_id}/status'
}

export type GetFalAiImageAppsV2TextureTransformRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageAppsV2TextureTransformRequestsByRequestIdStatusResponse =
  GetFalAiImageAppsV2TextureTransformRequestsByRequestIdStatusResponses[keyof GetFalAiImageAppsV2TextureTransformRequestsByRequestIdStatusResponses]

export type PutFalAiImageAppsV2TextureTransformRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/texture-transform/requests/{request_id}/cancel'
}

export type PutFalAiImageAppsV2TextureTransformRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageAppsV2TextureTransformRequestsByRequestIdCancelResponse =
  PutFalAiImageAppsV2TextureTransformRequestsByRequestIdCancelResponses[keyof PutFalAiImageAppsV2TextureTransformRequestsByRequestIdCancelResponses]

export type PostFalAiImageAppsV2TextureTransformData = {
  body: SchemaImageAppsV2TextureTransformInput
  path?: never
  query?: never
  url: '/fal-ai/image-apps-v2/texture-transform'
}

export type PostFalAiImageAppsV2TextureTransformResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageAppsV2TextureTransformResponse =
  PostFalAiImageAppsV2TextureTransformResponses[keyof PostFalAiImageAppsV2TextureTransformResponses]

export type GetFalAiImageAppsV2TextureTransformRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/texture-transform/requests/{request_id}'
}

export type GetFalAiImageAppsV2TextureTransformRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageAppsV2TextureTransformOutput
}

export type GetFalAiImageAppsV2TextureTransformRequestsByRequestIdResponse =
  GetFalAiImageAppsV2TextureTransformRequestsByRequestIdResponses[keyof GetFalAiImageAppsV2TextureTransformRequestsByRequestIdResponses]

export type GetFalAiImageAppsV2RelightingRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-apps-v2/relighting/requests/{request_id}/status'
}

export type GetFalAiImageAppsV2RelightingRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImageAppsV2RelightingRequestsByRequestIdStatusResponse =
  GetFalAiImageAppsV2RelightingRequestsByRequestIdStatusResponses[keyof GetFalAiImageAppsV2RelightingRequestsByRequestIdStatusResponses]

export type PutFalAiImageAppsV2RelightingRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/relighting/requests/{request_id}/cancel'
}

export type PutFalAiImageAppsV2RelightingRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImageAppsV2RelightingRequestsByRequestIdCancelResponse =
  PutFalAiImageAppsV2RelightingRequestsByRequestIdCancelResponses[keyof PutFalAiImageAppsV2RelightingRequestsByRequestIdCancelResponses]

export type PostFalAiImageAppsV2RelightingData = {
  body: SchemaImageAppsV2RelightingInput
  path?: never
  query?: never
  url: '/fal-ai/image-apps-v2/relighting'
}

export type PostFalAiImageAppsV2RelightingResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageAppsV2RelightingResponse =
  PostFalAiImageAppsV2RelightingResponses[keyof PostFalAiImageAppsV2RelightingResponses]

export type GetFalAiImageAppsV2RelightingRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/relighting/requests/{request_id}'
}

export type GetFalAiImageAppsV2RelightingRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageAppsV2RelightingOutput
}

export type GetFalAiImageAppsV2RelightingRequestsByRequestIdResponse =
  GetFalAiImageAppsV2RelightingRequestsByRequestIdResponses[keyof GetFalAiImageAppsV2RelightingRequestsByRequestIdResponses]

export type GetFalAiImageAppsV2StyleTransferRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-apps-v2/style-transfer/requests/{request_id}/status'
}

export type GetFalAiImageAppsV2StyleTransferRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageAppsV2StyleTransferRequestsByRequestIdStatusResponse =
  GetFalAiImageAppsV2StyleTransferRequestsByRequestIdStatusResponses[keyof GetFalAiImageAppsV2StyleTransferRequestsByRequestIdStatusResponses]

export type PutFalAiImageAppsV2StyleTransferRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/style-transfer/requests/{request_id}/cancel'
}

export type PutFalAiImageAppsV2StyleTransferRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageAppsV2StyleTransferRequestsByRequestIdCancelResponse =
  PutFalAiImageAppsV2StyleTransferRequestsByRequestIdCancelResponses[keyof PutFalAiImageAppsV2StyleTransferRequestsByRequestIdCancelResponses]

export type PostFalAiImageAppsV2StyleTransferData = {
  body: SchemaImageAppsV2StyleTransferInput
  path?: never
  query?: never
  url: '/fal-ai/image-apps-v2/style-transfer'
}

export type PostFalAiImageAppsV2StyleTransferResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageAppsV2StyleTransferResponse =
  PostFalAiImageAppsV2StyleTransferResponses[keyof PostFalAiImageAppsV2StyleTransferResponses]

export type GetFalAiImageAppsV2StyleTransferRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/style-transfer/requests/{request_id}'
}

export type GetFalAiImageAppsV2StyleTransferRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageAppsV2StyleTransferOutput
}

export type GetFalAiImageAppsV2StyleTransferRequestsByRequestIdResponse =
  GetFalAiImageAppsV2StyleTransferRequestsByRequestIdResponses[keyof GetFalAiImageAppsV2StyleTransferRequestsByRequestIdResponses]

export type GetFalAiImageAppsV2PhotoRestorationRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-apps-v2/photo-restoration/requests/{request_id}/status'
}

export type GetFalAiImageAppsV2PhotoRestorationRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageAppsV2PhotoRestorationRequestsByRequestIdStatusResponse =
  GetFalAiImageAppsV2PhotoRestorationRequestsByRequestIdStatusResponses[keyof GetFalAiImageAppsV2PhotoRestorationRequestsByRequestIdStatusResponses]

export type PutFalAiImageAppsV2PhotoRestorationRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/photo-restoration/requests/{request_id}/cancel'
}

export type PutFalAiImageAppsV2PhotoRestorationRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageAppsV2PhotoRestorationRequestsByRequestIdCancelResponse =
  PutFalAiImageAppsV2PhotoRestorationRequestsByRequestIdCancelResponses[keyof PutFalAiImageAppsV2PhotoRestorationRequestsByRequestIdCancelResponses]

export type PostFalAiImageAppsV2PhotoRestorationData = {
  body: SchemaImageAppsV2PhotoRestorationInput
  path?: never
  query?: never
  url: '/fal-ai/image-apps-v2/photo-restoration'
}

export type PostFalAiImageAppsV2PhotoRestorationResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageAppsV2PhotoRestorationResponse =
  PostFalAiImageAppsV2PhotoRestorationResponses[keyof PostFalAiImageAppsV2PhotoRestorationResponses]

export type GetFalAiImageAppsV2PhotoRestorationRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/photo-restoration/requests/{request_id}'
}

export type GetFalAiImageAppsV2PhotoRestorationRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageAppsV2PhotoRestorationOutput
}

export type GetFalAiImageAppsV2PhotoRestorationRequestsByRequestIdResponse =
  GetFalAiImageAppsV2PhotoRestorationRequestsByRequestIdResponses[keyof GetFalAiImageAppsV2PhotoRestorationRequestsByRequestIdResponses]

export type GetFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-apps-v2/portrait-enhance/requests/{request_id}/status'
}

export type GetFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdStatusResponse =
  GetFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdStatusResponses[keyof GetFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdStatusResponses]

export type PutFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/portrait-enhance/requests/{request_id}/cancel'
}

export type PutFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdCancelResponse =
  PutFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdCancelResponses[keyof PutFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdCancelResponses]

export type PostFalAiImageAppsV2PortraitEnhanceData = {
  body: SchemaImageAppsV2PortraitEnhanceInput
  path?: never
  query?: never
  url: '/fal-ai/image-apps-v2/portrait-enhance'
}

export type PostFalAiImageAppsV2PortraitEnhanceResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageAppsV2PortraitEnhanceResponse =
  PostFalAiImageAppsV2PortraitEnhanceResponses[keyof PostFalAiImageAppsV2PortraitEnhanceResponses]

export type GetFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/portrait-enhance/requests/{request_id}'
}

export type GetFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageAppsV2PortraitEnhanceOutput
}

export type GetFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdResponse =
  GetFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdResponses[keyof GetFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdResponses]

export type GetFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/image-apps-v2/photography-effects/requests/{request_id}/status'
  }

export type GetFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdStatusResponse =
  GetFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdStatusResponses[keyof GetFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdStatusResponses]

export type PutFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/image-apps-v2/photography-effects/requests/{request_id}/cancel'
  }

export type PutFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdCancelResponse =
  PutFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdCancelResponses[keyof PutFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdCancelResponses]

export type PostFalAiImageAppsV2PhotographyEffectsData = {
  body: SchemaImageAppsV2PhotographyEffectsInput
  path?: never
  query?: never
  url: '/fal-ai/image-apps-v2/photography-effects'
}

export type PostFalAiImageAppsV2PhotographyEffectsResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageAppsV2PhotographyEffectsResponse =
  PostFalAiImageAppsV2PhotographyEffectsResponses[keyof PostFalAiImageAppsV2PhotographyEffectsResponses]

export type GetFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/photography-effects/requests/{request_id}'
}

export type GetFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaImageAppsV2PhotographyEffectsOutput
  }

export type GetFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdResponse =
  GetFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdResponses[keyof GetFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdResponses]

export type GetFalAiImageAppsV2PerspectiveRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-apps-v2/perspective/requests/{request_id}/status'
}

export type GetFalAiImageAppsV2PerspectiveRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImageAppsV2PerspectiveRequestsByRequestIdStatusResponse =
  GetFalAiImageAppsV2PerspectiveRequestsByRequestIdStatusResponses[keyof GetFalAiImageAppsV2PerspectiveRequestsByRequestIdStatusResponses]

export type PutFalAiImageAppsV2PerspectiveRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/perspective/requests/{request_id}/cancel'
}

export type PutFalAiImageAppsV2PerspectiveRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImageAppsV2PerspectiveRequestsByRequestIdCancelResponse =
  PutFalAiImageAppsV2PerspectiveRequestsByRequestIdCancelResponses[keyof PutFalAiImageAppsV2PerspectiveRequestsByRequestIdCancelResponses]

export type PostFalAiImageAppsV2PerspectiveData = {
  body: SchemaImageAppsV2PerspectiveInput
  path?: never
  query?: never
  url: '/fal-ai/image-apps-v2/perspective'
}

export type PostFalAiImageAppsV2PerspectiveResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageAppsV2PerspectiveResponse =
  PostFalAiImageAppsV2PerspectiveResponses[keyof PostFalAiImageAppsV2PerspectiveResponses]

export type GetFalAiImageAppsV2PerspectiveRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/perspective/requests/{request_id}'
}

export type GetFalAiImageAppsV2PerspectiveRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageAppsV2PerspectiveOutput
}

export type GetFalAiImageAppsV2PerspectiveRequestsByRequestIdResponse =
  GetFalAiImageAppsV2PerspectiveRequestsByRequestIdResponses[keyof GetFalAiImageAppsV2PerspectiveRequestsByRequestIdResponses]

export type GetFalAiImageAppsV2ObjectRemovalRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-apps-v2/object-removal/requests/{request_id}/status'
}

export type GetFalAiImageAppsV2ObjectRemovalRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageAppsV2ObjectRemovalRequestsByRequestIdStatusResponse =
  GetFalAiImageAppsV2ObjectRemovalRequestsByRequestIdStatusResponses[keyof GetFalAiImageAppsV2ObjectRemovalRequestsByRequestIdStatusResponses]

export type PutFalAiImageAppsV2ObjectRemovalRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/object-removal/requests/{request_id}/cancel'
}

export type PutFalAiImageAppsV2ObjectRemovalRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageAppsV2ObjectRemovalRequestsByRequestIdCancelResponse =
  PutFalAiImageAppsV2ObjectRemovalRequestsByRequestIdCancelResponses[keyof PutFalAiImageAppsV2ObjectRemovalRequestsByRequestIdCancelResponses]

export type PostFalAiImageAppsV2ObjectRemovalData = {
  body: SchemaImageAppsV2ObjectRemovalInput
  path?: never
  query?: never
  url: '/fal-ai/image-apps-v2/object-removal'
}

export type PostFalAiImageAppsV2ObjectRemovalResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageAppsV2ObjectRemovalResponse =
  PostFalAiImageAppsV2ObjectRemovalResponses[keyof PostFalAiImageAppsV2ObjectRemovalResponses]

export type GetFalAiImageAppsV2ObjectRemovalRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/object-removal/requests/{request_id}'
}

export type GetFalAiImageAppsV2ObjectRemovalRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageAppsV2ObjectRemovalOutput
}

export type GetFalAiImageAppsV2ObjectRemovalRequestsByRequestIdResponse =
  GetFalAiImageAppsV2ObjectRemovalRequestsByRequestIdResponses[keyof GetFalAiImageAppsV2ObjectRemovalRequestsByRequestIdResponses]

export type GetFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-apps-v2/headshot-photo/requests/{request_id}/status'
}

export type GetFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdStatusResponse =
  GetFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdStatusResponses[keyof GetFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdStatusResponses]

export type PutFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/headshot-photo/requests/{request_id}/cancel'
}

export type PutFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdCancelResponse =
  PutFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdCancelResponses[keyof PutFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdCancelResponses]

export type PostFalAiImageAppsV2HeadshotPhotoData = {
  body: SchemaImageAppsV2HeadshotPhotoInput
  path?: never
  query?: never
  url: '/fal-ai/image-apps-v2/headshot-photo'
}

export type PostFalAiImageAppsV2HeadshotPhotoResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageAppsV2HeadshotPhotoResponse =
  PostFalAiImageAppsV2HeadshotPhotoResponses[keyof PostFalAiImageAppsV2HeadshotPhotoResponses]

export type GetFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/headshot-photo/requests/{request_id}'
}

export type GetFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageAppsV2HeadshotPhotoOutput
}

export type GetFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdResponse =
  GetFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdResponses[keyof GetFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdResponses]

export type GetFalAiImageAppsV2HairChangeRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-apps-v2/hair-change/requests/{request_id}/status'
}

export type GetFalAiImageAppsV2HairChangeRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImageAppsV2HairChangeRequestsByRequestIdStatusResponse =
  GetFalAiImageAppsV2HairChangeRequestsByRequestIdStatusResponses[keyof GetFalAiImageAppsV2HairChangeRequestsByRequestIdStatusResponses]

export type PutFalAiImageAppsV2HairChangeRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/hair-change/requests/{request_id}/cancel'
}

export type PutFalAiImageAppsV2HairChangeRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImageAppsV2HairChangeRequestsByRequestIdCancelResponse =
  PutFalAiImageAppsV2HairChangeRequestsByRequestIdCancelResponses[keyof PutFalAiImageAppsV2HairChangeRequestsByRequestIdCancelResponses]

export type PostFalAiImageAppsV2HairChangeData = {
  body: SchemaImageAppsV2HairChangeInput
  path?: never
  query?: never
  url: '/fal-ai/image-apps-v2/hair-change'
}

export type PostFalAiImageAppsV2HairChangeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageAppsV2HairChangeResponse =
  PostFalAiImageAppsV2HairChangeResponses[keyof PostFalAiImageAppsV2HairChangeResponses]

export type GetFalAiImageAppsV2HairChangeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/hair-change/requests/{request_id}'
}

export type GetFalAiImageAppsV2HairChangeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageAppsV2HairChangeOutput
}

export type GetFalAiImageAppsV2HairChangeRequestsByRequestIdResponse =
  GetFalAiImageAppsV2HairChangeRequestsByRequestIdResponses[keyof GetFalAiImageAppsV2HairChangeRequestsByRequestIdResponses]

export type GetFalAiImageAppsV2ExpressionChangeRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-apps-v2/expression-change/requests/{request_id}/status'
}

export type GetFalAiImageAppsV2ExpressionChangeRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageAppsV2ExpressionChangeRequestsByRequestIdStatusResponse =
  GetFalAiImageAppsV2ExpressionChangeRequestsByRequestIdStatusResponses[keyof GetFalAiImageAppsV2ExpressionChangeRequestsByRequestIdStatusResponses]

export type PutFalAiImageAppsV2ExpressionChangeRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/expression-change/requests/{request_id}/cancel'
}

export type PutFalAiImageAppsV2ExpressionChangeRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageAppsV2ExpressionChangeRequestsByRequestIdCancelResponse =
  PutFalAiImageAppsV2ExpressionChangeRequestsByRequestIdCancelResponses[keyof PutFalAiImageAppsV2ExpressionChangeRequestsByRequestIdCancelResponses]

export type PostFalAiImageAppsV2ExpressionChangeData = {
  body: SchemaImageAppsV2ExpressionChangeInput
  path?: never
  query?: never
  url: '/fal-ai/image-apps-v2/expression-change'
}

export type PostFalAiImageAppsV2ExpressionChangeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageAppsV2ExpressionChangeResponse =
  PostFalAiImageAppsV2ExpressionChangeResponses[keyof PostFalAiImageAppsV2ExpressionChangeResponses]

export type GetFalAiImageAppsV2ExpressionChangeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/expression-change/requests/{request_id}'
}

export type GetFalAiImageAppsV2ExpressionChangeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageAppsV2ExpressionChangeOutput
}

export type GetFalAiImageAppsV2ExpressionChangeRequestsByRequestIdResponse =
  GetFalAiImageAppsV2ExpressionChangeRequestsByRequestIdResponses[keyof GetFalAiImageAppsV2ExpressionChangeRequestsByRequestIdResponses]

export type GetFalAiImageAppsV2CityTeleportRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-apps-v2/city-teleport/requests/{request_id}/status'
}

export type GetFalAiImageAppsV2CityTeleportRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageAppsV2CityTeleportRequestsByRequestIdStatusResponse =
  GetFalAiImageAppsV2CityTeleportRequestsByRequestIdStatusResponses[keyof GetFalAiImageAppsV2CityTeleportRequestsByRequestIdStatusResponses]

export type PutFalAiImageAppsV2CityTeleportRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/city-teleport/requests/{request_id}/cancel'
}

export type PutFalAiImageAppsV2CityTeleportRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageAppsV2CityTeleportRequestsByRequestIdCancelResponse =
  PutFalAiImageAppsV2CityTeleportRequestsByRequestIdCancelResponses[keyof PutFalAiImageAppsV2CityTeleportRequestsByRequestIdCancelResponses]

export type PostFalAiImageAppsV2CityTeleportData = {
  body: SchemaImageAppsV2CityTeleportInput
  path?: never
  query?: never
  url: '/fal-ai/image-apps-v2/city-teleport'
}

export type PostFalAiImageAppsV2CityTeleportResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageAppsV2CityTeleportResponse =
  PostFalAiImageAppsV2CityTeleportResponses[keyof PostFalAiImageAppsV2CityTeleportResponses]

export type GetFalAiImageAppsV2CityTeleportRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/city-teleport/requests/{request_id}'
}

export type GetFalAiImageAppsV2CityTeleportRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageAppsV2CityTeleportOutput
}

export type GetFalAiImageAppsV2CityTeleportRequestsByRequestIdResponse =
  GetFalAiImageAppsV2CityTeleportRequestsByRequestIdResponses[keyof GetFalAiImageAppsV2CityTeleportRequestsByRequestIdResponses]

export type GetFalAiImageAppsV2AgeModifyRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-apps-v2/age-modify/requests/{request_id}/status'
}

export type GetFalAiImageAppsV2AgeModifyRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImageAppsV2AgeModifyRequestsByRequestIdStatusResponse =
  GetFalAiImageAppsV2AgeModifyRequestsByRequestIdStatusResponses[keyof GetFalAiImageAppsV2AgeModifyRequestsByRequestIdStatusResponses]

export type PutFalAiImageAppsV2AgeModifyRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/age-modify/requests/{request_id}/cancel'
}

export type PutFalAiImageAppsV2AgeModifyRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImageAppsV2AgeModifyRequestsByRequestIdCancelResponse =
  PutFalAiImageAppsV2AgeModifyRequestsByRequestIdCancelResponses[keyof PutFalAiImageAppsV2AgeModifyRequestsByRequestIdCancelResponses]

export type PostFalAiImageAppsV2AgeModifyData = {
  body: SchemaImageAppsV2AgeModifyInput
  path?: never
  query?: never
  url: '/fal-ai/image-apps-v2/age-modify'
}

export type PostFalAiImageAppsV2AgeModifyResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageAppsV2AgeModifyResponse =
  PostFalAiImageAppsV2AgeModifyResponses[keyof PostFalAiImageAppsV2AgeModifyResponses]

export type GetFalAiImageAppsV2AgeModifyRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/age-modify/requests/{request_id}'
}

export type GetFalAiImageAppsV2AgeModifyRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageAppsV2AgeModifyOutput
}

export type GetFalAiImageAppsV2AgeModifyRequestsByRequestIdResponse =
  GetFalAiImageAppsV2AgeModifyRequestsByRequestIdResponses[keyof GetFalAiImageAppsV2AgeModifyRequestsByRequestIdResponses]

export type GetFalAiImageAppsV2MakeupApplicationRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/image-apps-v2/makeup-application/requests/{request_id}/status'
  }

export type GetFalAiImageAppsV2MakeupApplicationRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageAppsV2MakeupApplicationRequestsByRequestIdStatusResponse =
  GetFalAiImageAppsV2MakeupApplicationRequestsByRequestIdStatusResponses[keyof GetFalAiImageAppsV2MakeupApplicationRequestsByRequestIdStatusResponses]

export type PutFalAiImageAppsV2MakeupApplicationRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/image-apps-v2/makeup-application/requests/{request_id}/cancel'
  }

export type PutFalAiImageAppsV2MakeupApplicationRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageAppsV2MakeupApplicationRequestsByRequestIdCancelResponse =
  PutFalAiImageAppsV2MakeupApplicationRequestsByRequestIdCancelResponses[keyof PutFalAiImageAppsV2MakeupApplicationRequestsByRequestIdCancelResponses]

export type PostFalAiImageAppsV2MakeupApplicationData = {
  body: SchemaImageAppsV2MakeupApplicationInput
  path?: never
  query?: never
  url: '/fal-ai/image-apps-v2/makeup-application'
}

export type PostFalAiImageAppsV2MakeupApplicationResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageAppsV2MakeupApplicationResponse =
  PostFalAiImageAppsV2MakeupApplicationResponses[keyof PostFalAiImageAppsV2MakeupApplicationResponses]

export type GetFalAiImageAppsV2MakeupApplicationRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-apps-v2/makeup-application/requests/{request_id}'
}

export type GetFalAiImageAppsV2MakeupApplicationRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageAppsV2MakeupApplicationOutput
}

export type GetFalAiImageAppsV2MakeupApplicationRequestsByRequestIdResponse =
  GetFalAiImageAppsV2MakeupApplicationRequestsByRequestIdResponses[keyof GetFalAiImageAppsV2MakeupApplicationRequestsByRequestIdResponses]

export type GetFalAiQwenImageEditInpaintRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/qwen-image-edit/inpaint/requests/{request_id}/status'
}

export type GetFalAiQwenImageEditInpaintRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiQwenImageEditInpaintRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEditInpaintRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEditInpaintRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEditInpaintRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit/inpaint/requests/{request_id}/cancel'
}

export type PutFalAiQwenImageEditInpaintRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiQwenImageEditInpaintRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEditInpaintRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEditInpaintRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEditInpaintData = {
  body: SchemaQwenImageEditInpaintInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit/inpaint'
}

export type PostFalAiQwenImageEditInpaintResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEditInpaintResponse =
  PostFalAiQwenImageEditInpaintResponses[keyof PostFalAiQwenImageEditInpaintResponses]

export type GetFalAiQwenImageEditInpaintRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit/inpaint/requests/{request_id}'
}

export type GetFalAiQwenImageEditInpaintRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaQwenImageEditInpaintOutput
}

export type GetFalAiQwenImageEditInpaintRequestsByRequestIdResponse =
  GetFalAiQwenImageEditInpaintRequestsByRequestIdResponses[keyof GetFalAiQwenImageEditInpaintRequestsByRequestIdResponses]

export type GetFalAiFluxSrpoImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux/srpo/image-to-image/requests/{request_id}/status'
}

export type GetFalAiFluxSrpoImageToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxSrpoImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiFluxSrpoImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiFluxSrpoImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiFluxSrpoImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/srpo/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiFluxSrpoImageToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxSrpoImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiFluxSrpoImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiFluxSrpoImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiFluxSrpoImageToImageData = {
  body: SchemaFluxSrpoImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/flux/srpo/image-to-image'
}

export type PostFalAiFluxSrpoImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxSrpoImageToImageResponse =
  PostFalAiFluxSrpoImageToImageResponses[keyof PostFalAiFluxSrpoImageToImageResponses]

export type GetFalAiFluxSrpoImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/srpo/image-to-image/requests/{request_id}'
}

export type GetFalAiFluxSrpoImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxSrpoImageToImageOutput
}

export type GetFalAiFluxSrpoImageToImageRequestsByRequestIdResponse =
  GetFalAiFluxSrpoImageToImageRequestsByRequestIdResponses[keyof GetFalAiFluxSrpoImageToImageRequestsByRequestIdResponses]

export type GetFalAiFlux1SrpoImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-1/srpo/image-to-image/requests/{request_id}/status'
}

export type GetFalAiFlux1SrpoImageToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux1SrpoImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiFlux1SrpoImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiFlux1SrpoImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiFlux1SrpoImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/srpo/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiFlux1SrpoImageToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux1SrpoImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiFlux1SrpoImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiFlux1SrpoImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiFlux1SrpoImageToImageData = {
  body: SchemaFlux1SrpoImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/flux-1/srpo/image-to-image'
}

export type PostFalAiFlux1SrpoImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux1SrpoImageToImageResponse =
  PostFalAiFlux1SrpoImageToImageResponses[keyof PostFalAiFlux1SrpoImageToImageResponses]

export type GetFalAiFlux1SrpoImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/srpo/image-to-image/requests/{request_id}'
}

export type GetFalAiFlux1SrpoImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux1SrpoImageToImageOutput
}

export type GetFalAiFlux1SrpoImageToImageRequestsByRequestIdResponse =
  GetFalAiFlux1SrpoImageToImageRequestsByRequestIdResponses[keyof GetFalAiFlux1SrpoImageToImageRequestsByRequestIdResponses]

export type GetFalAiQwenImageEditLoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/qwen-image-edit-lora/requests/{request_id}/status'
}

export type GetFalAiQwenImageEditLoraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiQwenImageEditLoraRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEditLoraRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEditLoraRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEditLoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit-lora/requests/{request_id}/cancel'
}

export type PutFalAiQwenImageEditLoraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiQwenImageEditLoraRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEditLoraRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEditLoraRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEditLoraData = {
  body: SchemaQwenImageEditLoraInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit-lora'
}

export type PostFalAiQwenImageEditLoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEditLoraResponse =
  PostFalAiQwenImageEditLoraResponses[keyof PostFalAiQwenImageEditLoraResponses]

export type GetFalAiQwenImageEditLoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit-lora/requests/{request_id}'
}

export type GetFalAiQwenImageEditLoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaQwenImageEditLoraOutput
}

export type GetFalAiQwenImageEditLoraRequestsByRequestIdResponse =
  GetFalAiQwenImageEditLoraRequestsByRequestIdResponses[keyof GetFalAiQwenImageEditLoraRequestsByRequestIdResponses]

export type GetFalAiViduReferenceToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/vidu/reference-to-image/requests/{request_id}/status'
}

export type GetFalAiViduReferenceToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiViduReferenceToImageRequestsByRequestIdStatusResponse =
  GetFalAiViduReferenceToImageRequestsByRequestIdStatusResponses[keyof GetFalAiViduReferenceToImageRequestsByRequestIdStatusResponses]

export type PutFalAiViduReferenceToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/vidu/reference-to-image/requests/{request_id}/cancel'
}

export type PutFalAiViduReferenceToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiViduReferenceToImageRequestsByRequestIdCancelResponse =
  PutFalAiViduReferenceToImageRequestsByRequestIdCancelResponses[keyof PutFalAiViduReferenceToImageRequestsByRequestIdCancelResponses]

export type PostFalAiViduReferenceToImageData = {
  body: SchemaViduReferenceToImageInput
  path?: never
  query?: never
  url: '/fal-ai/vidu/reference-to-image'
}

export type PostFalAiViduReferenceToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiViduReferenceToImageResponse =
  PostFalAiViduReferenceToImageResponses[keyof PostFalAiViduReferenceToImageResponses]

export type GetFalAiViduReferenceToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/vidu/reference-to-image/requests/{request_id}'
}

export type GetFalAiViduReferenceToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaViduReferenceToImageOutput
}

export type GetFalAiViduReferenceToImageRequestsByRequestIdResponse =
  GetFalAiViduReferenceToImageRequestsByRequestIdResponses[keyof GetFalAiViduReferenceToImageRequestsByRequestIdResponses]

export type GetFalAiBytedanceSeedreamV4EditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/bytedance/seedream/v4/edit/requests/{request_id}/status'
}

export type GetFalAiBytedanceSeedreamV4EditRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiBytedanceSeedreamV4EditRequestsByRequestIdStatusResponse =
  GetFalAiBytedanceSeedreamV4EditRequestsByRequestIdStatusResponses[keyof GetFalAiBytedanceSeedreamV4EditRequestsByRequestIdStatusResponses]

export type PutFalAiBytedanceSeedreamV4EditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bytedance/seedream/v4/edit/requests/{request_id}/cancel'
}

export type PutFalAiBytedanceSeedreamV4EditRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiBytedanceSeedreamV4EditRequestsByRequestIdCancelResponse =
  PutFalAiBytedanceSeedreamV4EditRequestsByRequestIdCancelResponses[keyof PutFalAiBytedanceSeedreamV4EditRequestsByRequestIdCancelResponses]

export type PostFalAiBytedanceSeedreamV4EditData = {
  body: SchemaBytedanceSeedreamV4EditInput
  path?: never
  query?: never
  url: '/fal-ai/bytedance/seedream/v4/edit'
}

export type PostFalAiBytedanceSeedreamV4EditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBytedanceSeedreamV4EditResponse =
  PostFalAiBytedanceSeedreamV4EditResponses[keyof PostFalAiBytedanceSeedreamV4EditResponses]

export type GetFalAiBytedanceSeedreamV4EditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bytedance/seedream/v4/edit/requests/{request_id}'
}

export type GetFalAiBytedanceSeedreamV4EditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaBytedanceSeedreamV4EditOutput
}

export type GetFalAiBytedanceSeedreamV4EditRequestsByRequestIdResponse =
  GetFalAiBytedanceSeedreamV4EditRequestsByRequestIdResponses[keyof GetFalAiBytedanceSeedreamV4EditRequestsByRequestIdResponses]

export type GetFalAiWanV22A14bImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/wan/v2.2-a14b/image-to-image/requests/{request_id}/status'
}

export type GetFalAiWanV22A14bImageToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiWanV22A14bImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiWanV22A14bImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiWanV22A14bImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiWanV22A14bImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/wan/v2.2-a14b/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiWanV22A14bImageToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiWanV22A14bImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiWanV22A14bImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiWanV22A14bImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiWanV22A14bImageToImageData = {
  body: SchemaWanV22A14bImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/wan/v2.2-a14b/image-to-image'
}

export type PostFalAiWanV22A14bImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiWanV22A14bImageToImageResponse =
  PostFalAiWanV22A14bImageToImageResponses[keyof PostFalAiWanV22A14bImageToImageResponses]

export type GetFalAiWanV22A14bImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/wan/v2.2-a14b/image-to-image/requests/{request_id}'
}

export type GetFalAiWanV22A14bImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaWanV22A14bImageToImageOutput
}

export type GetFalAiWanV22A14bImageToImageRequestsByRequestIdResponse =
  GetFalAiWanV22A14bImageToImageRequestsByRequestIdResponses[keyof GetFalAiWanV22A14bImageToImageRequestsByRequestIdResponses]

export type GetFalAiUsoRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/uso/requests/{request_id}/status'
}

export type GetFalAiUsoRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiUsoRequestsByRequestIdStatusResponse =
  GetFalAiUsoRequestsByRequestIdStatusResponses[keyof GetFalAiUsoRequestsByRequestIdStatusResponses]

export type PutFalAiUsoRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/uso/requests/{request_id}/cancel'
}

export type PutFalAiUsoRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiUsoRequestsByRequestIdCancelResponse =
  PutFalAiUsoRequestsByRequestIdCancelResponses[keyof PutFalAiUsoRequestsByRequestIdCancelResponses]

export type PostFalAiUsoData = {
  body: SchemaUsoInput
  path?: never
  query?: never
  url: '/fal-ai/uso'
}

export type PostFalAiUsoResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiUsoResponse =
  PostFalAiUsoResponses[keyof PostFalAiUsoResponses]

export type GetFalAiUsoRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/uso/requests/{request_id}'
}

export type GetFalAiUsoRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaUsoOutput
}

export type GetFalAiUsoRequestsByRequestIdResponse =
  GetFalAiUsoRequestsByRequestIdResponses[keyof GetFalAiUsoRequestsByRequestIdResponses]

export type GetFalAiGemini25FlashImageEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/gemini-25-flash-image/edit/requests/{request_id}/status'
}

export type GetFalAiGemini25FlashImageEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiGemini25FlashImageEditRequestsByRequestIdStatusResponse =
  GetFalAiGemini25FlashImageEditRequestsByRequestIdStatusResponses[keyof GetFalAiGemini25FlashImageEditRequestsByRequestIdStatusResponses]

export type PutFalAiGemini25FlashImageEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gemini-25-flash-image/edit/requests/{request_id}/cancel'
}

export type PutFalAiGemini25FlashImageEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiGemini25FlashImageEditRequestsByRequestIdCancelResponse =
  PutFalAiGemini25FlashImageEditRequestsByRequestIdCancelResponses[keyof PutFalAiGemini25FlashImageEditRequestsByRequestIdCancelResponses]

export type PostFalAiGemini25FlashImageEditData = {
  body: SchemaGemini25FlashImageEditInput
  path?: never
  query?: never
  url: '/fal-ai/gemini-25-flash-image/edit'
}

export type PostFalAiGemini25FlashImageEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiGemini25FlashImageEditResponse =
  PostFalAiGemini25FlashImageEditResponses[keyof PostFalAiGemini25FlashImageEditResponses]

export type GetFalAiGemini25FlashImageEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gemini-25-flash-image/edit/requests/{request_id}'
}

export type GetFalAiGemini25FlashImageEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaGemini25FlashImageEditOutput
}

export type GetFalAiGemini25FlashImageEditRequestsByRequestIdResponse =
  GetFalAiGemini25FlashImageEditRequestsByRequestIdResponses[keyof GetFalAiGemini25FlashImageEditRequestsByRequestIdResponses]

export type GetFalAiQwenImageImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/qwen-image/image-to-image/requests/{request_id}/status'
}

export type GetFalAiQwenImageImageToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiQwenImageImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiQwenImageImageToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiQwenImageImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageImageToImageData = {
  body: SchemaQwenImageImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image/image-to-image'
}

export type PostFalAiQwenImageImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageImageToImageResponse =
  PostFalAiQwenImageImageToImageResponses[keyof PostFalAiQwenImageImageToImageResponses]

export type GetFalAiQwenImageImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image/image-to-image/requests/{request_id}'
}

export type GetFalAiQwenImageImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaQwenImageImageToImageOutput
}

export type GetFalAiQwenImageImageToImageRequestsByRequestIdResponse =
  GetFalAiQwenImageImageToImageRequestsByRequestIdResponses[keyof GetFalAiQwenImageImageToImageRequestsByRequestIdResponses]

export type GetBriaReimagine32RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/bria/reimagine/3.2/requests/{request_id}/status'
}

export type GetBriaReimagine32RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetBriaReimagine32RequestsByRequestIdStatusResponse =
  GetBriaReimagine32RequestsByRequestIdStatusResponses[keyof GetBriaReimagine32RequestsByRequestIdStatusResponses]

export type PutBriaReimagine32RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/reimagine/3.2/requests/{request_id}/cancel'
}

export type PutBriaReimagine32RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutBriaReimagine32RequestsByRequestIdCancelResponse =
  PutBriaReimagine32RequestsByRequestIdCancelResponses[keyof PutBriaReimagine32RequestsByRequestIdCancelResponses]

export type PostBriaReimagine32Data = {
  body: SchemaReimagine32Input
  path?: never
  query?: never
  url: '/bria/reimagine/3.2'
}

export type PostBriaReimagine32Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostBriaReimagine32Response =
  PostBriaReimagine32Responses[keyof PostBriaReimagine32Responses]

export type GetBriaReimagine32RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/reimagine/3.2/requests/{request_id}'
}

export type GetBriaReimagine32RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaReimagine32Output
}

export type GetBriaReimagine32RequestsByRequestIdResponse =
  GetBriaReimagine32RequestsByRequestIdResponses[keyof GetBriaReimagine32RequestsByRequestIdResponses]

export type GetFalAiNanoBananaEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/nano-banana/edit/requests/{request_id}/status'
}

export type GetFalAiNanoBananaEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiNanoBananaEditRequestsByRequestIdStatusResponse =
  GetFalAiNanoBananaEditRequestsByRequestIdStatusResponses[keyof GetFalAiNanoBananaEditRequestsByRequestIdStatusResponses]

export type PutFalAiNanoBananaEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/nano-banana/edit/requests/{request_id}/cancel'
}

export type PutFalAiNanoBananaEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiNanoBananaEditRequestsByRequestIdCancelResponse =
  PutFalAiNanoBananaEditRequestsByRequestIdCancelResponses[keyof PutFalAiNanoBananaEditRequestsByRequestIdCancelResponses]

export type PostFalAiNanoBananaEditData = {
  body: SchemaNanoBananaEditInput
  path?: never
  query?: never
  url: '/fal-ai/nano-banana/edit'
}

export type PostFalAiNanoBananaEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiNanoBananaEditResponse =
  PostFalAiNanoBananaEditResponses[keyof PostFalAiNanoBananaEditResponses]

export type GetFalAiNanoBananaEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/nano-banana/edit/requests/{request_id}'
}

export type GetFalAiNanoBananaEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaNanoBananaEditOutput
}

export type GetFalAiNanoBananaEditRequestsByRequestIdResponse =
  GetFalAiNanoBananaEditRequestsByRequestIdResponses[keyof GetFalAiNanoBananaEditRequestsByRequestIdResponses]

export type GetFalAiNextstep1RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/nextstep-1/requests/{request_id}/status'
}

export type GetFalAiNextstep1RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiNextstep1RequestsByRequestIdStatusResponse =
  GetFalAiNextstep1RequestsByRequestIdStatusResponses[keyof GetFalAiNextstep1RequestsByRequestIdStatusResponses]

export type PutFalAiNextstep1RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/nextstep-1/requests/{request_id}/cancel'
}

export type PutFalAiNextstep1RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiNextstep1RequestsByRequestIdCancelResponse =
  PutFalAiNextstep1RequestsByRequestIdCancelResponses[keyof PutFalAiNextstep1RequestsByRequestIdCancelResponses]

export type PostFalAiNextstep1Data = {
  body: SchemaNextstep1Input
  path?: never
  query?: never
  url: '/fal-ai/nextstep-1'
}

export type PostFalAiNextstep1Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiNextstep1Response =
  PostFalAiNextstep1Responses[keyof PostFalAiNextstep1Responses]

export type GetFalAiNextstep1RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/nextstep-1/requests/{request_id}'
}

export type GetFalAiNextstep1RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaNextstep1Output
}

export type GetFalAiNextstep1RequestsByRequestIdResponse =
  GetFalAiNextstep1RequestsByRequestIdResponses[keyof GetFalAiNextstep1RequestsByRequestIdResponses]

export type GetFalAiQwenImageEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/qwen-image-edit/requests/{request_id}/status'
}

export type GetFalAiQwenImageEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiQwenImageEditRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageEditRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageEditRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit/requests/{request_id}/cancel'
}

export type PutFalAiQwenImageEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiQwenImageEditRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageEditRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageEditRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageEditData = {
  body: SchemaQwenImageEditInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-edit'
}

export type PostFalAiQwenImageEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageEditResponse =
  PostFalAiQwenImageEditResponses[keyof PostFalAiQwenImageEditResponses]

export type GetFalAiQwenImageEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-edit/requests/{request_id}'
}

export type GetFalAiQwenImageEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaQwenImageEditOutput
}

export type GetFalAiQwenImageEditRequestsByRequestIdResponse =
  GetFalAiQwenImageEditRequestsByRequestIdResponses[keyof GetFalAiQwenImageEditRequestsByRequestIdResponses]

export type GetFalAiIdeogramCharacterEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ideogram/character/edit/requests/{request_id}/status'
}

export type GetFalAiIdeogramCharacterEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIdeogramCharacterEditRequestsByRequestIdStatusResponse =
  GetFalAiIdeogramCharacterEditRequestsByRequestIdStatusResponses[keyof GetFalAiIdeogramCharacterEditRequestsByRequestIdStatusResponses]

export type PutFalAiIdeogramCharacterEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/character/edit/requests/{request_id}/cancel'
}

export type PutFalAiIdeogramCharacterEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIdeogramCharacterEditRequestsByRequestIdCancelResponse =
  PutFalAiIdeogramCharacterEditRequestsByRequestIdCancelResponses[keyof PutFalAiIdeogramCharacterEditRequestsByRequestIdCancelResponses]

export type PostFalAiIdeogramCharacterEditData = {
  body: SchemaIdeogramCharacterEditInput
  path?: never
  query?: never
  url: '/fal-ai/ideogram/character/edit'
}

export type PostFalAiIdeogramCharacterEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIdeogramCharacterEditResponse =
  PostFalAiIdeogramCharacterEditResponses[keyof PostFalAiIdeogramCharacterEditResponses]

export type GetFalAiIdeogramCharacterEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/character/edit/requests/{request_id}'
}

export type GetFalAiIdeogramCharacterEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIdeogramCharacterEditOutput
}

export type GetFalAiIdeogramCharacterEditRequestsByRequestIdResponse =
  GetFalAiIdeogramCharacterEditRequestsByRequestIdResponses[keyof GetFalAiIdeogramCharacterEditRequestsByRequestIdResponses]

export type GetFalAiIdeogramCharacterRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ideogram/character/requests/{request_id}/status'
}

export type GetFalAiIdeogramCharacterRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIdeogramCharacterRequestsByRequestIdStatusResponse =
  GetFalAiIdeogramCharacterRequestsByRequestIdStatusResponses[keyof GetFalAiIdeogramCharacterRequestsByRequestIdStatusResponses]

export type PutFalAiIdeogramCharacterRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/character/requests/{request_id}/cancel'
}

export type PutFalAiIdeogramCharacterRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIdeogramCharacterRequestsByRequestIdCancelResponse =
  PutFalAiIdeogramCharacterRequestsByRequestIdCancelResponses[keyof PutFalAiIdeogramCharacterRequestsByRequestIdCancelResponses]

export type PostFalAiIdeogramCharacterData = {
  body: SchemaIdeogramCharacterInput
  path?: never
  query?: never
  url: '/fal-ai/ideogram/character'
}

export type PostFalAiIdeogramCharacterResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIdeogramCharacterResponse =
  PostFalAiIdeogramCharacterResponses[keyof PostFalAiIdeogramCharacterResponses]

export type GetFalAiIdeogramCharacterRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/character/requests/{request_id}'
}

export type GetFalAiIdeogramCharacterRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIdeogramCharacterOutput
}

export type GetFalAiIdeogramCharacterRequestsByRequestIdResponse =
  GetFalAiIdeogramCharacterRequestsByRequestIdResponses[keyof GetFalAiIdeogramCharacterRequestsByRequestIdResponses]

export type GetFalAiIdeogramCharacterRemixRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ideogram/character/remix/requests/{request_id}/status'
}

export type GetFalAiIdeogramCharacterRemixRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIdeogramCharacterRemixRequestsByRequestIdStatusResponse =
  GetFalAiIdeogramCharacterRemixRequestsByRequestIdStatusResponses[keyof GetFalAiIdeogramCharacterRemixRequestsByRequestIdStatusResponses]

export type PutFalAiIdeogramCharacterRemixRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/character/remix/requests/{request_id}/cancel'
}

export type PutFalAiIdeogramCharacterRemixRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIdeogramCharacterRemixRequestsByRequestIdCancelResponse =
  PutFalAiIdeogramCharacterRemixRequestsByRequestIdCancelResponses[keyof PutFalAiIdeogramCharacterRemixRequestsByRequestIdCancelResponses]

export type PostFalAiIdeogramCharacterRemixData = {
  body: SchemaIdeogramCharacterRemixInput
  path?: never
  query?: never
  url: '/fal-ai/ideogram/character/remix'
}

export type PostFalAiIdeogramCharacterRemixResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIdeogramCharacterRemixResponse =
  PostFalAiIdeogramCharacterRemixResponses[keyof PostFalAiIdeogramCharacterRemixResponses]

export type GetFalAiIdeogramCharacterRemixRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/character/remix/requests/{request_id}'
}

export type GetFalAiIdeogramCharacterRemixRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIdeogramCharacterRemixOutput
}

export type GetFalAiIdeogramCharacterRemixRequestsByRequestIdResponse =
  GetFalAiIdeogramCharacterRemixRequestsByRequestIdResponses[keyof GetFalAiIdeogramCharacterRemixRequestsByRequestIdResponses]

export type GetFalAiFluxKreaLoraInpaintingRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-krea-lora/inpainting/requests/{request_id}/status'
}

export type GetFalAiFluxKreaLoraInpaintingRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxKreaLoraInpaintingRequestsByRequestIdStatusResponse =
  GetFalAiFluxKreaLoraInpaintingRequestsByRequestIdStatusResponses[keyof GetFalAiFluxKreaLoraInpaintingRequestsByRequestIdStatusResponses]

export type PutFalAiFluxKreaLoraInpaintingRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-krea-lora/inpainting/requests/{request_id}/cancel'
}

export type PutFalAiFluxKreaLoraInpaintingRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxKreaLoraInpaintingRequestsByRequestIdCancelResponse =
  PutFalAiFluxKreaLoraInpaintingRequestsByRequestIdCancelResponses[keyof PutFalAiFluxKreaLoraInpaintingRequestsByRequestIdCancelResponses]

export type PostFalAiFluxKreaLoraInpaintingData = {
  body: SchemaFluxKreaLoraInpaintingInput
  path?: never
  query?: never
  url: '/fal-ai/flux-krea-lora/inpainting'
}

export type PostFalAiFluxKreaLoraInpaintingResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxKreaLoraInpaintingResponse =
  PostFalAiFluxKreaLoraInpaintingResponses[keyof PostFalAiFluxKreaLoraInpaintingResponses]

export type GetFalAiFluxKreaLoraInpaintingRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-krea-lora/inpainting/requests/{request_id}'
}

export type GetFalAiFluxKreaLoraInpaintingRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxKreaLoraInpaintingOutput
}

export type GetFalAiFluxKreaLoraInpaintingRequestsByRequestIdResponse =
  GetFalAiFluxKreaLoraInpaintingRequestsByRequestIdResponses[keyof GetFalAiFluxKreaLoraInpaintingRequestsByRequestIdResponses]

export type GetFalAiFluxKreaLoraImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-krea-lora/image-to-image/requests/{request_id}/status'
}

export type GetFalAiFluxKreaLoraImageToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFluxKreaLoraImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiFluxKreaLoraImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiFluxKreaLoraImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiFluxKreaLoraImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-krea-lora/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiFluxKreaLoraImageToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFluxKreaLoraImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiFluxKreaLoraImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiFluxKreaLoraImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiFluxKreaLoraImageToImageData = {
  body: SchemaFluxKreaLoraImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/flux-krea-lora/image-to-image'
}

export type PostFalAiFluxKreaLoraImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxKreaLoraImageToImageResponse =
  PostFalAiFluxKreaLoraImageToImageResponses[keyof PostFalAiFluxKreaLoraImageToImageResponses]

export type GetFalAiFluxKreaLoraImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-krea-lora/image-to-image/requests/{request_id}'
}

export type GetFalAiFluxKreaLoraImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxKreaLoraImageToImageOutput
}

export type GetFalAiFluxKreaLoraImageToImageRequestsByRequestIdResponse =
  GetFalAiFluxKreaLoraImageToImageRequestsByRequestIdResponses[keyof GetFalAiFluxKreaLoraImageToImageRequestsByRequestIdResponses]

export type GetFalAiFluxKreaImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux/krea/image-to-image/requests/{request_id}/status'
}

export type GetFalAiFluxKreaImageToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxKreaImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiFluxKreaImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiFluxKreaImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiFluxKreaImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/krea/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiFluxKreaImageToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxKreaImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiFluxKreaImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiFluxKreaImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiFluxKreaImageToImageData = {
  body: SchemaFluxKreaImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/flux/krea/image-to-image'
}

export type PostFalAiFluxKreaImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxKreaImageToImageResponse =
  PostFalAiFluxKreaImageToImageResponses[keyof PostFalAiFluxKreaImageToImageResponses]

export type GetFalAiFluxKreaImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/krea/image-to-image/requests/{request_id}'
}

export type GetFalAiFluxKreaImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxKreaImageToImageOutput
}

export type GetFalAiFluxKreaImageToImageRequestsByRequestIdResponse =
  GetFalAiFluxKreaImageToImageRequestsByRequestIdResponses[keyof GetFalAiFluxKreaImageToImageRequestsByRequestIdResponses]

export type GetFalAiFluxKreaReduxRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux/krea/redux/requests/{request_id}/status'
}

export type GetFalAiFluxKreaReduxRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxKreaReduxRequestsByRequestIdStatusResponse =
  GetFalAiFluxKreaReduxRequestsByRequestIdStatusResponses[keyof GetFalAiFluxKreaReduxRequestsByRequestIdStatusResponses]

export type PutFalAiFluxKreaReduxRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/krea/redux/requests/{request_id}/cancel'
}

export type PutFalAiFluxKreaReduxRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxKreaReduxRequestsByRequestIdCancelResponse =
  PutFalAiFluxKreaReduxRequestsByRequestIdCancelResponses[keyof PutFalAiFluxKreaReduxRequestsByRequestIdCancelResponses]

export type PostFalAiFluxKreaReduxData = {
  body: SchemaFluxKreaReduxInput
  path?: never
  query?: never
  url: '/fal-ai/flux/krea/redux'
}

export type PostFalAiFluxKreaReduxResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxKreaReduxResponse =
  PostFalAiFluxKreaReduxResponses[keyof PostFalAiFluxKreaReduxResponses]

export type GetFalAiFluxKreaReduxRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/krea/redux/requests/{request_id}'
}

export type GetFalAiFluxKreaReduxRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxKreaReduxOutput
}

export type GetFalAiFluxKreaReduxRequestsByRequestIdResponse =
  GetFalAiFluxKreaReduxRequestsByRequestIdResponses[keyof GetFalAiFluxKreaReduxRequestsByRequestIdResponses]

export type GetFalAiFlux1KreaImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-1/krea/image-to-image/requests/{request_id}/status'
}

export type GetFalAiFlux1KreaImageToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux1KreaImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiFlux1KreaImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiFlux1KreaImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiFlux1KreaImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/krea/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiFlux1KreaImageToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux1KreaImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiFlux1KreaImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiFlux1KreaImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiFlux1KreaImageToImageData = {
  body: SchemaFlux1KreaImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/flux-1/krea/image-to-image'
}

export type PostFalAiFlux1KreaImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux1KreaImageToImageResponse =
  PostFalAiFlux1KreaImageToImageResponses[keyof PostFalAiFlux1KreaImageToImageResponses]

export type GetFalAiFlux1KreaImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/krea/image-to-image/requests/{request_id}'
}

export type GetFalAiFlux1KreaImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux1KreaImageToImageOutput
}

export type GetFalAiFlux1KreaImageToImageRequestsByRequestIdResponse =
  GetFalAiFlux1KreaImageToImageRequestsByRequestIdResponses[keyof GetFalAiFlux1KreaImageToImageRequestsByRequestIdResponses]

export type GetFalAiFlux1KreaReduxRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-1/krea/redux/requests/{request_id}/status'
}

export type GetFalAiFlux1KreaReduxRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux1KreaReduxRequestsByRequestIdStatusResponse =
  GetFalAiFlux1KreaReduxRequestsByRequestIdStatusResponses[keyof GetFalAiFlux1KreaReduxRequestsByRequestIdStatusResponses]

export type PutFalAiFlux1KreaReduxRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/krea/redux/requests/{request_id}/cancel'
}

export type PutFalAiFlux1KreaReduxRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux1KreaReduxRequestsByRequestIdCancelResponse =
  PutFalAiFlux1KreaReduxRequestsByRequestIdCancelResponses[keyof PutFalAiFlux1KreaReduxRequestsByRequestIdCancelResponses]

export type PostFalAiFlux1KreaReduxData = {
  body: SchemaFlux1KreaReduxInput
  path?: never
  query?: never
  url: '/fal-ai/flux-1/krea/redux'
}

export type PostFalAiFlux1KreaReduxResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux1KreaReduxResponse =
  PostFalAiFlux1KreaReduxResponses[keyof PostFalAiFlux1KreaReduxResponses]

export type GetFalAiFlux1KreaReduxRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/krea/redux/requests/{request_id}'
}

export type GetFalAiFlux1KreaReduxRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux1KreaReduxOutput
}

export type GetFalAiFlux1KreaReduxRequestsByRequestIdResponse =
  GetFalAiFlux1KreaReduxRequestsByRequestIdResponses[keyof GetFalAiFlux1KreaReduxRequestsByRequestIdResponses]

export type GetFalAiFluxKontextLoraInpaintRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-kontext-lora/inpaint/requests/{request_id}/status'
}

export type GetFalAiFluxKontextLoraInpaintRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxKontextLoraInpaintRequestsByRequestIdStatusResponse =
  GetFalAiFluxKontextLoraInpaintRequestsByRequestIdStatusResponses[keyof GetFalAiFluxKontextLoraInpaintRequestsByRequestIdStatusResponses]

export type PutFalAiFluxKontextLoraInpaintRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-kontext-lora/inpaint/requests/{request_id}/cancel'
}

export type PutFalAiFluxKontextLoraInpaintRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxKontextLoraInpaintRequestsByRequestIdCancelResponse =
  PutFalAiFluxKontextLoraInpaintRequestsByRequestIdCancelResponses[keyof PutFalAiFluxKontextLoraInpaintRequestsByRequestIdCancelResponses]

export type PostFalAiFluxKontextLoraInpaintData = {
  body: SchemaFluxKontextLoraInpaintInput
  path?: never
  query?: never
  url: '/fal-ai/flux-kontext-lora/inpaint'
}

export type PostFalAiFluxKontextLoraInpaintResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxKontextLoraInpaintResponse =
  PostFalAiFluxKontextLoraInpaintResponses[keyof PostFalAiFluxKontextLoraInpaintResponses]

export type GetFalAiFluxKontextLoraInpaintRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-kontext-lora/inpaint/requests/{request_id}'
}

export type GetFalAiFluxKontextLoraInpaintRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxKontextLoraInpaintOutput
}

export type GetFalAiFluxKontextLoraInpaintRequestsByRequestIdResponse =
  GetFalAiFluxKontextLoraInpaintRequestsByRequestIdResponses[keyof GetFalAiFluxKontextLoraInpaintRequestsByRequestIdResponses]

export type GetFalAiHunyuanWorldRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/hunyuan_world/requests/{request_id}/status'
}

export type GetFalAiHunyuanWorldRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiHunyuanWorldRequestsByRequestIdStatusResponse =
  GetFalAiHunyuanWorldRequestsByRequestIdStatusResponses[keyof GetFalAiHunyuanWorldRequestsByRequestIdStatusResponses]

export type PutFalAiHunyuanWorldRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/hunyuan_world/requests/{request_id}/cancel'
}

export type PutFalAiHunyuanWorldRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiHunyuanWorldRequestsByRequestIdCancelResponse =
  PutFalAiHunyuanWorldRequestsByRequestIdCancelResponses[keyof PutFalAiHunyuanWorldRequestsByRequestIdCancelResponses]

export type PostFalAiHunyuanWorldData = {
  body: SchemaHunyuanWorldInput
  path?: never
  query?: never
  url: '/fal-ai/hunyuan_world'
}

export type PostFalAiHunyuanWorldResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiHunyuanWorldResponse =
  PostFalAiHunyuanWorldResponses[keyof PostFalAiHunyuanWorldResponses]

export type GetFalAiHunyuanWorldRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/hunyuan_world/requests/{request_id}'
}

export type GetFalAiHunyuanWorldRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaHunyuanWorldOutput
}

export type GetFalAiHunyuanWorldRequestsByRequestIdResponse =
  GetFalAiHunyuanWorldRequestsByRequestIdResponses[keyof GetFalAiHunyuanWorldRequestsByRequestIdResponses]

export type GetFalAiImageEditingRetouchRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-editing/retouch/requests/{request_id}/status'
}

export type GetFalAiImageEditingRetouchRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImageEditingRetouchRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingRetouchRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingRetouchRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingRetouchRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/retouch/requests/{request_id}/cancel'
}

export type PutFalAiImageEditingRetouchRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImageEditingRetouchRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingRetouchRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingRetouchRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingRetouchData = {
  body: SchemaImageEditingRetouchInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/retouch'
}

export type PostFalAiImageEditingRetouchResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingRetouchResponse =
  PostFalAiImageEditingRetouchResponses[keyof PostFalAiImageEditingRetouchResponses]

export type GetFalAiImageEditingRetouchRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/retouch/requests/{request_id}'
}

export type GetFalAiImageEditingRetouchRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingRetouchOutput
}

export type GetFalAiImageEditingRetouchRequestsByRequestIdResponse =
  GetFalAiImageEditingRetouchRequestsByRequestIdResponses[keyof GetFalAiImageEditingRetouchRequestsByRequestIdResponses]

export type GetFalAiHidreamE11RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/hidream-e1-1/requests/{request_id}/status'
}

export type GetFalAiHidreamE11RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiHidreamE11RequestsByRequestIdStatusResponse =
  GetFalAiHidreamE11RequestsByRequestIdStatusResponses[keyof GetFalAiHidreamE11RequestsByRequestIdStatusResponses]

export type PutFalAiHidreamE11RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/hidream-e1-1/requests/{request_id}/cancel'
}

export type PutFalAiHidreamE11RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiHidreamE11RequestsByRequestIdCancelResponse =
  PutFalAiHidreamE11RequestsByRequestIdCancelResponses[keyof PutFalAiHidreamE11RequestsByRequestIdCancelResponses]

export type PostFalAiHidreamE11Data = {
  body: SchemaHidreamE11Input
  path?: never
  query?: never
  url: '/fal-ai/hidream-e1-1'
}

export type PostFalAiHidreamE11Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiHidreamE11Response =
  PostFalAiHidreamE11Responses[keyof PostFalAiHidreamE11Responses]

export type GetFalAiHidreamE11RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/hidream-e1-1/requests/{request_id}'
}

export type GetFalAiHidreamE11RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaHidreamE11Output
}

export type GetFalAiHidreamE11RequestsByRequestIdResponse =
  GetFalAiHidreamE11RequestsByRequestIdResponses[keyof GetFalAiHidreamE11RequestsByRequestIdResponses]

export type GetFalAiRifeRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/rife/requests/{request_id}/status'
}

export type GetFalAiRifeRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiRifeRequestsByRequestIdStatusResponse =
  GetFalAiRifeRequestsByRequestIdStatusResponses[keyof GetFalAiRifeRequestsByRequestIdStatusResponses]

export type PutFalAiRifeRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/rife/requests/{request_id}/cancel'
}

export type PutFalAiRifeRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiRifeRequestsByRequestIdCancelResponse =
  PutFalAiRifeRequestsByRequestIdCancelResponses[keyof PutFalAiRifeRequestsByRequestIdCancelResponses]

export type PostFalAiRifeData = {
  body: SchemaRifeInput
  path?: never
  query?: never
  url: '/fal-ai/rife'
}

export type PostFalAiRifeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiRifeResponse =
  PostFalAiRifeResponses[keyof PostFalAiRifeResponses]

export type GetFalAiRifeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/rife/requests/{request_id}'
}

export type GetFalAiRifeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaRifeOutput
}

export type GetFalAiRifeRequestsByRequestIdResponse =
  GetFalAiRifeRequestsByRequestIdResponses[keyof GetFalAiRifeRequestsByRequestIdResponses]

export type GetFalAiFilmRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/film/requests/{request_id}/status'
}

export type GetFalAiFilmRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFilmRequestsByRequestIdStatusResponse =
  GetFalAiFilmRequestsByRequestIdStatusResponses[keyof GetFalAiFilmRequestsByRequestIdStatusResponses]

export type PutFalAiFilmRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/film/requests/{request_id}/cancel'
}

export type PutFalAiFilmRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFilmRequestsByRequestIdCancelResponse =
  PutFalAiFilmRequestsByRequestIdCancelResponses[keyof PutFalAiFilmRequestsByRequestIdCancelResponses]

export type PostFalAiFilmData = {
  body: SchemaFilmInput
  path?: never
  query?: never
  url: '/fal-ai/film'
}

export type PostFalAiFilmResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFilmResponse =
  PostFalAiFilmResponses[keyof PostFalAiFilmResponses]

export type GetFalAiFilmRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/film/requests/{request_id}'
}

export type GetFalAiFilmRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFilmOutput
}

export type GetFalAiFilmRequestsByRequestIdResponse =
  GetFalAiFilmRequestsByRequestIdResponses[keyof GetFalAiFilmRequestsByRequestIdResponses]

export type GetFalAiCalligrapherRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/calligrapher/requests/{request_id}/status'
}

export type GetFalAiCalligrapherRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiCalligrapherRequestsByRequestIdStatusResponse =
  GetFalAiCalligrapherRequestsByRequestIdStatusResponses[keyof GetFalAiCalligrapherRequestsByRequestIdStatusResponses]

export type PutFalAiCalligrapherRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/calligrapher/requests/{request_id}/cancel'
}

export type PutFalAiCalligrapherRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiCalligrapherRequestsByRequestIdCancelResponse =
  PutFalAiCalligrapherRequestsByRequestIdCancelResponses[keyof PutFalAiCalligrapherRequestsByRequestIdCancelResponses]

export type PostFalAiCalligrapherData = {
  body: SchemaCalligrapherInput
  path?: never
  query?: never
  url: '/fal-ai/calligrapher'
}

export type PostFalAiCalligrapherResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiCalligrapherResponse =
  PostFalAiCalligrapherResponses[keyof PostFalAiCalligrapherResponses]

export type GetFalAiCalligrapherRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/calligrapher/requests/{request_id}'
}

export type GetFalAiCalligrapherRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaCalligrapherOutput
}

export type GetFalAiCalligrapherRequestsByRequestIdResponse =
  GetFalAiCalligrapherRequestsByRequestIdResponses[keyof GetFalAiCalligrapherRequestsByRequestIdResponses]

export type GetFalAiBriaReimagineRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/bria/reimagine/requests/{request_id}/status'
}

export type GetFalAiBriaReimagineRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiBriaReimagineRequestsByRequestIdStatusResponse =
  GetFalAiBriaReimagineRequestsByRequestIdStatusResponses[keyof GetFalAiBriaReimagineRequestsByRequestIdStatusResponses]

export type PutFalAiBriaReimagineRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/reimagine/requests/{request_id}/cancel'
}

export type PutFalAiBriaReimagineRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiBriaReimagineRequestsByRequestIdCancelResponse =
  PutFalAiBriaReimagineRequestsByRequestIdCancelResponses[keyof PutFalAiBriaReimagineRequestsByRequestIdCancelResponses]

export type PostFalAiBriaReimagineData = {
  body: SchemaBriaReimagineInput
  path?: never
  query?: never
  url: '/fal-ai/bria/reimagine'
}

export type PostFalAiBriaReimagineResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBriaReimagineResponse =
  PostFalAiBriaReimagineResponses[keyof PostFalAiBriaReimagineResponses]

export type GetFalAiBriaReimagineRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/reimagine/requests/{request_id}'
}

export type GetFalAiBriaReimagineRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaBriaReimagineOutput
}

export type GetFalAiBriaReimagineRequestsByRequestIdResponse =
  GetFalAiBriaReimagineRequestsByRequestIdResponses[keyof GetFalAiBriaReimagineRequestsByRequestIdResponses]

export type GetFalAiImageEditingRealismRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-editing/realism/requests/{request_id}/status'
}

export type GetFalAiImageEditingRealismRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImageEditingRealismRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingRealismRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingRealismRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingRealismRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/realism/requests/{request_id}/cancel'
}

export type PutFalAiImageEditingRealismRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImageEditingRealismRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingRealismRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingRealismRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingRealismData = {
  body: SchemaImageEditingRealismInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/realism'
}

export type PostFalAiImageEditingRealismResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingRealismResponse =
  PostFalAiImageEditingRealismResponses[keyof PostFalAiImageEditingRealismResponses]

export type GetFalAiImageEditingRealismRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/realism/requests/{request_id}'
}

export type GetFalAiImageEditingRealismRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingRealismOutput
}

export type GetFalAiImageEditingRealismRequestsByRequestIdResponse =
  GetFalAiImageEditingRealismRequestsByRequestIdResponses[keyof GetFalAiImageEditingRealismRequestsByRequestIdResponses]

export type GetFalAiPostProcessingVignetteRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/post-processing/vignette/requests/{request_id}/status'
}

export type GetFalAiPostProcessingVignetteRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiPostProcessingVignetteRequestsByRequestIdStatusResponse =
  GetFalAiPostProcessingVignetteRequestsByRequestIdStatusResponses[keyof GetFalAiPostProcessingVignetteRequestsByRequestIdStatusResponses]

export type PutFalAiPostProcessingVignetteRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/vignette/requests/{request_id}/cancel'
}

export type PutFalAiPostProcessingVignetteRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiPostProcessingVignetteRequestsByRequestIdCancelResponse =
  PutFalAiPostProcessingVignetteRequestsByRequestIdCancelResponses[keyof PutFalAiPostProcessingVignetteRequestsByRequestIdCancelResponses]

export type PostFalAiPostProcessingVignetteData = {
  body: SchemaPostProcessingVignetteInput
  path?: never
  query?: never
  url: '/fal-ai/post-processing/vignette'
}

export type PostFalAiPostProcessingVignetteResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPostProcessingVignetteResponse =
  PostFalAiPostProcessingVignetteResponses[keyof PostFalAiPostProcessingVignetteResponses]

export type GetFalAiPostProcessingVignetteRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/vignette/requests/{request_id}'
}

export type GetFalAiPostProcessingVignetteRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPostProcessingVignetteOutput
}

export type GetFalAiPostProcessingVignetteRequestsByRequestIdResponse =
  GetFalAiPostProcessingVignetteRequestsByRequestIdResponses[keyof GetFalAiPostProcessingVignetteRequestsByRequestIdResponses]

export type GetFalAiPostProcessingSolarizeRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/post-processing/solarize/requests/{request_id}/status'
}

export type GetFalAiPostProcessingSolarizeRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiPostProcessingSolarizeRequestsByRequestIdStatusResponse =
  GetFalAiPostProcessingSolarizeRequestsByRequestIdStatusResponses[keyof GetFalAiPostProcessingSolarizeRequestsByRequestIdStatusResponses]

export type PutFalAiPostProcessingSolarizeRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/solarize/requests/{request_id}/cancel'
}

export type PutFalAiPostProcessingSolarizeRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiPostProcessingSolarizeRequestsByRequestIdCancelResponse =
  PutFalAiPostProcessingSolarizeRequestsByRequestIdCancelResponses[keyof PutFalAiPostProcessingSolarizeRequestsByRequestIdCancelResponses]

export type PostFalAiPostProcessingSolarizeData = {
  body: SchemaPostProcessingSolarizeInput
  path?: never
  query?: never
  url: '/fal-ai/post-processing/solarize'
}

export type PostFalAiPostProcessingSolarizeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPostProcessingSolarizeResponse =
  PostFalAiPostProcessingSolarizeResponses[keyof PostFalAiPostProcessingSolarizeResponses]

export type GetFalAiPostProcessingSolarizeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/solarize/requests/{request_id}'
}

export type GetFalAiPostProcessingSolarizeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPostProcessingSolarizeOutput
}

export type GetFalAiPostProcessingSolarizeRequestsByRequestIdResponse =
  GetFalAiPostProcessingSolarizeRequestsByRequestIdResponses[keyof GetFalAiPostProcessingSolarizeRequestsByRequestIdResponses]

export type GetFalAiPostProcessingSharpenRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/post-processing/sharpen/requests/{request_id}/status'
}

export type GetFalAiPostProcessingSharpenRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiPostProcessingSharpenRequestsByRequestIdStatusResponse =
  GetFalAiPostProcessingSharpenRequestsByRequestIdStatusResponses[keyof GetFalAiPostProcessingSharpenRequestsByRequestIdStatusResponses]

export type PutFalAiPostProcessingSharpenRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/sharpen/requests/{request_id}/cancel'
}

export type PutFalAiPostProcessingSharpenRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiPostProcessingSharpenRequestsByRequestIdCancelResponse =
  PutFalAiPostProcessingSharpenRequestsByRequestIdCancelResponses[keyof PutFalAiPostProcessingSharpenRequestsByRequestIdCancelResponses]

export type PostFalAiPostProcessingSharpenData = {
  body: SchemaPostProcessingSharpenInput
  path?: never
  query?: never
  url: '/fal-ai/post-processing/sharpen'
}

export type PostFalAiPostProcessingSharpenResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPostProcessingSharpenResponse =
  PostFalAiPostProcessingSharpenResponses[keyof PostFalAiPostProcessingSharpenResponses]

export type GetFalAiPostProcessingSharpenRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/sharpen/requests/{request_id}'
}

export type GetFalAiPostProcessingSharpenRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPostProcessingSharpenOutput
}

export type GetFalAiPostProcessingSharpenRequestsByRequestIdResponse =
  GetFalAiPostProcessingSharpenRequestsByRequestIdResponses[keyof GetFalAiPostProcessingSharpenRequestsByRequestIdResponses]

export type GetFalAiPostProcessingParabolizeRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/post-processing/parabolize/requests/{request_id}/status'
}

export type GetFalAiPostProcessingParabolizeRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiPostProcessingParabolizeRequestsByRequestIdStatusResponse =
  GetFalAiPostProcessingParabolizeRequestsByRequestIdStatusResponses[keyof GetFalAiPostProcessingParabolizeRequestsByRequestIdStatusResponses]

export type PutFalAiPostProcessingParabolizeRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/parabolize/requests/{request_id}/cancel'
}

export type PutFalAiPostProcessingParabolizeRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiPostProcessingParabolizeRequestsByRequestIdCancelResponse =
  PutFalAiPostProcessingParabolizeRequestsByRequestIdCancelResponses[keyof PutFalAiPostProcessingParabolizeRequestsByRequestIdCancelResponses]

export type PostFalAiPostProcessingParabolizeData = {
  body: SchemaPostProcessingParabolizeInput
  path?: never
  query?: never
  url: '/fal-ai/post-processing/parabolize'
}

export type PostFalAiPostProcessingParabolizeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPostProcessingParabolizeResponse =
  PostFalAiPostProcessingParabolizeResponses[keyof PostFalAiPostProcessingParabolizeResponses]

export type GetFalAiPostProcessingParabolizeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/parabolize/requests/{request_id}'
}

export type GetFalAiPostProcessingParabolizeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPostProcessingParabolizeOutput
}

export type GetFalAiPostProcessingParabolizeRequestsByRequestIdResponse =
  GetFalAiPostProcessingParabolizeRequestsByRequestIdResponses[keyof GetFalAiPostProcessingParabolizeRequestsByRequestIdResponses]

export type GetFalAiPostProcessingGrainRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/post-processing/grain/requests/{request_id}/status'
}

export type GetFalAiPostProcessingGrainRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiPostProcessingGrainRequestsByRequestIdStatusResponse =
  GetFalAiPostProcessingGrainRequestsByRequestIdStatusResponses[keyof GetFalAiPostProcessingGrainRequestsByRequestIdStatusResponses]

export type PutFalAiPostProcessingGrainRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/grain/requests/{request_id}/cancel'
}

export type PutFalAiPostProcessingGrainRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiPostProcessingGrainRequestsByRequestIdCancelResponse =
  PutFalAiPostProcessingGrainRequestsByRequestIdCancelResponses[keyof PutFalAiPostProcessingGrainRequestsByRequestIdCancelResponses]

export type PostFalAiPostProcessingGrainData = {
  body: SchemaPostProcessingGrainInput
  path?: never
  query?: never
  url: '/fal-ai/post-processing/grain'
}

export type PostFalAiPostProcessingGrainResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPostProcessingGrainResponse =
  PostFalAiPostProcessingGrainResponses[keyof PostFalAiPostProcessingGrainResponses]

export type GetFalAiPostProcessingGrainRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/grain/requests/{request_id}'
}

export type GetFalAiPostProcessingGrainRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPostProcessingGrainOutput
}

export type GetFalAiPostProcessingGrainRequestsByRequestIdResponse =
  GetFalAiPostProcessingGrainRequestsByRequestIdResponses[keyof GetFalAiPostProcessingGrainRequestsByRequestIdResponses]

export type GetFalAiPostProcessingDodgeBurnRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/post-processing/dodge-burn/requests/{request_id}/status'
}

export type GetFalAiPostProcessingDodgeBurnRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiPostProcessingDodgeBurnRequestsByRequestIdStatusResponse =
  GetFalAiPostProcessingDodgeBurnRequestsByRequestIdStatusResponses[keyof GetFalAiPostProcessingDodgeBurnRequestsByRequestIdStatusResponses]

export type PutFalAiPostProcessingDodgeBurnRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/dodge-burn/requests/{request_id}/cancel'
}

export type PutFalAiPostProcessingDodgeBurnRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiPostProcessingDodgeBurnRequestsByRequestIdCancelResponse =
  PutFalAiPostProcessingDodgeBurnRequestsByRequestIdCancelResponses[keyof PutFalAiPostProcessingDodgeBurnRequestsByRequestIdCancelResponses]

export type PostFalAiPostProcessingDodgeBurnData = {
  body: SchemaPostProcessingDodgeBurnInput
  path?: never
  query?: never
  url: '/fal-ai/post-processing/dodge-burn'
}

export type PostFalAiPostProcessingDodgeBurnResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPostProcessingDodgeBurnResponse =
  PostFalAiPostProcessingDodgeBurnResponses[keyof PostFalAiPostProcessingDodgeBurnResponses]

export type GetFalAiPostProcessingDodgeBurnRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/dodge-burn/requests/{request_id}'
}

export type GetFalAiPostProcessingDodgeBurnRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPostProcessingDodgeBurnOutput
}

export type GetFalAiPostProcessingDodgeBurnRequestsByRequestIdResponse =
  GetFalAiPostProcessingDodgeBurnRequestsByRequestIdResponses[keyof GetFalAiPostProcessingDodgeBurnRequestsByRequestIdResponses]

export type GetFalAiPostProcessingDissolveRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/post-processing/dissolve/requests/{request_id}/status'
}

export type GetFalAiPostProcessingDissolveRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiPostProcessingDissolveRequestsByRequestIdStatusResponse =
  GetFalAiPostProcessingDissolveRequestsByRequestIdStatusResponses[keyof GetFalAiPostProcessingDissolveRequestsByRequestIdStatusResponses]

export type PutFalAiPostProcessingDissolveRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/dissolve/requests/{request_id}/cancel'
}

export type PutFalAiPostProcessingDissolveRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiPostProcessingDissolveRequestsByRequestIdCancelResponse =
  PutFalAiPostProcessingDissolveRequestsByRequestIdCancelResponses[keyof PutFalAiPostProcessingDissolveRequestsByRequestIdCancelResponses]

export type PostFalAiPostProcessingDissolveData = {
  body: SchemaPostProcessingDissolveInput
  path?: never
  query?: never
  url: '/fal-ai/post-processing/dissolve'
}

export type PostFalAiPostProcessingDissolveResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPostProcessingDissolveResponse =
  PostFalAiPostProcessingDissolveResponses[keyof PostFalAiPostProcessingDissolveResponses]

export type GetFalAiPostProcessingDissolveRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/dissolve/requests/{request_id}'
}

export type GetFalAiPostProcessingDissolveRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPostProcessingDissolveOutput
}

export type GetFalAiPostProcessingDissolveRequestsByRequestIdResponse =
  GetFalAiPostProcessingDissolveRequestsByRequestIdResponses[keyof GetFalAiPostProcessingDissolveRequestsByRequestIdResponses]

export type GetFalAiPostProcessingDesaturateRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/post-processing/desaturate/requests/{request_id}/status'
}

export type GetFalAiPostProcessingDesaturateRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiPostProcessingDesaturateRequestsByRequestIdStatusResponse =
  GetFalAiPostProcessingDesaturateRequestsByRequestIdStatusResponses[keyof GetFalAiPostProcessingDesaturateRequestsByRequestIdStatusResponses]

export type PutFalAiPostProcessingDesaturateRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/desaturate/requests/{request_id}/cancel'
}

export type PutFalAiPostProcessingDesaturateRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiPostProcessingDesaturateRequestsByRequestIdCancelResponse =
  PutFalAiPostProcessingDesaturateRequestsByRequestIdCancelResponses[keyof PutFalAiPostProcessingDesaturateRequestsByRequestIdCancelResponses]

export type PostFalAiPostProcessingDesaturateData = {
  body: SchemaPostProcessingDesaturateInput
  path?: never
  query?: never
  url: '/fal-ai/post-processing/desaturate'
}

export type PostFalAiPostProcessingDesaturateResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPostProcessingDesaturateResponse =
  PostFalAiPostProcessingDesaturateResponses[keyof PostFalAiPostProcessingDesaturateResponses]

export type GetFalAiPostProcessingDesaturateRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/desaturate/requests/{request_id}'
}

export type GetFalAiPostProcessingDesaturateRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPostProcessingDesaturateOutput
}

export type GetFalAiPostProcessingDesaturateRequestsByRequestIdResponse =
  GetFalAiPostProcessingDesaturateRequestsByRequestIdResponses[keyof GetFalAiPostProcessingDesaturateRequestsByRequestIdResponses]

export type GetFalAiPostProcessingColorTintRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/post-processing/color-tint/requests/{request_id}/status'
}

export type GetFalAiPostProcessingColorTintRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiPostProcessingColorTintRequestsByRequestIdStatusResponse =
  GetFalAiPostProcessingColorTintRequestsByRequestIdStatusResponses[keyof GetFalAiPostProcessingColorTintRequestsByRequestIdStatusResponses]

export type PutFalAiPostProcessingColorTintRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/color-tint/requests/{request_id}/cancel'
}

export type PutFalAiPostProcessingColorTintRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiPostProcessingColorTintRequestsByRequestIdCancelResponse =
  PutFalAiPostProcessingColorTintRequestsByRequestIdCancelResponses[keyof PutFalAiPostProcessingColorTintRequestsByRequestIdCancelResponses]

export type PostFalAiPostProcessingColorTintData = {
  body: SchemaPostProcessingColorTintInput
  path?: never
  query?: never
  url: '/fal-ai/post-processing/color-tint'
}

export type PostFalAiPostProcessingColorTintResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPostProcessingColorTintResponse =
  PostFalAiPostProcessingColorTintResponses[keyof PostFalAiPostProcessingColorTintResponses]

export type GetFalAiPostProcessingColorTintRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/color-tint/requests/{request_id}'
}

export type GetFalAiPostProcessingColorTintRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPostProcessingColorTintOutput
}

export type GetFalAiPostProcessingColorTintRequestsByRequestIdResponse =
  GetFalAiPostProcessingColorTintRequestsByRequestIdResponses[keyof GetFalAiPostProcessingColorTintRequestsByRequestIdResponses]

export type GetFalAiPostProcessingColorCorrectionRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/post-processing/color-correction/requests/{request_id}/status'
  }

export type GetFalAiPostProcessingColorCorrectionRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiPostProcessingColorCorrectionRequestsByRequestIdStatusResponse =
  GetFalAiPostProcessingColorCorrectionRequestsByRequestIdStatusResponses[keyof GetFalAiPostProcessingColorCorrectionRequestsByRequestIdStatusResponses]

export type PutFalAiPostProcessingColorCorrectionRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/post-processing/color-correction/requests/{request_id}/cancel'
  }

export type PutFalAiPostProcessingColorCorrectionRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiPostProcessingColorCorrectionRequestsByRequestIdCancelResponse =
  PutFalAiPostProcessingColorCorrectionRequestsByRequestIdCancelResponses[keyof PutFalAiPostProcessingColorCorrectionRequestsByRequestIdCancelResponses]

export type PostFalAiPostProcessingColorCorrectionData = {
  body: SchemaPostProcessingColorCorrectionInput
  path?: never
  query?: never
  url: '/fal-ai/post-processing/color-correction'
}

export type PostFalAiPostProcessingColorCorrectionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPostProcessingColorCorrectionResponse =
  PostFalAiPostProcessingColorCorrectionResponses[keyof PostFalAiPostProcessingColorCorrectionResponses]

export type GetFalAiPostProcessingColorCorrectionRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/color-correction/requests/{request_id}'
}

export type GetFalAiPostProcessingColorCorrectionRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaPostProcessingColorCorrectionOutput
  }

export type GetFalAiPostProcessingColorCorrectionRequestsByRequestIdResponse =
  GetFalAiPostProcessingColorCorrectionRequestsByRequestIdResponses[keyof GetFalAiPostProcessingColorCorrectionRequestsByRequestIdResponses]

export type GetFalAiPostProcessingChromaticAberrationRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/post-processing/chromatic-aberration/requests/{request_id}/status'
  }

export type GetFalAiPostProcessingChromaticAberrationRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiPostProcessingChromaticAberrationRequestsByRequestIdStatusResponse =
  GetFalAiPostProcessingChromaticAberrationRequestsByRequestIdStatusResponses[keyof GetFalAiPostProcessingChromaticAberrationRequestsByRequestIdStatusResponses]

export type PutFalAiPostProcessingChromaticAberrationRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/post-processing/chromatic-aberration/requests/{request_id}/cancel'
  }

export type PutFalAiPostProcessingChromaticAberrationRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiPostProcessingChromaticAberrationRequestsByRequestIdCancelResponse =
  PutFalAiPostProcessingChromaticAberrationRequestsByRequestIdCancelResponses[keyof PutFalAiPostProcessingChromaticAberrationRequestsByRequestIdCancelResponses]

export type PostFalAiPostProcessingChromaticAberrationData = {
  body: SchemaPostProcessingChromaticAberrationInput
  path?: never
  query?: never
  url: '/fal-ai/post-processing/chromatic-aberration'
}

export type PostFalAiPostProcessingChromaticAberrationResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPostProcessingChromaticAberrationResponse =
  PostFalAiPostProcessingChromaticAberrationResponses[keyof PostFalAiPostProcessingChromaticAberrationResponses]

export type GetFalAiPostProcessingChromaticAberrationRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/chromatic-aberration/requests/{request_id}'
}

export type GetFalAiPostProcessingChromaticAberrationRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaPostProcessingChromaticAberrationOutput
  }

export type GetFalAiPostProcessingChromaticAberrationRequestsByRequestIdResponse =
  GetFalAiPostProcessingChromaticAberrationRequestsByRequestIdResponses[keyof GetFalAiPostProcessingChromaticAberrationRequestsByRequestIdResponses]

export type GetFalAiPostProcessingBlurRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/post-processing/blur/requests/{request_id}/status'
}

export type GetFalAiPostProcessingBlurRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiPostProcessingBlurRequestsByRequestIdStatusResponse =
  GetFalAiPostProcessingBlurRequestsByRequestIdStatusResponses[keyof GetFalAiPostProcessingBlurRequestsByRequestIdStatusResponses]

export type PutFalAiPostProcessingBlurRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/blur/requests/{request_id}/cancel'
}

export type PutFalAiPostProcessingBlurRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiPostProcessingBlurRequestsByRequestIdCancelResponse =
  PutFalAiPostProcessingBlurRequestsByRequestIdCancelResponses[keyof PutFalAiPostProcessingBlurRequestsByRequestIdCancelResponses]

export type PostFalAiPostProcessingBlurData = {
  body: SchemaPostProcessingBlurInput
  path?: never
  query?: never
  url: '/fal-ai/post-processing/blur'
}

export type PostFalAiPostProcessingBlurResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPostProcessingBlurResponse =
  PostFalAiPostProcessingBlurResponses[keyof PostFalAiPostProcessingBlurResponses]

export type GetFalAiPostProcessingBlurRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/blur/requests/{request_id}'
}

export type GetFalAiPostProcessingBlurRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPostProcessingBlurOutput
}

export type GetFalAiPostProcessingBlurRequestsByRequestIdResponse =
  GetFalAiPostProcessingBlurRequestsByRequestIdResponses[keyof GetFalAiPostProcessingBlurRequestsByRequestIdResponses]

export type GetFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/image-editing/youtube-thumbnails/requests/{request_id}/status'
  }

export type GetFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/image-editing/youtube-thumbnails/requests/{request_id}/cancel'
  }

export type PutFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingYoutubeThumbnailsData = {
  body: SchemaImageEditingYoutubeThumbnailsInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/youtube-thumbnails'
}

export type PostFalAiImageEditingYoutubeThumbnailsResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingYoutubeThumbnailsResponse =
  PostFalAiImageEditingYoutubeThumbnailsResponses[keyof PostFalAiImageEditingYoutubeThumbnailsResponses]

export type GetFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/youtube-thumbnails/requests/{request_id}'
}

export type GetFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaImageEditingYoutubeThumbnailsOutput
  }

export type GetFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdResponse =
  GetFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdResponses[keyof GetFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdResponses]

export type GetFalAiTopazUpscaleImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/topaz/upscale/image/requests/{request_id}/status'
}

export type GetFalAiTopazUpscaleImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiTopazUpscaleImageRequestsByRequestIdStatusResponse =
  GetFalAiTopazUpscaleImageRequestsByRequestIdStatusResponses[keyof GetFalAiTopazUpscaleImageRequestsByRequestIdStatusResponses]

export type PutFalAiTopazUpscaleImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/topaz/upscale/image/requests/{request_id}/cancel'
}

export type PutFalAiTopazUpscaleImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiTopazUpscaleImageRequestsByRequestIdCancelResponse =
  PutFalAiTopazUpscaleImageRequestsByRequestIdCancelResponses[keyof PutFalAiTopazUpscaleImageRequestsByRequestIdCancelResponses]

export type PostFalAiTopazUpscaleImageData = {
  body: SchemaTopazUpscaleImageInput
  path?: never
  query?: never
  url: '/fal-ai/topaz/upscale/image'
}

export type PostFalAiTopazUpscaleImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiTopazUpscaleImageResponse =
  PostFalAiTopazUpscaleImageResponses[keyof PostFalAiTopazUpscaleImageResponses]

export type GetFalAiTopazUpscaleImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/topaz/upscale/image/requests/{request_id}'
}

export type GetFalAiTopazUpscaleImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaTopazUpscaleImageOutput
}

export type GetFalAiTopazUpscaleImageRequestsByRequestIdResponse =
  GetFalAiTopazUpscaleImageRequestsByRequestIdResponses[keyof GetFalAiTopazUpscaleImageRequestsByRequestIdResponses]

export type GetFalAiImageEditingBroccoliHaircutRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-editing/broccoli-haircut/requests/{request_id}/status'
}

export type GetFalAiImageEditingBroccoliHaircutRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageEditingBroccoliHaircutRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingBroccoliHaircutRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingBroccoliHaircutRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingBroccoliHaircutRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/broccoli-haircut/requests/{request_id}/cancel'
}

export type PutFalAiImageEditingBroccoliHaircutRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageEditingBroccoliHaircutRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingBroccoliHaircutRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingBroccoliHaircutRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingBroccoliHaircutData = {
  body: SchemaImageEditingBroccoliHaircutInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/broccoli-haircut'
}

export type PostFalAiImageEditingBroccoliHaircutResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingBroccoliHaircutResponse =
  PostFalAiImageEditingBroccoliHaircutResponses[keyof PostFalAiImageEditingBroccoliHaircutResponses]

export type GetFalAiImageEditingBroccoliHaircutRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/broccoli-haircut/requests/{request_id}'
}

export type GetFalAiImageEditingBroccoliHaircutRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingBroccoliHaircutOutput
}

export type GetFalAiImageEditingBroccoliHaircutRequestsByRequestIdResponse =
  GetFalAiImageEditingBroccoliHaircutRequestsByRequestIdResponses[keyof GetFalAiImageEditingBroccoliHaircutRequestsByRequestIdResponses]

export type GetFalAiImageEditingWojakStyleRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-editing/wojak-style/requests/{request_id}/status'
}

export type GetFalAiImageEditingWojakStyleRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImageEditingWojakStyleRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingWojakStyleRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingWojakStyleRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingWojakStyleRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/wojak-style/requests/{request_id}/cancel'
}

export type PutFalAiImageEditingWojakStyleRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImageEditingWojakStyleRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingWojakStyleRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingWojakStyleRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingWojakStyleData = {
  body: SchemaImageEditingWojakStyleInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/wojak-style'
}

export type PostFalAiImageEditingWojakStyleResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingWojakStyleResponse =
  PostFalAiImageEditingWojakStyleResponses[keyof PostFalAiImageEditingWojakStyleResponses]

export type GetFalAiImageEditingWojakStyleRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/wojak-style/requests/{request_id}'
}

export type GetFalAiImageEditingWojakStyleRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingWojakStyleOutput
}

export type GetFalAiImageEditingWojakStyleRequestsByRequestIdResponse =
  GetFalAiImageEditingWojakStyleRequestsByRequestIdResponses[keyof GetFalAiImageEditingWojakStyleRequestsByRequestIdResponses]

export type GetFalAiImageEditingPlushieStyleRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-editing/plushie-style/requests/{request_id}/status'
}

export type GetFalAiImageEditingPlushieStyleRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageEditingPlushieStyleRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingPlushieStyleRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingPlushieStyleRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingPlushieStyleRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/plushie-style/requests/{request_id}/cancel'
}

export type PutFalAiImageEditingPlushieStyleRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageEditingPlushieStyleRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingPlushieStyleRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingPlushieStyleRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingPlushieStyleData = {
  body: SchemaImageEditingPlushieStyleInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/plushie-style'
}

export type PostFalAiImageEditingPlushieStyleResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingPlushieStyleResponse =
  PostFalAiImageEditingPlushieStyleResponses[keyof PostFalAiImageEditingPlushieStyleResponses]

export type GetFalAiImageEditingPlushieStyleRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/plushie-style/requests/{request_id}'
}

export type GetFalAiImageEditingPlushieStyleRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingPlushieStyleOutput
}

export type GetFalAiImageEditingPlushieStyleRequestsByRequestIdResponse =
  GetFalAiImageEditingPlushieStyleRequestsByRequestIdResponses[keyof GetFalAiImageEditingPlushieStyleRequestsByRequestIdResponses]

export type GetFalAiFluxKontextLoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-kontext-lora/requests/{request_id}/status'
}

export type GetFalAiFluxKontextLoraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxKontextLoraRequestsByRequestIdStatusResponse =
  GetFalAiFluxKontextLoraRequestsByRequestIdStatusResponses[keyof GetFalAiFluxKontextLoraRequestsByRequestIdStatusResponses]

export type PutFalAiFluxKontextLoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-kontext-lora/requests/{request_id}/cancel'
}

export type PutFalAiFluxKontextLoraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxKontextLoraRequestsByRequestIdCancelResponse =
  PutFalAiFluxKontextLoraRequestsByRequestIdCancelResponses[keyof PutFalAiFluxKontextLoraRequestsByRequestIdCancelResponses]

export type PostFalAiFluxKontextLoraData = {
  body: SchemaFluxKontextLoraInput
  path?: never
  query?: never
  url: '/fal-ai/flux-kontext-lora'
}

export type PostFalAiFluxKontextLoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxKontextLoraResponse =
  PostFalAiFluxKontextLoraResponses[keyof PostFalAiFluxKontextLoraResponses]

export type GetFalAiFluxKontextLoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-kontext-lora/requests/{request_id}'
}

export type GetFalAiFluxKontextLoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxKontextLoraOutput
}

export type GetFalAiFluxKontextLoraRequestsByRequestIdResponse =
  GetFalAiFluxKontextLoraRequestsByRequestIdResponses[keyof GetFalAiFluxKontextLoraRequestsByRequestIdResponses]

export type GetFalAiFashnTryonV16RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/fashn/tryon/v1.6/requests/{request_id}/status'
}

export type GetFalAiFashnTryonV16RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFashnTryonV16RequestsByRequestIdStatusResponse =
  GetFalAiFashnTryonV16RequestsByRequestIdStatusResponses[keyof GetFalAiFashnTryonV16RequestsByRequestIdStatusResponses]

export type PutFalAiFashnTryonV16RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fashn/tryon/v1.6/requests/{request_id}/cancel'
}

export type PutFalAiFashnTryonV16RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFashnTryonV16RequestsByRequestIdCancelResponse =
  PutFalAiFashnTryonV16RequestsByRequestIdCancelResponses[keyof PutFalAiFashnTryonV16RequestsByRequestIdCancelResponses]

export type PostFalAiFashnTryonV16Data = {
  body: SchemaFashnTryonV16Input
  path?: never
  query?: never
  url: '/fal-ai/fashn/tryon/v1.6'
}

export type PostFalAiFashnTryonV16Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFashnTryonV16Response =
  PostFalAiFashnTryonV16Responses[keyof PostFalAiFashnTryonV16Responses]

export type GetFalAiFashnTryonV16RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fashn/tryon/v1.6/requests/{request_id}'
}

export type GetFalAiFashnTryonV16RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFashnTryonV16Output
}

export type GetFalAiFashnTryonV16RequestsByRequestIdResponse =
  GetFalAiFashnTryonV16RequestsByRequestIdResponses[keyof GetFalAiFashnTryonV16RequestsByRequestIdResponses]

export type GetFalAiChainOfZoomRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/chain-of-zoom/requests/{request_id}/status'
}

export type GetFalAiChainOfZoomRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiChainOfZoomRequestsByRequestIdStatusResponse =
  GetFalAiChainOfZoomRequestsByRequestIdStatusResponses[keyof GetFalAiChainOfZoomRequestsByRequestIdStatusResponses]

export type PutFalAiChainOfZoomRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/chain-of-zoom/requests/{request_id}/cancel'
}

export type PutFalAiChainOfZoomRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiChainOfZoomRequestsByRequestIdCancelResponse =
  PutFalAiChainOfZoomRequestsByRequestIdCancelResponses[keyof PutFalAiChainOfZoomRequestsByRequestIdCancelResponses]

export type PostFalAiChainOfZoomData = {
  body: SchemaChainOfZoomInput
  path?: never
  query?: never
  url: '/fal-ai/chain-of-zoom'
}

export type PostFalAiChainOfZoomResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiChainOfZoomResponse =
  PostFalAiChainOfZoomResponses[keyof PostFalAiChainOfZoomResponses]

export type GetFalAiChainOfZoomRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/chain-of-zoom/requests/{request_id}'
}

export type GetFalAiChainOfZoomRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaChainOfZoomOutput
}

export type GetFalAiChainOfZoomRequestsByRequestIdResponse =
  GetFalAiChainOfZoomRequestsByRequestIdResponses[keyof GetFalAiChainOfZoomRequestsByRequestIdResponses]

export type GetFalAiPasdRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/pasd/requests/{request_id}/status'
}

export type GetFalAiPasdRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiPasdRequestsByRequestIdStatusResponse =
  GetFalAiPasdRequestsByRequestIdStatusResponses[keyof GetFalAiPasdRequestsByRequestIdStatusResponses]

export type PutFalAiPasdRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/pasd/requests/{request_id}/cancel'
}

export type PutFalAiPasdRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiPasdRequestsByRequestIdCancelResponse =
  PutFalAiPasdRequestsByRequestIdCancelResponses[keyof PutFalAiPasdRequestsByRequestIdCancelResponses]

export type PostFalAiPasdData = {
  body: SchemaPasdInput
  path?: never
  query?: never
  url: '/fal-ai/pasd'
}

export type PostFalAiPasdResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPasdResponse =
  PostFalAiPasdResponses[keyof PostFalAiPasdResponses]

export type GetFalAiPasdRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/pasd/requests/{request_id}'
}

export type GetFalAiPasdRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPasdOutput
}

export type GetFalAiPasdRequestsByRequestIdResponse =
  GetFalAiPasdRequestsByRequestIdResponses[keyof GetFalAiPasdRequestsByRequestIdResponses]

export type GetFalAiObjectRemovalBboxRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/object-removal/bbox/requests/{request_id}/status'
}

export type GetFalAiObjectRemovalBboxRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiObjectRemovalBboxRequestsByRequestIdStatusResponse =
  GetFalAiObjectRemovalBboxRequestsByRequestIdStatusResponses[keyof GetFalAiObjectRemovalBboxRequestsByRequestIdStatusResponses]

export type PutFalAiObjectRemovalBboxRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/object-removal/bbox/requests/{request_id}/cancel'
}

export type PutFalAiObjectRemovalBboxRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiObjectRemovalBboxRequestsByRequestIdCancelResponse =
  PutFalAiObjectRemovalBboxRequestsByRequestIdCancelResponses[keyof PutFalAiObjectRemovalBboxRequestsByRequestIdCancelResponses]

export type PostFalAiObjectRemovalBboxData = {
  body: SchemaObjectRemovalBboxInput
  path?: never
  query?: never
  url: '/fal-ai/object-removal/bbox'
}

export type PostFalAiObjectRemovalBboxResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiObjectRemovalBboxResponse =
  PostFalAiObjectRemovalBboxResponses[keyof PostFalAiObjectRemovalBboxResponses]

export type GetFalAiObjectRemovalBboxRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/object-removal/bbox/requests/{request_id}'
}

export type GetFalAiObjectRemovalBboxRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaObjectRemovalBboxOutput
}

export type GetFalAiObjectRemovalBboxRequestsByRequestIdResponse =
  GetFalAiObjectRemovalBboxRequestsByRequestIdResponses[keyof GetFalAiObjectRemovalBboxRequestsByRequestIdResponses]

export type GetFalAiObjectRemovalMaskRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/object-removal/mask/requests/{request_id}/status'
}

export type GetFalAiObjectRemovalMaskRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiObjectRemovalMaskRequestsByRequestIdStatusResponse =
  GetFalAiObjectRemovalMaskRequestsByRequestIdStatusResponses[keyof GetFalAiObjectRemovalMaskRequestsByRequestIdStatusResponses]

export type PutFalAiObjectRemovalMaskRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/object-removal/mask/requests/{request_id}/cancel'
}

export type PutFalAiObjectRemovalMaskRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiObjectRemovalMaskRequestsByRequestIdCancelResponse =
  PutFalAiObjectRemovalMaskRequestsByRequestIdCancelResponses[keyof PutFalAiObjectRemovalMaskRequestsByRequestIdCancelResponses]

export type PostFalAiObjectRemovalMaskData = {
  body: SchemaObjectRemovalMaskInput
  path?: never
  query?: never
  url: '/fal-ai/object-removal/mask'
}

export type PostFalAiObjectRemovalMaskResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiObjectRemovalMaskResponse =
  PostFalAiObjectRemovalMaskResponses[keyof PostFalAiObjectRemovalMaskResponses]

export type GetFalAiObjectRemovalMaskRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/object-removal/mask/requests/{request_id}'
}

export type GetFalAiObjectRemovalMaskRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaObjectRemovalMaskOutput
}

export type GetFalAiObjectRemovalMaskRequestsByRequestIdResponse =
  GetFalAiObjectRemovalMaskRequestsByRequestIdResponses[keyof GetFalAiObjectRemovalMaskRequestsByRequestIdResponses]

export type GetFalAiObjectRemovalRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/object-removal/requests/{request_id}/status'
}

export type GetFalAiObjectRemovalRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiObjectRemovalRequestsByRequestIdStatusResponse =
  GetFalAiObjectRemovalRequestsByRequestIdStatusResponses[keyof GetFalAiObjectRemovalRequestsByRequestIdStatusResponses]

export type PutFalAiObjectRemovalRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/object-removal/requests/{request_id}/cancel'
}

export type PutFalAiObjectRemovalRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiObjectRemovalRequestsByRequestIdCancelResponse =
  PutFalAiObjectRemovalRequestsByRequestIdCancelResponses[keyof PutFalAiObjectRemovalRequestsByRequestIdCancelResponses]

export type PostFalAiObjectRemovalData = {
  body: SchemaObjectRemovalInput
  path?: never
  query?: never
  url: '/fal-ai/object-removal'
}

export type PostFalAiObjectRemovalResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiObjectRemovalResponse =
  PostFalAiObjectRemovalResponses[keyof PostFalAiObjectRemovalResponses]

export type GetFalAiObjectRemovalRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/object-removal/requests/{request_id}'
}

export type GetFalAiObjectRemovalRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaObjectRemovalOutput
}

export type GetFalAiObjectRemovalRequestsByRequestIdResponse =
  GetFalAiObjectRemovalRequestsByRequestIdResponses[keyof GetFalAiObjectRemovalRequestsByRequestIdResponses]

export type GetFalAiRecraftVectorizeRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/recraft/vectorize/requests/{request_id}/status'
}

export type GetFalAiRecraftVectorizeRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiRecraftVectorizeRequestsByRequestIdStatusResponse =
  GetFalAiRecraftVectorizeRequestsByRequestIdStatusResponses[keyof GetFalAiRecraftVectorizeRequestsByRequestIdStatusResponses]

export type PutFalAiRecraftVectorizeRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/recraft/vectorize/requests/{request_id}/cancel'
}

export type PutFalAiRecraftVectorizeRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiRecraftVectorizeRequestsByRequestIdCancelResponse =
  PutFalAiRecraftVectorizeRequestsByRequestIdCancelResponses[keyof PutFalAiRecraftVectorizeRequestsByRequestIdCancelResponses]

export type PostFalAiRecraftVectorizeData = {
  body: SchemaRecraftVectorizeInput
  path?: never
  query?: never
  url: '/fal-ai/recraft/vectorize'
}

export type PostFalAiRecraftVectorizeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiRecraftVectorizeResponse =
  PostFalAiRecraftVectorizeResponses[keyof PostFalAiRecraftVectorizeResponses]

export type GetFalAiRecraftVectorizeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/recraft/vectorize/requests/{request_id}'
}

export type GetFalAiRecraftVectorizeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaRecraftVectorizeOutput
}

export type GetFalAiRecraftVectorizeRequestsByRequestIdResponse =
  GetFalAiRecraftVectorizeRequestsByRequestIdResponses[keyof GetFalAiRecraftVectorizeRequestsByRequestIdResponses]

export type GetFalAiFfmpegApiExtractFrameRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ffmpeg-api/extract-frame/requests/{request_id}/status'
}

export type GetFalAiFfmpegApiExtractFrameRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFfmpegApiExtractFrameRequestsByRequestIdStatusResponse =
  GetFalAiFfmpegApiExtractFrameRequestsByRequestIdStatusResponses[keyof GetFalAiFfmpegApiExtractFrameRequestsByRequestIdStatusResponses]

export type PutFalAiFfmpegApiExtractFrameRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ffmpeg-api/extract-frame/requests/{request_id}/cancel'
}

export type PutFalAiFfmpegApiExtractFrameRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFfmpegApiExtractFrameRequestsByRequestIdCancelResponse =
  PutFalAiFfmpegApiExtractFrameRequestsByRequestIdCancelResponses[keyof PutFalAiFfmpegApiExtractFrameRequestsByRequestIdCancelResponses]

export type PostFalAiFfmpegApiExtractFrameData = {
  body: SchemaFfmpegApiExtractFrameInput
  path?: never
  query?: never
  url: '/fal-ai/ffmpeg-api/extract-frame'
}

export type PostFalAiFfmpegApiExtractFrameResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFfmpegApiExtractFrameResponse =
  PostFalAiFfmpegApiExtractFrameResponses[keyof PostFalAiFfmpegApiExtractFrameResponses]

export type GetFalAiFfmpegApiExtractFrameRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ffmpeg-api/extract-frame/requests/{request_id}'
}

export type GetFalAiFfmpegApiExtractFrameRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFfmpegApiExtractFrameOutput
}

export type GetFalAiFfmpegApiExtractFrameRequestsByRequestIdResponse =
  GetFalAiFfmpegApiExtractFrameRequestsByRequestIdResponses[keyof GetFalAiFfmpegApiExtractFrameRequestsByRequestIdResponses]

export type GetFalAiLumaPhotonFlashModifyRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/luma-photon/flash/modify/requests/{request_id}/status'
}

export type GetFalAiLumaPhotonFlashModifyRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLumaPhotonFlashModifyRequestsByRequestIdStatusResponse =
  GetFalAiLumaPhotonFlashModifyRequestsByRequestIdStatusResponses[keyof GetFalAiLumaPhotonFlashModifyRequestsByRequestIdStatusResponses]

export type PutFalAiLumaPhotonFlashModifyRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/luma-photon/flash/modify/requests/{request_id}/cancel'
}

export type PutFalAiLumaPhotonFlashModifyRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLumaPhotonFlashModifyRequestsByRequestIdCancelResponse =
  PutFalAiLumaPhotonFlashModifyRequestsByRequestIdCancelResponses[keyof PutFalAiLumaPhotonFlashModifyRequestsByRequestIdCancelResponses]

export type PostFalAiLumaPhotonFlashModifyData = {
  body: SchemaLumaPhotonFlashModifyInput
  path?: never
  query?: never
  url: '/fal-ai/luma-photon/flash/modify'
}

export type PostFalAiLumaPhotonFlashModifyResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLumaPhotonFlashModifyResponse =
  PostFalAiLumaPhotonFlashModifyResponses[keyof PostFalAiLumaPhotonFlashModifyResponses]

export type GetFalAiLumaPhotonFlashModifyRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/luma-photon/flash/modify/requests/{request_id}'
}

export type GetFalAiLumaPhotonFlashModifyRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLumaPhotonFlashModifyOutput
}

export type GetFalAiLumaPhotonFlashModifyRequestsByRequestIdResponse =
  GetFalAiLumaPhotonFlashModifyRequestsByRequestIdResponses[keyof GetFalAiLumaPhotonFlashModifyRequestsByRequestIdResponses]

export type GetFalAiLumaPhotonModifyRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/luma-photon/modify/requests/{request_id}/status'
}

export type GetFalAiLumaPhotonModifyRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLumaPhotonModifyRequestsByRequestIdStatusResponse =
  GetFalAiLumaPhotonModifyRequestsByRequestIdStatusResponses[keyof GetFalAiLumaPhotonModifyRequestsByRequestIdStatusResponses]

export type PutFalAiLumaPhotonModifyRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/luma-photon/modify/requests/{request_id}/cancel'
}

export type PutFalAiLumaPhotonModifyRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLumaPhotonModifyRequestsByRequestIdCancelResponse =
  PutFalAiLumaPhotonModifyRequestsByRequestIdCancelResponses[keyof PutFalAiLumaPhotonModifyRequestsByRequestIdCancelResponses]

export type PostFalAiLumaPhotonModifyData = {
  body: SchemaLumaPhotonModifyInput
  path?: never
  query?: never
  url: '/fal-ai/luma-photon/modify'
}

export type PostFalAiLumaPhotonModifyResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLumaPhotonModifyResponse =
  PostFalAiLumaPhotonModifyResponses[keyof PostFalAiLumaPhotonModifyResponses]

export type GetFalAiLumaPhotonModifyRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/luma-photon/modify/requests/{request_id}'
}

export type GetFalAiLumaPhotonModifyRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLumaPhotonModifyOutput
}

export type GetFalAiLumaPhotonModifyRequestsByRequestIdResponse =
  GetFalAiLumaPhotonModifyRequestsByRequestIdResponses[keyof GetFalAiLumaPhotonModifyRequestsByRequestIdResponses]

export type GetFalAiImageEditingReframeRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-editing/reframe/requests/{request_id}/status'
}

export type GetFalAiImageEditingReframeRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImageEditingReframeRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingReframeRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingReframeRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingReframeRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/reframe/requests/{request_id}/cancel'
}

export type PutFalAiImageEditingReframeRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImageEditingReframeRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingReframeRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingReframeRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingReframeData = {
  body: SchemaImageEditingReframeInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/reframe'
}

export type PostFalAiImageEditingReframeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingReframeResponse =
  PostFalAiImageEditingReframeResponses[keyof PostFalAiImageEditingReframeResponses]

export type GetFalAiImageEditingReframeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/reframe/requests/{request_id}'
}

export type GetFalAiImageEditingReframeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingReframeOutput
}

export type GetFalAiImageEditingReframeRequestsByRequestIdResponse =
  GetFalAiImageEditingReframeRequestsByRequestIdResponses[keyof GetFalAiImageEditingReframeRequestsByRequestIdResponses]

export type GetFalAiImageEditingBabyVersionRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-editing/baby-version/requests/{request_id}/status'
}

export type GetFalAiImageEditingBabyVersionRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageEditingBabyVersionRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingBabyVersionRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingBabyVersionRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingBabyVersionRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/baby-version/requests/{request_id}/cancel'
}

export type PutFalAiImageEditingBabyVersionRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageEditingBabyVersionRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingBabyVersionRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingBabyVersionRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingBabyVersionData = {
  body: SchemaImageEditingBabyVersionInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/baby-version'
}

export type PostFalAiImageEditingBabyVersionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingBabyVersionResponse =
  PostFalAiImageEditingBabyVersionResponses[keyof PostFalAiImageEditingBabyVersionResponses]

export type GetFalAiImageEditingBabyVersionRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/baby-version/requests/{request_id}'
}

export type GetFalAiImageEditingBabyVersionRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingBabyVersionOutput
}

export type GetFalAiImageEditingBabyVersionRequestsByRequestIdResponse =
  GetFalAiImageEditingBabyVersionRequestsByRequestIdResponses[keyof GetFalAiImageEditingBabyVersionRequestsByRequestIdResponses]

export type GetFalAiLumaPhotonFlashReframeRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/luma-photon/flash/reframe/requests/{request_id}/status'
}

export type GetFalAiLumaPhotonFlashReframeRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLumaPhotonFlashReframeRequestsByRequestIdStatusResponse =
  GetFalAiLumaPhotonFlashReframeRequestsByRequestIdStatusResponses[keyof GetFalAiLumaPhotonFlashReframeRequestsByRequestIdStatusResponses]

export type PutFalAiLumaPhotonFlashReframeRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/luma-photon/flash/reframe/requests/{request_id}/cancel'
}

export type PutFalAiLumaPhotonFlashReframeRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLumaPhotonFlashReframeRequestsByRequestIdCancelResponse =
  PutFalAiLumaPhotonFlashReframeRequestsByRequestIdCancelResponses[keyof PutFalAiLumaPhotonFlashReframeRequestsByRequestIdCancelResponses]

export type PostFalAiLumaPhotonFlashReframeData = {
  body: SchemaLumaPhotonFlashReframeInput
  path?: never
  query?: never
  url: '/fal-ai/luma-photon/flash/reframe'
}

export type PostFalAiLumaPhotonFlashReframeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLumaPhotonFlashReframeResponse =
  PostFalAiLumaPhotonFlashReframeResponses[keyof PostFalAiLumaPhotonFlashReframeResponses]

export type GetFalAiLumaPhotonFlashReframeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/luma-photon/flash/reframe/requests/{request_id}'
}

export type GetFalAiLumaPhotonFlashReframeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLumaPhotonFlashReframeOutput
}

export type GetFalAiLumaPhotonFlashReframeRequestsByRequestIdResponse =
  GetFalAiLumaPhotonFlashReframeRequestsByRequestIdResponses[keyof GetFalAiLumaPhotonFlashReframeRequestsByRequestIdResponses]

export type GetFalAiLumaPhotonReframeRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/luma-photon/reframe/requests/{request_id}/status'
}

export type GetFalAiLumaPhotonReframeRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLumaPhotonReframeRequestsByRequestIdStatusResponse =
  GetFalAiLumaPhotonReframeRequestsByRequestIdStatusResponses[keyof GetFalAiLumaPhotonReframeRequestsByRequestIdStatusResponses]

export type PutFalAiLumaPhotonReframeRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/luma-photon/reframe/requests/{request_id}/cancel'
}

export type PutFalAiLumaPhotonReframeRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLumaPhotonReframeRequestsByRequestIdCancelResponse =
  PutFalAiLumaPhotonReframeRequestsByRequestIdCancelResponses[keyof PutFalAiLumaPhotonReframeRequestsByRequestIdCancelResponses]

export type PostFalAiLumaPhotonReframeData = {
  body: SchemaLumaPhotonReframeInput
  path?: never
  query?: never
  url: '/fal-ai/luma-photon/reframe'
}

export type PostFalAiLumaPhotonReframeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLumaPhotonReframeResponse =
  PostFalAiLumaPhotonReframeResponses[keyof PostFalAiLumaPhotonReframeResponses]

export type GetFalAiLumaPhotonReframeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/luma-photon/reframe/requests/{request_id}'
}

export type GetFalAiLumaPhotonReframeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLumaPhotonReframeOutput
}

export type GetFalAiLumaPhotonReframeRequestsByRequestIdResponse =
  GetFalAiLumaPhotonReframeRequestsByRequestIdResponses[keyof GetFalAiLumaPhotonReframeRequestsByRequestIdResponses]

export type GetFalAiFlux1SchnellReduxRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-1/schnell/redux/requests/{request_id}/status'
}

export type GetFalAiFlux1SchnellReduxRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux1SchnellReduxRequestsByRequestIdStatusResponse =
  GetFalAiFlux1SchnellReduxRequestsByRequestIdStatusResponses[keyof GetFalAiFlux1SchnellReduxRequestsByRequestIdStatusResponses]

export type PutFalAiFlux1SchnellReduxRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/schnell/redux/requests/{request_id}/cancel'
}

export type PutFalAiFlux1SchnellReduxRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux1SchnellReduxRequestsByRequestIdCancelResponse =
  PutFalAiFlux1SchnellReduxRequestsByRequestIdCancelResponses[keyof PutFalAiFlux1SchnellReduxRequestsByRequestIdCancelResponses]

export type PostFalAiFlux1SchnellReduxData = {
  body: SchemaFlux1SchnellReduxInput
  path?: never
  query?: never
  url: '/fal-ai/flux-1/schnell/redux'
}

export type PostFalAiFlux1SchnellReduxResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux1SchnellReduxResponse =
  PostFalAiFlux1SchnellReduxResponses[keyof PostFalAiFlux1SchnellReduxResponses]

export type GetFalAiFlux1SchnellReduxRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/schnell/redux/requests/{request_id}'
}

export type GetFalAiFlux1SchnellReduxRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux1SchnellReduxOutput
}

export type GetFalAiFlux1SchnellReduxRequestsByRequestIdResponse =
  GetFalAiFlux1SchnellReduxRequestsByRequestIdResponses[keyof GetFalAiFlux1SchnellReduxRequestsByRequestIdResponses]

export type GetFalAiFlux1DevReduxRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-1/dev/redux/requests/{request_id}/status'
}

export type GetFalAiFlux1DevReduxRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux1DevReduxRequestsByRequestIdStatusResponse =
  GetFalAiFlux1DevReduxRequestsByRequestIdStatusResponses[keyof GetFalAiFlux1DevReduxRequestsByRequestIdStatusResponses]

export type PutFalAiFlux1DevReduxRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/dev/redux/requests/{request_id}/cancel'
}

export type PutFalAiFlux1DevReduxRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux1DevReduxRequestsByRequestIdCancelResponse =
  PutFalAiFlux1DevReduxRequestsByRequestIdCancelResponses[keyof PutFalAiFlux1DevReduxRequestsByRequestIdCancelResponses]

export type PostFalAiFlux1DevReduxData = {
  body: SchemaFlux1DevReduxInput
  path?: never
  query?: never
  url: '/fal-ai/flux-1/dev/redux'
}

export type PostFalAiFlux1DevReduxResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux1DevReduxResponse =
  PostFalAiFlux1DevReduxResponses[keyof PostFalAiFlux1DevReduxResponses]

export type GetFalAiFlux1DevReduxRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/dev/redux/requests/{request_id}'
}

export type GetFalAiFlux1DevReduxRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux1DevReduxOutput
}

export type GetFalAiFlux1DevReduxRequestsByRequestIdResponse =
  GetFalAiFlux1DevReduxRequestsByRequestIdResponses[keyof GetFalAiFlux1DevReduxRequestsByRequestIdResponses]

export type GetFalAiFlux1DevImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-1/dev/image-to-image/requests/{request_id}/status'
}

export type GetFalAiFlux1DevImageToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux1DevImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiFlux1DevImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiFlux1DevImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiFlux1DevImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/dev/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiFlux1DevImageToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux1DevImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiFlux1DevImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiFlux1DevImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiFlux1DevImageToImageData = {
  body: SchemaFlux1DevImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/flux-1/dev/image-to-image'
}

export type PostFalAiFlux1DevImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux1DevImageToImageResponse =
  PostFalAiFlux1DevImageToImageResponses[keyof PostFalAiFlux1DevImageToImageResponses]

export type GetFalAiFlux1DevImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/dev/image-to-image/requests/{request_id}'
}

export type GetFalAiFlux1DevImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux1DevImageToImageOutput
}

export type GetFalAiFlux1DevImageToImageRequestsByRequestIdResponse =
  GetFalAiFlux1DevImageToImageRequestsByRequestIdResponses[keyof GetFalAiFlux1DevImageToImageRequestsByRequestIdResponses]

export type GetFalAiImageEditingTextRemovalRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-editing/text-removal/requests/{request_id}/status'
}

export type GetFalAiImageEditingTextRemovalRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageEditingTextRemovalRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingTextRemovalRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingTextRemovalRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingTextRemovalRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/text-removal/requests/{request_id}/cancel'
}

export type PutFalAiImageEditingTextRemovalRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageEditingTextRemovalRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingTextRemovalRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingTextRemovalRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingTextRemovalData = {
  body: SchemaImageEditingTextRemovalInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/text-removal'
}

export type PostFalAiImageEditingTextRemovalResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingTextRemovalResponse =
  PostFalAiImageEditingTextRemovalResponses[keyof PostFalAiImageEditingTextRemovalResponses]

export type GetFalAiImageEditingTextRemovalRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/text-removal/requests/{request_id}'
}

export type GetFalAiImageEditingTextRemovalRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingTextRemovalOutput
}

export type GetFalAiImageEditingTextRemovalRequestsByRequestIdResponse =
  GetFalAiImageEditingTextRemovalRequestsByRequestIdResponses[keyof GetFalAiImageEditingTextRemovalRequestsByRequestIdResponses]

export type GetFalAiImageEditingPhotoRestorationRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/image-editing/photo-restoration/requests/{request_id}/status'
  }

export type GetFalAiImageEditingPhotoRestorationRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageEditingPhotoRestorationRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingPhotoRestorationRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingPhotoRestorationRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingPhotoRestorationRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/image-editing/photo-restoration/requests/{request_id}/cancel'
  }

export type PutFalAiImageEditingPhotoRestorationRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageEditingPhotoRestorationRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingPhotoRestorationRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingPhotoRestorationRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingPhotoRestorationData = {
  body: SchemaImageEditingPhotoRestorationInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/photo-restoration'
}

export type PostFalAiImageEditingPhotoRestorationResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingPhotoRestorationResponse =
  PostFalAiImageEditingPhotoRestorationResponses[keyof PostFalAiImageEditingPhotoRestorationResponses]

export type GetFalAiImageEditingPhotoRestorationRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/photo-restoration/requests/{request_id}'
}

export type GetFalAiImageEditingPhotoRestorationRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingPhotoRestorationOutput
}

export type GetFalAiImageEditingPhotoRestorationRequestsByRequestIdResponse =
  GetFalAiImageEditingPhotoRestorationRequestsByRequestIdResponses[keyof GetFalAiImageEditingPhotoRestorationRequestsByRequestIdResponses]

export type GetFalAiImageEditingWeatherEffectRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-editing/weather-effect/requests/{request_id}/status'
}

export type GetFalAiImageEditingWeatherEffectRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageEditingWeatherEffectRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingWeatherEffectRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingWeatherEffectRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingWeatherEffectRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/weather-effect/requests/{request_id}/cancel'
}

export type PutFalAiImageEditingWeatherEffectRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageEditingWeatherEffectRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingWeatherEffectRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingWeatherEffectRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingWeatherEffectData = {
  body: SchemaImageEditingWeatherEffectInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/weather-effect'
}

export type PostFalAiImageEditingWeatherEffectResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingWeatherEffectResponse =
  PostFalAiImageEditingWeatherEffectResponses[keyof PostFalAiImageEditingWeatherEffectResponses]

export type GetFalAiImageEditingWeatherEffectRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/weather-effect/requests/{request_id}'
}

export type GetFalAiImageEditingWeatherEffectRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingWeatherEffectOutput
}

export type GetFalAiImageEditingWeatherEffectRequestsByRequestIdResponse =
  GetFalAiImageEditingWeatherEffectRequestsByRequestIdResponses[keyof GetFalAiImageEditingWeatherEffectRequestsByRequestIdResponses]

export type GetFalAiImageEditingTimeOfDayRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-editing/time-of-day/requests/{request_id}/status'
}

export type GetFalAiImageEditingTimeOfDayRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImageEditingTimeOfDayRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingTimeOfDayRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingTimeOfDayRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingTimeOfDayRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/time-of-day/requests/{request_id}/cancel'
}

export type PutFalAiImageEditingTimeOfDayRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImageEditingTimeOfDayRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingTimeOfDayRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingTimeOfDayRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingTimeOfDayData = {
  body: SchemaImageEditingTimeOfDayInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/time-of-day'
}

export type PostFalAiImageEditingTimeOfDayResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingTimeOfDayResponse =
  PostFalAiImageEditingTimeOfDayResponses[keyof PostFalAiImageEditingTimeOfDayResponses]

export type GetFalAiImageEditingTimeOfDayRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/time-of-day/requests/{request_id}'
}

export type GetFalAiImageEditingTimeOfDayRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingTimeOfDayOutput
}

export type GetFalAiImageEditingTimeOfDayRequestsByRequestIdResponse =
  GetFalAiImageEditingTimeOfDayRequestsByRequestIdResponses[keyof GetFalAiImageEditingTimeOfDayRequestsByRequestIdResponses]

export type GetFalAiImageEditingStyleTransferRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-editing/style-transfer/requests/{request_id}/status'
}

export type GetFalAiImageEditingStyleTransferRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageEditingStyleTransferRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingStyleTransferRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingStyleTransferRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingStyleTransferRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/style-transfer/requests/{request_id}/cancel'
}

export type PutFalAiImageEditingStyleTransferRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageEditingStyleTransferRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingStyleTransferRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingStyleTransferRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingStyleTransferData = {
  body: SchemaImageEditingStyleTransferInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/style-transfer'
}

export type PostFalAiImageEditingStyleTransferResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingStyleTransferResponse =
  PostFalAiImageEditingStyleTransferResponses[keyof PostFalAiImageEditingStyleTransferResponses]

export type GetFalAiImageEditingStyleTransferRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/style-transfer/requests/{request_id}'
}

export type GetFalAiImageEditingStyleTransferRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingStyleTransferOutput
}

export type GetFalAiImageEditingStyleTransferRequestsByRequestIdResponse =
  GetFalAiImageEditingStyleTransferRequestsByRequestIdResponses[keyof GetFalAiImageEditingStyleTransferRequestsByRequestIdResponses]

export type GetFalAiImageEditingSceneCompositionRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/image-editing/scene-composition/requests/{request_id}/status'
  }

export type GetFalAiImageEditingSceneCompositionRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageEditingSceneCompositionRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingSceneCompositionRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingSceneCompositionRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingSceneCompositionRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/image-editing/scene-composition/requests/{request_id}/cancel'
  }

export type PutFalAiImageEditingSceneCompositionRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageEditingSceneCompositionRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingSceneCompositionRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingSceneCompositionRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingSceneCompositionData = {
  body: SchemaImageEditingSceneCompositionInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/scene-composition'
}

export type PostFalAiImageEditingSceneCompositionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingSceneCompositionResponse =
  PostFalAiImageEditingSceneCompositionResponses[keyof PostFalAiImageEditingSceneCompositionResponses]

export type GetFalAiImageEditingSceneCompositionRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/scene-composition/requests/{request_id}'
}

export type GetFalAiImageEditingSceneCompositionRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingSceneCompositionOutput
}

export type GetFalAiImageEditingSceneCompositionRequestsByRequestIdResponse =
  GetFalAiImageEditingSceneCompositionRequestsByRequestIdResponses[keyof GetFalAiImageEditingSceneCompositionRequestsByRequestIdResponses]

export type GetFalAiImageEditingProfessionalPhotoRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/image-editing/professional-photo/requests/{request_id}/status'
  }

export type GetFalAiImageEditingProfessionalPhotoRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageEditingProfessionalPhotoRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingProfessionalPhotoRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingProfessionalPhotoRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingProfessionalPhotoRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/image-editing/professional-photo/requests/{request_id}/cancel'
  }

export type PutFalAiImageEditingProfessionalPhotoRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageEditingProfessionalPhotoRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingProfessionalPhotoRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingProfessionalPhotoRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingProfessionalPhotoData = {
  body: SchemaImageEditingProfessionalPhotoInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/professional-photo'
}

export type PostFalAiImageEditingProfessionalPhotoResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingProfessionalPhotoResponse =
  PostFalAiImageEditingProfessionalPhotoResponses[keyof PostFalAiImageEditingProfessionalPhotoResponses]

export type GetFalAiImageEditingProfessionalPhotoRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/professional-photo/requests/{request_id}'
}

export type GetFalAiImageEditingProfessionalPhotoRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaImageEditingProfessionalPhotoOutput
  }

export type GetFalAiImageEditingProfessionalPhotoRequestsByRequestIdResponse =
  GetFalAiImageEditingProfessionalPhotoRequestsByRequestIdResponses[keyof GetFalAiImageEditingProfessionalPhotoRequestsByRequestIdResponses]

export type GetFalAiImageEditingObjectRemovalRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-editing/object-removal/requests/{request_id}/status'
}

export type GetFalAiImageEditingObjectRemovalRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageEditingObjectRemovalRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingObjectRemovalRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingObjectRemovalRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingObjectRemovalRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/object-removal/requests/{request_id}/cancel'
}

export type PutFalAiImageEditingObjectRemovalRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageEditingObjectRemovalRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingObjectRemovalRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingObjectRemovalRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingObjectRemovalData = {
  body: SchemaImageEditingObjectRemovalInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/object-removal'
}

export type PostFalAiImageEditingObjectRemovalResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingObjectRemovalResponse =
  PostFalAiImageEditingObjectRemovalResponses[keyof PostFalAiImageEditingObjectRemovalResponses]

export type GetFalAiImageEditingObjectRemovalRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/object-removal/requests/{request_id}'
}

export type GetFalAiImageEditingObjectRemovalRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingObjectRemovalOutput
}

export type GetFalAiImageEditingObjectRemovalRequestsByRequestIdResponse =
  GetFalAiImageEditingObjectRemovalRequestsByRequestIdResponses[keyof GetFalAiImageEditingObjectRemovalRequestsByRequestIdResponses]

export type GetFalAiImageEditingHairChangeRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-editing/hair-change/requests/{request_id}/status'
}

export type GetFalAiImageEditingHairChangeRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImageEditingHairChangeRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingHairChangeRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingHairChangeRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingHairChangeRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/hair-change/requests/{request_id}/cancel'
}

export type PutFalAiImageEditingHairChangeRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImageEditingHairChangeRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingHairChangeRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingHairChangeRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingHairChangeData = {
  body: SchemaImageEditingHairChangeInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/hair-change'
}

export type PostFalAiImageEditingHairChangeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingHairChangeResponse =
  PostFalAiImageEditingHairChangeResponses[keyof PostFalAiImageEditingHairChangeResponses]

export type GetFalAiImageEditingHairChangeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/hair-change/requests/{request_id}'
}

export type GetFalAiImageEditingHairChangeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingHairChangeOutput
}

export type GetFalAiImageEditingHairChangeRequestsByRequestIdResponse =
  GetFalAiImageEditingHairChangeRequestsByRequestIdResponses[keyof GetFalAiImageEditingHairChangeRequestsByRequestIdResponses]

export type GetFalAiImageEditingFaceEnhancementRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-editing/face-enhancement/requests/{request_id}/status'
}

export type GetFalAiImageEditingFaceEnhancementRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageEditingFaceEnhancementRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingFaceEnhancementRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingFaceEnhancementRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingFaceEnhancementRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/face-enhancement/requests/{request_id}/cancel'
}

export type PutFalAiImageEditingFaceEnhancementRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageEditingFaceEnhancementRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingFaceEnhancementRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingFaceEnhancementRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingFaceEnhancementData = {
  body: SchemaImageEditingFaceEnhancementInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/face-enhancement'
}

export type PostFalAiImageEditingFaceEnhancementResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingFaceEnhancementResponse =
  PostFalAiImageEditingFaceEnhancementResponses[keyof PostFalAiImageEditingFaceEnhancementResponses]

export type GetFalAiImageEditingFaceEnhancementRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/face-enhancement/requests/{request_id}'
}

export type GetFalAiImageEditingFaceEnhancementRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingFaceEnhancementOutput
}

export type GetFalAiImageEditingFaceEnhancementRequestsByRequestIdResponse =
  GetFalAiImageEditingFaceEnhancementRequestsByRequestIdResponses[keyof GetFalAiImageEditingFaceEnhancementRequestsByRequestIdResponses]

export type GetFalAiImageEditingExpressionChangeRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/image-editing/expression-change/requests/{request_id}/status'
  }

export type GetFalAiImageEditingExpressionChangeRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageEditingExpressionChangeRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingExpressionChangeRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingExpressionChangeRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingExpressionChangeRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/image-editing/expression-change/requests/{request_id}/cancel'
  }

export type PutFalAiImageEditingExpressionChangeRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageEditingExpressionChangeRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingExpressionChangeRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingExpressionChangeRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingExpressionChangeData = {
  body: SchemaImageEditingExpressionChangeInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/expression-change'
}

export type PostFalAiImageEditingExpressionChangeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingExpressionChangeResponse =
  PostFalAiImageEditingExpressionChangeResponses[keyof PostFalAiImageEditingExpressionChangeResponses]

export type GetFalAiImageEditingExpressionChangeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/expression-change/requests/{request_id}'
}

export type GetFalAiImageEditingExpressionChangeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingExpressionChangeOutput
}

export type GetFalAiImageEditingExpressionChangeRequestsByRequestIdResponse =
  GetFalAiImageEditingExpressionChangeRequestsByRequestIdResponses[keyof GetFalAiImageEditingExpressionChangeRequestsByRequestIdResponses]

export type GetFalAiImageEditingColorCorrectionRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-editing/color-correction/requests/{request_id}/status'
}

export type GetFalAiImageEditingColorCorrectionRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageEditingColorCorrectionRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingColorCorrectionRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingColorCorrectionRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingColorCorrectionRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/color-correction/requests/{request_id}/cancel'
}

export type PutFalAiImageEditingColorCorrectionRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageEditingColorCorrectionRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingColorCorrectionRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingColorCorrectionRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingColorCorrectionData = {
  body: SchemaImageEditingColorCorrectionInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/color-correction'
}

export type PostFalAiImageEditingColorCorrectionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingColorCorrectionResponse =
  PostFalAiImageEditingColorCorrectionResponses[keyof PostFalAiImageEditingColorCorrectionResponses]

export type GetFalAiImageEditingColorCorrectionRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/color-correction/requests/{request_id}'
}

export type GetFalAiImageEditingColorCorrectionRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingColorCorrectionOutput
}

export type GetFalAiImageEditingColorCorrectionRequestsByRequestIdResponse =
  GetFalAiImageEditingColorCorrectionRequestsByRequestIdResponses[keyof GetFalAiImageEditingColorCorrectionRequestsByRequestIdResponses]

export type GetFalAiImageEditingCartoonifyRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-editing/cartoonify/requests/{request_id}/status'
}

export type GetFalAiImageEditingCartoonifyRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImageEditingCartoonifyRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingCartoonifyRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingCartoonifyRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingCartoonifyRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/cartoonify/requests/{request_id}/cancel'
}

export type PutFalAiImageEditingCartoonifyRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImageEditingCartoonifyRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingCartoonifyRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingCartoonifyRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingCartoonifyData = {
  body: SchemaImageEditingCartoonifyInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/cartoonify'
}

export type PostFalAiImageEditingCartoonifyResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingCartoonifyResponse =
  PostFalAiImageEditingCartoonifyResponses[keyof PostFalAiImageEditingCartoonifyResponses]

export type GetFalAiImageEditingCartoonifyRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/cartoonify/requests/{request_id}'
}

export type GetFalAiImageEditingCartoonifyRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingCartoonifyOutput
}

export type GetFalAiImageEditingCartoonifyRequestsByRequestIdResponse =
  GetFalAiImageEditingCartoonifyRequestsByRequestIdResponses[keyof GetFalAiImageEditingCartoonifyRequestsByRequestIdResponses]

export type GetFalAiImageEditingBackgroundChangeRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/image-editing/background-change/requests/{request_id}/status'
  }

export type GetFalAiImageEditingBackgroundChangeRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageEditingBackgroundChangeRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingBackgroundChangeRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingBackgroundChangeRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingBackgroundChangeRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/image-editing/background-change/requests/{request_id}/cancel'
  }

export type PutFalAiImageEditingBackgroundChangeRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageEditingBackgroundChangeRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingBackgroundChangeRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingBackgroundChangeRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingBackgroundChangeData = {
  body: SchemaImageEditingBackgroundChangeInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/background-change'
}

export type PostFalAiImageEditingBackgroundChangeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingBackgroundChangeResponse =
  PostFalAiImageEditingBackgroundChangeResponses[keyof PostFalAiImageEditingBackgroundChangeResponses]

export type GetFalAiImageEditingBackgroundChangeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/background-change/requests/{request_id}'
}

export type GetFalAiImageEditingBackgroundChangeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingBackgroundChangeOutput
}

export type GetFalAiImageEditingBackgroundChangeRequestsByRequestIdResponse =
  GetFalAiImageEditingBackgroundChangeRequestsByRequestIdResponses[keyof GetFalAiImageEditingBackgroundChangeRequestsByRequestIdResponses]

export type GetFalAiImageEditingAgeProgressionRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-editing/age-progression/requests/{request_id}/status'
}

export type GetFalAiImageEditingAgeProgressionRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageEditingAgeProgressionRequestsByRequestIdStatusResponse =
  GetFalAiImageEditingAgeProgressionRequestsByRequestIdStatusResponses[keyof GetFalAiImageEditingAgeProgressionRequestsByRequestIdStatusResponses]

export type PutFalAiImageEditingAgeProgressionRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/age-progression/requests/{request_id}/cancel'
}

export type PutFalAiImageEditingAgeProgressionRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageEditingAgeProgressionRequestsByRequestIdCancelResponse =
  PutFalAiImageEditingAgeProgressionRequestsByRequestIdCancelResponses[keyof PutFalAiImageEditingAgeProgressionRequestsByRequestIdCancelResponses]

export type PostFalAiImageEditingAgeProgressionData = {
  body: SchemaImageEditingAgeProgressionInput
  path?: never
  query?: never
  url: '/fal-ai/image-editing/age-progression'
}

export type PostFalAiImageEditingAgeProgressionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageEditingAgeProgressionResponse =
  PostFalAiImageEditingAgeProgressionResponses[keyof PostFalAiImageEditingAgeProgressionResponses]

export type GetFalAiImageEditingAgeProgressionRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-editing/age-progression/requests/{request_id}'
}

export type GetFalAiImageEditingAgeProgressionRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageEditingAgeProgressionOutput
}

export type GetFalAiImageEditingAgeProgressionRequestsByRequestIdResponse =
  GetFalAiImageEditingAgeProgressionRequestsByRequestIdResponses[keyof GetFalAiImageEditingAgeProgressionRequestsByRequestIdResponses]

export type GetFalAiFluxProKontextMaxMultiRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-pro/kontext/max/multi/requests/{request_id}/status'
}

export type GetFalAiFluxProKontextMaxMultiRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxProKontextMaxMultiRequestsByRequestIdStatusResponse =
  GetFalAiFluxProKontextMaxMultiRequestsByRequestIdStatusResponses[keyof GetFalAiFluxProKontextMaxMultiRequestsByRequestIdStatusResponses]

export type PutFalAiFluxProKontextMaxMultiRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/kontext/max/multi/requests/{request_id}/cancel'
}

export type PutFalAiFluxProKontextMaxMultiRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxProKontextMaxMultiRequestsByRequestIdCancelResponse =
  PutFalAiFluxProKontextMaxMultiRequestsByRequestIdCancelResponses[keyof PutFalAiFluxProKontextMaxMultiRequestsByRequestIdCancelResponses]

export type PostFalAiFluxProKontextMaxMultiData = {
  body: SchemaFluxProKontextMaxMultiInput
  path?: never
  query?: never
  url: '/fal-ai/flux-pro/kontext/max/multi'
}

export type PostFalAiFluxProKontextMaxMultiResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxProKontextMaxMultiResponse =
  PostFalAiFluxProKontextMaxMultiResponses[keyof PostFalAiFluxProKontextMaxMultiResponses]

export type GetFalAiFluxProKontextMaxMultiRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/kontext/max/multi/requests/{request_id}'
}

export type GetFalAiFluxProKontextMaxMultiRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxProKontextMaxMultiOutput
}

export type GetFalAiFluxProKontextMaxMultiRequestsByRequestIdResponse =
  GetFalAiFluxProKontextMaxMultiRequestsByRequestIdResponses[keyof GetFalAiFluxProKontextMaxMultiRequestsByRequestIdResponses]

export type GetFalAiFluxProKontextMultiRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-pro/kontext/multi/requests/{request_id}/status'
}

export type GetFalAiFluxProKontextMultiRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxProKontextMultiRequestsByRequestIdStatusResponse =
  GetFalAiFluxProKontextMultiRequestsByRequestIdStatusResponses[keyof GetFalAiFluxProKontextMultiRequestsByRequestIdStatusResponses]

export type PutFalAiFluxProKontextMultiRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/kontext/multi/requests/{request_id}/cancel'
}

export type PutFalAiFluxProKontextMultiRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxProKontextMultiRequestsByRequestIdCancelResponse =
  PutFalAiFluxProKontextMultiRequestsByRequestIdCancelResponses[keyof PutFalAiFluxProKontextMultiRequestsByRequestIdCancelResponses]

export type PostFalAiFluxProKontextMultiData = {
  body: SchemaFluxProKontextMultiInput
  path?: never
  query?: never
  url: '/fal-ai/flux-pro/kontext/multi'
}

export type PostFalAiFluxProKontextMultiResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxProKontextMultiResponse =
  PostFalAiFluxProKontextMultiResponses[keyof PostFalAiFluxProKontextMultiResponses]

export type GetFalAiFluxProKontextMultiRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/kontext/multi/requests/{request_id}'
}

export type GetFalAiFluxProKontextMultiRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxProKontextMultiOutput
}

export type GetFalAiFluxProKontextMultiRequestsByRequestIdResponse =
  GetFalAiFluxProKontextMultiRequestsByRequestIdResponses[keyof GetFalAiFluxProKontextMultiRequestsByRequestIdResponses]

export type GetFalAiFluxProKontextMaxRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-pro/kontext/max/requests/{request_id}/status'
}

export type GetFalAiFluxProKontextMaxRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxProKontextMaxRequestsByRequestIdStatusResponse =
  GetFalAiFluxProKontextMaxRequestsByRequestIdStatusResponses[keyof GetFalAiFluxProKontextMaxRequestsByRequestIdStatusResponses]

export type PutFalAiFluxProKontextMaxRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/kontext/max/requests/{request_id}/cancel'
}

export type PutFalAiFluxProKontextMaxRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxProKontextMaxRequestsByRequestIdCancelResponse =
  PutFalAiFluxProKontextMaxRequestsByRequestIdCancelResponses[keyof PutFalAiFluxProKontextMaxRequestsByRequestIdCancelResponses]

export type PostFalAiFluxProKontextMaxData = {
  body: SchemaFluxProKontextMaxInput
  path?: never
  query?: never
  url: '/fal-ai/flux-pro/kontext/max'
}

export type PostFalAiFluxProKontextMaxResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxProKontextMaxResponse =
  PostFalAiFluxProKontextMaxResponses[keyof PostFalAiFluxProKontextMaxResponses]

export type GetFalAiFluxProKontextMaxRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/kontext/max/requests/{request_id}'
}

export type GetFalAiFluxProKontextMaxRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxProKontextMaxOutput
}

export type GetFalAiFluxProKontextMaxRequestsByRequestIdResponse =
  GetFalAiFluxProKontextMaxRequestsByRequestIdResponses[keyof GetFalAiFluxProKontextMaxRequestsByRequestIdResponses]

export type GetFalAiFluxKontextDevRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-kontext/dev/requests/{request_id}/status'
}

export type GetFalAiFluxKontextDevRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxKontextDevRequestsByRequestIdStatusResponse =
  GetFalAiFluxKontextDevRequestsByRequestIdStatusResponses[keyof GetFalAiFluxKontextDevRequestsByRequestIdStatusResponses]

export type PutFalAiFluxKontextDevRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-kontext/dev/requests/{request_id}/cancel'
}

export type PutFalAiFluxKontextDevRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxKontextDevRequestsByRequestIdCancelResponse =
  PutFalAiFluxKontextDevRequestsByRequestIdCancelResponses[keyof PutFalAiFluxKontextDevRequestsByRequestIdCancelResponses]

export type PostFalAiFluxKontextDevData = {
  body: SchemaFluxKontextDevInput
  path?: never
  query?: never
  url: '/fal-ai/flux-kontext/dev'
}

export type PostFalAiFluxKontextDevResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxKontextDevResponse =
  PostFalAiFluxKontextDevResponses[keyof PostFalAiFluxKontextDevResponses]

export type GetFalAiFluxKontextDevRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-kontext/dev/requests/{request_id}'
}

export type GetFalAiFluxKontextDevRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxKontextDevOutput
}

export type GetFalAiFluxKontextDevRequestsByRequestIdResponse =
  GetFalAiFluxKontextDevRequestsByRequestIdResponses[keyof GetFalAiFluxKontextDevRequestsByRequestIdResponses]

export type GetFalAiBagelEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/bagel/edit/requests/{request_id}/status'
}

export type GetFalAiBagelEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiBagelEditRequestsByRequestIdStatusResponse =
  GetFalAiBagelEditRequestsByRequestIdStatusResponses[keyof GetFalAiBagelEditRequestsByRequestIdStatusResponses]

export type PutFalAiBagelEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bagel/edit/requests/{request_id}/cancel'
}

export type PutFalAiBagelEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiBagelEditRequestsByRequestIdCancelResponse =
  PutFalAiBagelEditRequestsByRequestIdCancelResponses[keyof PutFalAiBagelEditRequestsByRequestIdCancelResponses]

export type PostFalAiBagelEditData = {
  body: SchemaBagelEditInput
  path?: never
  query?: never
  url: '/fal-ai/bagel/edit'
}

export type PostFalAiBagelEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBagelEditResponse =
  PostFalAiBagelEditResponses[keyof PostFalAiBagelEditResponses]

export type GetFalAiBagelEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bagel/edit/requests/{request_id}'
}

export type GetFalAiBagelEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaBagelEditOutput
}

export type GetFalAiBagelEditRequestsByRequestIdResponse =
  GetFalAiBagelEditRequestsByRequestIdResponses[keyof GetFalAiBagelEditRequestsByRequestIdResponses]

export type GetSmoretalkAiRembgEnhanceRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/smoretalk-ai/rembg-enhance/requests/{request_id}/status'
}

export type GetSmoretalkAiRembgEnhanceRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetSmoretalkAiRembgEnhanceRequestsByRequestIdStatusResponse =
  GetSmoretalkAiRembgEnhanceRequestsByRequestIdStatusResponses[keyof GetSmoretalkAiRembgEnhanceRequestsByRequestIdStatusResponses]

export type PutSmoretalkAiRembgEnhanceRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/smoretalk-ai/rembg-enhance/requests/{request_id}/cancel'
}

export type PutSmoretalkAiRembgEnhanceRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutSmoretalkAiRembgEnhanceRequestsByRequestIdCancelResponse =
  PutSmoretalkAiRembgEnhanceRequestsByRequestIdCancelResponses[keyof PutSmoretalkAiRembgEnhanceRequestsByRequestIdCancelResponses]

export type PostSmoretalkAiRembgEnhanceData = {
  body: SchemaRembgEnhanceInput
  path?: never
  query?: never
  url: '/smoretalk-ai/rembg-enhance'
}

export type PostSmoretalkAiRembgEnhanceResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostSmoretalkAiRembgEnhanceResponse =
  PostSmoretalkAiRembgEnhanceResponses[keyof PostSmoretalkAiRembgEnhanceResponses]

export type GetSmoretalkAiRembgEnhanceRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/smoretalk-ai/rembg-enhance/requests/{request_id}'
}

export type GetSmoretalkAiRembgEnhanceRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaRembgEnhanceOutput
}

export type GetSmoretalkAiRembgEnhanceRequestsByRequestIdResponse =
  GetSmoretalkAiRembgEnhanceRequestsByRequestIdResponses[keyof GetSmoretalkAiRembgEnhanceRequestsByRequestIdResponses]

export type GetFalAiRecraftUpscaleCreativeRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/recraft/upscale/creative/requests/{request_id}/status'
}

export type GetFalAiRecraftUpscaleCreativeRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiRecraftUpscaleCreativeRequestsByRequestIdStatusResponse =
  GetFalAiRecraftUpscaleCreativeRequestsByRequestIdStatusResponses[keyof GetFalAiRecraftUpscaleCreativeRequestsByRequestIdStatusResponses]

export type PutFalAiRecraftUpscaleCreativeRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/recraft/upscale/creative/requests/{request_id}/cancel'
}

export type PutFalAiRecraftUpscaleCreativeRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiRecraftUpscaleCreativeRequestsByRequestIdCancelResponse =
  PutFalAiRecraftUpscaleCreativeRequestsByRequestIdCancelResponses[keyof PutFalAiRecraftUpscaleCreativeRequestsByRequestIdCancelResponses]

export type PostFalAiRecraftUpscaleCreativeData = {
  body: SchemaRecraftUpscaleCreativeInput
  path?: never
  query?: never
  url: '/fal-ai/recraft/upscale/creative'
}

export type PostFalAiRecraftUpscaleCreativeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiRecraftUpscaleCreativeResponse =
  PostFalAiRecraftUpscaleCreativeResponses[keyof PostFalAiRecraftUpscaleCreativeResponses]

export type GetFalAiRecraftUpscaleCreativeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/recraft/upscale/creative/requests/{request_id}'
}

export type GetFalAiRecraftUpscaleCreativeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaRecraftUpscaleCreativeOutput
}

export type GetFalAiRecraftUpscaleCreativeRequestsByRequestIdResponse =
  GetFalAiRecraftUpscaleCreativeRequestsByRequestIdResponses[keyof GetFalAiRecraftUpscaleCreativeRequestsByRequestIdResponses]

export type GetFalAiRecraftUpscaleCrispRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/recraft/upscale/crisp/requests/{request_id}/status'
}

export type GetFalAiRecraftUpscaleCrispRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiRecraftUpscaleCrispRequestsByRequestIdStatusResponse =
  GetFalAiRecraftUpscaleCrispRequestsByRequestIdStatusResponses[keyof GetFalAiRecraftUpscaleCrispRequestsByRequestIdStatusResponses]

export type PutFalAiRecraftUpscaleCrispRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/recraft/upscale/crisp/requests/{request_id}/cancel'
}

export type PutFalAiRecraftUpscaleCrispRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiRecraftUpscaleCrispRequestsByRequestIdCancelResponse =
  PutFalAiRecraftUpscaleCrispRequestsByRequestIdCancelResponses[keyof PutFalAiRecraftUpscaleCrispRequestsByRequestIdCancelResponses]

export type PostFalAiRecraftUpscaleCrispData = {
  body: SchemaRecraftUpscaleCrispInput
  path?: never
  query?: never
  url: '/fal-ai/recraft/upscale/crisp'
}

export type PostFalAiRecraftUpscaleCrispResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiRecraftUpscaleCrispResponse =
  PostFalAiRecraftUpscaleCrispResponses[keyof PostFalAiRecraftUpscaleCrispResponses]

export type GetFalAiRecraftUpscaleCrispRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/recraft/upscale/crisp/requests/{request_id}'
}

export type GetFalAiRecraftUpscaleCrispRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaRecraftUpscaleCrispOutput
}

export type GetFalAiRecraftUpscaleCrispRequestsByRequestIdResponse =
  GetFalAiRecraftUpscaleCrispRequestsByRequestIdResponses[keyof GetFalAiRecraftUpscaleCrispRequestsByRequestIdResponses]

export type GetFalAiRecraftV3ImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/recraft/v3/image-to-image/requests/{request_id}/status'
}

export type GetFalAiRecraftV3ImageToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiRecraftV3ImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiRecraftV3ImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiRecraftV3ImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiRecraftV3ImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/recraft/v3/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiRecraftV3ImageToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiRecraftV3ImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiRecraftV3ImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiRecraftV3ImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiRecraftV3ImageToImageData = {
  body: SchemaRecraftV3ImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/recraft/v3/image-to-image'
}

export type PostFalAiRecraftV3ImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiRecraftV3ImageToImageResponse =
  PostFalAiRecraftV3ImageToImageResponses[keyof PostFalAiRecraftV3ImageToImageResponses]

export type GetFalAiRecraftV3ImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/recraft/v3/image-to-image/requests/{request_id}'
}

export type GetFalAiRecraftV3ImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaRecraftV3ImageToImageOutput
}

export type GetFalAiRecraftV3ImageToImageRequestsByRequestIdResponse =
  GetFalAiRecraftV3ImageToImageRequestsByRequestIdResponses[keyof GetFalAiRecraftV3ImageToImageRequestsByRequestIdResponses]

export type GetFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/minimax/image-01/subject-reference/requests/{request_id}/status'
  }

export type GetFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdStatusResponse =
  GetFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdStatusResponses[keyof GetFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdStatusResponses]

export type PutFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/minimax/image-01/subject-reference/requests/{request_id}/cancel'
  }

export type PutFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdCancelResponse =
  PutFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdCancelResponses[keyof PutFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdCancelResponses]

export type PostFalAiMinimaxImage01SubjectReferenceData = {
  body: SchemaMinimaxImage01SubjectReferenceInput
  path?: never
  query?: never
  url: '/fal-ai/minimax/image-01/subject-reference'
}

export type PostFalAiMinimaxImage01SubjectReferenceResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiMinimaxImage01SubjectReferenceResponse =
  PostFalAiMinimaxImage01SubjectReferenceResponses[keyof PostFalAiMinimaxImage01SubjectReferenceResponses]

export type GetFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/minimax/image-01/subject-reference/requests/{request_id}'
}

export type GetFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaMinimaxImage01SubjectReferenceOutput
  }

export type GetFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdResponse =
  GetFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdResponses[keyof GetFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdResponses]

export type GetFalAiHidreamI1FullImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/hidream-i1-full/image-to-image/requests/{request_id}/status'
}

export type GetFalAiHidreamI1FullImageToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiHidreamI1FullImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiHidreamI1FullImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiHidreamI1FullImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiHidreamI1FullImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/hidream-i1-full/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiHidreamI1FullImageToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiHidreamI1FullImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiHidreamI1FullImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiHidreamI1FullImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiHidreamI1FullImageToImageData = {
  body: SchemaHidreamI1FullImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/hidream-i1-full/image-to-image'
}

export type PostFalAiHidreamI1FullImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiHidreamI1FullImageToImageResponse =
  PostFalAiHidreamI1FullImageToImageResponses[keyof PostFalAiHidreamI1FullImageToImageResponses]

export type GetFalAiHidreamI1FullImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/hidream-i1-full/image-to-image/requests/{request_id}'
}

export type GetFalAiHidreamI1FullImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaHidreamI1FullImageToImageOutput
}

export type GetFalAiHidreamI1FullImageToImageRequestsByRequestIdResponse =
  GetFalAiHidreamI1FullImageToImageRequestsByRequestIdResponses[keyof GetFalAiHidreamI1FullImageToImageRequestsByRequestIdResponses]

export type GetFalAiIdeogramV3ReframeRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ideogram/v3/reframe/requests/{request_id}/status'
}

export type GetFalAiIdeogramV3ReframeRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIdeogramV3ReframeRequestsByRequestIdStatusResponse =
  GetFalAiIdeogramV3ReframeRequestsByRequestIdStatusResponses[keyof GetFalAiIdeogramV3ReframeRequestsByRequestIdStatusResponses]

export type PutFalAiIdeogramV3ReframeRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v3/reframe/requests/{request_id}/cancel'
}

export type PutFalAiIdeogramV3ReframeRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIdeogramV3ReframeRequestsByRequestIdCancelResponse =
  PutFalAiIdeogramV3ReframeRequestsByRequestIdCancelResponses[keyof PutFalAiIdeogramV3ReframeRequestsByRequestIdCancelResponses]

export type PostFalAiIdeogramV3ReframeData = {
  body: SchemaIdeogramV3ReframeInput
  path?: never
  query?: never
  url: '/fal-ai/ideogram/v3/reframe'
}

export type PostFalAiIdeogramV3ReframeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIdeogramV3ReframeResponse =
  PostFalAiIdeogramV3ReframeResponses[keyof PostFalAiIdeogramV3ReframeResponses]

export type GetFalAiIdeogramV3ReframeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v3/reframe/requests/{request_id}'
}

export type GetFalAiIdeogramV3ReframeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIdeogramV3ReframeOutput
}

export type GetFalAiIdeogramV3ReframeRequestsByRequestIdResponse =
  GetFalAiIdeogramV3ReframeRequestsByRequestIdResponses[keyof GetFalAiIdeogramV3ReframeRequestsByRequestIdResponses]

export type GetFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ideogram/v3/replace-background/requests/{request_id}/status'
}

export type GetFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdStatusResponse =
  GetFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdStatusResponses[keyof GetFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdStatusResponses]

export type PutFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v3/replace-background/requests/{request_id}/cancel'
}

export type PutFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdCancelResponse =
  PutFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdCancelResponses[keyof PutFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdCancelResponses]

export type PostFalAiIdeogramV3ReplaceBackgroundData = {
  body: SchemaIdeogramV3ReplaceBackgroundInput
  path?: never
  query?: never
  url: '/fal-ai/ideogram/v3/replace-background'
}

export type PostFalAiIdeogramV3ReplaceBackgroundResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIdeogramV3ReplaceBackgroundResponse =
  PostFalAiIdeogramV3ReplaceBackgroundResponses[keyof PostFalAiIdeogramV3ReplaceBackgroundResponses]

export type GetFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v3/replace-background/requests/{request_id}'
}

export type GetFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIdeogramV3ReplaceBackgroundOutput
}

export type GetFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdResponse =
  GetFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdResponses[keyof GetFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdResponses]

export type GetFalAiIdeogramV3RemixRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ideogram/v3/remix/requests/{request_id}/status'
}

export type GetFalAiIdeogramV3RemixRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIdeogramV3RemixRequestsByRequestIdStatusResponse =
  GetFalAiIdeogramV3RemixRequestsByRequestIdStatusResponses[keyof GetFalAiIdeogramV3RemixRequestsByRequestIdStatusResponses]

export type PutFalAiIdeogramV3RemixRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v3/remix/requests/{request_id}/cancel'
}

export type PutFalAiIdeogramV3RemixRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIdeogramV3RemixRequestsByRequestIdCancelResponse =
  PutFalAiIdeogramV3RemixRequestsByRequestIdCancelResponses[keyof PutFalAiIdeogramV3RemixRequestsByRequestIdCancelResponses]

export type PostFalAiIdeogramV3RemixData = {
  body: SchemaIdeogramV3RemixInput
  path?: never
  query?: never
  url: '/fal-ai/ideogram/v3/remix'
}

export type PostFalAiIdeogramV3RemixResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIdeogramV3RemixResponse =
  PostFalAiIdeogramV3RemixResponses[keyof PostFalAiIdeogramV3RemixResponses]

export type GetFalAiIdeogramV3RemixRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v3/remix/requests/{request_id}'
}

export type GetFalAiIdeogramV3RemixRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIdeogramV3RemixOutput
}

export type GetFalAiIdeogramV3RemixRequestsByRequestIdResponse =
  GetFalAiIdeogramV3RemixRequestsByRequestIdResponses[keyof GetFalAiIdeogramV3RemixRequestsByRequestIdResponses]

export type GetFalAiIdeogramV3EditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ideogram/v3/edit/requests/{request_id}/status'
}

export type GetFalAiIdeogramV3EditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIdeogramV3EditRequestsByRequestIdStatusResponse =
  GetFalAiIdeogramV3EditRequestsByRequestIdStatusResponses[keyof GetFalAiIdeogramV3EditRequestsByRequestIdStatusResponses]

export type PutFalAiIdeogramV3EditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v3/edit/requests/{request_id}/cancel'
}

export type PutFalAiIdeogramV3EditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIdeogramV3EditRequestsByRequestIdCancelResponse =
  PutFalAiIdeogramV3EditRequestsByRequestIdCancelResponses[keyof PutFalAiIdeogramV3EditRequestsByRequestIdCancelResponses]

export type PostFalAiIdeogramV3EditData = {
  body: SchemaIdeogramV3EditInput
  path?: never
  query?: never
  url: '/fal-ai/ideogram/v3/edit'
}

export type PostFalAiIdeogramV3EditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIdeogramV3EditResponse =
  PostFalAiIdeogramV3EditResponses[keyof PostFalAiIdeogramV3EditResponses]

export type GetFalAiIdeogramV3EditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v3/edit/requests/{request_id}'
}

export type GetFalAiIdeogramV3EditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIdeogramV3EditOutput
}

export type GetFalAiIdeogramV3EditRequestsByRequestIdResponse =
  GetFalAiIdeogramV3EditRequestsByRequestIdResponses[keyof GetFalAiIdeogramV3EditRequestsByRequestIdResponses]

export type GetFalAiStep1xEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/step1x-edit/requests/{request_id}/status'
}

export type GetFalAiStep1xEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiStep1xEditRequestsByRequestIdStatusResponse =
  GetFalAiStep1xEditRequestsByRequestIdStatusResponses[keyof GetFalAiStep1xEditRequestsByRequestIdStatusResponses]

export type PutFalAiStep1xEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/step1x-edit/requests/{request_id}/cancel'
}

export type PutFalAiStep1xEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiStep1xEditRequestsByRequestIdCancelResponse =
  PutFalAiStep1xEditRequestsByRequestIdCancelResponses[keyof PutFalAiStep1xEditRequestsByRequestIdCancelResponses]

export type PostFalAiStep1xEditData = {
  body: SchemaStep1xEditInput
  path?: never
  query?: never
  url: '/fal-ai/step1x-edit'
}

export type PostFalAiStep1xEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiStep1xEditResponse =
  PostFalAiStep1xEditResponses[keyof PostFalAiStep1xEditResponses]

export type GetFalAiStep1xEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/step1x-edit/requests/{request_id}'
}

export type GetFalAiStep1xEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaStep1xEditOutput
}

export type GetFalAiStep1xEditRequestsByRequestIdResponse =
  GetFalAiStep1xEditRequestsByRequestIdResponses[keyof GetFalAiStep1xEditRequestsByRequestIdResponses]

export type GetFalAiImage2SvgRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image2svg/requests/{request_id}/status'
}

export type GetFalAiImage2SvgRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImage2SvgRequestsByRequestIdStatusResponse =
  GetFalAiImage2SvgRequestsByRequestIdStatusResponses[keyof GetFalAiImage2SvgRequestsByRequestIdStatusResponses]

export type PutFalAiImage2SvgRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image2svg/requests/{request_id}/cancel'
}

export type PutFalAiImage2SvgRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImage2SvgRequestsByRequestIdCancelResponse =
  PutFalAiImage2SvgRequestsByRequestIdCancelResponses[keyof PutFalAiImage2SvgRequestsByRequestIdCancelResponses]

export type PostFalAiImage2SvgData = {
  body: SchemaImage2SvgInput
  path?: never
  query?: never
  url: '/fal-ai/image2svg'
}

export type PostFalAiImage2SvgResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImage2SvgResponse =
  PostFalAiImage2SvgResponses[keyof PostFalAiImage2SvgResponses]

export type GetFalAiImage2SvgRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image2svg/requests/{request_id}'
}

export type GetFalAiImage2SvgRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImage2SvgOutput
}

export type GetFalAiImage2SvgRequestsByRequestIdResponse =
  GetFalAiImage2SvgRequestsByRequestIdResponses[keyof GetFalAiImage2SvgRequestsByRequestIdResponses]

export type GetFalAiUnoRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/uno/requests/{request_id}/status'
}

export type GetFalAiUnoRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiUnoRequestsByRequestIdStatusResponse =
  GetFalAiUnoRequestsByRequestIdStatusResponses[keyof GetFalAiUnoRequestsByRequestIdStatusResponses]

export type PutFalAiUnoRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/uno/requests/{request_id}/cancel'
}

export type PutFalAiUnoRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiUnoRequestsByRequestIdCancelResponse =
  PutFalAiUnoRequestsByRequestIdCancelResponses[keyof PutFalAiUnoRequestsByRequestIdCancelResponses]

export type PostFalAiUnoData = {
  body: SchemaUnoInput
  path?: never
  query?: never
  url: '/fal-ai/uno'
}

export type PostFalAiUnoResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiUnoResponse =
  PostFalAiUnoResponses[keyof PostFalAiUnoResponses]

export type GetFalAiUnoRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/uno/requests/{request_id}'
}

export type GetFalAiUnoRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaUnoOutput
}

export type GetFalAiUnoRequestsByRequestIdResponse =
  GetFalAiUnoRequestsByRequestIdResponses[keyof GetFalAiUnoRequestsByRequestIdResponses]

export type GetFalAiGptImage1EditImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/gpt-image-1/edit-image/requests/{request_id}/status'
}

export type GetFalAiGptImage1EditImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiGptImage1EditImageRequestsByRequestIdStatusResponse =
  GetFalAiGptImage1EditImageRequestsByRequestIdStatusResponses[keyof GetFalAiGptImage1EditImageRequestsByRequestIdStatusResponses]

export type PutFalAiGptImage1EditImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gpt-image-1/edit-image/requests/{request_id}/cancel'
}

export type PutFalAiGptImage1EditImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiGptImage1EditImageRequestsByRequestIdCancelResponse =
  PutFalAiGptImage1EditImageRequestsByRequestIdCancelResponses[keyof PutFalAiGptImage1EditImageRequestsByRequestIdCancelResponses]

export type PostFalAiGptImage1EditImageData = {
  body: SchemaGptImage1EditImageInput
  path?: never
  query?: never
  url: '/fal-ai/gpt-image-1/edit-image'
}

export type PostFalAiGptImage1EditImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiGptImage1EditImageResponse =
  PostFalAiGptImage1EditImageResponses[keyof PostFalAiGptImage1EditImageResponses]

export type GetFalAiGptImage1EditImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gpt-image-1/edit-image/requests/{request_id}'
}

export type GetFalAiGptImage1EditImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaGptImage1EditImageOutput
}

export type GetFalAiGptImage1EditImageRequestsByRequestIdResponse =
  GetFalAiGptImage1EditImageRequestsByRequestIdResponses[keyof GetFalAiGptImage1EditImageRequestsByRequestIdResponses]

export type GetRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/rundiffusion-fal/juggernaut-flux-lora/inpainting/requests/{request_id}/status'
  }

export type GetRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdStatusResponse =
  GetRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdStatusResponses[keyof GetRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdStatusResponses]

export type PutRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/rundiffusion-fal/juggernaut-flux-lora/inpainting/requests/{request_id}/cancel'
  }

export type PutRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdCancelResponse =
  PutRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdCancelResponses[keyof PutRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdCancelResponses]

export type PostRundiffusionFalJuggernautFluxLoraInpaintingData = {
  body: SchemaJuggernautFluxLoraInpaintingInput
  path?: never
  query?: never
  url: '/rundiffusion-fal/juggernaut-flux-lora/inpainting'
}

export type PostRundiffusionFalJuggernautFluxLoraInpaintingResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostRundiffusionFalJuggernautFluxLoraInpaintingResponse =
  PostRundiffusionFalJuggernautFluxLoraInpaintingResponses[keyof PostRundiffusionFalJuggernautFluxLoraInpaintingResponses]

export type GetRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/rundiffusion-fal/juggernaut-flux-lora/inpainting/requests/{request_id}'
  }

export type GetRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaJuggernautFluxLoraInpaintingOutput
  }

export type GetRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdResponse =
  GetRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdResponses[keyof GetRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdResponses]

export type GetFalAiFashnTryonV15RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/fashn/tryon/v1.5/requests/{request_id}/status'
}

export type GetFalAiFashnTryonV15RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFashnTryonV15RequestsByRequestIdStatusResponse =
  GetFalAiFashnTryonV15RequestsByRequestIdStatusResponses[keyof GetFalAiFashnTryonV15RequestsByRequestIdStatusResponses]

export type PutFalAiFashnTryonV15RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fashn/tryon/v1.5/requests/{request_id}/cancel'
}

export type PutFalAiFashnTryonV15RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFashnTryonV15RequestsByRequestIdCancelResponse =
  PutFalAiFashnTryonV15RequestsByRequestIdCancelResponses[keyof PutFalAiFashnTryonV15RequestsByRequestIdCancelResponses]

export type PostFalAiFashnTryonV15Data = {
  body: SchemaFashnTryonV15Input
  path?: never
  query?: never
  url: '/fal-ai/fashn/tryon/v1.5'
}

export type PostFalAiFashnTryonV15Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFashnTryonV15Response =
  PostFalAiFashnTryonV15Responses[keyof PostFalAiFashnTryonV15Responses]

export type GetFalAiFashnTryonV15RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fashn/tryon/v1.5/requests/{request_id}'
}

export type GetFalAiFashnTryonV15RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFashnTryonV15Output
}

export type GetFalAiFashnTryonV15RequestsByRequestIdResponse =
  GetFalAiFashnTryonV15RequestsByRequestIdResponses[keyof GetFalAiFashnTryonV15RequestsByRequestIdResponses]

export type GetFalAiPlushifyRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/plushify/requests/{request_id}/status'
}

export type GetFalAiPlushifyRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiPlushifyRequestsByRequestIdStatusResponse =
  GetFalAiPlushifyRequestsByRequestIdStatusResponses[keyof GetFalAiPlushifyRequestsByRequestIdStatusResponses]

export type PutFalAiPlushifyRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/plushify/requests/{request_id}/cancel'
}

export type PutFalAiPlushifyRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiPlushifyRequestsByRequestIdCancelResponse =
  PutFalAiPlushifyRequestsByRequestIdCancelResponses[keyof PutFalAiPlushifyRequestsByRequestIdCancelResponses]

export type PostFalAiPlushifyData = {
  body: SchemaPlushifyInput
  path?: never
  query?: never
  url: '/fal-ai/plushify'
}

export type PostFalAiPlushifyResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPlushifyResponse =
  PostFalAiPlushifyResponses[keyof PostFalAiPlushifyResponses]

export type GetFalAiPlushifyRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/plushify/requests/{request_id}'
}

export type GetFalAiPlushifyRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPlushifyOutput
}

export type GetFalAiPlushifyRequestsByRequestIdResponse =
  GetFalAiPlushifyRequestsByRequestIdResponses[keyof GetFalAiPlushifyRequestsByRequestIdResponses]

export type GetFalAiInstantCharacterRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/instant-character/requests/{request_id}/status'
}

export type GetFalAiInstantCharacterRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiInstantCharacterRequestsByRequestIdStatusResponse =
  GetFalAiInstantCharacterRequestsByRequestIdStatusResponses[keyof GetFalAiInstantCharacterRequestsByRequestIdStatusResponses]

export type PutFalAiInstantCharacterRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/instant-character/requests/{request_id}/cancel'
}

export type PutFalAiInstantCharacterRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiInstantCharacterRequestsByRequestIdCancelResponse =
  PutFalAiInstantCharacterRequestsByRequestIdCancelResponses[keyof PutFalAiInstantCharacterRequestsByRequestIdCancelResponses]

export type PostFalAiInstantCharacterData = {
  body: SchemaInstantCharacterInput
  path?: never
  query?: never
  url: '/fal-ai/instant-character'
}

export type PostFalAiInstantCharacterResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiInstantCharacterResponse =
  PostFalAiInstantCharacterResponses[keyof PostFalAiInstantCharacterResponses]

export type GetFalAiInstantCharacterRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/instant-character/requests/{request_id}'
}

export type GetFalAiInstantCharacterRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaInstantCharacterOutput
}

export type GetFalAiInstantCharacterRequestsByRequestIdResponse =
  GetFalAiInstantCharacterRequestsByRequestIdResponses[keyof GetFalAiInstantCharacterRequestsByRequestIdResponses]

export type GetFalAiCartoonifyRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/cartoonify/requests/{request_id}/status'
}

export type GetFalAiCartoonifyRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiCartoonifyRequestsByRequestIdStatusResponse =
  GetFalAiCartoonifyRequestsByRequestIdStatusResponses[keyof GetFalAiCartoonifyRequestsByRequestIdStatusResponses]

export type PutFalAiCartoonifyRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/cartoonify/requests/{request_id}/cancel'
}

export type PutFalAiCartoonifyRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiCartoonifyRequestsByRequestIdCancelResponse =
  PutFalAiCartoonifyRequestsByRequestIdCancelResponses[keyof PutFalAiCartoonifyRequestsByRequestIdCancelResponses]

export type PostFalAiCartoonifyData = {
  body: SchemaCartoonifyInput
  path?: never
  query?: never
  url: '/fal-ai/cartoonify'
}

export type PostFalAiCartoonifyResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiCartoonifyResponse =
  PostFalAiCartoonifyResponses[keyof PostFalAiCartoonifyResponses]

export type GetFalAiCartoonifyRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/cartoonify/requests/{request_id}'
}

export type GetFalAiCartoonifyRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaCartoonifyOutput
}

export type GetFalAiCartoonifyRequestsByRequestIdResponse =
  GetFalAiCartoonifyRequestsByRequestIdResponses[keyof GetFalAiCartoonifyRequestsByRequestIdResponses]

export type GetFalAiFinegrainEraserMaskRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/finegrain-eraser/mask/requests/{request_id}/status'
}

export type GetFalAiFinegrainEraserMaskRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFinegrainEraserMaskRequestsByRequestIdStatusResponse =
  GetFalAiFinegrainEraserMaskRequestsByRequestIdStatusResponses[keyof GetFalAiFinegrainEraserMaskRequestsByRequestIdStatusResponses]

export type PutFalAiFinegrainEraserMaskRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/finegrain-eraser/mask/requests/{request_id}/cancel'
}

export type PutFalAiFinegrainEraserMaskRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFinegrainEraserMaskRequestsByRequestIdCancelResponse =
  PutFalAiFinegrainEraserMaskRequestsByRequestIdCancelResponses[keyof PutFalAiFinegrainEraserMaskRequestsByRequestIdCancelResponses]

export type PostFalAiFinegrainEraserMaskData = {
  body: SchemaFinegrainEraserMaskInput
  path?: never
  query?: never
  url: '/fal-ai/finegrain-eraser/mask'
}

export type PostFalAiFinegrainEraserMaskResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFinegrainEraserMaskResponse =
  PostFalAiFinegrainEraserMaskResponses[keyof PostFalAiFinegrainEraserMaskResponses]

export type GetFalAiFinegrainEraserMaskRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/finegrain-eraser/mask/requests/{request_id}'
}

export type GetFalAiFinegrainEraserMaskRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFinegrainEraserMaskOutput
}

export type GetFalAiFinegrainEraserMaskRequestsByRequestIdResponse =
  GetFalAiFinegrainEraserMaskRequestsByRequestIdResponses[keyof GetFalAiFinegrainEraserMaskRequestsByRequestIdResponses]

export type GetFalAiFinegrainEraserBboxRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/finegrain-eraser/bbox/requests/{request_id}/status'
}

export type GetFalAiFinegrainEraserBboxRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFinegrainEraserBboxRequestsByRequestIdStatusResponse =
  GetFalAiFinegrainEraserBboxRequestsByRequestIdStatusResponses[keyof GetFalAiFinegrainEraserBboxRequestsByRequestIdStatusResponses]

export type PutFalAiFinegrainEraserBboxRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/finegrain-eraser/bbox/requests/{request_id}/cancel'
}

export type PutFalAiFinegrainEraserBboxRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFinegrainEraserBboxRequestsByRequestIdCancelResponse =
  PutFalAiFinegrainEraserBboxRequestsByRequestIdCancelResponses[keyof PutFalAiFinegrainEraserBboxRequestsByRequestIdCancelResponses]

export type PostFalAiFinegrainEraserBboxData = {
  body: SchemaFinegrainEraserBboxInput
  path?: never
  query?: never
  url: '/fal-ai/finegrain-eraser/bbox'
}

export type PostFalAiFinegrainEraserBboxResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFinegrainEraserBboxResponse =
  PostFalAiFinegrainEraserBboxResponses[keyof PostFalAiFinegrainEraserBboxResponses]

export type GetFalAiFinegrainEraserBboxRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/finegrain-eraser/bbox/requests/{request_id}'
}

export type GetFalAiFinegrainEraserBboxRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFinegrainEraserBboxOutput
}

export type GetFalAiFinegrainEraserBboxRequestsByRequestIdResponse =
  GetFalAiFinegrainEraserBboxRequestsByRequestIdResponses[keyof GetFalAiFinegrainEraserBboxRequestsByRequestIdResponses]

export type GetFalAiFinegrainEraserRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/finegrain-eraser/requests/{request_id}/status'
}

export type GetFalAiFinegrainEraserRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFinegrainEraserRequestsByRequestIdStatusResponse =
  GetFalAiFinegrainEraserRequestsByRequestIdStatusResponses[keyof GetFalAiFinegrainEraserRequestsByRequestIdStatusResponses]

export type PutFalAiFinegrainEraserRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/finegrain-eraser/requests/{request_id}/cancel'
}

export type PutFalAiFinegrainEraserRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFinegrainEraserRequestsByRequestIdCancelResponse =
  PutFalAiFinegrainEraserRequestsByRequestIdCancelResponses[keyof PutFalAiFinegrainEraserRequestsByRequestIdCancelResponses]

export type PostFalAiFinegrainEraserData = {
  body: SchemaFinegrainEraserInput
  path?: never
  query?: never
  url: '/fal-ai/finegrain-eraser'
}

export type PostFalAiFinegrainEraserResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFinegrainEraserResponse =
  PostFalAiFinegrainEraserResponses[keyof PostFalAiFinegrainEraserResponses]

export type GetFalAiFinegrainEraserRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/finegrain-eraser/requests/{request_id}'
}

export type GetFalAiFinegrainEraserRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFinegrainEraserOutput
}

export type GetFalAiFinegrainEraserRequestsByRequestIdResponse =
  GetFalAiFinegrainEraserRequestsByRequestIdResponses[keyof GetFalAiFinegrainEraserRequestsByRequestIdResponses]

export type GetFalAiStarVectorRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/star-vector/requests/{request_id}/status'
}

export type GetFalAiStarVectorRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiStarVectorRequestsByRequestIdStatusResponse =
  GetFalAiStarVectorRequestsByRequestIdStatusResponses[keyof GetFalAiStarVectorRequestsByRequestIdStatusResponses]

export type PutFalAiStarVectorRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/star-vector/requests/{request_id}/cancel'
}

export type PutFalAiStarVectorRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiStarVectorRequestsByRequestIdCancelResponse =
  PutFalAiStarVectorRequestsByRequestIdCancelResponses[keyof PutFalAiStarVectorRequestsByRequestIdCancelResponses]

export type PostFalAiStarVectorData = {
  body: SchemaStarVectorInput
  path?: never
  query?: never
  url: '/fal-ai/star-vector'
}

export type PostFalAiStarVectorResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiStarVectorResponse =
  PostFalAiStarVectorResponses[keyof PostFalAiStarVectorResponses]

export type GetFalAiStarVectorRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/star-vector/requests/{request_id}'
}

export type GetFalAiStarVectorRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaStarVectorOutput
}

export type GetFalAiStarVectorRequestsByRequestIdResponse =
  GetFalAiStarVectorRequestsByRequestIdResponses[keyof GetFalAiStarVectorRequestsByRequestIdResponses]

export type GetFalAiGhiblifyRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ghiblify/requests/{request_id}/status'
}

export type GetFalAiGhiblifyRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiGhiblifyRequestsByRequestIdStatusResponse =
  GetFalAiGhiblifyRequestsByRequestIdStatusResponses[keyof GetFalAiGhiblifyRequestsByRequestIdStatusResponses]

export type PutFalAiGhiblifyRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ghiblify/requests/{request_id}/cancel'
}

export type PutFalAiGhiblifyRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiGhiblifyRequestsByRequestIdCancelResponse =
  PutFalAiGhiblifyRequestsByRequestIdCancelResponses[keyof PutFalAiGhiblifyRequestsByRequestIdCancelResponses]

export type PostFalAiGhiblifyData = {
  body: SchemaGhiblifyInput
  path?: never
  query?: never
  url: '/fal-ai/ghiblify'
}

export type PostFalAiGhiblifyResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiGhiblifyResponse =
  PostFalAiGhiblifyResponses[keyof PostFalAiGhiblifyResponses]

export type GetFalAiGhiblifyRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ghiblify/requests/{request_id}'
}

export type GetFalAiGhiblifyRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaGhiblifyOutput
}

export type GetFalAiGhiblifyRequestsByRequestIdResponse =
  GetFalAiGhiblifyRequestsByRequestIdResponses[keyof GetFalAiGhiblifyRequestsByRequestIdResponses]

export type GetFalAiTheraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/thera/requests/{request_id}/status'
}

export type GetFalAiTheraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiTheraRequestsByRequestIdStatusResponse =
  GetFalAiTheraRequestsByRequestIdStatusResponses[keyof GetFalAiTheraRequestsByRequestIdStatusResponses]

export type PutFalAiTheraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/thera/requests/{request_id}/cancel'
}

export type PutFalAiTheraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiTheraRequestsByRequestIdCancelResponse =
  PutFalAiTheraRequestsByRequestIdCancelResponses[keyof PutFalAiTheraRequestsByRequestIdCancelResponses]

export type PostFalAiTheraData = {
  body: SchemaTheraInput
  path?: never
  query?: never
  url: '/fal-ai/thera'
}

export type PostFalAiTheraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiTheraResponse =
  PostFalAiTheraResponses[keyof PostFalAiTheraResponses]

export type GetFalAiTheraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/thera/requests/{request_id}'
}

export type GetFalAiTheraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaTheraOutput
}

export type GetFalAiTheraRequestsByRequestIdResponse =
  GetFalAiTheraRequestsByRequestIdResponses[keyof GetFalAiTheraRequestsByRequestIdResponses]

export type GetFalAiMixDehazeNetRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/mix-dehaze-net/requests/{request_id}/status'
}

export type GetFalAiMixDehazeNetRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiMixDehazeNetRequestsByRequestIdStatusResponse =
  GetFalAiMixDehazeNetRequestsByRequestIdStatusResponses[keyof GetFalAiMixDehazeNetRequestsByRequestIdStatusResponses]

export type PutFalAiMixDehazeNetRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/mix-dehaze-net/requests/{request_id}/cancel'
}

export type PutFalAiMixDehazeNetRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiMixDehazeNetRequestsByRequestIdCancelResponse =
  PutFalAiMixDehazeNetRequestsByRequestIdCancelResponses[keyof PutFalAiMixDehazeNetRequestsByRequestIdCancelResponses]

export type PostFalAiMixDehazeNetData = {
  body: SchemaMixDehazeNetInput
  path?: never
  query?: never
  url: '/fal-ai/mix-dehaze-net'
}

export type PostFalAiMixDehazeNetResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiMixDehazeNetResponse =
  PostFalAiMixDehazeNetResponses[keyof PostFalAiMixDehazeNetResponses]

export type GetFalAiMixDehazeNetRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/mix-dehaze-net/requests/{request_id}'
}

export type GetFalAiMixDehazeNetRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaMixDehazeNetOutput
}

export type GetFalAiMixDehazeNetRequestsByRequestIdResponse =
  GetFalAiMixDehazeNetRequestsByRequestIdResponses[keyof GetFalAiMixDehazeNetRequestsByRequestIdResponses]

export type GetFalAiGeminiFlashEditMultiRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/gemini-flash-edit/multi/requests/{request_id}/status'
}

export type GetFalAiGeminiFlashEditMultiRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiGeminiFlashEditMultiRequestsByRequestIdStatusResponse =
  GetFalAiGeminiFlashEditMultiRequestsByRequestIdStatusResponses[keyof GetFalAiGeminiFlashEditMultiRequestsByRequestIdStatusResponses]

export type PutFalAiGeminiFlashEditMultiRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gemini-flash-edit/multi/requests/{request_id}/cancel'
}

export type PutFalAiGeminiFlashEditMultiRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiGeminiFlashEditMultiRequestsByRequestIdCancelResponse =
  PutFalAiGeminiFlashEditMultiRequestsByRequestIdCancelResponses[keyof PutFalAiGeminiFlashEditMultiRequestsByRequestIdCancelResponses]

export type PostFalAiGeminiFlashEditMultiData = {
  body: SchemaGeminiFlashEditMultiInput
  path?: never
  query?: never
  url: '/fal-ai/gemini-flash-edit/multi'
}

export type PostFalAiGeminiFlashEditMultiResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiGeminiFlashEditMultiResponse =
  PostFalAiGeminiFlashEditMultiResponses[keyof PostFalAiGeminiFlashEditMultiResponses]

export type GetFalAiGeminiFlashEditMultiRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gemini-flash-edit/multi/requests/{request_id}'
}

export type GetFalAiGeminiFlashEditMultiRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaGeminiFlashEditMultiOutput
}

export type GetFalAiGeminiFlashEditMultiRequestsByRequestIdResponse =
  GetFalAiGeminiFlashEditMultiRequestsByRequestIdResponses[keyof GetFalAiGeminiFlashEditMultiRequestsByRequestIdResponses]

export type GetFalAiGeminiFlashEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/gemini-flash-edit/requests/{request_id}/status'
}

export type GetFalAiGeminiFlashEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiGeminiFlashEditRequestsByRequestIdStatusResponse =
  GetFalAiGeminiFlashEditRequestsByRequestIdStatusResponses[keyof GetFalAiGeminiFlashEditRequestsByRequestIdStatusResponses]

export type PutFalAiGeminiFlashEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gemini-flash-edit/requests/{request_id}/cancel'
}

export type PutFalAiGeminiFlashEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiGeminiFlashEditRequestsByRequestIdCancelResponse =
  PutFalAiGeminiFlashEditRequestsByRequestIdCancelResponses[keyof PutFalAiGeminiFlashEditRequestsByRequestIdCancelResponses]

export type PostFalAiGeminiFlashEditData = {
  body: SchemaGeminiFlashEditInput
  path?: never
  query?: never
  url: '/fal-ai/gemini-flash-edit'
}

export type PostFalAiGeminiFlashEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiGeminiFlashEditResponse =
  PostFalAiGeminiFlashEditResponses[keyof PostFalAiGeminiFlashEditResponses]

export type GetFalAiGeminiFlashEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gemini-flash-edit/requests/{request_id}'
}

export type GetFalAiGeminiFlashEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaGeminiFlashEditOutput
}

export type GetFalAiGeminiFlashEditRequestsByRequestIdResponse =
  GetFalAiGeminiFlashEditRequestsByRequestIdResponses[keyof GetFalAiGeminiFlashEditRequestsByRequestIdResponses]

export type GetFalAiInvisibleWatermarkRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/invisible-watermark/requests/{request_id}/status'
}

export type GetFalAiInvisibleWatermarkRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiInvisibleWatermarkRequestsByRequestIdStatusResponse =
  GetFalAiInvisibleWatermarkRequestsByRequestIdStatusResponses[keyof GetFalAiInvisibleWatermarkRequestsByRequestIdStatusResponses]

export type PutFalAiInvisibleWatermarkRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/invisible-watermark/requests/{request_id}/cancel'
}

export type PutFalAiInvisibleWatermarkRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiInvisibleWatermarkRequestsByRequestIdCancelResponse =
  PutFalAiInvisibleWatermarkRequestsByRequestIdCancelResponses[keyof PutFalAiInvisibleWatermarkRequestsByRequestIdCancelResponses]

export type PostFalAiInvisibleWatermarkData = {
  body: SchemaInvisibleWatermarkInput
  path?: never
  query?: never
  url: '/fal-ai/invisible-watermark'
}

export type PostFalAiInvisibleWatermarkResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiInvisibleWatermarkResponse =
  PostFalAiInvisibleWatermarkResponses[keyof PostFalAiInvisibleWatermarkResponses]

export type GetFalAiInvisibleWatermarkRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/invisible-watermark/requests/{request_id}'
}

export type GetFalAiInvisibleWatermarkRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaInvisibleWatermarkOutput
}

export type GetFalAiInvisibleWatermarkRequestsByRequestIdResponse =
  GetFalAiInvisibleWatermarkRequestsByRequestIdResponses[keyof GetFalAiInvisibleWatermarkRequestsByRequestIdResponses]

export type GetRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/rundiffusion-fal/juggernaut-flux/pro/image-to-image/requests/{request_id}/status'
  }

export type GetRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdStatusResponse =
  GetRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdStatusResponses[keyof GetRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdStatusResponses]

export type PutRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/rundiffusion-fal/juggernaut-flux/pro/image-to-image/requests/{request_id}/cancel'
  }

export type PutRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdCancelResponse =
  PutRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdCancelResponses[keyof PutRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdCancelResponses]

export type PostRundiffusionFalJuggernautFluxProImageToImageData = {
  body: SchemaJuggernautFluxProImageToImageInput
  path?: never
  query?: never
  url: '/rundiffusion-fal/juggernaut-flux/pro/image-to-image'
}

export type PostRundiffusionFalJuggernautFluxProImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostRundiffusionFalJuggernautFluxProImageToImageResponse =
  PostRundiffusionFalJuggernautFluxProImageToImageResponses[keyof PostRundiffusionFalJuggernautFluxProImageToImageResponses]

export type GetRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/rundiffusion-fal/juggernaut-flux/pro/image-to-image/requests/{request_id}'
  }

export type GetRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaJuggernautFluxProImageToImageOutput
  }

export type GetRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdResponse =
  GetRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdResponses[keyof GetRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdResponses]

export type GetRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/rundiffusion-fal/juggernaut-flux/base/image-to-image/requests/{request_id}/status'
  }

export type GetRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdStatusResponse =
  GetRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdStatusResponses[keyof GetRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdStatusResponses]

export type PutRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/rundiffusion-fal/juggernaut-flux/base/image-to-image/requests/{request_id}/cancel'
  }

export type PutRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdCancelResponse =
  PutRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdCancelResponses[keyof PutRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdCancelResponses]

export type PostRundiffusionFalJuggernautFluxBaseImageToImageData = {
  body: SchemaJuggernautFluxBaseImageToImageInput
  path?: never
  query?: never
  url: '/rundiffusion-fal/juggernaut-flux/base/image-to-image'
}

export type PostRundiffusionFalJuggernautFluxBaseImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostRundiffusionFalJuggernautFluxBaseImageToImageResponse =
  PostRundiffusionFalJuggernautFluxBaseImageToImageResponses[keyof PostRundiffusionFalJuggernautFluxBaseImageToImageResponses]

export type GetRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/rundiffusion-fal/juggernaut-flux/base/image-to-image/requests/{request_id}'
  }

export type GetRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaJuggernautFluxBaseImageToImageOutput
  }

export type GetRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdResponse =
  GetRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdResponses[keyof GetRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdResponses]

export type GetFalAiDocresDewarpRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/docres/dewarp/requests/{request_id}/status'
}

export type GetFalAiDocresDewarpRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiDocresDewarpRequestsByRequestIdStatusResponse =
  GetFalAiDocresDewarpRequestsByRequestIdStatusResponses[keyof GetFalAiDocresDewarpRequestsByRequestIdStatusResponses]

export type PutFalAiDocresDewarpRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/docres/dewarp/requests/{request_id}/cancel'
}

export type PutFalAiDocresDewarpRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiDocresDewarpRequestsByRequestIdCancelResponse =
  PutFalAiDocresDewarpRequestsByRequestIdCancelResponses[keyof PutFalAiDocresDewarpRequestsByRequestIdCancelResponses]

export type PostFalAiDocresDewarpData = {
  body: SchemaDocresDewarpInput
  path?: never
  query?: never
  url: '/fal-ai/docres/dewarp'
}

export type PostFalAiDocresDewarpResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiDocresDewarpResponse =
  PostFalAiDocresDewarpResponses[keyof PostFalAiDocresDewarpResponses]

export type GetFalAiDocresDewarpRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/docres/dewarp/requests/{request_id}'
}

export type GetFalAiDocresDewarpRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaDocresDewarpOutput
}

export type GetFalAiDocresDewarpRequestsByRequestIdResponse =
  GetFalAiDocresDewarpRequestsByRequestIdResponses[keyof GetFalAiDocresDewarpRequestsByRequestIdResponses]

export type GetFalAiDocresRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/docres/requests/{request_id}/status'
}

export type GetFalAiDocresRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiDocresRequestsByRequestIdStatusResponse =
  GetFalAiDocresRequestsByRequestIdStatusResponses[keyof GetFalAiDocresRequestsByRequestIdStatusResponses]

export type PutFalAiDocresRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/docres/requests/{request_id}/cancel'
}

export type PutFalAiDocresRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiDocresRequestsByRequestIdCancelResponse =
  PutFalAiDocresRequestsByRequestIdCancelResponses[keyof PutFalAiDocresRequestsByRequestIdCancelResponses]

export type PostFalAiDocresData = {
  body: SchemaDocresInput
  path?: never
  query?: never
  url: '/fal-ai/docres'
}

export type PostFalAiDocresResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiDocresResponse =
  PostFalAiDocresResponses[keyof PostFalAiDocresResponses]

export type GetFalAiDocresRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/docres/requests/{request_id}'
}

export type GetFalAiDocresRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaDocresOutput
}

export type GetFalAiDocresRequestsByRequestIdResponse =
  GetFalAiDocresRequestsByRequestIdResponses[keyof GetFalAiDocresRequestsByRequestIdResponses]

export type GetFalAiSwin2SrRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/swin2sr/requests/{request_id}/status'
}

export type GetFalAiSwin2SrRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiSwin2SrRequestsByRequestIdStatusResponse =
  GetFalAiSwin2SrRequestsByRequestIdStatusResponses[keyof GetFalAiSwin2SrRequestsByRequestIdStatusResponses]

export type PutFalAiSwin2SrRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/swin2sr/requests/{request_id}/cancel'
}

export type PutFalAiSwin2SrRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiSwin2SrRequestsByRequestIdCancelResponse =
  PutFalAiSwin2SrRequestsByRequestIdCancelResponses[keyof PutFalAiSwin2SrRequestsByRequestIdCancelResponses]

export type PostFalAiSwin2SrData = {
  body: SchemaSwin2SrInput
  path?: never
  query?: never
  url: '/fal-ai/swin2sr'
}

export type PostFalAiSwin2SrResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiSwin2SrResponse =
  PostFalAiSwin2SrResponses[keyof PostFalAiSwin2SrResponses]

export type GetFalAiSwin2SrRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/swin2sr/requests/{request_id}'
}

export type GetFalAiSwin2SrRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaSwin2SrOutput
}

export type GetFalAiSwin2SrRequestsByRequestIdResponse =
  GetFalAiSwin2SrRequestsByRequestIdResponses[keyof GetFalAiSwin2SrRequestsByRequestIdResponses]

export type GetFalAiIdeogramV2aRemixRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ideogram/v2a/remix/requests/{request_id}/status'
}

export type GetFalAiIdeogramV2aRemixRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIdeogramV2aRemixRequestsByRequestIdStatusResponse =
  GetFalAiIdeogramV2aRemixRequestsByRequestIdStatusResponses[keyof GetFalAiIdeogramV2aRemixRequestsByRequestIdStatusResponses]

export type PutFalAiIdeogramV2aRemixRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2a/remix/requests/{request_id}/cancel'
}

export type PutFalAiIdeogramV2aRemixRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIdeogramV2aRemixRequestsByRequestIdCancelResponse =
  PutFalAiIdeogramV2aRemixRequestsByRequestIdCancelResponses[keyof PutFalAiIdeogramV2aRemixRequestsByRequestIdCancelResponses]

export type PostFalAiIdeogramV2aRemixData = {
  body: SchemaIdeogramV2aRemixInput
  path?: never
  query?: never
  url: '/fal-ai/ideogram/v2a/remix'
}

export type PostFalAiIdeogramV2aRemixResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIdeogramV2aRemixResponse =
  PostFalAiIdeogramV2aRemixResponses[keyof PostFalAiIdeogramV2aRemixResponses]

export type GetFalAiIdeogramV2aRemixRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2a/remix/requests/{request_id}'
}

export type GetFalAiIdeogramV2aRemixRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIdeogramV2aRemixOutput
}

export type GetFalAiIdeogramV2aRemixRequestsByRequestIdResponse =
  GetFalAiIdeogramV2aRemixRequestsByRequestIdResponses[keyof GetFalAiIdeogramV2aRemixRequestsByRequestIdResponses]

export type GetFalAiIdeogramV2aTurboRemixRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ideogram/v2a/turbo/remix/requests/{request_id}/status'
}

export type GetFalAiIdeogramV2aTurboRemixRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIdeogramV2aTurboRemixRequestsByRequestIdStatusResponse =
  GetFalAiIdeogramV2aTurboRemixRequestsByRequestIdStatusResponses[keyof GetFalAiIdeogramV2aTurboRemixRequestsByRequestIdStatusResponses]

export type PutFalAiIdeogramV2aTurboRemixRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2a/turbo/remix/requests/{request_id}/cancel'
}

export type PutFalAiIdeogramV2aTurboRemixRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIdeogramV2aTurboRemixRequestsByRequestIdCancelResponse =
  PutFalAiIdeogramV2aTurboRemixRequestsByRequestIdCancelResponses[keyof PutFalAiIdeogramV2aTurboRemixRequestsByRequestIdCancelResponses]

export type PostFalAiIdeogramV2aTurboRemixData = {
  body: SchemaIdeogramV2aTurboRemixInput
  path?: never
  query?: never
  url: '/fal-ai/ideogram/v2a/turbo/remix'
}

export type PostFalAiIdeogramV2aTurboRemixResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIdeogramV2aTurboRemixResponse =
  PostFalAiIdeogramV2aTurboRemixResponses[keyof PostFalAiIdeogramV2aTurboRemixResponses]

export type GetFalAiIdeogramV2aTurboRemixRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2a/turbo/remix/requests/{request_id}'
}

export type GetFalAiIdeogramV2aTurboRemixRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIdeogramV2aTurboRemixOutput
}

export type GetFalAiIdeogramV2aTurboRemixRequestsByRequestIdResponse =
  GetFalAiIdeogramV2aTurboRemixRequestsByRequestIdResponses[keyof GetFalAiIdeogramV2aTurboRemixRequestsByRequestIdResponses]

export type GetFalAiEvfSamRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/evf-sam/requests/{request_id}/status'
}

export type GetFalAiEvfSamRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiEvfSamRequestsByRequestIdStatusResponse =
  GetFalAiEvfSamRequestsByRequestIdStatusResponses[keyof GetFalAiEvfSamRequestsByRequestIdStatusResponses]

export type PutFalAiEvfSamRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/evf-sam/requests/{request_id}/cancel'
}

export type PutFalAiEvfSamRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiEvfSamRequestsByRequestIdCancelResponse =
  PutFalAiEvfSamRequestsByRequestIdCancelResponses[keyof PutFalAiEvfSamRequestsByRequestIdCancelResponses]

export type PostFalAiEvfSamData = {
  body: SchemaEvfSamInput
  path?: never
  query?: never
  url: '/fal-ai/evf-sam'
}

export type PostFalAiEvfSamResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiEvfSamResponse =
  PostFalAiEvfSamResponses[keyof PostFalAiEvfSamResponses]

export type GetFalAiEvfSamRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/evf-sam/requests/{request_id}'
}

export type GetFalAiEvfSamRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaEvfSamOutput
}

export type GetFalAiEvfSamRequestsByRequestIdResponse =
  GetFalAiEvfSamRequestsByRequestIdResponses[keyof GetFalAiEvfSamRequestsByRequestIdResponses]

export type GetFalAiDdcolorRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ddcolor/requests/{request_id}/status'
}

export type GetFalAiDdcolorRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiDdcolorRequestsByRequestIdStatusResponse =
  GetFalAiDdcolorRequestsByRequestIdStatusResponses[keyof GetFalAiDdcolorRequestsByRequestIdStatusResponses]

export type PutFalAiDdcolorRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ddcolor/requests/{request_id}/cancel'
}

export type PutFalAiDdcolorRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiDdcolorRequestsByRequestIdCancelResponse =
  PutFalAiDdcolorRequestsByRequestIdCancelResponses[keyof PutFalAiDdcolorRequestsByRequestIdCancelResponses]

export type PostFalAiDdcolorData = {
  body: SchemaDdcolorInput
  path?: never
  query?: never
  url: '/fal-ai/ddcolor'
}

export type PostFalAiDdcolorResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiDdcolorResponse =
  PostFalAiDdcolorResponses[keyof PostFalAiDdcolorResponses]

export type GetFalAiDdcolorRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ddcolor/requests/{request_id}'
}

export type GetFalAiDdcolorRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaDdcolorOutput
}

export type GetFalAiDdcolorRequestsByRequestIdResponse =
  GetFalAiDdcolorRequestsByRequestIdResponses[keyof GetFalAiDdcolorRequestsByRequestIdResponses]

export type GetFalAiSam2AutoSegmentRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/sam2/auto-segment/requests/{request_id}/status'
}

export type GetFalAiSam2AutoSegmentRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiSam2AutoSegmentRequestsByRequestIdStatusResponse =
  GetFalAiSam2AutoSegmentRequestsByRequestIdStatusResponses[keyof GetFalAiSam2AutoSegmentRequestsByRequestIdStatusResponses]

export type PutFalAiSam2AutoSegmentRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sam2/auto-segment/requests/{request_id}/cancel'
}

export type PutFalAiSam2AutoSegmentRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiSam2AutoSegmentRequestsByRequestIdCancelResponse =
  PutFalAiSam2AutoSegmentRequestsByRequestIdCancelResponses[keyof PutFalAiSam2AutoSegmentRequestsByRequestIdCancelResponses]

export type PostFalAiSam2AutoSegmentData = {
  body: SchemaSam2AutoSegmentInput
  path?: never
  query?: never
  url: '/fal-ai/sam2/auto-segment'
}

export type PostFalAiSam2AutoSegmentResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiSam2AutoSegmentResponse =
  PostFalAiSam2AutoSegmentResponses[keyof PostFalAiSam2AutoSegmentResponses]

export type GetFalAiSam2AutoSegmentRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sam2/auto-segment/requests/{request_id}'
}

export type GetFalAiSam2AutoSegmentRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaSam2AutoSegmentOutput
}

export type GetFalAiSam2AutoSegmentRequestsByRequestIdResponse =
  GetFalAiSam2AutoSegmentRequestsByRequestIdResponses[keyof GetFalAiSam2AutoSegmentRequestsByRequestIdResponses]

export type GetFalAiDrctSuperResolutionRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/drct-super-resolution/requests/{request_id}/status'
}

export type GetFalAiDrctSuperResolutionRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiDrctSuperResolutionRequestsByRequestIdStatusResponse =
  GetFalAiDrctSuperResolutionRequestsByRequestIdStatusResponses[keyof GetFalAiDrctSuperResolutionRequestsByRequestIdStatusResponses]

export type PutFalAiDrctSuperResolutionRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/drct-super-resolution/requests/{request_id}/cancel'
}

export type PutFalAiDrctSuperResolutionRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiDrctSuperResolutionRequestsByRequestIdCancelResponse =
  PutFalAiDrctSuperResolutionRequestsByRequestIdCancelResponses[keyof PutFalAiDrctSuperResolutionRequestsByRequestIdCancelResponses]

export type PostFalAiDrctSuperResolutionData = {
  body: SchemaDrctSuperResolutionInput
  path?: never
  query?: never
  url: '/fal-ai/drct-super-resolution'
}

export type PostFalAiDrctSuperResolutionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiDrctSuperResolutionResponse =
  PostFalAiDrctSuperResolutionResponses[keyof PostFalAiDrctSuperResolutionResponses]

export type GetFalAiDrctSuperResolutionRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/drct-super-resolution/requests/{request_id}'
}

export type GetFalAiDrctSuperResolutionRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaDrctSuperResolutionOutput
}

export type GetFalAiDrctSuperResolutionRequestsByRequestIdResponse =
  GetFalAiDrctSuperResolutionRequestsByRequestIdResponses[keyof GetFalAiDrctSuperResolutionRequestsByRequestIdResponses]

export type GetFalAiNafnetDeblurRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/nafnet/deblur/requests/{request_id}/status'
}

export type GetFalAiNafnetDeblurRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiNafnetDeblurRequestsByRequestIdStatusResponse =
  GetFalAiNafnetDeblurRequestsByRequestIdStatusResponses[keyof GetFalAiNafnetDeblurRequestsByRequestIdStatusResponses]

export type PutFalAiNafnetDeblurRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/nafnet/deblur/requests/{request_id}/cancel'
}

export type PutFalAiNafnetDeblurRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiNafnetDeblurRequestsByRequestIdCancelResponse =
  PutFalAiNafnetDeblurRequestsByRequestIdCancelResponses[keyof PutFalAiNafnetDeblurRequestsByRequestIdCancelResponses]

export type PostFalAiNafnetDeblurData = {
  body: SchemaNafnetDeblurInput
  path?: never
  query?: never
  url: '/fal-ai/nafnet/deblur'
}

export type PostFalAiNafnetDeblurResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiNafnetDeblurResponse =
  PostFalAiNafnetDeblurResponses[keyof PostFalAiNafnetDeblurResponses]

export type GetFalAiNafnetDeblurRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/nafnet/deblur/requests/{request_id}'
}

export type GetFalAiNafnetDeblurRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaNafnetDeblurOutput
}

export type GetFalAiNafnetDeblurRequestsByRequestIdResponse =
  GetFalAiNafnetDeblurRequestsByRequestIdResponses[keyof GetFalAiNafnetDeblurRequestsByRequestIdResponses]

export type GetFalAiNafnetDenoiseRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/nafnet/denoise/requests/{request_id}/status'
}

export type GetFalAiNafnetDenoiseRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiNafnetDenoiseRequestsByRequestIdStatusResponse =
  GetFalAiNafnetDenoiseRequestsByRequestIdStatusResponses[keyof GetFalAiNafnetDenoiseRequestsByRequestIdStatusResponses]

export type PutFalAiNafnetDenoiseRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/nafnet/denoise/requests/{request_id}/cancel'
}

export type PutFalAiNafnetDenoiseRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiNafnetDenoiseRequestsByRequestIdCancelResponse =
  PutFalAiNafnetDenoiseRequestsByRequestIdCancelResponses[keyof PutFalAiNafnetDenoiseRequestsByRequestIdCancelResponses]

export type PostFalAiNafnetDenoiseData = {
  body: SchemaNafnetDenoiseInput
  path?: never
  query?: never
  url: '/fal-ai/nafnet/denoise'
}

export type PostFalAiNafnetDenoiseResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiNafnetDenoiseResponse =
  PostFalAiNafnetDenoiseResponses[keyof PostFalAiNafnetDenoiseResponses]

export type GetFalAiNafnetDenoiseRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/nafnet/denoise/requests/{request_id}'
}

export type GetFalAiNafnetDenoiseRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaNafnetDenoiseOutput
}

export type GetFalAiNafnetDenoiseRequestsByRequestIdResponse =
  GetFalAiNafnetDenoiseRequestsByRequestIdResponses[keyof GetFalAiNafnetDenoiseRequestsByRequestIdResponses]

export type GetFalAiPostProcessingRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/post-processing/requests/{request_id}/status'
}

export type GetFalAiPostProcessingRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiPostProcessingRequestsByRequestIdStatusResponse =
  GetFalAiPostProcessingRequestsByRequestIdStatusResponses[keyof GetFalAiPostProcessingRequestsByRequestIdStatusResponses]

export type PutFalAiPostProcessingRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/requests/{request_id}/cancel'
}

export type PutFalAiPostProcessingRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiPostProcessingRequestsByRequestIdCancelResponse =
  PutFalAiPostProcessingRequestsByRequestIdCancelResponses[keyof PutFalAiPostProcessingRequestsByRequestIdCancelResponses]

export type PostFalAiPostProcessingData = {
  body: SchemaPostProcessingInput
  path?: never
  query?: never
  url: '/fal-ai/post-processing'
}

export type PostFalAiPostProcessingResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPostProcessingResponse =
  PostFalAiPostProcessingResponses[keyof PostFalAiPostProcessingResponses]

export type GetFalAiPostProcessingRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/post-processing/requests/{request_id}'
}

export type GetFalAiPostProcessingRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPostProcessingOutput
}

export type GetFalAiPostProcessingRequestsByRequestIdResponse =
  GetFalAiPostProcessingRequestsByRequestIdResponses[keyof GetFalAiPostProcessingRequestsByRequestIdResponses]

export type GetFalAiFloweditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flowedit/requests/{request_id}/status'
}

export type GetFalAiFloweditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFloweditRequestsByRequestIdStatusResponse =
  GetFalAiFloweditRequestsByRequestIdStatusResponses[keyof GetFalAiFloweditRequestsByRequestIdStatusResponses]

export type PutFalAiFloweditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flowedit/requests/{request_id}/cancel'
}

export type PutFalAiFloweditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFloweditRequestsByRequestIdCancelResponse =
  PutFalAiFloweditRequestsByRequestIdCancelResponses[keyof PutFalAiFloweditRequestsByRequestIdCancelResponses]

export type PostFalAiFloweditData = {
  body: SchemaFloweditInput
  path?: never
  query?: never
  url: '/fal-ai/flowedit'
}

export type PostFalAiFloweditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFloweditResponse =
  PostFalAiFloweditResponses[keyof PostFalAiFloweditResponses]

export type GetFalAiFloweditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flowedit/requests/{request_id}'
}

export type GetFalAiFloweditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFloweditOutput
}

export type GetFalAiFloweditRequestsByRequestIdResponse =
  GetFalAiFloweditRequestsByRequestIdResponses[keyof GetFalAiFloweditRequestsByRequestIdResponses]

export type GetFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/flux-control-lora-depth/image-to-image/requests/{request_id}/status'
  }

export type GetFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/flux-control-lora-depth/image-to-image/requests/{request_id}/cancel'
  }

export type PutFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiFluxControlLoraDepthImageToImageData = {
  body: SchemaFluxControlLoraDepthImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/flux-control-lora-depth/image-to-image'
}

export type PostFalAiFluxControlLoraDepthImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxControlLoraDepthImageToImageResponse =
  PostFalAiFluxControlLoraDepthImageToImageResponses[keyof PostFalAiFluxControlLoraDepthImageToImageResponses]

export type GetFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-control-lora-depth/image-to-image/requests/{request_id}'
}

export type GetFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaFluxControlLoraDepthImageToImageOutput
  }

export type GetFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdResponse =
  GetFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdResponses[keyof GetFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdResponses]

export type GetFalAiBenV2ImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ben/v2/image/requests/{request_id}/status'
}

export type GetFalAiBenV2ImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiBenV2ImageRequestsByRequestIdStatusResponse =
  GetFalAiBenV2ImageRequestsByRequestIdStatusResponses[keyof GetFalAiBenV2ImageRequestsByRequestIdStatusResponses]

export type PutFalAiBenV2ImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ben/v2/image/requests/{request_id}/cancel'
}

export type PutFalAiBenV2ImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiBenV2ImageRequestsByRequestIdCancelResponse =
  PutFalAiBenV2ImageRequestsByRequestIdCancelResponses[keyof PutFalAiBenV2ImageRequestsByRequestIdCancelResponses]

export type PostFalAiBenV2ImageData = {
  body: SchemaBenV2ImageInput
  path?: never
  query?: never
  url: '/fal-ai/ben/v2/image'
}

export type PostFalAiBenV2ImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBenV2ImageResponse =
  PostFalAiBenV2ImageResponses[keyof PostFalAiBenV2ImageResponses]

export type GetFalAiBenV2ImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ben/v2/image/requests/{request_id}'
}

export type GetFalAiBenV2ImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaBenV2ImageOutput
}

export type GetFalAiBenV2ImageRequestsByRequestIdResponse =
  GetFalAiBenV2ImageRequestsByRequestIdResponses[keyof GetFalAiBenV2ImageRequestsByRequestIdResponses]

export type GetFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/flux-control-lora-canny/image-to-image/requests/{request_id}/status'
  }

export type GetFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/flux-control-lora-canny/image-to-image/requests/{request_id}/cancel'
  }

export type PutFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiFluxControlLoraCannyImageToImageData = {
  body: SchemaFluxControlLoraCannyImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/flux-control-lora-canny/image-to-image'
}

export type PostFalAiFluxControlLoraCannyImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxControlLoraCannyImageToImageResponse =
  PostFalAiFluxControlLoraCannyImageToImageResponses[keyof PostFalAiFluxControlLoraCannyImageToImageResponses]

export type GetFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-control-lora-canny/image-to-image/requests/{request_id}'
}

export type GetFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaFluxControlLoraCannyImageToImageOutput
  }

export type GetFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdResponse =
  GetFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdResponses[keyof GetFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdResponses]

export type GetFalAiIdeogramUpscaleRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ideogram/upscale/requests/{request_id}/status'
}

export type GetFalAiIdeogramUpscaleRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIdeogramUpscaleRequestsByRequestIdStatusResponse =
  GetFalAiIdeogramUpscaleRequestsByRequestIdStatusResponses[keyof GetFalAiIdeogramUpscaleRequestsByRequestIdStatusResponses]

export type PutFalAiIdeogramUpscaleRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/upscale/requests/{request_id}/cancel'
}

export type PutFalAiIdeogramUpscaleRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIdeogramUpscaleRequestsByRequestIdCancelResponse =
  PutFalAiIdeogramUpscaleRequestsByRequestIdCancelResponses[keyof PutFalAiIdeogramUpscaleRequestsByRequestIdCancelResponses]

export type PostFalAiIdeogramUpscaleData = {
  body: SchemaIdeogramUpscaleInput
  path?: never
  query?: never
  url: '/fal-ai/ideogram/upscale'
}

export type PostFalAiIdeogramUpscaleResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIdeogramUpscaleResponse =
  PostFalAiIdeogramUpscaleResponses[keyof PostFalAiIdeogramUpscaleResponses]

export type GetFalAiIdeogramUpscaleRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/upscale/requests/{request_id}'
}

export type GetFalAiIdeogramUpscaleRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIdeogramUpscaleOutput
}

export type GetFalAiIdeogramUpscaleRequestsByRequestIdResponse =
  GetFalAiIdeogramUpscaleRequestsByRequestIdResponses[keyof GetFalAiIdeogramUpscaleRequestsByRequestIdResponses]

export type GetFalAiCodeformerRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/codeformer/requests/{request_id}/status'
}

export type GetFalAiCodeformerRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiCodeformerRequestsByRequestIdStatusResponse =
  GetFalAiCodeformerRequestsByRequestIdStatusResponses[keyof GetFalAiCodeformerRequestsByRequestIdStatusResponses]

export type PutFalAiCodeformerRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/codeformer/requests/{request_id}/cancel'
}

export type PutFalAiCodeformerRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiCodeformerRequestsByRequestIdCancelResponse =
  PutFalAiCodeformerRequestsByRequestIdCancelResponses[keyof PutFalAiCodeformerRequestsByRequestIdCancelResponses]

export type PostFalAiCodeformerData = {
  body: SchemaCodeformerInput
  path?: never
  query?: never
  url: '/fal-ai/codeformer'
}

export type PostFalAiCodeformerResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiCodeformerResponse =
  PostFalAiCodeformerResponses[keyof PostFalAiCodeformerResponses]

export type GetFalAiCodeformerRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/codeformer/requests/{request_id}'
}

export type GetFalAiCodeformerRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaCodeformerOutput
}

export type GetFalAiCodeformerRequestsByRequestIdResponse =
  GetFalAiCodeformerRequestsByRequestIdResponses[keyof GetFalAiCodeformerRequestsByRequestIdResponses]

export type GetFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/kling/v1-5/kolors-virtual-try-on/requests/{request_id}/status'
}

export type GetFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdStatusResponse =
  GetFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdStatusResponses[keyof GetFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdStatusResponses]

export type PutFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/kling/v1-5/kolors-virtual-try-on/requests/{request_id}/cancel'
}

export type PutFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdCancelResponse =
  PutFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdCancelResponses[keyof PutFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdCancelResponses]

export type PostFalAiKlingV15KolorsVirtualTryOnData = {
  body: SchemaKlingV15KolorsVirtualTryOnInput
  path?: never
  query?: never
  url: '/fal-ai/kling/v1-5/kolors-virtual-try-on'
}

export type PostFalAiKlingV15KolorsVirtualTryOnResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiKlingV15KolorsVirtualTryOnResponse =
  PostFalAiKlingV15KolorsVirtualTryOnResponses[keyof PostFalAiKlingV15KolorsVirtualTryOnResponses]

export type GetFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/kling/v1-5/kolors-virtual-try-on/requests/{request_id}'
}

export type GetFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaKlingV15KolorsVirtualTryOnOutput
}

export type GetFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdResponse =
  GetFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdResponses[keyof GetFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdResponses]

export type GetFalAiFluxLoraCannyRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-lora-canny/requests/{request_id}/status'
}

export type GetFalAiFluxLoraCannyRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxLoraCannyRequestsByRequestIdStatusResponse =
  GetFalAiFluxLoraCannyRequestsByRequestIdStatusResponses[keyof GetFalAiFluxLoraCannyRequestsByRequestIdStatusResponses]

export type PutFalAiFluxLoraCannyRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-lora-canny/requests/{request_id}/cancel'
}

export type PutFalAiFluxLoraCannyRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxLoraCannyRequestsByRequestIdCancelResponse =
  PutFalAiFluxLoraCannyRequestsByRequestIdCancelResponses[keyof PutFalAiFluxLoraCannyRequestsByRequestIdCancelResponses]

export type PostFalAiFluxLoraCannyData = {
  body: SchemaFluxLoraCannyInput
  path?: never
  query?: never
  url: '/fal-ai/flux-lora-canny'
}

export type PostFalAiFluxLoraCannyResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxLoraCannyResponse =
  PostFalAiFluxLoraCannyResponses[keyof PostFalAiFluxLoraCannyResponses]

export type GetFalAiFluxLoraCannyRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-lora-canny/requests/{request_id}'
}

export type GetFalAiFluxLoraCannyRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxLoraCannyOutput
}

export type GetFalAiFluxLoraCannyRequestsByRequestIdResponse =
  GetFalAiFluxLoraCannyRequestsByRequestIdResponses[keyof GetFalAiFluxLoraCannyRequestsByRequestIdResponses]

export type GetFalAiFluxProV1FillFinetunedRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-pro/v1/fill-finetuned/requests/{request_id}/status'
}

export type GetFalAiFluxProV1FillFinetunedRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxProV1FillFinetunedRequestsByRequestIdStatusResponse =
  GetFalAiFluxProV1FillFinetunedRequestsByRequestIdStatusResponses[keyof GetFalAiFluxProV1FillFinetunedRequestsByRequestIdStatusResponses]

export type PutFalAiFluxProV1FillFinetunedRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/v1/fill-finetuned/requests/{request_id}/cancel'
}

export type PutFalAiFluxProV1FillFinetunedRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxProV1FillFinetunedRequestsByRequestIdCancelResponse =
  PutFalAiFluxProV1FillFinetunedRequestsByRequestIdCancelResponses[keyof PutFalAiFluxProV1FillFinetunedRequestsByRequestIdCancelResponses]

export type PostFalAiFluxProV1FillFinetunedData = {
  body: SchemaFluxProV1FillFinetunedInput
  path?: never
  query?: never
  url: '/fal-ai/flux-pro/v1/fill-finetuned'
}

export type PostFalAiFluxProV1FillFinetunedResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxProV1FillFinetunedResponse =
  PostFalAiFluxProV1FillFinetunedResponses[keyof PostFalAiFluxProV1FillFinetunedResponses]

export type GetFalAiFluxProV1FillFinetunedRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/v1/fill-finetuned/requests/{request_id}'
}

export type GetFalAiFluxProV1FillFinetunedRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxProV1FillFinetunedOutput
}

export type GetFalAiFluxProV1FillFinetunedRequestsByRequestIdResponse =
  GetFalAiFluxProV1FillFinetunedRequestsByRequestIdResponses[keyof GetFalAiFluxProV1FillFinetunedRequestsByRequestIdResponses]

export type GetFalAiMoondreamNextDetectionRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/moondream-next/detection/requests/{request_id}/status'
}

export type GetFalAiMoondreamNextDetectionRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiMoondreamNextDetectionRequestsByRequestIdStatusResponse =
  GetFalAiMoondreamNextDetectionRequestsByRequestIdStatusResponses[keyof GetFalAiMoondreamNextDetectionRequestsByRequestIdStatusResponses]

export type PutFalAiMoondreamNextDetectionRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/moondream-next/detection/requests/{request_id}/cancel'
}

export type PutFalAiMoondreamNextDetectionRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiMoondreamNextDetectionRequestsByRequestIdCancelResponse =
  PutFalAiMoondreamNextDetectionRequestsByRequestIdCancelResponses[keyof PutFalAiMoondreamNextDetectionRequestsByRequestIdCancelResponses]

export type PostFalAiMoondreamNextDetectionData = {
  body: SchemaMoondreamNextDetectionInput
  path?: never
  query?: never
  url: '/fal-ai/moondream-next/detection'
}

export type PostFalAiMoondreamNextDetectionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiMoondreamNextDetectionResponse =
  PostFalAiMoondreamNextDetectionResponses[keyof PostFalAiMoondreamNextDetectionResponses]

export type GetFalAiMoondreamNextDetectionRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/moondream-next/detection/requests/{request_id}'
}

export type GetFalAiMoondreamNextDetectionRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaMoondreamNextDetectionOutput
}

export type GetFalAiMoondreamNextDetectionRequestsByRequestIdResponse =
  GetFalAiMoondreamNextDetectionRequestsByRequestIdResponses[keyof GetFalAiMoondreamNextDetectionRequestsByRequestIdResponses]

export type GetFalAiBriaExpandRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/bria/expand/requests/{request_id}/status'
}

export type GetFalAiBriaExpandRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiBriaExpandRequestsByRequestIdStatusResponse =
  GetFalAiBriaExpandRequestsByRequestIdStatusResponses[keyof GetFalAiBriaExpandRequestsByRequestIdStatusResponses]

export type PutFalAiBriaExpandRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/expand/requests/{request_id}/cancel'
}

export type PutFalAiBriaExpandRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiBriaExpandRequestsByRequestIdCancelResponse =
  PutFalAiBriaExpandRequestsByRequestIdCancelResponses[keyof PutFalAiBriaExpandRequestsByRequestIdCancelResponses]

export type PostFalAiBriaExpandData = {
  body: SchemaBriaExpandInput
  path?: never
  query?: never
  url: '/fal-ai/bria/expand'
}

export type PostFalAiBriaExpandResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBriaExpandResponse =
  PostFalAiBriaExpandResponses[keyof PostFalAiBriaExpandResponses]

export type GetFalAiBriaExpandRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/expand/requests/{request_id}'
}

export type GetFalAiBriaExpandRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaBriaExpandOutput
}

export type GetFalAiBriaExpandRequestsByRequestIdResponse =
  GetFalAiBriaExpandRequestsByRequestIdResponses[keyof GetFalAiBriaExpandRequestsByRequestIdResponses]

export type GetFalAiBriaGenfillRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/bria/genfill/requests/{request_id}/status'
}

export type GetFalAiBriaGenfillRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiBriaGenfillRequestsByRequestIdStatusResponse =
  GetFalAiBriaGenfillRequestsByRequestIdStatusResponses[keyof GetFalAiBriaGenfillRequestsByRequestIdStatusResponses]

export type PutFalAiBriaGenfillRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/genfill/requests/{request_id}/cancel'
}

export type PutFalAiBriaGenfillRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiBriaGenfillRequestsByRequestIdCancelResponse =
  PutFalAiBriaGenfillRequestsByRequestIdCancelResponses[keyof PutFalAiBriaGenfillRequestsByRequestIdCancelResponses]

export type PostFalAiBriaGenfillData = {
  body: SchemaBriaGenfillInput
  path?: never
  query?: never
  url: '/fal-ai/bria/genfill'
}

export type PostFalAiBriaGenfillResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBriaGenfillResponse =
  PostFalAiBriaGenfillResponses[keyof PostFalAiBriaGenfillResponses]

export type GetFalAiBriaGenfillRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/genfill/requests/{request_id}'
}

export type GetFalAiBriaGenfillRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaBriaGenfillOutput
}

export type GetFalAiBriaGenfillRequestsByRequestIdResponse =
  GetFalAiBriaGenfillRequestsByRequestIdResponses[keyof GetFalAiBriaGenfillRequestsByRequestIdResponses]

export type GetFalAiFluxLoraFillRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-lora-fill/requests/{request_id}/status'
}

export type GetFalAiFluxLoraFillRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxLoraFillRequestsByRequestIdStatusResponse =
  GetFalAiFluxLoraFillRequestsByRequestIdStatusResponses[keyof GetFalAiFluxLoraFillRequestsByRequestIdStatusResponses]

export type PutFalAiFluxLoraFillRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-lora-fill/requests/{request_id}/cancel'
}

export type PutFalAiFluxLoraFillRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxLoraFillRequestsByRequestIdCancelResponse =
  PutFalAiFluxLoraFillRequestsByRequestIdCancelResponses[keyof PutFalAiFluxLoraFillRequestsByRequestIdCancelResponses]

export type PostFalAiFluxLoraFillData = {
  body: SchemaFluxLoraFillInput
  path?: never
  query?: never
  url: '/fal-ai/flux-lora-fill'
}

export type PostFalAiFluxLoraFillResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxLoraFillResponse =
  PostFalAiFluxLoraFillResponses[keyof PostFalAiFluxLoraFillResponses]

export type GetFalAiFluxLoraFillRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-lora-fill/requests/{request_id}'
}

export type GetFalAiFluxLoraFillRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxLoraFillOutput
}

export type GetFalAiFluxLoraFillRequestsByRequestIdResponse =
  GetFalAiFluxLoraFillRequestsByRequestIdResponses[keyof GetFalAiFluxLoraFillRequestsByRequestIdResponses]

export type GetFalAiBriaBackgroundReplaceRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/bria/background/replace/requests/{request_id}/status'
}

export type GetFalAiBriaBackgroundReplaceRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiBriaBackgroundReplaceRequestsByRequestIdStatusResponse =
  GetFalAiBriaBackgroundReplaceRequestsByRequestIdStatusResponses[keyof GetFalAiBriaBackgroundReplaceRequestsByRequestIdStatusResponses]

export type PutFalAiBriaBackgroundReplaceRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/background/replace/requests/{request_id}/cancel'
}

export type PutFalAiBriaBackgroundReplaceRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiBriaBackgroundReplaceRequestsByRequestIdCancelResponse =
  PutFalAiBriaBackgroundReplaceRequestsByRequestIdCancelResponses[keyof PutFalAiBriaBackgroundReplaceRequestsByRequestIdCancelResponses]

export type PostFalAiBriaBackgroundReplaceData = {
  body: SchemaBriaBackgroundReplaceInput
  path?: never
  query?: never
  url: '/fal-ai/bria/background/replace'
}

export type PostFalAiBriaBackgroundReplaceResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBriaBackgroundReplaceResponse =
  PostFalAiBriaBackgroundReplaceResponses[keyof PostFalAiBriaBackgroundReplaceResponses]

export type GetFalAiBriaBackgroundReplaceRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/background/replace/requests/{request_id}'
}

export type GetFalAiBriaBackgroundReplaceRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaBriaBackgroundReplaceOutput
}

export type GetFalAiBriaBackgroundReplaceRequestsByRequestIdResponse =
  GetFalAiBriaBackgroundReplaceRequestsByRequestIdResponses[keyof GetFalAiBriaBackgroundReplaceRequestsByRequestIdResponses]

export type GetFalAiBriaEraserRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/bria/eraser/requests/{request_id}/status'
}

export type GetFalAiBriaEraserRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiBriaEraserRequestsByRequestIdStatusResponse =
  GetFalAiBriaEraserRequestsByRequestIdStatusResponses[keyof GetFalAiBriaEraserRequestsByRequestIdStatusResponses]

export type PutFalAiBriaEraserRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/eraser/requests/{request_id}/cancel'
}

export type PutFalAiBriaEraserRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiBriaEraserRequestsByRequestIdCancelResponse =
  PutFalAiBriaEraserRequestsByRequestIdCancelResponses[keyof PutFalAiBriaEraserRequestsByRequestIdCancelResponses]

export type PostFalAiBriaEraserData = {
  body: SchemaBriaEraserInput
  path?: never
  query?: never
  url: '/fal-ai/bria/eraser'
}

export type PostFalAiBriaEraserResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBriaEraserResponse =
  PostFalAiBriaEraserResponses[keyof PostFalAiBriaEraserResponses]

export type GetFalAiBriaEraserRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/eraser/requests/{request_id}'
}

export type GetFalAiBriaEraserRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaBriaEraserOutput
}

export type GetFalAiBriaEraserRequestsByRequestIdResponse =
  GetFalAiBriaEraserRequestsByRequestIdResponses[keyof GetFalAiBriaEraserRequestsByRequestIdResponses]

export type GetFalAiBriaProductShotRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/bria/product-shot/requests/{request_id}/status'
}

export type GetFalAiBriaProductShotRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiBriaProductShotRequestsByRequestIdStatusResponse =
  GetFalAiBriaProductShotRequestsByRequestIdStatusResponses[keyof GetFalAiBriaProductShotRequestsByRequestIdStatusResponses]

export type PutFalAiBriaProductShotRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/product-shot/requests/{request_id}/cancel'
}

export type PutFalAiBriaProductShotRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiBriaProductShotRequestsByRequestIdCancelResponse =
  PutFalAiBriaProductShotRequestsByRequestIdCancelResponses[keyof PutFalAiBriaProductShotRequestsByRequestIdCancelResponses]

export type PostFalAiBriaProductShotData = {
  body: SchemaBriaProductShotInput
  path?: never
  query?: never
  url: '/fal-ai/bria/product-shot'
}

export type PostFalAiBriaProductShotResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBriaProductShotResponse =
  PostFalAiBriaProductShotResponses[keyof PostFalAiBriaProductShotResponses]

export type GetFalAiBriaProductShotRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/product-shot/requests/{request_id}'
}

export type GetFalAiBriaProductShotRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaBriaProductShotOutput
}

export type GetFalAiBriaProductShotRequestsByRequestIdResponse =
  GetFalAiBriaProductShotRequestsByRequestIdResponses[keyof GetFalAiBriaProductShotRequestsByRequestIdResponses]

export type GetFalAiBriaBackgroundRemoveRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/bria/background/remove/requests/{request_id}/status'
}

export type GetFalAiBriaBackgroundRemoveRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiBriaBackgroundRemoveRequestsByRequestIdStatusResponse =
  GetFalAiBriaBackgroundRemoveRequestsByRequestIdStatusResponses[keyof GetFalAiBriaBackgroundRemoveRequestsByRequestIdStatusResponses]

export type PutFalAiBriaBackgroundRemoveRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/background/remove/requests/{request_id}/cancel'
}

export type PutFalAiBriaBackgroundRemoveRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiBriaBackgroundRemoveRequestsByRequestIdCancelResponse =
  PutFalAiBriaBackgroundRemoveRequestsByRequestIdCancelResponses[keyof PutFalAiBriaBackgroundRemoveRequestsByRequestIdCancelResponses]

export type PostFalAiBriaBackgroundRemoveData = {
  body: SchemaBriaBackgroundRemoveInput
  path?: never
  query?: never
  url: '/fal-ai/bria/background/remove'
}

export type PostFalAiBriaBackgroundRemoveResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBriaBackgroundRemoveResponse =
  PostFalAiBriaBackgroundRemoveResponses[keyof PostFalAiBriaBackgroundRemoveResponses]

export type GetFalAiBriaBackgroundRemoveRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/background/remove/requests/{request_id}'
}

export type GetFalAiBriaBackgroundRemoveRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaBriaBackgroundRemoveOutput
}

export type GetFalAiBriaBackgroundRemoveRequestsByRequestIdResponse =
  GetFalAiBriaBackgroundRemoveRequestsByRequestIdResponses[keyof GetFalAiBriaBackgroundRemoveRequestsByRequestIdResponses]

export type GetFalAiCatVtonRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/cat-vton/requests/{request_id}/status'
}

export type GetFalAiCatVtonRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiCatVtonRequestsByRequestIdStatusResponse =
  GetFalAiCatVtonRequestsByRequestIdStatusResponses[keyof GetFalAiCatVtonRequestsByRequestIdStatusResponses]

export type PutFalAiCatVtonRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/cat-vton/requests/{request_id}/cancel'
}

export type PutFalAiCatVtonRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiCatVtonRequestsByRequestIdCancelResponse =
  PutFalAiCatVtonRequestsByRequestIdCancelResponses[keyof PutFalAiCatVtonRequestsByRequestIdCancelResponses]

export type PostFalAiCatVtonData = {
  body: SchemaCatVtonInput
  path?: never
  query?: never
  url: '/fal-ai/cat-vton'
}

export type PostFalAiCatVtonResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiCatVtonResponse =
  PostFalAiCatVtonResponses[keyof PostFalAiCatVtonResponses]

export type GetFalAiCatVtonRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/cat-vton/requests/{request_id}'
}

export type GetFalAiCatVtonRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaCatVtonOutput
}

export type GetFalAiCatVtonRequestsByRequestIdResponse =
  GetFalAiCatVtonRequestsByRequestIdResponses[keyof GetFalAiCatVtonRequestsByRequestIdResponses]

export type GetFalAiLeffaPoseTransferRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/leffa/pose-transfer/requests/{request_id}/status'
}

export type GetFalAiLeffaPoseTransferRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLeffaPoseTransferRequestsByRequestIdStatusResponse =
  GetFalAiLeffaPoseTransferRequestsByRequestIdStatusResponses[keyof GetFalAiLeffaPoseTransferRequestsByRequestIdStatusResponses]

export type PutFalAiLeffaPoseTransferRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/leffa/pose-transfer/requests/{request_id}/cancel'
}

export type PutFalAiLeffaPoseTransferRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLeffaPoseTransferRequestsByRequestIdCancelResponse =
  PutFalAiLeffaPoseTransferRequestsByRequestIdCancelResponses[keyof PutFalAiLeffaPoseTransferRequestsByRequestIdCancelResponses]

export type PostFalAiLeffaPoseTransferData = {
  body: SchemaLeffaPoseTransferInput
  path?: never
  query?: never
  url: '/fal-ai/leffa/pose-transfer'
}

export type PostFalAiLeffaPoseTransferResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLeffaPoseTransferResponse =
  PostFalAiLeffaPoseTransferResponses[keyof PostFalAiLeffaPoseTransferResponses]

export type GetFalAiLeffaPoseTransferRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/leffa/pose-transfer/requests/{request_id}'
}

export type GetFalAiLeffaPoseTransferRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLeffaPoseTransferOutput
}

export type GetFalAiLeffaPoseTransferRequestsByRequestIdResponse =
  GetFalAiLeffaPoseTransferRequestsByRequestIdResponses[keyof GetFalAiLeffaPoseTransferRequestsByRequestIdResponses]

export type GetFalAiLeffaVirtualTryonRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/leffa/virtual-tryon/requests/{request_id}/status'
}

export type GetFalAiLeffaVirtualTryonRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLeffaVirtualTryonRequestsByRequestIdStatusResponse =
  GetFalAiLeffaVirtualTryonRequestsByRequestIdStatusResponses[keyof GetFalAiLeffaVirtualTryonRequestsByRequestIdStatusResponses]

export type PutFalAiLeffaVirtualTryonRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/leffa/virtual-tryon/requests/{request_id}/cancel'
}

export type PutFalAiLeffaVirtualTryonRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLeffaVirtualTryonRequestsByRequestIdCancelResponse =
  PutFalAiLeffaVirtualTryonRequestsByRequestIdCancelResponses[keyof PutFalAiLeffaVirtualTryonRequestsByRequestIdCancelResponses]

export type PostFalAiLeffaVirtualTryonData = {
  body: SchemaLeffaVirtualTryonInput
  path?: never
  query?: never
  url: '/fal-ai/leffa/virtual-tryon'
}

export type PostFalAiLeffaVirtualTryonResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLeffaVirtualTryonResponse =
  PostFalAiLeffaVirtualTryonResponses[keyof PostFalAiLeffaVirtualTryonResponses]

export type GetFalAiLeffaVirtualTryonRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/leffa/virtual-tryon/requests/{request_id}'
}

export type GetFalAiLeffaVirtualTryonRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLeffaVirtualTryonOutput
}

export type GetFalAiLeffaVirtualTryonRequestsByRequestIdResponse =
  GetFalAiLeffaVirtualTryonRequestsByRequestIdResponses[keyof GetFalAiLeffaVirtualTryonRequestsByRequestIdResponses]

export type GetFalAiIdeogramV2EditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ideogram/v2/edit/requests/{request_id}/status'
}

export type GetFalAiIdeogramV2EditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIdeogramV2EditRequestsByRequestIdStatusResponse =
  GetFalAiIdeogramV2EditRequestsByRequestIdStatusResponses[keyof GetFalAiIdeogramV2EditRequestsByRequestIdStatusResponses]

export type PutFalAiIdeogramV2EditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2/edit/requests/{request_id}/cancel'
}

export type PutFalAiIdeogramV2EditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIdeogramV2EditRequestsByRequestIdCancelResponse =
  PutFalAiIdeogramV2EditRequestsByRequestIdCancelResponses[keyof PutFalAiIdeogramV2EditRequestsByRequestIdCancelResponses]

export type PostFalAiIdeogramV2EditData = {
  body: SchemaIdeogramV2EditInput
  path?: never
  query?: never
  url: '/fal-ai/ideogram/v2/edit'
}

export type PostFalAiIdeogramV2EditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIdeogramV2EditResponse =
  PostFalAiIdeogramV2EditResponses[keyof PostFalAiIdeogramV2EditResponses]

export type GetFalAiIdeogramV2EditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2/edit/requests/{request_id}'
}

export type GetFalAiIdeogramV2EditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIdeogramV2EditOutput
}

export type GetFalAiIdeogramV2EditRequestsByRequestIdResponse =
  GetFalAiIdeogramV2EditRequestsByRequestIdResponses[keyof GetFalAiIdeogramV2EditRequestsByRequestIdResponses]

export type GetFalAiIdeogramV2TurboEditRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ideogram/v2/turbo/edit/requests/{request_id}/status'
}

export type GetFalAiIdeogramV2TurboEditRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIdeogramV2TurboEditRequestsByRequestIdStatusResponse =
  GetFalAiIdeogramV2TurboEditRequestsByRequestIdStatusResponses[keyof GetFalAiIdeogramV2TurboEditRequestsByRequestIdStatusResponses]

export type PutFalAiIdeogramV2TurboEditRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2/turbo/edit/requests/{request_id}/cancel'
}

export type PutFalAiIdeogramV2TurboEditRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIdeogramV2TurboEditRequestsByRequestIdCancelResponse =
  PutFalAiIdeogramV2TurboEditRequestsByRequestIdCancelResponses[keyof PutFalAiIdeogramV2TurboEditRequestsByRequestIdCancelResponses]

export type PostFalAiIdeogramV2TurboEditData = {
  body: SchemaIdeogramV2TurboEditInput
  path?: never
  query?: never
  url: '/fal-ai/ideogram/v2/turbo/edit'
}

export type PostFalAiIdeogramV2TurboEditResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIdeogramV2TurboEditResponse =
  PostFalAiIdeogramV2TurboEditResponses[keyof PostFalAiIdeogramV2TurboEditResponses]

export type GetFalAiIdeogramV2TurboEditRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2/turbo/edit/requests/{request_id}'
}

export type GetFalAiIdeogramV2TurboEditRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIdeogramV2TurboEditOutput
}

export type GetFalAiIdeogramV2TurboEditRequestsByRequestIdResponse =
  GetFalAiIdeogramV2TurboEditRequestsByRequestIdResponses[keyof GetFalAiIdeogramV2TurboEditRequestsByRequestIdResponses]

export type GetFalAiIdeogramV2TurboRemixRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ideogram/v2/turbo/remix/requests/{request_id}/status'
}

export type GetFalAiIdeogramV2TurboRemixRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIdeogramV2TurboRemixRequestsByRequestIdStatusResponse =
  GetFalAiIdeogramV2TurboRemixRequestsByRequestIdStatusResponses[keyof GetFalAiIdeogramV2TurboRemixRequestsByRequestIdStatusResponses]

export type PutFalAiIdeogramV2TurboRemixRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2/turbo/remix/requests/{request_id}/cancel'
}

export type PutFalAiIdeogramV2TurboRemixRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIdeogramV2TurboRemixRequestsByRequestIdCancelResponse =
  PutFalAiIdeogramV2TurboRemixRequestsByRequestIdCancelResponses[keyof PutFalAiIdeogramV2TurboRemixRequestsByRequestIdCancelResponses]

export type PostFalAiIdeogramV2TurboRemixData = {
  body: SchemaIdeogramV2TurboRemixInput
  path?: never
  query?: never
  url: '/fal-ai/ideogram/v2/turbo/remix'
}

export type PostFalAiIdeogramV2TurboRemixResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIdeogramV2TurboRemixResponse =
  PostFalAiIdeogramV2TurboRemixResponses[keyof PostFalAiIdeogramV2TurboRemixResponses]

export type GetFalAiIdeogramV2TurboRemixRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2/turbo/remix/requests/{request_id}'
}

export type GetFalAiIdeogramV2TurboRemixRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIdeogramV2TurboRemixOutput
}

export type GetFalAiIdeogramV2TurboRemixRequestsByRequestIdResponse =
  GetFalAiIdeogramV2TurboRemixRequestsByRequestIdResponses[keyof GetFalAiIdeogramV2TurboRemixRequestsByRequestIdResponses]

export type GetFalAiIdeogramV2RemixRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ideogram/v2/remix/requests/{request_id}/status'
}

export type GetFalAiIdeogramV2RemixRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIdeogramV2RemixRequestsByRequestIdStatusResponse =
  GetFalAiIdeogramV2RemixRequestsByRequestIdStatusResponses[keyof GetFalAiIdeogramV2RemixRequestsByRequestIdStatusResponses]

export type PutFalAiIdeogramV2RemixRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2/remix/requests/{request_id}/cancel'
}

export type PutFalAiIdeogramV2RemixRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIdeogramV2RemixRequestsByRequestIdCancelResponse =
  PutFalAiIdeogramV2RemixRequestsByRequestIdCancelResponses[keyof PutFalAiIdeogramV2RemixRequestsByRequestIdCancelResponses]

export type PostFalAiIdeogramV2RemixData = {
  body: SchemaIdeogramV2RemixInput
  path?: never
  query?: never
  url: '/fal-ai/ideogram/v2/remix'
}

export type PostFalAiIdeogramV2RemixResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIdeogramV2RemixResponse =
  PostFalAiIdeogramV2RemixResponses[keyof PostFalAiIdeogramV2RemixResponses]

export type GetFalAiIdeogramV2RemixRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2/remix/requests/{request_id}'
}

export type GetFalAiIdeogramV2RemixRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIdeogramV2RemixOutput
}

export type GetFalAiIdeogramV2RemixRequestsByRequestIdResponse =
  GetFalAiIdeogramV2RemixRequestsByRequestIdResponses[keyof GetFalAiIdeogramV2RemixRequestsByRequestIdResponses]

export type GetFalAiFluxSchnellReduxRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux/schnell/redux/requests/{request_id}/status'
}

export type GetFalAiFluxSchnellReduxRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxSchnellReduxRequestsByRequestIdStatusResponse =
  GetFalAiFluxSchnellReduxRequestsByRequestIdStatusResponses[keyof GetFalAiFluxSchnellReduxRequestsByRequestIdStatusResponses]

export type PutFalAiFluxSchnellReduxRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/schnell/redux/requests/{request_id}/cancel'
}

export type PutFalAiFluxSchnellReduxRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxSchnellReduxRequestsByRequestIdCancelResponse =
  PutFalAiFluxSchnellReduxRequestsByRequestIdCancelResponses[keyof PutFalAiFluxSchnellReduxRequestsByRequestIdCancelResponses]

export type PostFalAiFluxSchnellReduxData = {
  body: SchemaFluxSchnellReduxInput
  path?: never
  query?: never
  url: '/fal-ai/flux/schnell/redux'
}

export type PostFalAiFluxSchnellReduxResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxSchnellReduxResponse =
  PostFalAiFluxSchnellReduxResponses[keyof PostFalAiFluxSchnellReduxResponses]

export type GetFalAiFluxSchnellReduxRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/schnell/redux/requests/{request_id}'
}

export type GetFalAiFluxSchnellReduxRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxSchnellReduxOutput
}

export type GetFalAiFluxSchnellReduxRequestsByRequestIdResponse =
  GetFalAiFluxSchnellReduxRequestsByRequestIdResponses[keyof GetFalAiFluxSchnellReduxRequestsByRequestIdResponses]

export type GetFalAiFluxProV11ReduxRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-pro/v1.1/redux/requests/{request_id}/status'
}

export type GetFalAiFluxProV11ReduxRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxProV11ReduxRequestsByRequestIdStatusResponse =
  GetFalAiFluxProV11ReduxRequestsByRequestIdStatusResponses[keyof GetFalAiFluxProV11ReduxRequestsByRequestIdStatusResponses]

export type PutFalAiFluxProV11ReduxRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/v1.1/redux/requests/{request_id}/cancel'
}

export type PutFalAiFluxProV11ReduxRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxProV11ReduxRequestsByRequestIdCancelResponse =
  PutFalAiFluxProV11ReduxRequestsByRequestIdCancelResponses[keyof PutFalAiFluxProV11ReduxRequestsByRequestIdCancelResponses]

export type PostFalAiFluxProV11ReduxData = {
  body: SchemaFluxProV11ReduxInput
  path?: never
  query?: never
  url: '/fal-ai/flux-pro/v1.1/redux'
}

export type PostFalAiFluxProV11ReduxResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxProV11ReduxResponse =
  PostFalAiFluxProV11ReduxResponses[keyof PostFalAiFluxProV11ReduxResponses]

export type GetFalAiFluxProV11ReduxRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/v1.1/redux/requests/{request_id}'
}

export type GetFalAiFluxProV11ReduxRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxProV11ReduxOutput
}

export type GetFalAiFluxProV11ReduxRequestsByRequestIdResponse =
  GetFalAiFluxProV11ReduxRequestsByRequestIdResponses[keyof GetFalAiFluxProV11ReduxRequestsByRequestIdResponses]

export type GetFalAiFluxDevReduxRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux/dev/redux/requests/{request_id}/status'
}

export type GetFalAiFluxDevReduxRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxDevReduxRequestsByRequestIdStatusResponse =
  GetFalAiFluxDevReduxRequestsByRequestIdStatusResponses[keyof GetFalAiFluxDevReduxRequestsByRequestIdStatusResponses]

export type PutFalAiFluxDevReduxRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/dev/redux/requests/{request_id}/cancel'
}

export type PutFalAiFluxDevReduxRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxDevReduxRequestsByRequestIdCancelResponse =
  PutFalAiFluxDevReduxRequestsByRequestIdCancelResponses[keyof PutFalAiFluxDevReduxRequestsByRequestIdCancelResponses]

export type PostFalAiFluxDevReduxData = {
  body: SchemaFluxDevReduxInput
  path?: never
  query?: never
  url: '/fal-ai/flux/dev/redux'
}

export type PostFalAiFluxDevReduxResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxDevReduxResponse =
  PostFalAiFluxDevReduxResponses[keyof PostFalAiFluxDevReduxResponses]

export type GetFalAiFluxDevReduxRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/dev/redux/requests/{request_id}'
}

export type GetFalAiFluxDevReduxRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxDevReduxOutput
}

export type GetFalAiFluxDevReduxRequestsByRequestIdResponse =
  GetFalAiFluxDevReduxRequestsByRequestIdResponses[keyof GetFalAiFluxDevReduxRequestsByRequestIdResponses]

export type GetFalAiFluxProV11UltraReduxRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-pro/v1.1-ultra/redux/requests/{request_id}/status'
}

export type GetFalAiFluxProV11UltraReduxRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxProV11UltraReduxRequestsByRequestIdStatusResponse =
  GetFalAiFluxProV11UltraReduxRequestsByRequestIdStatusResponses[keyof GetFalAiFluxProV11UltraReduxRequestsByRequestIdStatusResponses]

export type PutFalAiFluxProV11UltraReduxRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/v1.1-ultra/redux/requests/{request_id}/cancel'
}

export type PutFalAiFluxProV11UltraReduxRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxProV11UltraReduxRequestsByRequestIdCancelResponse =
  PutFalAiFluxProV11UltraReduxRequestsByRequestIdCancelResponses[keyof PutFalAiFluxProV11UltraReduxRequestsByRequestIdCancelResponses]

export type PostFalAiFluxProV11UltraReduxData = {
  body: SchemaFluxProV11UltraReduxInput
  path?: never
  query?: never
  url: '/fal-ai/flux-pro/v1.1-ultra/redux'
}

export type PostFalAiFluxProV11UltraReduxResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxProV11UltraReduxResponse =
  PostFalAiFluxProV11UltraReduxResponses[keyof PostFalAiFluxProV11UltraReduxResponses]

export type GetFalAiFluxProV11UltraReduxRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/v1.1-ultra/redux/requests/{request_id}'
}

export type GetFalAiFluxProV11UltraReduxRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxProV11UltraReduxOutput
}

export type GetFalAiFluxProV11UltraReduxRequestsByRequestIdResponse =
  GetFalAiFluxProV11UltraReduxRequestsByRequestIdResponses[keyof GetFalAiFluxProV11UltraReduxRequestsByRequestIdResponses]

export type GetFalAiFluxLoraDepthRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-lora-depth/requests/{request_id}/status'
}

export type GetFalAiFluxLoraDepthRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxLoraDepthRequestsByRequestIdStatusResponse =
  GetFalAiFluxLoraDepthRequestsByRequestIdStatusResponses[keyof GetFalAiFluxLoraDepthRequestsByRequestIdStatusResponses]

export type PutFalAiFluxLoraDepthRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-lora-depth/requests/{request_id}/cancel'
}

export type PutFalAiFluxLoraDepthRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxLoraDepthRequestsByRequestIdCancelResponse =
  PutFalAiFluxLoraDepthRequestsByRequestIdCancelResponses[keyof PutFalAiFluxLoraDepthRequestsByRequestIdCancelResponses]

export type PostFalAiFluxLoraDepthData = {
  body: SchemaFluxLoraDepthInput
  path?: never
  query?: never
  url: '/fal-ai/flux-lora-depth'
}

export type PostFalAiFluxLoraDepthResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxLoraDepthResponse =
  PostFalAiFluxLoraDepthResponses[keyof PostFalAiFluxLoraDepthResponses]

export type GetFalAiFluxLoraDepthRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-lora-depth/requests/{request_id}'
}

export type GetFalAiFluxLoraDepthRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxLoraDepthOutput
}

export type GetFalAiFluxLoraDepthRequestsByRequestIdResponse =
  GetFalAiFluxLoraDepthRequestsByRequestIdResponses[keyof GetFalAiFluxLoraDepthRequestsByRequestIdResponses]

export type GetFalAiFluxProV1FillRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-pro/v1/fill/requests/{request_id}/status'
}

export type GetFalAiFluxProV1FillRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxProV1FillRequestsByRequestIdStatusResponse =
  GetFalAiFluxProV1FillRequestsByRequestIdStatusResponses[keyof GetFalAiFluxProV1FillRequestsByRequestIdStatusResponses]

export type PutFalAiFluxProV1FillRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/v1/fill/requests/{request_id}/cancel'
}

export type PutFalAiFluxProV1FillRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxProV1FillRequestsByRequestIdCancelResponse =
  PutFalAiFluxProV1FillRequestsByRequestIdCancelResponses[keyof PutFalAiFluxProV1FillRequestsByRequestIdCancelResponses]

export type PostFalAiFluxProV1FillData = {
  body: SchemaFluxProV1FillInput
  path?: never
  query?: never
  url: '/fal-ai/flux-pro/v1/fill'
}

export type PostFalAiFluxProV1FillResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxProV1FillResponse =
  PostFalAiFluxProV1FillResponses[keyof PostFalAiFluxProV1FillResponses]

export type GetFalAiFluxProV1FillRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/v1/fill/requests/{request_id}'
}

export type GetFalAiFluxProV1FillRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxProV1FillOutput
}

export type GetFalAiFluxProV1FillRequestsByRequestIdResponse =
  GetFalAiFluxProV1FillRequestsByRequestIdResponses[keyof GetFalAiFluxProV1FillRequestsByRequestIdResponses]

export type GetFalAiKolorsImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/kolors/image-to-image/requests/{request_id}/status'
}

export type GetFalAiKolorsImageToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiKolorsImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiKolorsImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiKolorsImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiKolorsImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/kolors/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiKolorsImageToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiKolorsImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiKolorsImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiKolorsImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiKolorsImageToImageData = {
  body: SchemaKolorsImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/kolors/image-to-image'
}

export type PostFalAiKolorsImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiKolorsImageToImageResponse =
  PostFalAiKolorsImageToImageResponses[keyof PostFalAiKolorsImageToImageResponses]

export type GetFalAiKolorsImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/kolors/image-to-image/requests/{request_id}'
}

export type GetFalAiKolorsImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaKolorsImageToImageOutput
}

export type GetFalAiKolorsImageToImageRequestsByRequestIdResponse =
  GetFalAiKolorsImageToImageRequestsByRequestIdResponses[keyof GetFalAiKolorsImageToImageRequestsByRequestIdResponses]

export type GetFalAiIclightV2RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/iclight-v2/requests/{request_id}/status'
}

export type GetFalAiIclightV2RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIclightV2RequestsByRequestIdStatusResponse =
  GetFalAiIclightV2RequestsByRequestIdStatusResponses[keyof GetFalAiIclightV2RequestsByRequestIdStatusResponses]

export type PutFalAiIclightV2RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/iclight-v2/requests/{request_id}/cancel'
}

export type PutFalAiIclightV2RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIclightV2RequestsByRequestIdCancelResponse =
  PutFalAiIclightV2RequestsByRequestIdCancelResponses[keyof PutFalAiIclightV2RequestsByRequestIdCancelResponses]

export type PostFalAiIclightV2Data = {
  body: SchemaIclightV2Input
  path?: never
  query?: never
  url: '/fal-ai/iclight-v2'
}

export type PostFalAiIclightV2Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIclightV2Response =
  PostFalAiIclightV2Responses[keyof PostFalAiIclightV2Responses]

export type GetFalAiIclightV2RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/iclight-v2/requests/{request_id}'
}

export type GetFalAiIclightV2RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIclightV2Output
}

export type GetFalAiIclightV2RequestsByRequestIdResponse =
  GetFalAiIclightV2RequestsByRequestIdResponses[keyof GetFalAiIclightV2RequestsByRequestIdResponses]

export type GetFalAiFluxDifferentialDiffusionRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-differential-diffusion/requests/{request_id}/status'
}

export type GetFalAiFluxDifferentialDiffusionRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFluxDifferentialDiffusionRequestsByRequestIdStatusResponse =
  GetFalAiFluxDifferentialDiffusionRequestsByRequestIdStatusResponses[keyof GetFalAiFluxDifferentialDiffusionRequestsByRequestIdStatusResponses]

export type PutFalAiFluxDifferentialDiffusionRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-differential-diffusion/requests/{request_id}/cancel'
}

export type PutFalAiFluxDifferentialDiffusionRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFluxDifferentialDiffusionRequestsByRequestIdCancelResponse =
  PutFalAiFluxDifferentialDiffusionRequestsByRequestIdCancelResponses[keyof PutFalAiFluxDifferentialDiffusionRequestsByRequestIdCancelResponses]

export type PostFalAiFluxDifferentialDiffusionData = {
  body: SchemaFluxDifferentialDiffusionInput
  path?: never
  query?: never
  url: '/fal-ai/flux-differential-diffusion'
}

export type PostFalAiFluxDifferentialDiffusionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxDifferentialDiffusionResponse =
  PostFalAiFluxDifferentialDiffusionResponses[keyof PostFalAiFluxDifferentialDiffusionResponses]

export type GetFalAiFluxDifferentialDiffusionRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-differential-diffusion/requests/{request_id}'
}

export type GetFalAiFluxDifferentialDiffusionRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxDifferentialDiffusionOutput
}

export type GetFalAiFluxDifferentialDiffusionRequestsByRequestIdResponse =
  GetFalAiFluxDifferentialDiffusionRequestsByRequestIdResponses[keyof GetFalAiFluxDifferentialDiffusionRequestsByRequestIdResponses]

export type GetFalAiFluxPulidRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-pulid/requests/{request_id}/status'
}

export type GetFalAiFluxPulidRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxPulidRequestsByRequestIdStatusResponse =
  GetFalAiFluxPulidRequestsByRequestIdStatusResponses[keyof GetFalAiFluxPulidRequestsByRequestIdStatusResponses]

export type PutFalAiFluxPulidRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pulid/requests/{request_id}/cancel'
}

export type PutFalAiFluxPulidRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxPulidRequestsByRequestIdCancelResponse =
  PutFalAiFluxPulidRequestsByRequestIdCancelResponses[keyof PutFalAiFluxPulidRequestsByRequestIdCancelResponses]

export type PostFalAiFluxPulidData = {
  body: SchemaFluxPulidInput
  path?: never
  query?: never
  url: '/fal-ai/flux-pulid'
}

export type PostFalAiFluxPulidResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxPulidResponse =
  PostFalAiFluxPulidResponses[keyof PostFalAiFluxPulidResponses]

export type GetFalAiFluxPulidRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pulid/requests/{request_id}'
}

export type GetFalAiFluxPulidRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxPulidOutput
}

export type GetFalAiFluxPulidRequestsByRequestIdResponse =
  GetFalAiFluxPulidRequestsByRequestIdResponses[keyof GetFalAiFluxPulidRequestsByRequestIdResponses]

export type GetFalAiBirefnetV2RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/birefnet/v2/requests/{request_id}/status'
}

export type GetFalAiBirefnetV2RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiBirefnetV2RequestsByRequestIdStatusResponse =
  GetFalAiBirefnetV2RequestsByRequestIdStatusResponses[keyof GetFalAiBirefnetV2RequestsByRequestIdStatusResponses]

export type PutFalAiBirefnetV2RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/birefnet/v2/requests/{request_id}/cancel'
}

export type PutFalAiBirefnetV2RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiBirefnetV2RequestsByRequestIdCancelResponse =
  PutFalAiBirefnetV2RequestsByRequestIdCancelResponses[keyof PutFalAiBirefnetV2RequestsByRequestIdCancelResponses]

export type PostFalAiBirefnetV2Data = {
  body: SchemaBirefnetV2Input
  path?: never
  query?: never
  url: '/fal-ai/birefnet/v2'
}

export type PostFalAiBirefnetV2Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBirefnetV2Response =
  PostFalAiBirefnetV2Responses[keyof PostFalAiBirefnetV2Responses]

export type GetFalAiBirefnetV2RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/birefnet/v2/requests/{request_id}'
}

export type GetFalAiBirefnetV2RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaBirefnetV2Output
}

export type GetFalAiBirefnetV2RequestsByRequestIdResponse =
  GetFalAiBirefnetV2RequestsByRequestIdResponses[keyof GetFalAiBirefnetV2RequestsByRequestIdResponses]

export type GetFalAiLivePortraitImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/live-portrait/image/requests/{request_id}/status'
}

export type GetFalAiLivePortraitImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLivePortraitImageRequestsByRequestIdStatusResponse =
  GetFalAiLivePortraitImageRequestsByRequestIdStatusResponses[keyof GetFalAiLivePortraitImageRequestsByRequestIdStatusResponses]

export type PutFalAiLivePortraitImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/live-portrait/image/requests/{request_id}/cancel'
}

export type PutFalAiLivePortraitImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLivePortraitImageRequestsByRequestIdCancelResponse =
  PutFalAiLivePortraitImageRequestsByRequestIdCancelResponses[keyof PutFalAiLivePortraitImageRequestsByRequestIdCancelResponses]

export type PostFalAiLivePortraitImageData = {
  body: SchemaLivePortraitImageInput
  path?: never
  query?: never
  url: '/fal-ai/live-portrait/image'
}

export type PostFalAiLivePortraitImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLivePortraitImageResponse =
  PostFalAiLivePortraitImageResponses[keyof PostFalAiLivePortraitImageResponses]

export type GetFalAiLivePortraitImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/live-portrait/image/requests/{request_id}'
}

export type GetFalAiLivePortraitImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLivePortraitImageOutput
}

export type GetFalAiLivePortraitImageRequestsByRequestIdResponse =
  GetFalAiLivePortraitImageRequestsByRequestIdResponses[keyof GetFalAiLivePortraitImageRequestsByRequestIdResponses]

export type GetFalAiFluxGeneralRfInversionRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-general/rf-inversion/requests/{request_id}/status'
}

export type GetFalAiFluxGeneralRfInversionRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxGeneralRfInversionRequestsByRequestIdStatusResponse =
  GetFalAiFluxGeneralRfInversionRequestsByRequestIdStatusResponses[keyof GetFalAiFluxGeneralRfInversionRequestsByRequestIdStatusResponses]

export type PutFalAiFluxGeneralRfInversionRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-general/rf-inversion/requests/{request_id}/cancel'
}

export type PutFalAiFluxGeneralRfInversionRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxGeneralRfInversionRequestsByRequestIdCancelResponse =
  PutFalAiFluxGeneralRfInversionRequestsByRequestIdCancelResponses[keyof PutFalAiFluxGeneralRfInversionRequestsByRequestIdCancelResponses]

export type PostFalAiFluxGeneralRfInversionData = {
  body: SchemaFluxGeneralRfInversionInput
  path?: never
  query?: never
  url: '/fal-ai/flux-general/rf-inversion'
}

export type PostFalAiFluxGeneralRfInversionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxGeneralRfInversionResponse =
  PostFalAiFluxGeneralRfInversionResponses[keyof PostFalAiFluxGeneralRfInversionResponses]

export type GetFalAiFluxGeneralRfInversionRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-general/rf-inversion/requests/{request_id}'
}

export type GetFalAiFluxGeneralRfInversionRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxGeneralRfInversionOutput
}

export type GetFalAiFluxGeneralRfInversionRequestsByRequestIdResponse =
  GetFalAiFluxGeneralRfInversionRequestsByRequestIdResponses[keyof GetFalAiFluxGeneralRfInversionRequestsByRequestIdResponses]

export type GetFalAiImagePreprocessorsHedRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-preprocessors/hed/requests/{request_id}/status'
}

export type GetFalAiImagePreprocessorsHedRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImagePreprocessorsHedRequestsByRequestIdStatusResponse =
  GetFalAiImagePreprocessorsHedRequestsByRequestIdStatusResponses[keyof GetFalAiImagePreprocessorsHedRequestsByRequestIdStatusResponses]

export type PutFalAiImagePreprocessorsHedRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-preprocessors/hed/requests/{request_id}/cancel'
}

export type PutFalAiImagePreprocessorsHedRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImagePreprocessorsHedRequestsByRequestIdCancelResponse =
  PutFalAiImagePreprocessorsHedRequestsByRequestIdCancelResponses[keyof PutFalAiImagePreprocessorsHedRequestsByRequestIdCancelResponses]

export type PostFalAiImagePreprocessorsHedData = {
  body: SchemaImagePreprocessorsHedInput
  path?: never
  query?: never
  url: '/fal-ai/image-preprocessors/hed'
}

export type PostFalAiImagePreprocessorsHedResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImagePreprocessorsHedResponse =
  PostFalAiImagePreprocessorsHedResponses[keyof PostFalAiImagePreprocessorsHedResponses]

export type GetFalAiImagePreprocessorsHedRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-preprocessors/hed/requests/{request_id}'
}

export type GetFalAiImagePreprocessorsHedRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImagePreprocessorsHedOutput
}

export type GetFalAiImagePreprocessorsHedRequestsByRequestIdResponse =
  GetFalAiImagePreprocessorsHedRequestsByRequestIdResponses[keyof GetFalAiImagePreprocessorsHedRequestsByRequestIdResponses]

export type GetFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/image-preprocessors/depth-anything/v2/requests/{request_id}/status'
  }

export type GetFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdStatusResponse =
  GetFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdStatusResponses[keyof GetFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdStatusResponses]

export type PutFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/image-preprocessors/depth-anything/v2/requests/{request_id}/cancel'
  }

export type PutFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdCancelResponse =
  PutFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdCancelResponses[keyof PutFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdCancelResponses]

export type PostFalAiImagePreprocessorsDepthAnythingV2Data = {
  body: SchemaImagePreprocessorsDepthAnythingV2Input
  path?: never
  query?: never
  url: '/fal-ai/image-preprocessors/depth-anything/v2'
}

export type PostFalAiImagePreprocessorsDepthAnythingV2Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImagePreprocessorsDepthAnythingV2Response =
  PostFalAiImagePreprocessorsDepthAnythingV2Responses[keyof PostFalAiImagePreprocessorsDepthAnythingV2Responses]

export type GetFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-preprocessors/depth-anything/v2/requests/{request_id}'
}

export type GetFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaImagePreprocessorsDepthAnythingV2Output
  }

export type GetFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdResponse =
  GetFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdResponses[keyof GetFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdResponses]

export type GetFalAiImagePreprocessorsScribbleRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-preprocessors/scribble/requests/{request_id}/status'
}

export type GetFalAiImagePreprocessorsScribbleRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImagePreprocessorsScribbleRequestsByRequestIdStatusResponse =
  GetFalAiImagePreprocessorsScribbleRequestsByRequestIdStatusResponses[keyof GetFalAiImagePreprocessorsScribbleRequestsByRequestIdStatusResponses]

export type PutFalAiImagePreprocessorsScribbleRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-preprocessors/scribble/requests/{request_id}/cancel'
}

export type PutFalAiImagePreprocessorsScribbleRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImagePreprocessorsScribbleRequestsByRequestIdCancelResponse =
  PutFalAiImagePreprocessorsScribbleRequestsByRequestIdCancelResponses[keyof PutFalAiImagePreprocessorsScribbleRequestsByRequestIdCancelResponses]

export type PostFalAiImagePreprocessorsScribbleData = {
  body: SchemaImagePreprocessorsScribbleInput
  path?: never
  query?: never
  url: '/fal-ai/image-preprocessors/scribble'
}

export type PostFalAiImagePreprocessorsScribbleResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImagePreprocessorsScribbleResponse =
  PostFalAiImagePreprocessorsScribbleResponses[keyof PostFalAiImagePreprocessorsScribbleResponses]

export type GetFalAiImagePreprocessorsScribbleRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-preprocessors/scribble/requests/{request_id}'
}

export type GetFalAiImagePreprocessorsScribbleRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImagePreprocessorsScribbleOutput
}

export type GetFalAiImagePreprocessorsScribbleRequestsByRequestIdResponse =
  GetFalAiImagePreprocessorsScribbleRequestsByRequestIdResponses[keyof GetFalAiImagePreprocessorsScribbleRequestsByRequestIdResponses]

export type GetFalAiImagePreprocessorsMlsdRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-preprocessors/mlsd/requests/{request_id}/status'
}

export type GetFalAiImagePreprocessorsMlsdRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImagePreprocessorsMlsdRequestsByRequestIdStatusResponse =
  GetFalAiImagePreprocessorsMlsdRequestsByRequestIdStatusResponses[keyof GetFalAiImagePreprocessorsMlsdRequestsByRequestIdStatusResponses]

export type PutFalAiImagePreprocessorsMlsdRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-preprocessors/mlsd/requests/{request_id}/cancel'
}

export type PutFalAiImagePreprocessorsMlsdRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImagePreprocessorsMlsdRequestsByRequestIdCancelResponse =
  PutFalAiImagePreprocessorsMlsdRequestsByRequestIdCancelResponses[keyof PutFalAiImagePreprocessorsMlsdRequestsByRequestIdCancelResponses]

export type PostFalAiImagePreprocessorsMlsdData = {
  body: SchemaImagePreprocessorsMlsdInput
  path?: never
  query?: never
  url: '/fal-ai/image-preprocessors/mlsd'
}

export type PostFalAiImagePreprocessorsMlsdResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImagePreprocessorsMlsdResponse =
  PostFalAiImagePreprocessorsMlsdResponses[keyof PostFalAiImagePreprocessorsMlsdResponses]

export type GetFalAiImagePreprocessorsMlsdRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-preprocessors/mlsd/requests/{request_id}'
}

export type GetFalAiImagePreprocessorsMlsdRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImagePreprocessorsMlsdOutput
}

export type GetFalAiImagePreprocessorsMlsdRequestsByRequestIdResponse =
  GetFalAiImagePreprocessorsMlsdRequestsByRequestIdResponses[keyof GetFalAiImagePreprocessorsMlsdRequestsByRequestIdResponses]

export type GetFalAiImagePreprocessorsSamRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-preprocessors/sam/requests/{request_id}/status'
}

export type GetFalAiImagePreprocessorsSamRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImagePreprocessorsSamRequestsByRequestIdStatusResponse =
  GetFalAiImagePreprocessorsSamRequestsByRequestIdStatusResponses[keyof GetFalAiImagePreprocessorsSamRequestsByRequestIdStatusResponses]

export type PutFalAiImagePreprocessorsSamRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-preprocessors/sam/requests/{request_id}/cancel'
}

export type PutFalAiImagePreprocessorsSamRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImagePreprocessorsSamRequestsByRequestIdCancelResponse =
  PutFalAiImagePreprocessorsSamRequestsByRequestIdCancelResponses[keyof PutFalAiImagePreprocessorsSamRequestsByRequestIdCancelResponses]

export type PostFalAiImagePreprocessorsSamData = {
  body: SchemaImagePreprocessorsSamInput
  path?: never
  query?: never
  url: '/fal-ai/image-preprocessors/sam'
}

export type PostFalAiImagePreprocessorsSamResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImagePreprocessorsSamResponse =
  PostFalAiImagePreprocessorsSamResponses[keyof PostFalAiImagePreprocessorsSamResponses]

export type GetFalAiImagePreprocessorsSamRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-preprocessors/sam/requests/{request_id}'
}

export type GetFalAiImagePreprocessorsSamRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImagePreprocessorsSamOutput
}

export type GetFalAiImagePreprocessorsSamRequestsByRequestIdResponse =
  GetFalAiImagePreprocessorsSamRequestsByRequestIdResponses[keyof GetFalAiImagePreprocessorsSamRequestsByRequestIdResponses]

export type GetFalAiImagePreprocessorsMidasRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-preprocessors/midas/requests/{request_id}/status'
}

export type GetFalAiImagePreprocessorsMidasRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImagePreprocessorsMidasRequestsByRequestIdStatusResponse =
  GetFalAiImagePreprocessorsMidasRequestsByRequestIdStatusResponses[keyof GetFalAiImagePreprocessorsMidasRequestsByRequestIdStatusResponses]

export type PutFalAiImagePreprocessorsMidasRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-preprocessors/midas/requests/{request_id}/cancel'
}

export type PutFalAiImagePreprocessorsMidasRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImagePreprocessorsMidasRequestsByRequestIdCancelResponse =
  PutFalAiImagePreprocessorsMidasRequestsByRequestIdCancelResponses[keyof PutFalAiImagePreprocessorsMidasRequestsByRequestIdCancelResponses]

export type PostFalAiImagePreprocessorsMidasData = {
  body: SchemaImagePreprocessorsMidasInput
  path?: never
  query?: never
  url: '/fal-ai/image-preprocessors/midas'
}

export type PostFalAiImagePreprocessorsMidasResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImagePreprocessorsMidasResponse =
  PostFalAiImagePreprocessorsMidasResponses[keyof PostFalAiImagePreprocessorsMidasResponses]

export type GetFalAiImagePreprocessorsMidasRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-preprocessors/midas/requests/{request_id}'
}

export type GetFalAiImagePreprocessorsMidasRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImagePreprocessorsMidasOutput
}

export type GetFalAiImagePreprocessorsMidasRequestsByRequestIdResponse =
  GetFalAiImagePreprocessorsMidasRequestsByRequestIdResponses[keyof GetFalAiImagePreprocessorsMidasRequestsByRequestIdResponses]

export type GetFalAiImagePreprocessorsTeedRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-preprocessors/teed/requests/{request_id}/status'
}

export type GetFalAiImagePreprocessorsTeedRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImagePreprocessorsTeedRequestsByRequestIdStatusResponse =
  GetFalAiImagePreprocessorsTeedRequestsByRequestIdStatusResponses[keyof GetFalAiImagePreprocessorsTeedRequestsByRequestIdStatusResponses]

export type PutFalAiImagePreprocessorsTeedRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-preprocessors/teed/requests/{request_id}/cancel'
}

export type PutFalAiImagePreprocessorsTeedRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImagePreprocessorsTeedRequestsByRequestIdCancelResponse =
  PutFalAiImagePreprocessorsTeedRequestsByRequestIdCancelResponses[keyof PutFalAiImagePreprocessorsTeedRequestsByRequestIdCancelResponses]

export type PostFalAiImagePreprocessorsTeedData = {
  body: SchemaImagePreprocessorsTeedInput
  path?: never
  query?: never
  url: '/fal-ai/image-preprocessors/teed'
}

export type PostFalAiImagePreprocessorsTeedResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImagePreprocessorsTeedResponse =
  PostFalAiImagePreprocessorsTeedResponses[keyof PostFalAiImagePreprocessorsTeedResponses]

export type GetFalAiImagePreprocessorsTeedRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-preprocessors/teed/requests/{request_id}'
}

export type GetFalAiImagePreprocessorsTeedRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImagePreprocessorsTeedOutput
}

export type GetFalAiImagePreprocessorsTeedRequestsByRequestIdResponse =
  GetFalAiImagePreprocessorsTeedRequestsByRequestIdResponses[keyof GetFalAiImagePreprocessorsTeedRequestsByRequestIdResponses]

export type GetFalAiImagePreprocessorsLineartRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-preprocessors/lineart/requests/{request_id}/status'
}

export type GetFalAiImagePreprocessorsLineartRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImagePreprocessorsLineartRequestsByRequestIdStatusResponse =
  GetFalAiImagePreprocessorsLineartRequestsByRequestIdStatusResponses[keyof GetFalAiImagePreprocessorsLineartRequestsByRequestIdStatusResponses]

export type PutFalAiImagePreprocessorsLineartRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-preprocessors/lineart/requests/{request_id}/cancel'
}

export type PutFalAiImagePreprocessorsLineartRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImagePreprocessorsLineartRequestsByRequestIdCancelResponse =
  PutFalAiImagePreprocessorsLineartRequestsByRequestIdCancelResponses[keyof PutFalAiImagePreprocessorsLineartRequestsByRequestIdCancelResponses]

export type PostFalAiImagePreprocessorsLineartData = {
  body: SchemaImagePreprocessorsLineartInput
  path?: never
  query?: never
  url: '/fal-ai/image-preprocessors/lineart'
}

export type PostFalAiImagePreprocessorsLineartResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImagePreprocessorsLineartResponse =
  PostFalAiImagePreprocessorsLineartResponses[keyof PostFalAiImagePreprocessorsLineartResponses]

export type GetFalAiImagePreprocessorsLineartRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-preprocessors/lineart/requests/{request_id}'
}

export type GetFalAiImagePreprocessorsLineartRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImagePreprocessorsLineartOutput
}

export type GetFalAiImagePreprocessorsLineartRequestsByRequestIdResponse =
  GetFalAiImagePreprocessorsLineartRequestsByRequestIdResponses[keyof GetFalAiImagePreprocessorsLineartRequestsByRequestIdResponses]

export type GetFalAiImagePreprocessorsZoeRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-preprocessors/zoe/requests/{request_id}/status'
}

export type GetFalAiImagePreprocessorsZoeRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImagePreprocessorsZoeRequestsByRequestIdStatusResponse =
  GetFalAiImagePreprocessorsZoeRequestsByRequestIdStatusResponses[keyof GetFalAiImagePreprocessorsZoeRequestsByRequestIdStatusResponses]

export type PutFalAiImagePreprocessorsZoeRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-preprocessors/zoe/requests/{request_id}/cancel'
}

export type PutFalAiImagePreprocessorsZoeRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImagePreprocessorsZoeRequestsByRequestIdCancelResponse =
  PutFalAiImagePreprocessorsZoeRequestsByRequestIdCancelResponses[keyof PutFalAiImagePreprocessorsZoeRequestsByRequestIdCancelResponses]

export type PostFalAiImagePreprocessorsZoeData = {
  body: SchemaImagePreprocessorsZoeInput
  path?: never
  query?: never
  url: '/fal-ai/image-preprocessors/zoe'
}

export type PostFalAiImagePreprocessorsZoeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImagePreprocessorsZoeResponse =
  PostFalAiImagePreprocessorsZoeResponses[keyof PostFalAiImagePreprocessorsZoeResponses]

export type GetFalAiImagePreprocessorsZoeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-preprocessors/zoe/requests/{request_id}'
}

export type GetFalAiImagePreprocessorsZoeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImagePreprocessorsZoeOutput
}

export type GetFalAiImagePreprocessorsZoeRequestsByRequestIdResponse =
  GetFalAiImagePreprocessorsZoeRequestsByRequestIdResponses[keyof GetFalAiImagePreprocessorsZoeRequestsByRequestIdResponses]

export type GetFalAiImagePreprocessorsPidiRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/image-preprocessors/pidi/requests/{request_id}/status'
}

export type GetFalAiImagePreprocessorsPidiRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImagePreprocessorsPidiRequestsByRequestIdStatusResponse =
  GetFalAiImagePreprocessorsPidiRequestsByRequestIdStatusResponses[keyof GetFalAiImagePreprocessorsPidiRequestsByRequestIdStatusResponses]

export type PutFalAiImagePreprocessorsPidiRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-preprocessors/pidi/requests/{request_id}/cancel'
}

export type PutFalAiImagePreprocessorsPidiRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImagePreprocessorsPidiRequestsByRequestIdCancelResponse =
  PutFalAiImagePreprocessorsPidiRequestsByRequestIdCancelResponses[keyof PutFalAiImagePreprocessorsPidiRequestsByRequestIdCancelResponses]

export type PostFalAiImagePreprocessorsPidiData = {
  body: SchemaImagePreprocessorsPidiInput
  path?: never
  query?: never
  url: '/fal-ai/image-preprocessors/pidi'
}

export type PostFalAiImagePreprocessorsPidiResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImagePreprocessorsPidiResponse =
  PostFalAiImagePreprocessorsPidiResponses[keyof PostFalAiImagePreprocessorsPidiResponses]

export type GetFalAiImagePreprocessorsPidiRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/image-preprocessors/pidi/requests/{request_id}'
}

export type GetFalAiImagePreprocessorsPidiRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImagePreprocessorsPidiOutput
}

export type GetFalAiImagePreprocessorsPidiRequestsByRequestIdResponse =
  GetFalAiImagePreprocessorsPidiRequestsByRequestIdResponses[keyof GetFalAiImagePreprocessorsPidiRequestsByRequestIdResponses]

export type GetFalAiSam2ImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/sam2/image/requests/{request_id}/status'
}

export type GetFalAiSam2ImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiSam2ImageRequestsByRequestIdStatusResponse =
  GetFalAiSam2ImageRequestsByRequestIdStatusResponses[keyof GetFalAiSam2ImageRequestsByRequestIdStatusResponses]

export type PutFalAiSam2ImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sam2/image/requests/{request_id}/cancel'
}

export type PutFalAiSam2ImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiSam2ImageRequestsByRequestIdCancelResponse =
  PutFalAiSam2ImageRequestsByRequestIdCancelResponses[keyof PutFalAiSam2ImageRequestsByRequestIdCancelResponses]

export type PostFalAiSam2ImageData = {
  body: SchemaSam2ImageInput
  path?: never
  query?: never
  url: '/fal-ai/sam2/image'
}

export type PostFalAiSam2ImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiSam2ImageResponse =
  PostFalAiSam2ImageResponses[keyof PostFalAiSam2ImageResponses]

export type GetFalAiSam2ImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sam2/image/requests/{request_id}'
}

export type GetFalAiSam2ImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaSam2ImageOutput
}

export type GetFalAiSam2ImageRequestsByRequestIdResponse =
  GetFalAiSam2ImageRequestsByRequestIdResponses[keyof GetFalAiSam2ImageRequestsByRequestIdResponses]

export type GetFalAiFluxGeneralImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-general/image-to-image/requests/{request_id}/status'
}

export type GetFalAiFluxGeneralImageToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFluxGeneralImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiFluxGeneralImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiFluxGeneralImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiFluxGeneralImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-general/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiFluxGeneralImageToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFluxGeneralImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiFluxGeneralImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiFluxGeneralImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiFluxGeneralImageToImageData = {
  body: SchemaFluxGeneralImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/flux-general/image-to-image'
}

export type PostFalAiFluxGeneralImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxGeneralImageToImageResponse =
  PostFalAiFluxGeneralImageToImageResponses[keyof PostFalAiFluxGeneralImageToImageResponses]

export type GetFalAiFluxGeneralImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-general/image-to-image/requests/{request_id}'
}

export type GetFalAiFluxGeneralImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxGeneralImageToImageOutput
}

export type GetFalAiFluxGeneralImageToImageRequestsByRequestIdResponse =
  GetFalAiFluxGeneralImageToImageRequestsByRequestIdResponses[keyof GetFalAiFluxGeneralImageToImageRequestsByRequestIdResponses]

export type GetFalAiFluxGeneralInpaintingRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-general/inpainting/requests/{request_id}/status'
}

export type GetFalAiFluxGeneralInpaintingRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxGeneralInpaintingRequestsByRequestIdStatusResponse =
  GetFalAiFluxGeneralInpaintingRequestsByRequestIdStatusResponses[keyof GetFalAiFluxGeneralInpaintingRequestsByRequestIdStatusResponses]

export type PutFalAiFluxGeneralInpaintingRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-general/inpainting/requests/{request_id}/cancel'
}

export type PutFalAiFluxGeneralInpaintingRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxGeneralInpaintingRequestsByRequestIdCancelResponse =
  PutFalAiFluxGeneralInpaintingRequestsByRequestIdCancelResponses[keyof PutFalAiFluxGeneralInpaintingRequestsByRequestIdCancelResponses]

export type PostFalAiFluxGeneralInpaintingData = {
  body: SchemaFluxGeneralInpaintingInput
  path?: never
  query?: never
  url: '/fal-ai/flux-general/inpainting'
}

export type PostFalAiFluxGeneralInpaintingResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxGeneralInpaintingResponse =
  PostFalAiFluxGeneralInpaintingResponses[keyof PostFalAiFluxGeneralInpaintingResponses]

export type GetFalAiFluxGeneralInpaintingRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-general/inpainting/requests/{request_id}'
}

export type GetFalAiFluxGeneralInpaintingRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxGeneralInpaintingOutput
}

export type GetFalAiFluxGeneralInpaintingRequestsByRequestIdResponse =
  GetFalAiFluxGeneralInpaintingRequestsByRequestIdResponses[keyof GetFalAiFluxGeneralInpaintingRequestsByRequestIdResponses]

export type GetFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/flux-general/differential-diffusion/requests/{request_id}/status'
  }

export type GetFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdStatusResponse =
  GetFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdStatusResponses[keyof GetFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdStatusResponses]

export type PutFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/flux-general/differential-diffusion/requests/{request_id}/cancel'
  }

export type PutFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdCancelResponse =
  PutFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdCancelResponses[keyof PutFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdCancelResponses]

export type PostFalAiFluxGeneralDifferentialDiffusionData = {
  body: SchemaFluxGeneralDifferentialDiffusionInput
  path?: never
  query?: never
  url: '/fal-ai/flux-general/differential-diffusion'
}

export type PostFalAiFluxGeneralDifferentialDiffusionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxGeneralDifferentialDiffusionResponse =
  PostFalAiFluxGeneralDifferentialDiffusionResponses[keyof PostFalAiFluxGeneralDifferentialDiffusionResponses]

export type GetFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-general/differential-diffusion/requests/{request_id}'
}

export type GetFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaFluxGeneralDifferentialDiffusionOutput
  }

export type GetFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdResponse =
  GetFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdResponses[keyof GetFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdResponses]

export type GetFalAiFluxLoraImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-lora/image-to-image/requests/{request_id}/status'
}

export type GetFalAiFluxLoraImageToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxLoraImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiFluxLoraImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiFluxLoraImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiFluxLoraImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-lora/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiFluxLoraImageToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxLoraImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiFluxLoraImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiFluxLoraImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiFluxLoraImageToImageData = {
  body: SchemaFluxLoraImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/flux-lora/image-to-image'
}

export type PostFalAiFluxLoraImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxLoraImageToImageResponse =
  PostFalAiFluxLoraImageToImageResponses[keyof PostFalAiFluxLoraImageToImageResponses]

export type GetFalAiFluxLoraImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-lora/image-to-image/requests/{request_id}'
}

export type GetFalAiFluxLoraImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxLoraImageToImageOutput
}

export type GetFalAiFluxLoraImageToImageRequestsByRequestIdResponse =
  GetFalAiFluxLoraImageToImageRequestsByRequestIdResponses[keyof GetFalAiFluxLoraImageToImageRequestsByRequestIdResponses]

export type GetFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/sdxl-controlnet-union/inpainting/requests/{request_id}/status'
  }

export type GetFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdStatusResponse =
  GetFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdStatusResponses[keyof GetFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdStatusResponses]

export type PutFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/sdxl-controlnet-union/inpainting/requests/{request_id}/cancel'
  }

export type PutFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdCancelResponse =
  PutFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdCancelResponses[keyof PutFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdCancelResponses]

export type PostFalAiSdxlControlnetUnionInpaintingData = {
  body: SchemaSdxlControlnetUnionInpaintingInput
  path?: never
  query?: never
  url: '/fal-ai/sdxl-controlnet-union/inpainting'
}

export type PostFalAiSdxlControlnetUnionInpaintingResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiSdxlControlnetUnionInpaintingResponse =
  PostFalAiSdxlControlnetUnionInpaintingResponses[keyof PostFalAiSdxlControlnetUnionInpaintingResponses]

export type GetFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sdxl-controlnet-union/inpainting/requests/{request_id}'
}

export type GetFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaSdxlControlnetUnionInpaintingOutput
  }

export type GetFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdResponse =
  GetFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdResponses[keyof GetFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdResponses]

export type GetFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/sdxl-controlnet-union/image-to-image/requests/{request_id}/status'
  }

export type GetFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/sdxl-controlnet-union/image-to-image/requests/{request_id}/cancel'
  }

export type PutFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiSdxlControlnetUnionImageToImageData = {
  body: SchemaSdxlControlnetUnionImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/sdxl-controlnet-union/image-to-image'
}

export type PostFalAiSdxlControlnetUnionImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiSdxlControlnetUnionImageToImageResponse =
  PostFalAiSdxlControlnetUnionImageToImageResponses[keyof PostFalAiSdxlControlnetUnionImageToImageResponses]

export type GetFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sdxl-controlnet-union/image-to-image/requests/{request_id}'
}

export type GetFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaSdxlControlnetUnionImageToImageOutput
  }

export type GetFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdResponse =
  GetFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdResponses[keyof GetFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdResponses]

export type GetFalAiEra3dRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/era-3d/requests/{request_id}/status'
}

export type GetFalAiEra3dRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiEra3dRequestsByRequestIdStatusResponse =
  GetFalAiEra3dRequestsByRequestIdStatusResponses[keyof GetFalAiEra3dRequestsByRequestIdStatusResponses]

export type PutFalAiEra3dRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/era-3d/requests/{request_id}/cancel'
}

export type PutFalAiEra3dRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiEra3dRequestsByRequestIdCancelResponse =
  PutFalAiEra3dRequestsByRequestIdCancelResponses[keyof PutFalAiEra3dRequestsByRequestIdCancelResponses]

export type PostFalAiEra3dData = {
  body: SchemaEra3dInput
  path?: never
  query?: never
  url: '/fal-ai/era-3d'
}

export type PostFalAiEra3dResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiEra3dResponse =
  PostFalAiEra3dResponses[keyof PostFalAiEra3dResponses]

export type GetFalAiEra3dRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/era-3d/requests/{request_id}'
}

export type GetFalAiEra3dRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaEra3dOutput
}

export type GetFalAiEra3dRequestsByRequestIdResponse =
  GetFalAiEra3dRequestsByRequestIdResponses[keyof GetFalAiEra3dRequestsByRequestIdResponses]

export type GetFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/florence-2-large/dense-region-caption/requests/{request_id}/status'
  }

export type GetFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdStatusResponse =
  GetFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdStatusResponses[keyof GetFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdStatusResponses]

export type PutFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/florence-2-large/dense-region-caption/requests/{request_id}/cancel'
  }

export type PutFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdCancelResponse =
  PutFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdCancelResponses[keyof PutFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdCancelResponses]

export type PostFalAiFlorence2LargeDenseRegionCaptionData = {
  body: SchemaFlorence2LargeDenseRegionCaptionInput
  path?: never
  query?: never
  url: '/fal-ai/florence-2-large/dense-region-caption'
}

export type PostFalAiFlorence2LargeDenseRegionCaptionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlorence2LargeDenseRegionCaptionResponse =
  PostFalAiFlorence2LargeDenseRegionCaptionResponses[keyof PostFalAiFlorence2LargeDenseRegionCaptionResponses]

export type GetFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/florence-2-large/dense-region-caption/requests/{request_id}'
}

export type GetFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaFlorence2LargeDenseRegionCaptionOutput
  }

export type GetFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdResponse =
  GetFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdResponses[keyof GetFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdResponses]

export type GetFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/florence-2-large/referring-expression-segmentation/requests/{request_id}/status'
  }

export type GetFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdStatusResponse =
  GetFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdStatusResponses[keyof GetFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdStatusResponses]

export type PutFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/florence-2-large/referring-expression-segmentation/requests/{request_id}/cancel'
  }

export type PutFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdCancelResponse =
  PutFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdCancelResponses[keyof PutFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdCancelResponses]

export type PostFalAiFlorence2LargeReferringExpressionSegmentationData = {
  body: SchemaFlorence2LargeReferringExpressionSegmentationInput
  path?: never
  query?: never
  url: '/fal-ai/florence-2-large/referring-expression-segmentation'
}

export type PostFalAiFlorence2LargeReferringExpressionSegmentationResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlorence2LargeReferringExpressionSegmentationResponse =
  PostFalAiFlorence2LargeReferringExpressionSegmentationResponses[keyof PostFalAiFlorence2LargeReferringExpressionSegmentationResponses]

export type GetFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/florence-2-large/referring-expression-segmentation/requests/{request_id}'
  }

export type GetFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaFlorence2LargeReferringExpressionSegmentationOutput
  }

export type GetFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdResponse =
  GetFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdResponses[keyof GetFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdResponses]

export type GetFalAiFlorence2LargeObjectDetectionRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/florence-2-large/object-detection/requests/{request_id}/status'
  }

export type GetFalAiFlorence2LargeObjectDetectionRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlorence2LargeObjectDetectionRequestsByRequestIdStatusResponse =
  GetFalAiFlorence2LargeObjectDetectionRequestsByRequestIdStatusResponses[keyof GetFalAiFlorence2LargeObjectDetectionRequestsByRequestIdStatusResponses]

export type PutFalAiFlorence2LargeObjectDetectionRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/florence-2-large/object-detection/requests/{request_id}/cancel'
  }

export type PutFalAiFlorence2LargeObjectDetectionRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlorence2LargeObjectDetectionRequestsByRequestIdCancelResponse =
  PutFalAiFlorence2LargeObjectDetectionRequestsByRequestIdCancelResponses[keyof PutFalAiFlorence2LargeObjectDetectionRequestsByRequestIdCancelResponses]

export type PostFalAiFlorence2LargeObjectDetectionData = {
  body: SchemaFlorence2LargeObjectDetectionInput
  path?: never
  query?: never
  url: '/fal-ai/florence-2-large/object-detection'
}

export type PostFalAiFlorence2LargeObjectDetectionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlorence2LargeObjectDetectionResponse =
  PostFalAiFlorence2LargeObjectDetectionResponses[keyof PostFalAiFlorence2LargeObjectDetectionResponses]

export type GetFalAiFlorence2LargeObjectDetectionRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/florence-2-large/object-detection/requests/{request_id}'
}

export type GetFalAiFlorence2LargeObjectDetectionRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaFlorence2LargeObjectDetectionOutput
  }

export type GetFalAiFlorence2LargeObjectDetectionRequestsByRequestIdResponse =
  GetFalAiFlorence2LargeObjectDetectionRequestsByRequestIdResponses[keyof GetFalAiFlorence2LargeObjectDetectionRequestsByRequestIdResponses]

export type GetFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/florence-2-large/open-vocabulary-detection/requests/{request_id}/status'
  }

export type GetFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdStatusResponse =
  GetFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdStatusResponses[keyof GetFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdStatusResponses]

export type PutFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/florence-2-large/open-vocabulary-detection/requests/{request_id}/cancel'
  }

export type PutFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdCancelResponse =
  PutFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdCancelResponses[keyof PutFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdCancelResponses]

export type PostFalAiFlorence2LargeOpenVocabularyDetectionData = {
  body: SchemaFlorence2LargeOpenVocabularyDetectionInput
  path?: never
  query?: never
  url: '/fal-ai/florence-2-large/open-vocabulary-detection'
}

export type PostFalAiFlorence2LargeOpenVocabularyDetectionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlorence2LargeOpenVocabularyDetectionResponse =
  PostFalAiFlorence2LargeOpenVocabularyDetectionResponses[keyof PostFalAiFlorence2LargeOpenVocabularyDetectionResponses]

export type GetFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/florence-2-large/open-vocabulary-detection/requests/{request_id}'
  }

export type GetFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaFlorence2LargeOpenVocabularyDetectionOutput
  }

export type GetFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdResponse =
  GetFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdResponses[keyof GetFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdResponses]

export type GetFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/florence-2-large/caption-to-phrase-grounding/requests/{request_id}/status'
  }

export type GetFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdStatusResponse =
  GetFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdStatusResponses[keyof GetFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdStatusResponses]

export type PutFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/florence-2-large/caption-to-phrase-grounding/requests/{request_id}/cancel'
  }

export type PutFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdCancelResponse =
  PutFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdCancelResponses[keyof PutFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdCancelResponses]

export type PostFalAiFlorence2LargeCaptionToPhraseGroundingData = {
  body: SchemaFlorence2LargeCaptionToPhraseGroundingInput
  path?: never
  query?: never
  url: '/fal-ai/florence-2-large/caption-to-phrase-grounding'
}

export type PostFalAiFlorence2LargeCaptionToPhraseGroundingResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlorence2LargeCaptionToPhraseGroundingResponse =
  PostFalAiFlorence2LargeCaptionToPhraseGroundingResponses[keyof PostFalAiFlorence2LargeCaptionToPhraseGroundingResponses]

export type GetFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/florence-2-large/caption-to-phrase-grounding/requests/{request_id}'
  }

export type GetFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaFlorence2LargeCaptionToPhraseGroundingOutput
  }

export type GetFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdResponse =
  GetFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdResponses[keyof GetFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdResponses]

export type GetFalAiFlorence2LargeRegionProposalRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/florence-2-large/region-proposal/requests/{request_id}/status'
  }

export type GetFalAiFlorence2LargeRegionProposalRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlorence2LargeRegionProposalRequestsByRequestIdStatusResponse =
  GetFalAiFlorence2LargeRegionProposalRequestsByRequestIdStatusResponses[keyof GetFalAiFlorence2LargeRegionProposalRequestsByRequestIdStatusResponses]

export type PutFalAiFlorence2LargeRegionProposalRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/florence-2-large/region-proposal/requests/{request_id}/cancel'
  }

export type PutFalAiFlorence2LargeRegionProposalRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlorence2LargeRegionProposalRequestsByRequestIdCancelResponse =
  PutFalAiFlorence2LargeRegionProposalRequestsByRequestIdCancelResponses[keyof PutFalAiFlorence2LargeRegionProposalRequestsByRequestIdCancelResponses]

export type PostFalAiFlorence2LargeRegionProposalData = {
  body: SchemaFlorence2LargeRegionProposalInput
  path?: never
  query?: never
  url: '/fal-ai/florence-2-large/region-proposal'
}

export type PostFalAiFlorence2LargeRegionProposalResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlorence2LargeRegionProposalResponse =
  PostFalAiFlorence2LargeRegionProposalResponses[keyof PostFalAiFlorence2LargeRegionProposalResponses]

export type GetFalAiFlorence2LargeRegionProposalRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/florence-2-large/region-proposal/requests/{request_id}'
}

export type GetFalAiFlorence2LargeRegionProposalRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlorence2LargeRegionProposalOutput
}

export type GetFalAiFlorence2LargeRegionProposalRequestsByRequestIdResponse =
  GetFalAiFlorence2LargeRegionProposalRequestsByRequestIdResponses[keyof GetFalAiFlorence2LargeRegionProposalRequestsByRequestIdResponses]

export type GetFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/florence-2-large/ocr-with-region/requests/{request_id}/status'
}

export type GetFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdStatusResponse =
  GetFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdStatusResponses[keyof GetFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdStatusResponses]

export type PutFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/florence-2-large/ocr-with-region/requests/{request_id}/cancel'
}

export type PutFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdCancelResponse =
  PutFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdCancelResponses[keyof PutFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdCancelResponses]

export type PostFalAiFlorence2LargeOcrWithRegionData = {
  body: SchemaFlorence2LargeOcrWithRegionInput
  path?: never
  query?: never
  url: '/fal-ai/florence-2-large/ocr-with-region'
}

export type PostFalAiFlorence2LargeOcrWithRegionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlorence2LargeOcrWithRegionResponse =
  PostFalAiFlorence2LargeOcrWithRegionResponses[keyof PostFalAiFlorence2LargeOcrWithRegionResponses]

export type GetFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/florence-2-large/ocr-with-region/requests/{request_id}'
}

export type GetFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlorence2LargeOcrWithRegionOutput
}

export type GetFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdResponse =
  GetFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdResponses[keyof GetFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdResponses]

export type GetFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/florence-2-large/region-to-segmentation/requests/{request_id}/status'
  }

export type GetFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdStatusResponse =
  GetFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdStatusResponses[keyof GetFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdStatusResponses]

export type PutFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/florence-2-large/region-to-segmentation/requests/{request_id}/cancel'
  }

export type PutFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdCancelResponse =
  PutFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdCancelResponses[keyof PutFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdCancelResponses]

export type PostFalAiFlorence2LargeRegionToSegmentationData = {
  body: SchemaFlorence2LargeRegionToSegmentationInput
  path?: never
  query?: never
  url: '/fal-ai/florence-2-large/region-to-segmentation'
}

export type PostFalAiFlorence2LargeRegionToSegmentationResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlorence2LargeRegionToSegmentationResponse =
  PostFalAiFlorence2LargeRegionToSegmentationResponses[keyof PostFalAiFlorence2LargeRegionToSegmentationResponses]

export type GetFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/florence-2-large/region-to-segmentation/requests/{request_id}'
  }

export type GetFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaFlorence2LargeRegionToSegmentationOutput
  }

export type GetFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdResponse =
  GetFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdResponses[keyof GetFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdResponses]

export type GetFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/stable-diffusion-v3-medium/image-to-image/requests/{request_id}/status'
  }

export type GetFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/stable-diffusion-v3-medium/image-to-image/requests/{request_id}/cancel'
  }

export type PutFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiStableDiffusionV3MediumImageToImageData = {
  body: SchemaStableDiffusionV3MediumImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/stable-diffusion-v3-medium/image-to-image'
}

export type PostFalAiStableDiffusionV3MediumImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiStableDiffusionV3MediumImageToImageResponse =
  PostFalAiStableDiffusionV3MediumImageToImageResponses[keyof PostFalAiStableDiffusionV3MediumImageToImageResponses]

export type GetFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/stable-diffusion-v3-medium/image-to-image/requests/{request_id}'
  }

export type GetFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaStableDiffusionV3MediumImageToImageOutput
  }

export type GetFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdResponse =
  GetFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdResponses[keyof GetFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdResponses]

export type GetFalAiDwposeRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/dwpose/requests/{request_id}/status'
}

export type GetFalAiDwposeRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiDwposeRequestsByRequestIdStatusResponse =
  GetFalAiDwposeRequestsByRequestIdStatusResponses[keyof GetFalAiDwposeRequestsByRequestIdStatusResponses]

export type PutFalAiDwposeRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/dwpose/requests/{request_id}/cancel'
}

export type PutFalAiDwposeRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiDwposeRequestsByRequestIdCancelResponse =
  PutFalAiDwposeRequestsByRequestIdCancelResponses[keyof PutFalAiDwposeRequestsByRequestIdCancelResponses]

export type PostFalAiDwposeData = {
  body: SchemaDwposeInput
  path?: never
  query?: never
  url: '/fal-ai/dwpose'
}

export type PostFalAiDwposeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiDwposeResponse =
  PostFalAiDwposeResponses[keyof PostFalAiDwposeResponses]

export type GetFalAiDwposeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/dwpose/requests/{request_id}'
}

export type GetFalAiDwposeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaDwposeOutput
}

export type GetFalAiDwposeRequestsByRequestIdResponse =
  GetFalAiDwposeRequestsByRequestIdResponses[keyof GetFalAiDwposeRequestsByRequestIdResponses]

export type GetFalAiSd15DepthControlnetRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/sd15-depth-controlnet/requests/{request_id}/status'
}

export type GetFalAiSd15DepthControlnetRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiSd15DepthControlnetRequestsByRequestIdStatusResponse =
  GetFalAiSd15DepthControlnetRequestsByRequestIdStatusResponses[keyof GetFalAiSd15DepthControlnetRequestsByRequestIdStatusResponses]

export type PutFalAiSd15DepthControlnetRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sd15-depth-controlnet/requests/{request_id}/cancel'
}

export type PutFalAiSd15DepthControlnetRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiSd15DepthControlnetRequestsByRequestIdCancelResponse =
  PutFalAiSd15DepthControlnetRequestsByRequestIdCancelResponses[keyof PutFalAiSd15DepthControlnetRequestsByRequestIdCancelResponses]

export type PostFalAiSd15DepthControlnetData = {
  body: SchemaSd15DepthControlnetInput
  path?: never
  query?: never
  url: '/fal-ai/sd15-depth-controlnet'
}

export type PostFalAiSd15DepthControlnetResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiSd15DepthControlnetResponse =
  PostFalAiSd15DepthControlnetResponses[keyof PostFalAiSd15DepthControlnetResponses]

export type GetFalAiSd15DepthControlnetRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sd15-depth-controlnet/requests/{request_id}'
}

export type GetFalAiSd15DepthControlnetRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaSd15DepthControlnetOutput
}

export type GetFalAiSd15DepthControlnetRequestsByRequestIdResponse =
  GetFalAiSd15DepthControlnetRequestsByRequestIdResponses[keyof GetFalAiSd15DepthControlnetRequestsByRequestIdResponses]

export type GetFalAiCcsrRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ccsr/requests/{request_id}/status'
}

export type GetFalAiCcsrRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiCcsrRequestsByRequestIdStatusResponse =
  GetFalAiCcsrRequestsByRequestIdStatusResponses[keyof GetFalAiCcsrRequestsByRequestIdStatusResponses]

export type PutFalAiCcsrRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ccsr/requests/{request_id}/cancel'
}

export type PutFalAiCcsrRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiCcsrRequestsByRequestIdCancelResponse =
  PutFalAiCcsrRequestsByRequestIdCancelResponses[keyof PutFalAiCcsrRequestsByRequestIdCancelResponses]

export type PostFalAiCcsrData = {
  body: SchemaCcsrInput
  path?: never
  query?: never
  url: '/fal-ai/ccsr'
}

export type PostFalAiCcsrResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiCcsrResponse =
  PostFalAiCcsrResponses[keyof PostFalAiCcsrResponses]

export type GetFalAiCcsrRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ccsr/requests/{request_id}'
}

export type GetFalAiCcsrRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaCcsrOutput
}

export type GetFalAiCcsrRequestsByRequestIdResponse =
  GetFalAiCcsrRequestsByRequestIdResponses[keyof GetFalAiCcsrRequestsByRequestIdResponses]

export type GetFalAiOmniZeroRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/omni-zero/requests/{request_id}/status'
}

export type GetFalAiOmniZeroRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiOmniZeroRequestsByRequestIdStatusResponse =
  GetFalAiOmniZeroRequestsByRequestIdStatusResponses[keyof GetFalAiOmniZeroRequestsByRequestIdStatusResponses]

export type PutFalAiOmniZeroRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/omni-zero/requests/{request_id}/cancel'
}

export type PutFalAiOmniZeroRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiOmniZeroRequestsByRequestIdCancelResponse =
  PutFalAiOmniZeroRequestsByRequestIdCancelResponses[keyof PutFalAiOmniZeroRequestsByRequestIdCancelResponses]

export type PostFalAiOmniZeroData = {
  body: SchemaOmniZeroInput
  path?: never
  query?: never
  url: '/fal-ai/omni-zero'
}

export type PostFalAiOmniZeroResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiOmniZeroResponse =
  PostFalAiOmniZeroResponses[keyof PostFalAiOmniZeroResponses]

export type GetFalAiOmniZeroRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/omni-zero/requests/{request_id}'
}

export type GetFalAiOmniZeroRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaOmniZeroOutput
}

export type GetFalAiOmniZeroRequestsByRequestIdResponse =
  GetFalAiOmniZeroRequestsByRequestIdResponses[keyof GetFalAiOmniZeroRequestsByRequestIdResponses]

export type GetFalAiIpAdapterFaceIdRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ip-adapter-face-id/requests/{request_id}/status'
}

export type GetFalAiIpAdapterFaceIdRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIpAdapterFaceIdRequestsByRequestIdStatusResponse =
  GetFalAiIpAdapterFaceIdRequestsByRequestIdStatusResponses[keyof GetFalAiIpAdapterFaceIdRequestsByRequestIdStatusResponses]

export type PutFalAiIpAdapterFaceIdRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ip-adapter-face-id/requests/{request_id}/cancel'
}

export type PutFalAiIpAdapterFaceIdRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIpAdapterFaceIdRequestsByRequestIdCancelResponse =
  PutFalAiIpAdapterFaceIdRequestsByRequestIdCancelResponses[keyof PutFalAiIpAdapterFaceIdRequestsByRequestIdCancelResponses]

export type PostFalAiIpAdapterFaceIdData = {
  body: SchemaIpAdapterFaceIdInput
  path?: never
  query?: never
  url: '/fal-ai/ip-adapter-face-id'
}

export type PostFalAiIpAdapterFaceIdResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIpAdapterFaceIdResponse =
  PostFalAiIpAdapterFaceIdResponses[keyof PostFalAiIpAdapterFaceIdResponses]

export type GetFalAiIpAdapterFaceIdRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ip-adapter-face-id/requests/{request_id}'
}

export type GetFalAiIpAdapterFaceIdRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIpAdapterFaceIdOutput
}

export type GetFalAiIpAdapterFaceIdRequestsByRequestIdResponse =
  GetFalAiIpAdapterFaceIdRequestsByRequestIdResponses[keyof GetFalAiIpAdapterFaceIdRequestsByRequestIdResponses]

export type GetFalAiLoraInpaintRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/lora/inpaint/requests/{request_id}/status'
}

export type GetFalAiLoraInpaintRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLoraInpaintRequestsByRequestIdStatusResponse =
  GetFalAiLoraInpaintRequestsByRequestIdStatusResponses[keyof GetFalAiLoraInpaintRequestsByRequestIdStatusResponses]

export type PutFalAiLoraInpaintRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/lora/inpaint/requests/{request_id}/cancel'
}

export type PutFalAiLoraInpaintRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLoraInpaintRequestsByRequestIdCancelResponse =
  PutFalAiLoraInpaintRequestsByRequestIdCancelResponses[keyof PutFalAiLoraInpaintRequestsByRequestIdCancelResponses]

export type PostFalAiLoraInpaintData = {
  body: SchemaLoraInpaintInput
  path?: never
  query?: never
  url: '/fal-ai/lora/inpaint'
}

export type PostFalAiLoraInpaintResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLoraInpaintResponse =
  PostFalAiLoraInpaintResponses[keyof PostFalAiLoraInpaintResponses]

export type GetFalAiLoraInpaintRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/lora/inpaint/requests/{request_id}'
}

export type GetFalAiLoraInpaintRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLoraInpaintOutput
}

export type GetFalAiLoraInpaintRequestsByRequestIdResponse =
  GetFalAiLoraInpaintRequestsByRequestIdResponses[keyof GetFalAiLoraInpaintRequestsByRequestIdResponses]

export type GetFalAiLoraImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/lora/image-to-image/requests/{request_id}/status'
}

export type GetFalAiLoraImageToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLoraImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiLoraImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiLoraImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiLoraImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/lora/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiLoraImageToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLoraImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiLoraImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiLoraImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiLoraImageToImageData = {
  body: SchemaLoraImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/lora/image-to-image'
}

export type PostFalAiLoraImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLoraImageToImageResponse =
  PostFalAiLoraImageToImageResponses[keyof PostFalAiLoraImageToImageResponses]

export type GetFalAiLoraImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/lora/image-to-image/requests/{request_id}'
}

export type GetFalAiLoraImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLoraImageToImageOutput
}

export type GetFalAiLoraImageToImageRequestsByRequestIdResponse =
  GetFalAiLoraImageToImageRequestsByRequestIdResponses[keyof GetFalAiLoraImageToImageRequestsByRequestIdResponses]

export type GetFalAiFastSdxlImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/fast-sdxl/image-to-image/requests/{request_id}/status'
}

export type GetFalAiFastSdxlImageToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFastSdxlImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiFastSdxlImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiFastSdxlImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiFastSdxlImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-sdxl/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiFastSdxlImageToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFastSdxlImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiFastSdxlImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiFastSdxlImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiFastSdxlImageToImageData = {
  body: SchemaFastSdxlImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/fast-sdxl/image-to-image'
}

export type PostFalAiFastSdxlImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFastSdxlImageToImageResponse =
  PostFalAiFastSdxlImageToImageResponses[keyof PostFalAiFastSdxlImageToImageResponses]

export type GetFalAiFastSdxlImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-sdxl/image-to-image/requests/{request_id}'
}

export type GetFalAiFastSdxlImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFastSdxlImageToImageOutput
}

export type GetFalAiFastSdxlImageToImageRequestsByRequestIdResponse =
  GetFalAiFastSdxlImageToImageRequestsByRequestIdResponses[keyof GetFalAiFastSdxlImageToImageRequestsByRequestIdResponses]

export type GetFalAiFastSdxlInpaintingRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/fast-sdxl/inpainting/requests/{request_id}/status'
}

export type GetFalAiFastSdxlInpaintingRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFastSdxlInpaintingRequestsByRequestIdStatusResponse =
  GetFalAiFastSdxlInpaintingRequestsByRequestIdStatusResponses[keyof GetFalAiFastSdxlInpaintingRequestsByRequestIdStatusResponses]

export type PutFalAiFastSdxlInpaintingRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-sdxl/inpainting/requests/{request_id}/cancel'
}

export type PutFalAiFastSdxlInpaintingRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFastSdxlInpaintingRequestsByRequestIdCancelResponse =
  PutFalAiFastSdxlInpaintingRequestsByRequestIdCancelResponses[keyof PutFalAiFastSdxlInpaintingRequestsByRequestIdCancelResponses]

export type PostFalAiFastSdxlInpaintingData = {
  body: SchemaFastSdxlInpaintingInput
  path?: never
  query?: never
  url: '/fal-ai/fast-sdxl/inpainting'
}

export type PostFalAiFastSdxlInpaintingResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFastSdxlInpaintingResponse =
  PostFalAiFastSdxlInpaintingResponses[keyof PostFalAiFastSdxlInpaintingResponses]

export type GetFalAiFastSdxlInpaintingRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-sdxl/inpainting/requests/{request_id}'
}

export type GetFalAiFastSdxlInpaintingRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFastSdxlInpaintingOutput
}

export type GetFalAiFastSdxlInpaintingRequestsByRequestIdResponse =
  GetFalAiFastSdxlInpaintingRequestsByRequestIdResponses[keyof GetFalAiFastSdxlInpaintingRequestsByRequestIdResponses]

export type GetFalAiFaceToStickerRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/face-to-sticker/requests/{request_id}/status'
}

export type GetFalAiFaceToStickerRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFaceToStickerRequestsByRequestIdStatusResponse =
  GetFalAiFaceToStickerRequestsByRequestIdStatusResponses[keyof GetFalAiFaceToStickerRequestsByRequestIdStatusResponses]

export type PutFalAiFaceToStickerRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/face-to-sticker/requests/{request_id}/cancel'
}

export type PutFalAiFaceToStickerRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFaceToStickerRequestsByRequestIdCancelResponse =
  PutFalAiFaceToStickerRequestsByRequestIdCancelResponses[keyof PutFalAiFaceToStickerRequestsByRequestIdCancelResponses]

export type PostFalAiFaceToStickerData = {
  body: SchemaFaceToStickerInput
  path?: never
  query?: never
  url: '/fal-ai/face-to-sticker'
}

export type PostFalAiFaceToStickerResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFaceToStickerResponse =
  PostFalAiFaceToStickerResponses[keyof PostFalAiFaceToStickerResponses]

export type GetFalAiFaceToStickerRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/face-to-sticker/requests/{request_id}'
}

export type GetFalAiFaceToStickerRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFaceToStickerOutput
}

export type GetFalAiFaceToStickerRequestsByRequestIdResponse =
  GetFalAiFaceToStickerRequestsByRequestIdResponses[keyof GetFalAiFaceToStickerRequestsByRequestIdResponses]

export type GetFalAiPhotomakerRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/photomaker/requests/{request_id}/status'
}

export type GetFalAiPhotomakerRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiPhotomakerRequestsByRequestIdStatusResponse =
  GetFalAiPhotomakerRequestsByRequestIdStatusResponses[keyof GetFalAiPhotomakerRequestsByRequestIdStatusResponses]

export type PutFalAiPhotomakerRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/photomaker/requests/{request_id}/cancel'
}

export type PutFalAiPhotomakerRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiPhotomakerRequestsByRequestIdCancelResponse =
  PutFalAiPhotomakerRequestsByRequestIdCancelResponses[keyof PutFalAiPhotomakerRequestsByRequestIdCancelResponses]

export type PostFalAiPhotomakerData = {
  body: SchemaPhotomakerInput
  path?: never
  query?: never
  url: '/fal-ai/photomaker'
}

export type PostFalAiPhotomakerResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPhotomakerResponse =
  PostFalAiPhotomakerResponses[keyof PostFalAiPhotomakerResponses]

export type GetFalAiPhotomakerRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/photomaker/requests/{request_id}'
}

export type GetFalAiPhotomakerRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPhotomakerOutput
}

export type GetFalAiPhotomakerRequestsByRequestIdResponse =
  GetFalAiPhotomakerRequestsByRequestIdResponses[keyof GetFalAiPhotomakerRequestsByRequestIdResponses]

export type GetFalAiCreativeUpscalerRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/creative-upscaler/requests/{request_id}/status'
}

export type GetFalAiCreativeUpscalerRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiCreativeUpscalerRequestsByRequestIdStatusResponse =
  GetFalAiCreativeUpscalerRequestsByRequestIdStatusResponses[keyof GetFalAiCreativeUpscalerRequestsByRequestIdStatusResponses]

export type PutFalAiCreativeUpscalerRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/creative-upscaler/requests/{request_id}/cancel'
}

export type PutFalAiCreativeUpscalerRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiCreativeUpscalerRequestsByRequestIdCancelResponse =
  PutFalAiCreativeUpscalerRequestsByRequestIdCancelResponses[keyof PutFalAiCreativeUpscalerRequestsByRequestIdCancelResponses]

export type PostFalAiCreativeUpscalerData = {
  body: SchemaCreativeUpscalerInput
  path?: never
  query?: never
  url: '/fal-ai/creative-upscaler'
}

export type PostFalAiCreativeUpscalerResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiCreativeUpscalerResponse =
  PostFalAiCreativeUpscalerResponses[keyof PostFalAiCreativeUpscalerResponses]

export type GetFalAiCreativeUpscalerRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/creative-upscaler/requests/{request_id}'
}

export type GetFalAiCreativeUpscalerRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaCreativeUpscalerOutput
}

export type GetFalAiCreativeUpscalerRequestsByRequestIdResponse =
  GetFalAiCreativeUpscalerRequestsByRequestIdResponses[keyof GetFalAiCreativeUpscalerRequestsByRequestIdResponses]

export type GetFalAiBirefnetRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/birefnet/requests/{request_id}/status'
}

export type GetFalAiBirefnetRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiBirefnetRequestsByRequestIdStatusResponse =
  GetFalAiBirefnetRequestsByRequestIdStatusResponses[keyof GetFalAiBirefnetRequestsByRequestIdStatusResponses]

export type PutFalAiBirefnetRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/birefnet/requests/{request_id}/cancel'
}

export type PutFalAiBirefnetRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiBirefnetRequestsByRequestIdCancelResponse =
  PutFalAiBirefnetRequestsByRequestIdCancelResponses[keyof PutFalAiBirefnetRequestsByRequestIdCancelResponses]

export type PostFalAiBirefnetData = {
  body: SchemaBirefnetInput
  path?: never
  query?: never
  url: '/fal-ai/birefnet'
}

export type PostFalAiBirefnetResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBirefnetResponse =
  PostFalAiBirefnetResponses[keyof PostFalAiBirefnetResponses]

export type GetFalAiBirefnetRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/birefnet/requests/{request_id}'
}

export type GetFalAiBirefnetRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaBirefnetOutput
}

export type GetFalAiBirefnetRequestsByRequestIdResponse =
  GetFalAiBirefnetRequestsByRequestIdResponses[keyof GetFalAiBirefnetRequestsByRequestIdResponses]

export type GetFalAiPlaygroundV25ImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/playground-v25/image-to-image/requests/{request_id}/status'
}

export type GetFalAiPlaygroundV25ImageToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiPlaygroundV25ImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiPlaygroundV25ImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiPlaygroundV25ImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiPlaygroundV25ImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/playground-v25/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiPlaygroundV25ImageToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiPlaygroundV25ImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiPlaygroundV25ImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiPlaygroundV25ImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiPlaygroundV25ImageToImageData = {
  body: SchemaPlaygroundV25ImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/playground-v25/image-to-image'
}

export type PostFalAiPlaygroundV25ImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPlaygroundV25ImageToImageResponse =
  PostFalAiPlaygroundV25ImageToImageResponses[keyof PostFalAiPlaygroundV25ImageToImageResponses]

export type GetFalAiPlaygroundV25ImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/playground-v25/image-to-image/requests/{request_id}'
}

export type GetFalAiPlaygroundV25ImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPlaygroundV25ImageToImageOutput
}

export type GetFalAiPlaygroundV25ImageToImageRequestsByRequestIdResponse =
  GetFalAiPlaygroundV25ImageToImageRequestsByRequestIdResponses[keyof GetFalAiPlaygroundV25ImageToImageRequestsByRequestIdResponses]

export type GetFalAiFastLightningSdxlImageToImageRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/fast-lightning-sdxl/image-to-image/requests/{request_id}/status'
  }

export type GetFalAiFastLightningSdxlImageToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFastLightningSdxlImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiFastLightningSdxlImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiFastLightningSdxlImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiFastLightningSdxlImageToImageRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/fast-lightning-sdxl/image-to-image/requests/{request_id}/cancel'
  }

export type PutFalAiFastLightningSdxlImageToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFastLightningSdxlImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiFastLightningSdxlImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiFastLightningSdxlImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiFastLightningSdxlImageToImageData = {
  body: SchemaFastLightningSdxlImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/fast-lightning-sdxl/image-to-image'
}

export type PostFalAiFastLightningSdxlImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFastLightningSdxlImageToImageResponse =
  PostFalAiFastLightningSdxlImageToImageResponses[keyof PostFalAiFastLightningSdxlImageToImageResponses]

export type GetFalAiFastLightningSdxlImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-lightning-sdxl/image-to-image/requests/{request_id}'
}

export type GetFalAiFastLightningSdxlImageToImageRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaFastLightningSdxlImageToImageOutput
  }

export type GetFalAiFastLightningSdxlImageToImageRequestsByRequestIdResponse =
  GetFalAiFastLightningSdxlImageToImageRequestsByRequestIdResponses[keyof GetFalAiFastLightningSdxlImageToImageRequestsByRequestIdResponses]

export type GetFalAiFastLightningSdxlInpaintingRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/fast-lightning-sdxl/inpainting/requests/{request_id}/status'
}

export type GetFalAiFastLightningSdxlInpaintingRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFastLightningSdxlInpaintingRequestsByRequestIdStatusResponse =
  GetFalAiFastLightningSdxlInpaintingRequestsByRequestIdStatusResponses[keyof GetFalAiFastLightningSdxlInpaintingRequestsByRequestIdStatusResponses]

export type PutFalAiFastLightningSdxlInpaintingRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-lightning-sdxl/inpainting/requests/{request_id}/cancel'
}

export type PutFalAiFastLightningSdxlInpaintingRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFastLightningSdxlInpaintingRequestsByRequestIdCancelResponse =
  PutFalAiFastLightningSdxlInpaintingRequestsByRequestIdCancelResponses[keyof PutFalAiFastLightningSdxlInpaintingRequestsByRequestIdCancelResponses]

export type PostFalAiFastLightningSdxlInpaintingData = {
  body: SchemaFastLightningSdxlInpaintingInput
  path?: never
  query?: never
  url: '/fal-ai/fast-lightning-sdxl/inpainting'
}

export type PostFalAiFastLightningSdxlInpaintingResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFastLightningSdxlInpaintingResponse =
  PostFalAiFastLightningSdxlInpaintingResponses[keyof PostFalAiFastLightningSdxlInpaintingResponses]

export type GetFalAiFastLightningSdxlInpaintingRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-lightning-sdxl/inpainting/requests/{request_id}'
}

export type GetFalAiFastLightningSdxlInpaintingRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFastLightningSdxlInpaintingOutput
}

export type GetFalAiFastLightningSdxlInpaintingRequestsByRequestIdResponse =
  GetFalAiFastLightningSdxlInpaintingRequestsByRequestIdResponses[keyof GetFalAiFastLightningSdxlInpaintingRequestsByRequestIdResponses]

export type GetFalAiPlaygroundV25InpaintingRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/playground-v25/inpainting/requests/{request_id}/status'
}

export type GetFalAiPlaygroundV25InpaintingRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiPlaygroundV25InpaintingRequestsByRequestIdStatusResponse =
  GetFalAiPlaygroundV25InpaintingRequestsByRequestIdStatusResponses[keyof GetFalAiPlaygroundV25InpaintingRequestsByRequestIdStatusResponses]

export type PutFalAiPlaygroundV25InpaintingRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/playground-v25/inpainting/requests/{request_id}/cancel'
}

export type PutFalAiPlaygroundV25InpaintingRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiPlaygroundV25InpaintingRequestsByRequestIdCancelResponse =
  PutFalAiPlaygroundV25InpaintingRequestsByRequestIdCancelResponses[keyof PutFalAiPlaygroundV25InpaintingRequestsByRequestIdCancelResponses]

export type PostFalAiPlaygroundV25InpaintingData = {
  body: SchemaPlaygroundV25InpaintingInput
  path?: never
  query?: never
  url: '/fal-ai/playground-v25/inpainting'
}

export type PostFalAiPlaygroundV25InpaintingResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPlaygroundV25InpaintingResponse =
  PostFalAiPlaygroundV25InpaintingResponses[keyof PostFalAiPlaygroundV25InpaintingResponses]

export type GetFalAiPlaygroundV25InpaintingRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/playground-v25/inpainting/requests/{request_id}'
}

export type GetFalAiPlaygroundV25InpaintingRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPlaygroundV25InpaintingOutput
}

export type GetFalAiPlaygroundV25InpaintingRequestsByRequestIdResponse =
  GetFalAiPlaygroundV25InpaintingRequestsByRequestIdResponses[keyof GetFalAiPlaygroundV25InpaintingRequestsByRequestIdResponses]

export type GetFalAiFastLcmDiffusionInpaintingRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/fast-lcm-diffusion/inpainting/requests/{request_id}/status'
}

export type GetFalAiFastLcmDiffusionInpaintingRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFastLcmDiffusionInpaintingRequestsByRequestIdStatusResponse =
  GetFalAiFastLcmDiffusionInpaintingRequestsByRequestIdStatusResponses[keyof GetFalAiFastLcmDiffusionInpaintingRequestsByRequestIdStatusResponses]

export type PutFalAiFastLcmDiffusionInpaintingRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-lcm-diffusion/inpainting/requests/{request_id}/cancel'
}

export type PutFalAiFastLcmDiffusionInpaintingRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFastLcmDiffusionInpaintingRequestsByRequestIdCancelResponse =
  PutFalAiFastLcmDiffusionInpaintingRequestsByRequestIdCancelResponses[keyof PutFalAiFastLcmDiffusionInpaintingRequestsByRequestIdCancelResponses]

export type PostFalAiFastLcmDiffusionInpaintingData = {
  body: SchemaFastLcmDiffusionInpaintingInput
  path?: never
  query?: never
  url: '/fal-ai/fast-lcm-diffusion/inpainting'
}

export type PostFalAiFastLcmDiffusionInpaintingResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFastLcmDiffusionInpaintingResponse =
  PostFalAiFastLcmDiffusionInpaintingResponses[keyof PostFalAiFastLcmDiffusionInpaintingResponses]

export type GetFalAiFastLcmDiffusionInpaintingRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-lcm-diffusion/inpainting/requests/{request_id}'
}

export type GetFalAiFastLcmDiffusionInpaintingRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFastLcmDiffusionInpaintingOutput
}

export type GetFalAiFastLcmDiffusionInpaintingRequestsByRequestIdResponse =
  GetFalAiFastLcmDiffusionInpaintingRequestsByRequestIdResponses[keyof GetFalAiFastLcmDiffusionInpaintingRequestsByRequestIdResponses]

export type GetFalAiFastLcmDiffusionImageToImageRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/fast-lcm-diffusion/image-to-image/requests/{request_id}/status'
  }

export type GetFalAiFastLcmDiffusionImageToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFastLcmDiffusionImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiFastLcmDiffusionImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiFastLcmDiffusionImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiFastLcmDiffusionImageToImageRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/fast-lcm-diffusion/image-to-image/requests/{request_id}/cancel'
  }

export type PutFalAiFastLcmDiffusionImageToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFastLcmDiffusionImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiFastLcmDiffusionImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiFastLcmDiffusionImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiFastLcmDiffusionImageToImageData = {
  body: SchemaFastLcmDiffusionImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/fast-lcm-diffusion/image-to-image'
}

export type PostFalAiFastLcmDiffusionImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFastLcmDiffusionImageToImageResponse =
  PostFalAiFastLcmDiffusionImageToImageResponses[keyof PostFalAiFastLcmDiffusionImageToImageResponses]

export type GetFalAiFastLcmDiffusionImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-lcm-diffusion/image-to-image/requests/{request_id}'
}

export type GetFalAiFastLcmDiffusionImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFastLcmDiffusionImageToImageOutput
}

export type GetFalAiFastLcmDiffusionImageToImageRequestsByRequestIdResponse =
  GetFalAiFastLcmDiffusionImageToImageRequestsByRequestIdResponses[keyof GetFalAiFastLcmDiffusionImageToImageRequestsByRequestIdResponses]

export type GetFalAiRetoucherRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/retoucher/requests/{request_id}/status'
}

export type GetFalAiRetoucherRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiRetoucherRequestsByRequestIdStatusResponse =
  GetFalAiRetoucherRequestsByRequestIdStatusResponses[keyof GetFalAiRetoucherRequestsByRequestIdStatusResponses]

export type PutFalAiRetoucherRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/retoucher/requests/{request_id}/cancel'
}

export type PutFalAiRetoucherRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiRetoucherRequestsByRequestIdCancelResponse =
  PutFalAiRetoucherRequestsByRequestIdCancelResponses[keyof PutFalAiRetoucherRequestsByRequestIdCancelResponses]

export type PostFalAiRetoucherData = {
  body: SchemaRetoucherInput
  path?: never
  query?: never
  url: '/fal-ai/retoucher'
}

export type PostFalAiRetoucherResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiRetoucherResponse =
  PostFalAiRetoucherResponses[keyof PostFalAiRetoucherResponses]

export type GetFalAiRetoucherRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/retoucher/requests/{request_id}'
}

export type GetFalAiRetoucherRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaRetoucherOutput
}

export type GetFalAiRetoucherRequestsByRequestIdResponse =
  GetFalAiRetoucherRequestsByRequestIdResponses[keyof GetFalAiRetoucherRequestsByRequestIdResponses]

export type GetFalAiImageutilsDepthRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/imageutils/depth/requests/{request_id}/status'
}

export type GetFalAiImageutilsDepthRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImageutilsDepthRequestsByRequestIdStatusResponse =
  GetFalAiImageutilsDepthRequestsByRequestIdStatusResponses[keyof GetFalAiImageutilsDepthRequestsByRequestIdStatusResponses]

export type PutFalAiImageutilsDepthRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/imageutils/depth/requests/{request_id}/cancel'
}

export type PutFalAiImageutilsDepthRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImageutilsDepthRequestsByRequestIdCancelResponse =
  PutFalAiImageutilsDepthRequestsByRequestIdCancelResponses[keyof PutFalAiImageutilsDepthRequestsByRequestIdCancelResponses]

export type PostFalAiImageutilsDepthData = {
  body: SchemaImageutilsDepthInput
  path?: never
  query?: never
  url: '/fal-ai/imageutils/depth'
}

export type PostFalAiImageutilsDepthResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageutilsDepthResponse =
  PostFalAiImageutilsDepthResponses[keyof PostFalAiImageutilsDepthResponses]

export type GetFalAiImageutilsDepthRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/imageutils/depth/requests/{request_id}'
}

export type GetFalAiImageutilsDepthRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageutilsDepthOutput
}

export type GetFalAiImageutilsDepthRequestsByRequestIdResponse =
  GetFalAiImageutilsDepthRequestsByRequestIdResponses[keyof GetFalAiImageutilsDepthRequestsByRequestIdResponses]

export type GetFalAiImageutilsMarigoldDepthRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/imageutils/marigold-depth/requests/{request_id}/status'
}

export type GetFalAiImageutilsMarigoldDepthRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiImageutilsMarigoldDepthRequestsByRequestIdStatusResponse =
  GetFalAiImageutilsMarigoldDepthRequestsByRequestIdStatusResponses[keyof GetFalAiImageutilsMarigoldDepthRequestsByRequestIdStatusResponses]

export type PutFalAiImageutilsMarigoldDepthRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/imageutils/marigold-depth/requests/{request_id}/cancel'
}

export type PutFalAiImageutilsMarigoldDepthRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiImageutilsMarigoldDepthRequestsByRequestIdCancelResponse =
  PutFalAiImageutilsMarigoldDepthRequestsByRequestIdCancelResponses[keyof PutFalAiImageutilsMarigoldDepthRequestsByRequestIdCancelResponses]

export type PostFalAiImageutilsMarigoldDepthData = {
  body: SchemaImageutilsMarigoldDepthInput
  path?: never
  query?: never
  url: '/fal-ai/imageutils/marigold-depth'
}

export type PostFalAiImageutilsMarigoldDepthResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageutilsMarigoldDepthResponse =
  PostFalAiImageutilsMarigoldDepthResponses[keyof PostFalAiImageutilsMarigoldDepthResponses]

export type GetFalAiImageutilsMarigoldDepthRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/imageutils/marigold-depth/requests/{request_id}'
}

export type GetFalAiImageutilsMarigoldDepthRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageutilsMarigoldDepthOutput
}

export type GetFalAiImageutilsMarigoldDepthRequestsByRequestIdResponse =
  GetFalAiImageutilsMarigoldDepthRequestsByRequestIdResponses[keyof GetFalAiImageutilsMarigoldDepthRequestsByRequestIdResponses]

export type GetFalAiPulidRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/pulid/requests/{request_id}/status'
}

export type GetFalAiPulidRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiPulidRequestsByRequestIdStatusResponse =
  GetFalAiPulidRequestsByRequestIdStatusResponses[keyof GetFalAiPulidRequestsByRequestIdStatusResponses]

export type PutFalAiPulidRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/pulid/requests/{request_id}/cancel'
}

export type PutFalAiPulidRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiPulidRequestsByRequestIdCancelResponse =
  PutFalAiPulidRequestsByRequestIdCancelResponses[keyof PutFalAiPulidRequestsByRequestIdCancelResponses]

export type PostFalAiPulidData = {
  body: SchemaPulidInput
  path?: never
  query?: never
  url: '/fal-ai/pulid'
}

export type PostFalAiPulidResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPulidResponse =
  PostFalAiPulidResponses[keyof PostFalAiPulidResponses]

export type GetFalAiPulidRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/pulid/requests/{request_id}'
}

export type GetFalAiPulidRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPulidOutput
}

export type GetFalAiPulidRequestsByRequestIdResponse =
  GetFalAiPulidRequestsByRequestIdResponses[keyof GetFalAiPulidRequestsByRequestIdResponses]

export type GetFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/fast-sdxl-controlnet-canny/image-to-image/requests/{request_id}/status'
  }

export type GetFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/fast-sdxl-controlnet-canny/image-to-image/requests/{request_id}/cancel'
  }

export type PutFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiFastSdxlControlnetCannyImageToImageData = {
  body: SchemaFastSdxlControlnetCannyImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/fast-sdxl-controlnet-canny/image-to-image'
}

export type PostFalAiFastSdxlControlnetCannyImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFastSdxlControlnetCannyImageToImageResponse =
  PostFalAiFastSdxlControlnetCannyImageToImageResponses[keyof PostFalAiFastSdxlControlnetCannyImageToImageResponses]

export type GetFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/fast-sdxl-controlnet-canny/image-to-image/requests/{request_id}'
  }

export type GetFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaFastSdxlControlnetCannyImageToImageOutput
  }

export type GetFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdResponse =
  GetFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdResponses[keyof GetFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdResponses]

export type GetFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/fast-sdxl-controlnet-canny/inpainting/requests/{request_id}/status'
  }

export type GetFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdStatusResponse =
  GetFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdStatusResponses[keyof GetFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdStatusResponses]

export type PutFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/fast-sdxl-controlnet-canny/inpainting/requests/{request_id}/cancel'
  }

export type PutFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdCancelResponse =
  PutFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdCancelResponses[keyof PutFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdCancelResponses]

export type PostFalAiFastSdxlControlnetCannyInpaintingData = {
  body: SchemaFastSdxlControlnetCannyInpaintingInput
  path?: never
  query?: never
  url: '/fal-ai/fast-sdxl-controlnet-canny/inpainting'
}

export type PostFalAiFastSdxlControlnetCannyInpaintingResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFastSdxlControlnetCannyInpaintingResponse =
  PostFalAiFastSdxlControlnetCannyInpaintingResponses[keyof PostFalAiFastSdxlControlnetCannyInpaintingResponses]

export type GetFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-sdxl-controlnet-canny/inpainting/requests/{request_id}'
}

export type GetFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaFastSdxlControlnetCannyInpaintingOutput
  }

export type GetFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdResponse =
  GetFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdResponses[keyof GetFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdResponses]

export type GetFalAiLcmSd15I2iRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/lcm-sd15-i2i/requests/{request_id}/status'
}

export type GetFalAiLcmSd15I2iRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLcmSd15I2iRequestsByRequestIdStatusResponse =
  GetFalAiLcmSd15I2iRequestsByRequestIdStatusResponses[keyof GetFalAiLcmSd15I2iRequestsByRequestIdStatusResponses]

export type PutFalAiLcmSd15I2iRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/lcm-sd15-i2i/requests/{request_id}/cancel'
}

export type PutFalAiLcmSd15I2iRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLcmSd15I2iRequestsByRequestIdCancelResponse =
  PutFalAiLcmSd15I2iRequestsByRequestIdCancelResponses[keyof PutFalAiLcmSd15I2iRequestsByRequestIdCancelResponses]

export type PostFalAiLcmSd15I2iData = {
  body: SchemaLcmSd15I2iInput
  path?: never
  query?: never
  url: '/fal-ai/lcm-sd15-i2i'
}

export type PostFalAiLcmSd15I2iResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLcmSd15I2iResponse =
  PostFalAiLcmSd15I2iResponses[keyof PostFalAiLcmSd15I2iResponses]

export type GetFalAiLcmSd15I2iRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/lcm-sd15-i2i/requests/{request_id}'
}

export type GetFalAiLcmSd15I2iRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLcmSd15I2iOutput
}

export type GetFalAiLcmSd15I2iRequestsByRequestIdResponse =
  GetFalAiLcmSd15I2iRequestsByRequestIdResponses[keyof GetFalAiLcmSd15I2iRequestsByRequestIdResponses]

export type GetFalAiInpaintRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/inpaint/requests/{request_id}/status'
}

export type GetFalAiInpaintRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiInpaintRequestsByRequestIdStatusResponse =
  GetFalAiInpaintRequestsByRequestIdStatusResponses[keyof GetFalAiInpaintRequestsByRequestIdStatusResponses]

export type PutFalAiInpaintRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/inpaint/requests/{request_id}/cancel'
}

export type PutFalAiInpaintRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiInpaintRequestsByRequestIdCancelResponse =
  PutFalAiInpaintRequestsByRequestIdCancelResponses[keyof PutFalAiInpaintRequestsByRequestIdCancelResponses]

export type PostFalAiInpaintData = {
  body: SchemaInpaintInput
  path?: never
  query?: never
  url: '/fal-ai/inpaint'
}

export type PostFalAiInpaintResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiInpaintResponse =
  PostFalAiInpaintResponses[keyof PostFalAiInpaintResponses]

export type GetFalAiInpaintRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/inpaint/requests/{request_id}'
}

export type GetFalAiInpaintRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaInpaintOutput
}

export type GetFalAiInpaintRequestsByRequestIdResponse =
  GetFalAiInpaintRequestsByRequestIdResponses[keyof GetFalAiInpaintRequestsByRequestIdResponses]

export type GetFalAiEsrganRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/esrgan/requests/{request_id}/status'
}

export type GetFalAiEsrganRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiEsrganRequestsByRequestIdStatusResponse =
  GetFalAiEsrganRequestsByRequestIdStatusResponses[keyof GetFalAiEsrganRequestsByRequestIdStatusResponses]

export type PutFalAiEsrganRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/esrgan/requests/{request_id}/cancel'
}

export type PutFalAiEsrganRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiEsrganRequestsByRequestIdCancelResponse =
  PutFalAiEsrganRequestsByRequestIdCancelResponses[keyof PutFalAiEsrganRequestsByRequestIdCancelResponses]

export type PostFalAiEsrganData = {
  body: SchemaEsrganInput
  path?: never
  query?: never
  url: '/fal-ai/esrgan'
}

export type PostFalAiEsrganResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiEsrganResponse =
  PostFalAiEsrganResponses[keyof PostFalAiEsrganResponses]

export type GetFalAiEsrganRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/esrgan/requests/{request_id}'
}

export type GetFalAiEsrganRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaEsrganOutput
}

export type GetFalAiEsrganRequestsByRequestIdResponse =
  GetFalAiEsrganRequestsByRequestIdResponses[keyof GetFalAiEsrganRequestsByRequestIdResponses]

export type GetFalAiImageutilsRembgRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/imageutils/rembg/requests/{request_id}/status'
}

export type GetFalAiImageutilsRembgRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImageutilsRembgRequestsByRequestIdStatusResponse =
  GetFalAiImageutilsRembgRequestsByRequestIdStatusResponses[keyof GetFalAiImageutilsRembgRequestsByRequestIdStatusResponses]

export type PutFalAiImageutilsRembgRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/imageutils/rembg/requests/{request_id}/cancel'
}

export type PutFalAiImageutilsRembgRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImageutilsRembgRequestsByRequestIdCancelResponse =
  PutFalAiImageutilsRembgRequestsByRequestIdCancelResponses[keyof PutFalAiImageutilsRembgRequestsByRequestIdCancelResponses]

export type PostFalAiImageutilsRembgData = {
  body: SchemaImageutilsRembgInput
  path?: never
  query?: never
  url: '/fal-ai/imageutils/rembg'
}

export type PostFalAiImageutilsRembgResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImageutilsRembgResponse =
  PostFalAiImageutilsRembgResponses[keyof PostFalAiImageutilsRembgResponses]

export type GetFalAiImageutilsRembgRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/imageutils/rembg/requests/{request_id}'
}

export type GetFalAiImageutilsRembgRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImageutilsRembgOutput
}

export type GetFalAiImageutilsRembgRequestsByRequestIdResponse =
  GetFalAiImageutilsRembgRequestsByRequestIdResponses[keyof GetFalAiImageutilsRembgRequestsByRequestIdResponses]
