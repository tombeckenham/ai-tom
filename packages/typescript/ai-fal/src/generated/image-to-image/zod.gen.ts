// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod'

/**
 * Image
 *
 * Represents an image file.
 */
export const zSchemaImage = z
  .object({
    height: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The height of the image in pixels.',
      }),
    ),
    file_size: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The size of the file in bytes.',
      }),
    ),
    url: z.string().register(z.globalRegistry, {
      description: 'The URL where the file can be downloaded from.',
    }),
    width: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The width of the image in pixels.',
      }),
    ),
    file_name: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The name of the file. It will be auto-generated if not provided.',
      }),
    ),
    content_type: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The mime type of the file.',
      }),
    ),
    file_data: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'File data',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Represents an image file.',
  })

/**
 * RemoveBackgroundOutput
 */
export const zSchemaImageutilsRembgOutput = z.object({
  image: zSchemaImage,
})

/**
 * RemoveBackgroundInput
 */
export const zSchemaImageutilsRembgInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  crop_to_bbox: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the resulting image be cropped to a bounding box around the subject\n        ',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Input image url.',
  }),
})

/**
 * UpscaleOutput
 */
export const zSchemaEsrganOutput = z.object({
  image: zSchemaImage,
})

/**
 * UpscaleInput
 */
export const zSchemaEsrganInput = z.object({
  model: z.optional(
    z
      .enum([
        'RealESRGAN_x4plus',
        'RealESRGAN_x2plus',
        'RealESRGAN_x4plus_anime_6B',
        'RealESRGAN_x4_v3',
        'RealESRGAN_x4_wdn_v3',
        'RealESRGAN_x4_anime_v3',
      ])
      .register(z.globalRegistry, {
        description: 'Model to use for upscaling',
      }),
  ),
  face: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Upscaling a face',
      }),
    )
    .default(false),
  scale: z
    .optional(
      z.number().gte(1).lte(8).register(z.globalRegistry, {
        description: 'Rescaling factor',
      }),
    )
    .default(2),
  tile: z
    .optional(
      z.int().register(z.globalRegistry, {
        description:
          'Tile size. Default is 0, that is no tile. When encountering the out-of-GPU-memory issue, please specify it, e.g., 400 or 200',
      }),
    )
    .default(0),
  output_format: z.optional(
    z.enum(['png', 'jpeg']).register(z.globalRegistry, {
      description: 'Output image format (png or jpeg)',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Url to input image',
  }),
})

/**
 * InpaintOutput
 */
export const zSchemaInpaintOutput = z.object({
  image: zSchemaImage,
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * InpaintInput
 */
export const zSchemaInpaintInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Input image for img2img or inpaint mode',
  }),
  model_name: z.string().register(z.globalRegistry, {
    description:
      'URL or HuggingFace ID of the base model to generate the image.',
  }),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(7.5),
  num_inference_steps: z
    .optional(
      z.int().gte(0).lte(150).register(z.globalRegistry, {
        description:
          '\n            Increasing the amount of steps tells Stable Diffusion that it should take more steps\n            to generate your final result which can increase the amount of detail in your image.\n        ',
      }),
    )
    .default(30),
  mask_url: z.string().register(z.globalRegistry, {
    description:
      'Input mask for inpaint mode. Black areas will be preserved, white areas will be inpainted.',
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * LCMOutput
 */
export const zSchemaLcmSd15I2iOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  timings: z.record(z.string(), z.number()),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  num_inference_steps: z
    .optional(
      z.int().register(z.globalRegistry, {
        description:
          '\n            Number of inference steps used to generate the image. It will be the same value of the one passed in the\n            input or the default one in case none was passed.\n        ',
      }),
    )
    .default(4),
  nsfw_content_detected: z.array(z.boolean()).register(z.globalRegistry, {
    description:
      '\n            A list of booleans indicating whether the generated image contains any\n            potentially unsafe content. If the safety check is disabled, this field\n            will have a false for each generated image.\n        ',
  }),
})

/**
 * LCMI2IInput
 */
export const zSchemaLcmSd15I2iInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description:
          '\n            The number of images to generate. The function will return a list of images\n            with the same prompt and negative prompt but different seeds.\n        ',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The image to use as a base.',
  }),
  strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The strength of the image.',
      }),
    )
    .default(0.8),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  enable_safety_checks: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the resulting image will be checked whether it includes any\n            potentially unsafe content. If it does, it will be replaced with a black\n            image.\n        ',
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(16).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(1),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(12).register(z.globalRegistry, {
        description:
          '\n            The number of inference steps to use for generating the image. The more steps\n            the better the image will be but it will also take longer to generate.\n        ',
      }),
    )
    .default(4),
})

/**
 * Output
 */
export const zSchemaFastSdxlControlnetCannyInpaintingOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * LoraWeight
 */
export const zSchemaLoraWeight = z.object({
  path: z.string().register(z.globalRegistry, {
    description: 'URL or the path to the LoRA weights. Or HF model name.',
  }),
  scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The scale of the LoRA weight. This is used to scale the LoRA weight\n            before merging it with the base model.\n        ',
      }),
    )
    .default(1),
})

/**
 * ImageSize
 */
export const zSchemaImageSize = z.object({
  height: z
    .optional(
      z.int().lte(14142).register(z.globalRegistry, {
        description: 'The height of the generated image.',
      }),
    )
    .default(512),
  width: z
    .optional(
      z.int().lte(14142).register(z.globalRegistry, {
        description: 'The width of the generated image.',
      }),
    )
    .default(512),
})

/**
 * InpaintingControlNetInput
 */
export const zSchemaFastSdxlControlnetCannyInpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
      z.null(),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description: 'The list of LoRA weights to use.',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(7.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  controlnet_conditioning_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The scale of the controlnet conditioning.',
      }),
    )
    .default(0.5),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the image to use as a starting point for the generation.',
  }),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'determines how much the generated image resembles the initial image',
      }),
    )
    .default(0.95),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  control_image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the control image.',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  mask_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the mask to use for inpainting.',
  }),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(65).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(25),
})

/**
 * Output
 */
export const zSchemaFastSdxlControlnetCannyImageToImageOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * ImageToImageControlNetInput
 */
export const zSchemaFastSdxlControlnetCannyImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
      z.null(),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description: 'The list of LoRA weights to use.',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(7.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  controlnet_conditioning_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The scale of the controlnet conditioning.',
      }),
    )
    .default(0.5),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the image to use as a starting point for the generation.',
  }),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'determines how much the generated image resembles the initial image',
      }),
    )
    .default(0.95),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  control_image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the control image.',
  }),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(65).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(25),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * ReferenceFace
 */
export const zSchemaReferenceFace = z.object({
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the reference face image',
  }),
})

/**
 * OutputModel
 */
export const zSchemaPulidOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'List of generated images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'Random seed used for reproducibility',
  }),
})

/**
 * InputModel
 */
export const zSchemaPulidInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Prompt to generate the face from',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'Number of images to generate',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  id_scale: z
    .optional(
      z.number().lte(5).register(z.globalRegistry, {
        description: 'ID scale',
      }),
    )
    .default(0.8),
  mode: z.optional(
    z.enum(['fidelity', 'extreme style']).register(z.globalRegistry, {
      description: 'Mode of generation',
    }),
  ),
  id_mix: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'if you want to mix two ID image, please turn this on, otherwise, turn this off',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(1.5).register(z.globalRegistry, {
        description: 'Guidance scale',
      }),
    )
    .default(1.2),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(12).register(z.globalRegistry, {
        description: 'Number of steps to take',
      }),
    )
    .default(4),
  reference_images: z.array(zSchemaReferenceFace).register(z.globalRegistry, {
    description: 'List of reference faces, ideally 4 images.',
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to generate the face from',
      }),
    )
    .default(
      'flaws in the eyes, flaws in the face, flaws, lowres, non-HDRi, low quality, worst quality,artifacts noise, text, watermark, glitch, deformed, mutated, ugly, disfigured, hands, low resolution, partially rendered objects,  deformed or partially rendered eyes, deformed, deformed eyeballs, cross-eyed,blurry',
    ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducibility',
    }),
  ),
})

/**
 * MarigoldDepthMapOutput
 */
export const zSchemaImageutilsMarigoldDepthOutput = z.object({
  image: zSchemaImage,
})

/**
 * MarigoldDepthMapInput
 */
export const zSchemaImageutilsMarigoldDepthInput = z.object({
  ensemble_size: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description:
          'Number of predictions to average over. Defaults to `10`. The higher the number, the more accurate the result, but the slower the inference.',
      }),
    )
    .default(10),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description:
          'Number of denoising steps. Defaults to `10`. The higher the number, the more accurate the result, but the slower the inference.',
      }),
    )
    .default(10),
  processing_res: z
    .optional(
      z.int().gte(0).lte(2048).register(z.globalRegistry, {
        description:
          'Maximum processing resolution. Defaults `0` which means it uses the size of the input image.',
      }),
    )
    .default(0),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Input image url.',
  }),
})

/**
 * DepthMapOutput
 */
export const zSchemaImageutilsDepthOutput = z.object({
  image: zSchemaImage,
})

/**
 * DepthMapInput
 */
export const zSchemaImageutilsDepthInput = z.object({
  bg_th: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'bg_th',
      }),
    )
    .default(0.1),
  a: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'a',
      }),
    )
    .default(6.283185307179586),
  depth_and_normal: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'depth_and_normal',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Input image url.',
  }),
})

/**
 * RetoucherOutput
 */
export const zSchemaRetoucherOutput = z.object({
  image: zSchemaImage,
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for the generation.',
  }),
})

/**
 * RetoucherInput
 */
export const zSchemaRetoucherInput = z.object({
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Seed for reproducibility. Different seeds will make slightly different results.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to be retouched.',
  }),
})

/**
 * Output
 */
export const zSchemaFastLcmDiffusionImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * ImageToImageLCMInput
 */
export const zSchemaFastLcmDiffusionImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The rescale factor for the CFG.',
      }),
    )
    .default(0),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(1.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  preserve_aspect_ratio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n        If set to true, the aspect ratio of the generated image will be preserved even\n        if the image size is too large. However, if the image is not a multiple of 32\n        in width or height, it will be resized to the nearest multiple of 32. By default,\n        this snapping to the nearest multiple of 32 will not preserve the aspect ratio.\n        Set crop_output to True, to crop the output to the proper aspect ratio\n        after generating.\n        ',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  crop_output: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n        If set to true, the output cropped to the proper aspect ratio after generating.\n        ',
      }),
    )
    .default(false),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the image to use as a starting point for the generation.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(true),
  model_name: z.optional(
    z
      .enum([
        'stabilityai/stable-diffusion-xl-base-1.0',
        'runwayml/stable-diffusion-v1-5',
      ])
      .register(z.globalRegistry, {
        description: 'The name of the model to use.',
      }),
  ),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(32).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(6),
  strength: z
    .optional(
      z.number().gte(0.05).lte(1).register(z.globalRegistry, {
        description:
          'determines how much the generated image resembles the initial image',
      }),
    )
    .default(0.95),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaFastLcmDiffusionInpaintingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * InpaintingLCMInput
 */
export const zSchemaFastLcmDiffusionInpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The rescale factor for the CFG.',
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(1.5),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the image to use as a starting point for the generation.',
  }),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'determines how much the generated image resembles the initial image',
      }),
    )
    .default(0.95),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(true),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(32).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(6),
  mask_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the mask to use for inpainting.',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  model_name: z.optional(
    z
      .enum([
        'stabilityai/stable-diffusion-xl-base-1.0',
        'runwayml/stable-diffusion-v1-5',
      ])
      .register(z.globalRegistry, {
        description: 'The name of the model to use.',
      }),
  ),
})

/**
 * Output
 */
export const zSchemaPlaygroundV25InpaintingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * Embedding
 */
export const zSchemaEmbedding = z.object({
  tokens: z
    .optional(
      z.array(z.string()).register(z.globalRegistry, {
        description: 'The list of tokens to use for the embedding.',
      }),
    )
    .default(['<s0>', '<s1>']),
  path: z.string().register(z.globalRegistry, {
    description: 'URL or the path to the embedding weights.',
  }),
})

/**
 * InpaintingPlaygroundv25Input
 */
export const zSchemaPlaygroundV25InpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description: 'The list of embeddings to use.',
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The rescale factor for the CFG.',
      }),
    )
    .default(0),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the image to use as a starting point for the generation.',
  }),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'determines how much the generated image resembles the initial image',
      }),
    )
    .default(0.95),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  mask_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the mask to use for inpainting.',
  }),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(65).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(25),
})

/**
 * Output
 */
export const zSchemaFastLightningSdxlInpaintingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * InpaintingLightningInput
 */
export const zSchemaFastLightningSdxlInpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description: 'The list of embeddings to use.',
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The rescale factor for the CFG.',
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the image to use as a starting point for the generation.',
  }),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'determines how much the generated image resembles the initial image',
      }),
    )
    .default(0.95),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  num_inference_steps: z.optional(
    z.enum(['1', '2', '4', '8']).register(z.globalRegistry, {
      description: 'The number of inference steps to perform.',
    }),
  ),
  mask_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the mask to use for inpainting.',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaFastLightningSdxlImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * ImageToImageLightningInput
 */
export const zSchemaFastLightningSdxlImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description: 'The list of embeddings to use.',
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The rescale factor for the CFG.',
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  preserve_aspect_ratio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n        If set to true, the aspect ratio of the generated image will be preserved even\n        if the image size is too large. However, if the image is not a multiple of 32\n        in width or height, it will be resized to the nearest multiple of 32. By default,\n        this snapping to the nearest multiple of 32 will not preserve the aspect ratio.\n        Set crop_output to True, to crop the output to the proper aspect ratio\n        after generating.\n        ',
      }),
    )
    .default(false),
  crop_output: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n        If set to true, the output cropped to the proper aspect ratio after generating.\n        ',
      }),
    )
    .default(false),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the image to use as a starting point for the generation.',
  }),
  strength: z
    .optional(
      z.number().gte(0.05).lte(1).register(z.globalRegistry, {
        description:
          'determines how much the generated image resembles the initial image',
      }),
    )
    .default(0.95),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  num_inference_steps: z.optional(
    z.enum(['1', '2', '4', '8']).register(z.globalRegistry, {
      description: 'The number of inference steps to perform.',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaPlaygroundV25ImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * ImageToImagePlaygroundv25Input
 */
export const zSchemaPlaygroundV25ImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description: 'The list of embeddings to use.',
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The rescale factor for the CFG.',
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3),
  preserve_aspect_ratio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n        If set to true, the aspect ratio of the generated image will be preserved even\n        if the image size is too large. However, if the image is not a multiple of 32\n        in width or height, it will be resized to the nearest multiple of 32. By default,\n        this snapping to the nearest multiple of 32 will not preserve the aspect ratio.\n        Set crop_output to True, to crop the output to the proper aspect ratio\n        after generating.\n        ',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  crop_output: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n        If set to true, the output cropped to the proper aspect ratio after generating.\n        ',
      }),
    )
    .default(false),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the image to use as a starting point for the generation.',
  }),
  strength: z
    .optional(
      z.number().gte(0.05).lte(1).register(z.globalRegistry, {
        description:
          'determines how much the generated image resembles the initial image',
      }),
    )
    .default(0.95),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(65).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(25),
})

/**
 * ImageFile
 */
export const zSchemaImageFile = z.object({
  height: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The height of the image',
    }),
  ),
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  width: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The width of the image',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaBirefnetOutput = z.object({
  image: zSchemaImageFile,
  mask_image: z.optional(zSchemaImageFile),
})

/**
 * Input
 */
export const zSchemaBirefnetInput = z.object({
  operating_resolution: z.optional(
    z.enum(['1024x1024', '2048x2048']).register(z.globalRegistry, {
      description:
        'The resolution to operate on. The higher the resolution, the more accurate the output will be for high res input images.',
    }),
  ),
  output_format: z.optional(
    z.enum(['webp', 'png', 'gif']).register(z.globalRegistry, {
      description: 'The format of the output image',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to remove background from',
  }),
  model: z.optional(
    z
      .enum(['General Use (Light)', 'General Use (Heavy)', 'Portrait'])
      .register(z.globalRegistry, {
        description:
          "\n            Model to use for background removal.\n            The 'General Use (Light)' model is the original model used in the BiRefNet repository.\n            The 'General Use (Heavy)' model is a slower but more accurate model.\n            The 'Portrait' model is a model trained specifically for portrait images.\n            The 'General Use (Light)' model is recommended for most use cases.\n\n            The corresponding models are as follows:\n            - 'General Use (Light)': BiRefNet-DIS_ep580.pth\n            - 'General Use (Heavy)': BiRefNet-massive-epoch_240.pth\n            - 'Portrait': BiRefNet-portrait-TR_P3M_10k-epoch_120.pth\n        ",
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  output_mask: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to output the mask used to remove the background',
      }),
    )
    .default(false),
  refine_foreground: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to refine the foreground using the estimated mask',
      }),
    )
    .default(true),
})

/**
 * CreativeUpscalerOutput
 */
export const zSchemaCreativeUpscalerOutput = z.object({
  image: zSchemaImage,
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * CreativeUpscalerInput
 */
export const zSchemaCreativeUpscalerInput = z.object({
  shape_preservation: z
    .optional(
      z.number().gte(0).lte(3).register(z.globalRegistry, {
        description: 'How much to preserve the shape of the original image',
      }),
    )
    .default(0.25),
  prompt: z.optional(z.union([z.string(), z.null()])),
  additional_embedding_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The URL to the additional embeddings to use for the upscaling. Default is None',
    }),
  ),
  enable_safety_checks: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the resulting image will be checked whether it includes any\n            potentially unsafe content. If it does, it will be replaced with a black\n            image.\n        ',
      }),
    )
    .default(true),
  additional_lora_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The URL to the additional LORA model to use for the upscaling. Default is None',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(16).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(7.5),
  scale: z
    .optional(
      z.number().gte(1).lte(5).register(z.globalRegistry, {
        description:
          'The scale of the output image. The higher the scale, the bigger the output image will be.',
      }),
    )
    .default(2),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(
      'blurry, low resolution, bad, ugly, low quality, pixelated, interpolated, compression artifacts, noisey, grainy',
    ),
  skip_ccsr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the image will not be processed by the CCSR model before\n            being processed by the creativity model.\n        ',
      }),
    )
    .default(false),
  additional_lora_scale: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          'The scale of the additional LORA model to use for the upscaling. Default is 1.0',
      }),
    )
    .default(1),
  detail: z
    .optional(
      z.number().gte(0).lte(5).register(z.globalRegistry, {
        description: 'How much detail to add',
      }),
    )
    .default(1),
  base_model_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL to the base model to use for the upscaling',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The image to upscale.',
  }),
  creativity: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'How much the output can deviate from the original',
      }),
    )
    .default(0.5),
  override_size_limits: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            Allow for large uploads that could take a very long time.\n        ',
      }),
    )
    .default(false),
  prompt_suffix: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The suffix to add to the prompt. This is useful to add a common ending to all prompts such as 'high quality' etc or embedding tokens.",
      }),
    )
    .default(' high quality, highly detailed, high resolution, sharp'),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(200).register(z.globalRegistry, {
        description:
          '\n            The number of inference steps to use for generating the image. The more steps\n            the better the image will be but it will also take longer to generate.\n        ',
      }),
    )
    .default(20),
  model_type: z.optional(
    z.enum(['SD_1_5', 'SDXL']).register(z.globalRegistry, {
      description:
        'The type of model to use for the upscaling. Default is SD_1_5',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * PhotoMakerOutput
 */
export const zSchemaPhotomakerOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * PhotoMakerInput
 */
export const zSchemaPhotomakerInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          '\n            Number of images to generate in one request. Note that the higher the batch size,\n            the longer it will take to generate the images.\n        ',
      }),
    )
    .default(1),
  style_strength: z.optional(z.int().gte(15).lte(50)).default(20),
  style: z.optional(
    z.enum([
      '(No style)',
      'Cinematic',
      'Disney Character',
      'Digital Art',
      'Photographic',
      'Fantasy art',
      'Neonpunk',
      'Enhance',
      'Comic book',
      'Lowpoly',
      'Line art',
    ]),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0.1).lte(10).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  image_archive_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the image archive containing the images you want to use.',
  }),
  initial_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Optional initial image for img2img',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(20).lte(100).register(z.globalRegistry, {
        description:
          '\n            Increasing the amount of steps tells Stable Diffusion that it should take more steps\n            to generate your final result which can increase the amount of detail in your image.\n        ',
      }),
    )
    .default(50),
  initial_image_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'How much noise to add to the latent image. O for no noise, 1 for maximum noise.',
      }),
    )
    .default(0.5),
  base_pipeline: z.optional(
    z.enum(['photomaker', 'photomaker-style']).register(z.globalRegistry, {
      description: 'The base pipeline to use for generating the image.',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
})

/**
 * FaceToStickerOutput
 */
export const zSchemaFaceToStickerOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  sticker_image: zSchemaImage,
  sticker_image_background_removed: zSchemaImage,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used during the inference.',
  }),
  has_nsfw_concepts: z
    .record(z.string(), z.boolean())
    .register(z.globalRegistry, {
      description:
        '\n            Whether the generated images contain NSFW concepts.\n            The key is the image type and the value is a boolean.\n        ',
    }),
})

/**
 * FaceToStickerInput
 */
export const zSchemaFaceToStickerInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to false, the safety checker will be disabled.',
      }),
    )
    .default(true),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  ip_adapter_weight: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The weight of the IP adapter.',
      }),
    )
    .default(0.2),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the video.',
  }),
  upscale_steps: z
    .optional(
      z.int().gte(1).lte(20).register(z.globalRegistry, {
        description:
          'The number of steps to use for upscaling. Only used if `upscale` is `true`.',
      }),
    )
    .default(10),
  instant_id_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The strength of the instant ID.',
      }),
    )
    .default(0.7),
  upscale: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to upscale the image 2x.',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(40).register(z.globalRegistry, {
        description:
          '\n            Increasing the amount of steps tells Stable Diffusion that it should take more steps\n            to generate your final result which can increase the amount of detail in your image.\n        ',
      }),
    )
    .default(20),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  ip_adapter_noise: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The amount of noise to add to the IP adapter.',
      }),
    )
    .default(0.5),
})

/**
 * Output
 */
export const zSchemaFastSdxlInpaintingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * InpaintingInput
 */
export const zSchemaFastSdxlInpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description: 'The list of embeddings to use.',
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description: 'The list of LoRA weights to use.',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(7.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the image to use as a starting point for the generation.',
  }),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'determines how much the generated image resembles the initial image',
      }),
    )
    .default(0.95),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(65).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(25),
  mask_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the mask to use for inpainting.',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaFastSdxlImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * ImageToImageInput
 */
export const zSchemaFastSdxlImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description: 'The list of embeddings to use.',
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description: 'The list of LoRA weights to use.',
      }),
    )
    .default([]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(7.5),
  preserve_aspect_ratio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n        If set to true, the aspect ratio of the generated image will be preserved even\n        if the image size is too large. However, if the image is not a multiple of 32\n        in width or height, it will be resized to the nearest multiple of 32. By default,\n        this snapping to the nearest multiple of 32 will not preserve the aspect ratio.\n        Set crop_output to True, to crop the output to the proper aspect ratio\n        after generating.\n        ',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  crop_output: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n        If set to true, the output cropped to the proper aspect ratio after generating.\n        ',
      }),
    )
    .default(false),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the image to use as a starting point for the generation.',
  }),
  strength: z
    .optional(
      z.number().gte(0.05).lte(1).register(z.globalRegistry, {
        description:
          'determines how much the generated image resembles the initial image',
      }),
    )
    .default(0.95),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(65).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(25),
})

/**
 * File
 */
export const zSchemaFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * OutputParameters
 */
export const zSchemaLoraImageToImageOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  debug_latents: z.optional(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  debug_per_pass_latents: z.optional(zSchemaFile),
})

/**
 * ControlNet
 */
export const zSchemaControlNet = z.object({
  conditioning_scale: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description:
          '\n            The scale of the control net weight. This is used to scale the control net weight\n            before merging it with the base model.\n        ',
      }),
    )
    .default(1),
  path: z.string().register(z.globalRegistry, {
    description: 'URL or the path to the control net weights.',
  }),
  ip_adapter_index: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The index of the IP adapter to be applied to the controlnet. This is only needed for InstantID ControlNets.\n        ',
    }),
  ),
  end_percentage: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The percentage of the image to end applying the controlnet in terms of the total timesteps.\n        ',
      }),
    )
    .default(1),
  config_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'optional URL to the controlnet config.json file.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be used as the control net.',
  }),
  variant: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The optional variant if a Hugging Face repo key is used.',
    }),
  ),
  mask_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The mask to use for the controlnet. When using a mask, the control image size and the mask size must be the same and divisible by 32.\n        ',
    }),
  ),
  start_percentage: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The percentage of the image to start applying the controlnet in terms of the total timesteps.\n        ',
      }),
    )
    .default(0),
})

/**
 * TimestepsInput
 */
export const zSchemaTimestepsInput = z.object({
  method: z.optional(
    z.enum(['default', 'array']).register(z.globalRegistry, {
      description:
        "\n            The method to use for the timesteps. If set to 'array', the timesteps will be set based\n            on the provided timesteps schedule in the `array` field.\n            Defaults to 'default' which means the scheduler will use the `num_inference_steps` parameter.\n        ",
    }),
  ),
  array: z
    .optional(
      z.array(z.int()).register(z.globalRegistry, {
        description:
          "\n           Timesteps schedule to be used if 'custom' method is selected.\n        ",
      }),
    )
    .default([]),
})

/**
 * SigmasInput
 */
export const zSchemaSigmasInput = z.object({
  method: z.optional(
    z.enum(['default', 'array']).register(z.globalRegistry, {
      description:
        "\n            The method to use for the sigmas. If set to 'custom', the sigmas will be set based\n            on the provided sigmas schedule in the `array` field.\n            Defaults to 'default' which means the scheduler will use the sigmas of the scheduler.\n        ",
    }),
  ),
  array: z
    .optional(
      z.array(z.number()).register(z.globalRegistry, {
        description:
          "\n           Sigmas schedule to be used if 'custom' method is selected.\n        ",
      }),
    )
    .default([]),
})

/**
 * IPAdapter
 */
export const zSchemaIpAdapter = z.object({
  unconditional_noising_factor: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'The factor to apply to the unconditional noising of the IP adapter.',
      }),
    )
    .default(0),
  ip_adapter_image_url: z.union([z.string(), z.array(z.string())]),
  path: z.string().register(z.globalRegistry, {
    description: 'URL or the path to the IP adapter weights.',
  }),
  image_projection_shortcut: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            The value to set the image projection shortcut to. For FaceID plus V1 models,\n            this should be set to False. For FaceID plus V2 models, this should be set to True.\n            Default is True.\n        ',
      }),
    )
    .default(true),
  scale_json: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description:
        '\n            The scale of the IP adapter weight. This is used to scale the IP adapter weight\n            before merging it with the base model.\n        ',
    }),
  ),
  ip_adapter_mask_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The mask to use for the IP adapter. When using a mask, the ip-adapter image size and the mask size must be the same\n        ',
    }),
  ),
  model_subfolder: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Subfolder in the model directory where the IP adapter weights are stored.',
    }),
  ),
  scale: z
    .optional(
      z.number().gte(0).register(z.globalRegistry, {
        description:
          '\n            The scale of the IP adapter weight. This is used to scale the IP adapter weight\n            before merging it with the base model.\n        ',
      }),
    )
    .default(1),
  insight_face_model_path: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL or the path to the InsightFace model weights.',
    }),
  ),
  weight_name: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Name of the weight file.',
    }),
  ),
})

/**
 * ImageToImageInput
 */
export const zSchemaLoraImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  noise_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'The amount of noise to add to noise image for image. Only used if the image_url is provided. 1.0 is complete noise and 0 is no noise.',
      }),
    )
    .default(0.5),
  tile_height: z
    .optional(
      z.int().gte(128).lte(4096).register(z.globalRegistry, {
        description:
          'The size of the tiles to be used for the image generation.',
      }),
    )
    .default(4096),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description:
          '\n            The embeddings to use for the image generation. Only a single embedding is supported at the moment.\n            The embeddings will be used to map the tokens in the prompt to the embedding weights.\n        ',
      }),
    )
    .default([]),
  ic_light_model_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The URL of the IC Light model to use for the image generation.\n        ',
    }),
  ),
  image_encoder_weight_name: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            The weight name of the image encoder model to use for the image generation.\n        ',
      }),
    )
    .default('pytorch_model.bin'),
  ip_adapter: z
    .optional(
      z.array(zSchemaIpAdapter).register(z.globalRegistry, {
        description:
          '\n            The IP adapter to use for the image generation.\n        ',
      }),
    )
    .default([]),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  scheduler: z.optional(
    z
      .enum([
        'DPM++ 2M',
        'DPM++ 2M Karras',
        'DPM++ 2M SDE',
        'DPM++ 2M SDE Karras',
        'Euler',
        'Euler A',
        'Euler (trailing timesteps)',
        'LCM',
        'LCM (trailing timesteps)',
        'DDIM',
        'TCD',
      ])
      .register(z.globalRegistry, {
        description:
          'Scheduler / sampler to use for the image denoising process.',
      }),
  ),
  sigmas: z.optional(zSchemaSigmasInput),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(7.5),
  tile_stride_width: z
    .optional(
      z.int().gte(64).lte(2048).register(z.globalRegistry, {
        description:
          'The stride of the tiles to be used for the image generation.',
      }),
    )
    .default(2048),
  debug_per_pass_latents: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the latents will be saved for debugging per pass.',
      }),
    )
    .default(false),
  timesteps: z.optional(zSchemaTimestepsInput),
  model_name: z.string().register(z.globalRegistry, {
    description:
      'URL or HuggingFace ID of the base model to generate the image.',
  }),
  prompt_weighting: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the prompt weighting syntax will be used.\n            Additionally, this will lift the 77 token limit by averaging embeddings.\n        ',
      }),
    )
    .default(false),
  variant: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "The variant of the model to use for huggingface models, e.g. 'fp16'.",
    }),
  ),
  image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of image to use for image to image/inpainting.',
    }),
  ),
  controlnet_guess_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the controlnet will be applied to only the conditional predictions.\n        ',
      }),
    )
    .default(false),
  image_encoder_subfolder: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The subfolder of the image encoder model to use for the image generation.\n        ',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  ic_light_model_background_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The URL of the IC Light model background image to use for the image generation.\n            Make sure to use a background compatible with the model.\n        ',
    }),
  ),
  rescale_betas_snr_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            Whether to set the rescale_betas_snr_zero option or not for the sampler\n        ',
      }),
    )
    .default(false),
  tile_width: z
    .optional(
      z.int().gte(128).lte(4096).register(z.globalRegistry, {
        description:
          'The size of the tiles to be used for the image generation.',
      }),
    )
    .default(4096),
  prediction_type: z.optional(
    z.enum(['v_prediction', 'epsilon']).register(z.globalRegistry, {
      description:
        '\n            The type of prediction to use for the image generation.\n            The `epsilon` is the default.\n        ',
    }),
  ),
  eta: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The eta value to be used for the image generation.',
      }),
    )
    .default(0),
  image_encoder_path: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The path to the image encoder model to use for the image generation.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  image_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description:
          '\n            Number of images to generate in one request. Note that the higher the batch size,\n            the longer it will take to generate the images.\n        ',
      }),
    )
    .default(1),
  debug_latents: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the latents will be saved for debugging.',
      }),
    )
    .default(false),
  ic_light_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The URL of the IC Light model image to use for the image generation.\n        ',
    }),
  ),
  unet_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'URL or HuggingFace ID of the custom U-Net model to use for the image generation.',
    }),
  ),
  clip_skip: z
    .optional(
      z.int().gte(0).lte(2).register(z.globalRegistry, {
        description:
          '\n            Skips part of the image generation process, leading to slightly different results.\n            This means the image renders faster, too.\n        ',
      }),
    )
    .default(0),
  tile_stride_height: z
    .optional(
      z.int().gte(64).lte(2048).register(z.globalRegistry, {
        description:
          'The stride of the tiles to be used for the image generation.',
      }),
    )
    .default(2048),
  controlnets: z
    .optional(
      z.array(zSchemaControlNet).register(z.globalRegistry, {
        description:
          '\n            The control nets to use for the image generation. You can use any number of control nets\n            and they will be applied to the image at the specified timesteps.\n        ',
      }),
    )
    .default([]),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(150).register(z.globalRegistry, {
        description:
          '\n            Increasing the amount of steps tells Stable Diffusion that it should take more steps\n            to generate your final result which can increase the amount of detail in your image.\n        ',
      }),
    )
    .default(30),
})

/**
 * OutputParameters
 */
export const zSchemaLoraInpaintOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  debug_latents: z.optional(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  debug_per_pass_latents: z.optional(zSchemaFile),
})

/**
 * InpaintInput
 */
export const zSchemaLoraInpaintInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  noise_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'The amount of noise to add to noise image for image. Only used if the image_url is provided. 1.0 is complete noise and 0 is no noise.',
      }),
    )
    .default(0.5),
  tile_height: z
    .optional(
      z.int().gte(128).lte(4096).register(z.globalRegistry, {
        description:
          'The size of the tiles to be used for the image generation.',
      }),
    )
    .default(4096),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description:
          '\n            The embeddings to use for the image generation. Only a single embedding is supported at the moment.\n            The embeddings will be used to map the tokens in the prompt to the embedding weights.\n        ',
      }),
    )
    .default([]),
  ic_light_model_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The URL of the IC Light model to use for the image generation.\n        ',
    }),
  ),
  image_encoder_weight_name: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            The weight name of the image encoder model to use for the image generation.\n        ',
      }),
    )
    .default('pytorch_model.bin'),
  ip_adapter: z
    .optional(
      z.array(zSchemaIpAdapter).register(z.globalRegistry, {
        description:
          '\n            The IP adapter to use for the image generation.\n        ',
      }),
    )
    .default([]),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  scheduler: z.optional(
    z
      .enum([
        'DPM++ 2M',
        'DPM++ 2M Karras',
        'DPM++ 2M SDE',
        'DPM++ 2M SDE Karras',
        'Euler',
        'Euler A',
        'Euler (trailing timesteps)',
        'LCM',
        'LCM (trailing timesteps)',
        'DDIM',
        'TCD',
      ])
      .register(z.globalRegistry, {
        description:
          'Scheduler / sampler to use for the image denoising process.',
      }),
  ),
  sigmas: z.optional(zSchemaSigmasInput),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(7.5),
  tile_stride_width: z
    .optional(
      z.int().gte(64).lte(2048).register(z.globalRegistry, {
        description:
          'The stride of the tiles to be used for the image generation.',
      }),
    )
    .default(2048),
  debug_per_pass_latents: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the latents will be saved for debugging per pass.',
      }),
    )
    .default(false),
  timesteps: z.optional(zSchemaTimestepsInput),
  model_name: z.string().register(z.globalRegistry, {
    description:
      'URL or HuggingFace ID of the base model to generate the image.',
  }),
  prompt_weighting: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the prompt weighting syntax will be used.\n            Additionally, this will lift the 77 token limit by averaging embeddings.\n        ',
      }),
    )
    .default(false),
  variant: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "The variant of the model to use for huggingface models, e.g. 'fp16'.",
    }),
  ),
  image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of image to use for image to image/inpainting.',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  mask_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'URL of black-and-white image to use as mask during inpainting.',
    }),
  ),
  image_encoder_subfolder: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The subfolder of the image encoder model to use for the image generation.\n        ',
    }),
  ),
  ic_light_model_background_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The URL of the IC Light model background image to use for the image generation.\n            Make sure to use a background compatible with the model.\n        ',
    }),
  ),
  rescale_betas_snr_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            Whether to set the rescale_betas_snr_zero option or not for the sampler\n        ',
      }),
    )
    .default(false),
  tile_width: z
    .optional(
      z.int().gte(128).lte(4096).register(z.globalRegistry, {
        description:
          'The size of the tiles to be used for the image generation.',
      }),
    )
    .default(4096),
  controlnet_guess_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the controlnet will be applied to only the conditional predictions.\n        ',
      }),
    )
    .default(false),
  prediction_type: z.optional(
    z.enum(['v_prediction', 'epsilon']).register(z.globalRegistry, {
      description:
        '\n            The type of prediction to use for the image generation.\n            The `epsilon` is the default.\n        ',
    }),
  ),
  eta: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The eta value to be used for the image generation.',
      }),
    )
    .default(0),
  image_encoder_path: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The path to the image encoder model to use for the image generation.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  image_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description:
          '\n            Number of images to generate in one request. Note that the higher the batch size,\n            the longer it will take to generate the images.\n        ',
      }),
    )
    .default(1),
  debug_latents: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the latents will be saved for debugging.',
      }),
    )
    .default(false),
  ic_light_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The URL of the IC Light model image to use for the image generation.\n        ',
    }),
  ),
  unet_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'URL or HuggingFace ID of the custom U-Net model to use for the image generation.',
    }),
  ),
  clip_skip: z
    .optional(
      z.int().gte(0).lte(2).register(z.globalRegistry, {
        description:
          '\n            Skips part of the image generation process, leading to slightly different results.\n            This means the image renders faster, too.\n        ',
      }),
    )
    .default(0),
  tile_stride_height: z
    .optional(
      z.int().gte(64).lte(2048).register(z.globalRegistry, {
        description:
          'The stride of the tiles to be used for the image generation.',
      }),
    )
    .default(2048),
  controlnets: z
    .optional(
      z.array(zSchemaControlNet).register(z.globalRegistry, {
        description:
          '\n            The control nets to use for the image generation. You can use any number of control nets\n            and they will be applied to the image at the specified timesteps.\n        ',
      }),
    )
    .default([]),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(150).register(z.globalRegistry, {
        description:
          '\n            Increasing the amount of steps tells Stable Diffusion that it should take more steps\n            to generate your final result which can increase the amount of detail in your image.\n        ',
      }),
    )
    .default(30),
})

/**
 * IpAdapterFaceIdOutput
 */
export const zSchemaIpAdapterFaceIdOutput = z.object({
  image: zSchemaImage,
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * IpAdapterFaceIdInput
 */
export const zSchemaIpAdapterFaceIdInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  face_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'An image of a face to match. If an image with a size of 640x640 is not provided, it will be scaled and cropped to that size.',
    }),
  ),
  width: z
    .optional(
      z.int().gte(512).lte(1024).register(z.globalRegistry, {
        description:
          '\n            The width of the generated image.\n        ',
      }),
    )
    .default(512),
  face_id_det_size: z
    .optional(
      z.int().gte(64).lte(640).register(z.globalRegistry, {
        description:
          '\n            The size of the face detection model. The higher the number the more accurate\n            the detection will be but it will also take longer to run. The higher the number the more\n            likely it will fail to find a face as well. Lower it if you are having trouble\n            finding a face in the image.\n        ',
      }),
    )
    .default(640),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(16).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(7.5),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(
      'blurry, low resolution, bad, ugly, low quality, pixelated, interpolated, compression artifacts, noisey, grainy',
    ),
  height: z
    .optional(
      z.int().gte(512).lte(1024).register(z.globalRegistry, {
        description:
          '\n            The height of the generated image.\n        ',
      }),
    )
    .default(512),
  num_samples: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          '\n            The number of samples for face id. The more samples the better the image will\n            be but it will also take longer to generate. Default is 4.\n        ',
      }),
    )
    .default(4),
  base_sdxl_model_repo: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The URL to the base SDXL model. Default is SG161222/RealVisXL_V3.0',
      }),
    )
    .default('SG161222/RealVisXL_V3.0'),
  base_1_5_model_repo: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The URL to the base 1.5 model. Default is SG161222/Realistic_Vision_V4.0_noVAE',
      }),
    )
    .default('SG161222/Realistic_Vision_V4.0_noVAE'),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(200).register(z.globalRegistry, {
        description:
          '\n            The number of inference steps to use for generating the image. The more steps\n            the better the image will be but it will also take longer to generate.\n        ',
      }),
    )
    .default(50),
  model_type: z.optional(
    z
      .enum([
        '1_5-v1',
        '1_5-v1-plus',
        '1_5-v2-plus',
        'SDXL-v1',
        'SDXL-v2-plus',
        '1_5-auraface-v1',
      ])
      .register(z.globalRegistry, {
        description:
          'The model type to use. 1_5 is the default and is recommended for most use cases.',
      }),
  ),
  face_images_data_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            URL to zip archive with images of faces. The images embedding will be averaged to\n            create a more accurate face id.\n        ',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * OmniZeroOutput
 */
export const zSchemaOmniZeroOutput = z.object({
  image: zSchemaImage,
})

/**
 * OmniZeroInput
 */
export const zSchemaOmniZeroInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Prompt to guide the image generation.',
  }),
  identity_image_url: z.string().register(z.globalRegistry, {
    description: 'Identity image url.',
  }),
  identity_strength: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'Identity strength.',
      }),
    )
    .default(1),
  number_of_images: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Number of images.',
      }),
    )
    .default(1),
  guidance_scale: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'Guidance scale.',
      }),
    )
    .default(5),
  image_strength: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'Image strength.',
      }),
    )
    .default(0.75),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to guide the image generation.',
      }),
    )
    .default(''),
  composition_image_url: z.string().register(z.globalRegistry, {
    description: 'Composition image url.',
  }),
  depth_strength: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'Depth strength.',
      }),
    )
    .default(0.5),
  composition_strength: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'Composition strength.',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Input image url.',
  }),
  style_image_url: z.string().register(z.globalRegistry, {
    description: 'Style image url.',
  }),
  face_strength: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'Face strength.',
      }),
    )
    .default(1),
  style_strength: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'Style strength.',
      }),
    )
    .default(1),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Seed.',
      }),
    )
    .default(42),
})

/**
 * CCSROutput
 */
export const zSchemaCcsrOutput = z.object({
  image: zSchemaImage,
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for the generation.',
  }),
})

/**
 * CCSRInput
 */
export const zSchemaCcsrInput = z.object({
  color_fix_type: z.optional(
    z.enum(['none', 'wavelet', 'adain']).register(z.globalRegistry, {
      description: 'Type of color correction for samples.',
    }),
  ),
  tile_diffusion_size: z
    .optional(
      z.int().gte(256).lte(2048).register(z.globalRegistry, {
        description: 'Size of patch.',
      }),
    )
    .default(1024),
  tile_vae_decoder_size: z
    .optional(
      z.int().gte(64).lte(2048).register(z.globalRegistry, {
        description: 'Size of VAE patch.',
      }),
    )
    .default(226),
  tile_vae_encoder_size: z
    .optional(
      z.int().gte(128).lte(2048).register(z.globalRegistry, {
        description: 'Size of latent image',
      }),
    )
    .default(1024),
  t_min: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The starting point of uniform sampling strategy.',
      }),
    )
    .default(0.3333),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL or data URI of the image to upscale.',
  }),
  tile_diffusion_stride: z
    .optional(
      z.int().gte(128).lte(1024).register(z.globalRegistry, {
        description: 'Stride of sliding patch.',
      }),
    )
    .default(512),
  tile_vae: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If specified, a patch-based sampling strategy will be used for VAE decoding.',
      }),
    )
    .default(false),
  scale: z
    .optional(
      z.number().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'The scale of the output image. The higher the scale, the bigger the output image will be.',
      }),
    )
    .default(2),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Seed for reproducibility. Different seeds will make slightly different results.',
    }),
  ),
  t_max: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The ending point of uniform sampling strategy.',
      }),
    )
    .default(0.6667),
  steps: z
    .optional(
      z.int().gte(10).lte(100).register(z.globalRegistry, {
        description:
          'The number of steps to run the model for. The higher the number the better the quality and longer it will take to generate.',
      }),
    )
    .default(50),
  tile_diffusion: z.optional(
    z.enum(['none', 'mix', 'gaussian']).register(z.globalRegistry, {
      description:
        'If specified, a patch-based sampling strategy will be used for sampling.',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaSd15DepthControlnetOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageControlNetInput
 */
export const zSchemaSd15DepthControlnetInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
      z.null(),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description: 'The list of LoRA weights to use.',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(7.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  controlnet_conditioning_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The scale of the controlnet conditioning.',
      }),
    )
    .default(0.5),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  control_image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the control image.',
  }),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(70).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(35),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  enable_deep_cache: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, DeepCache will be enabled. TBD\n        ',
      }),
    )
    .default(false),
})

/**
 * DWPoseOutput
 */
export const zSchemaDwposeOutput = z.object({
  image: zSchemaImage,
})

/**
 * DWPoseInput
 */
export const zSchemaDwposeInput = z.object({
  draw_mode: z.optional(
    z
      .enum([
        'full-pose',
        'body-pose',
        'face-pose',
        'hand-pose',
        'face-hand-mask',
        'face-mask',
        'hand-mask',
      ])
      .register(z.globalRegistry, {
        description:
          "Mode of drawing the pose on the image. Options are: 'full-pose', 'body-pose', 'face-pose', 'hand-pose', 'face-hand-mask', 'face-mask', 'hand-mask'.",
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be processed',
  }),
})

/**
 * SD3Output
 */
export const zSchemaStableDiffusionV3MediumImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  num_images: z.int().register(z.globalRegistry, {
    description: 'The number of images generated.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * ImageToImageInput
 */
export const zSchemaStableDiffusionV3MediumImageToImageInput = z.object({
  prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, prompt will be upsampled with more details.',
      }),
    )
    .default(false),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
      z.null(),
    ]),
  ),
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The image URL to generate an image from.',
  }),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description: 'The strength of the image-to-image transformation.',
      }),
    )
    .default(0.9),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to generate an image from.',
      }),
    )
    .default(''),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Region
 */
export const zSchemaRegion = z.object({
  y1: z.int().gte(0).lte(999).register(z.globalRegistry, {
    description: 'Y-coordinate of the top-left corner',
  }),
  x2: z.int().gte(0).lte(999).register(z.globalRegistry, {
    description: 'X-coordinate of the bottom-right corner',
  }),
  x1: z.int().gte(0).lte(999).register(z.globalRegistry, {
    description: 'X-coordinate of the top-left corner',
  }),
  y2: z.int().gte(0).lte(999).register(z.globalRegistry, {
    description: 'Y-coordinate of the bottom-right corner',
  }),
})

/**
 * Polygon
 */
export const zSchemaPolygon = z.object({
  points: z.array(z.record(z.string(), z.number())).register(z.globalRegistry, {
    description: 'List of points',
  }),
  label: z.string().register(z.globalRegistry, {
    description: 'Label of the polygon',
  }),
})

/**
 * PolygonOutput
 */
export const zSchemaPolygonOutput = z.object({
  polygons: z.array(zSchemaPolygon).register(z.globalRegistry, {
    description: 'List of polygons',
  }),
})

/**
 * PolygonOutputWithLabels
 */
export const zSchemaFlorence2LargeRegionToSegmentationOutput = z.object({
  image: z.optional(zSchemaImage),
  results: zSchemaPolygonOutput,
})

/**
 * ImageWithUserCoordinatesInput
 */
export const zSchemaFlorence2LargeRegionToSegmentationInput = z.object({
  region: zSchemaRegion,
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to be processed.',
  }),
})

/**
 * OCRBoundingBoxSingle
 */
export const zSchemaOcrBoundingBoxSingle = z.object({
  y: z.number().register(z.globalRegistry, {
    description: 'Y-coordinate of the top-left corner',
  }),
  label: z.string().register(z.globalRegistry, {
    description: 'Label of the bounding box',
  }),
  h: z.number().register(z.globalRegistry, {
    description: 'Height of the bounding box',
  }),
  w: z.number().register(z.globalRegistry, {
    description: 'Width of the bounding box',
  }),
  x: z.number().register(z.globalRegistry, {
    description: 'X-coordinate of the top-left corner',
  }),
})

/**
 * OCRBoundingBox
 */
export const zSchemaOcrBoundingBox = z.object({
  quad_boxes: z.array(zSchemaOcrBoundingBoxSingle).register(z.globalRegistry, {
    description: 'List of quadrilateral boxes',
  }),
})

/**
 * OCRBoundingBoxOutputWithLabels
 */
export const zSchemaFlorence2LargeOcrWithRegionOutput = z.object({
  image: z.optional(zSchemaImage),
  results: zSchemaOcrBoundingBox,
})

/**
 * ImageInput
 */
export const zSchemaFlorence2LargeOcrWithRegionInput = z.object({
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to be processed.',
  }),
})

/**
 * BoundingBox
 */
export const zSchemaBoundingBox = z.object({
  y: z.number().register(z.globalRegistry, {
    description: 'Y-coordinate of the top-left corner',
  }),
  label: z.string().register(z.globalRegistry, {
    description: 'Label of the bounding box',
  }),
  h: z.number().register(z.globalRegistry, {
    description: 'Height of the bounding box',
  }),
  w: z.number().register(z.globalRegistry, {
    description: 'Width of the bounding box',
  }),
  x: z.number().register(z.globalRegistry, {
    description: 'X-coordinate of the top-left corner',
  }),
})

/**
 * BoundingBoxes
 */
export const zSchemaBoundingBoxes = z.object({
  bboxes: z.array(zSchemaBoundingBox).register(z.globalRegistry, {
    description: 'List of bounding boxes',
  }),
})

/**
 * BoundingBoxOutputWithLabels
 */
export const zSchemaFlorence2LargeRegionProposalOutput = z.object({
  image: z.optional(zSchemaImage),
  results: zSchemaBoundingBoxes,
})

/**
 * ImageInput
 */
export const zSchemaFlorence2LargeRegionProposalInput = z.object({
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to be processed.',
  }),
})

/**
 * BoundingBoxOutputWithLabels
 */
export const zSchemaFlorence2LargeCaptionToPhraseGroundingOutput = z.object({
  image: z.optional(zSchemaImage),
  results: zSchemaBoundingBoxes,
})

/**
 * ImageWithTextInput
 */
export const zSchemaFlorence2LargeCaptionToPhraseGroundingInput = z.object({
  text_input: z.string().register(z.globalRegistry, {
    description: 'Text input for the task',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to be processed.',
  }),
})

/**
 * BoundingBoxOutputWithLabels
 */
export const zSchemaFlorence2LargeOpenVocabularyDetectionOutput = z.object({
  image: z.optional(zSchemaImage),
  results: zSchemaBoundingBoxes,
})

/**
 * ImageWithTextInput
 */
export const zSchemaFlorence2LargeOpenVocabularyDetectionInput = z.object({
  text_input: z.string().register(z.globalRegistry, {
    description: 'Text input for the task',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to be processed.',
  }),
})

/**
 * BoundingBoxOutputWithLabels
 */
export const zSchemaFlorence2LargeObjectDetectionOutput = z.object({
  image: z.optional(zSchemaImage),
  results: zSchemaBoundingBoxes,
})

/**
 * ImageInput
 */
export const zSchemaFlorence2LargeObjectDetectionInput = z.object({
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to be processed.',
  }),
})

/**
 * PolygonOutputWithLabels
 */
export const zSchemaFlorence2LargeReferringExpressionSegmentationOutput =
  z.object({
    image: z.optional(zSchemaImage),
    results: zSchemaPolygonOutput,
  })

/**
 * ImageWithTextInput
 */
export const zSchemaFlorence2LargeReferringExpressionSegmentationInput =
  z.object({
    text_input: z.string().register(z.globalRegistry, {
      description: 'Text input for the task',
    }),
    image_url: z.string().register(z.globalRegistry, {
      description: 'The URL of the image to be processed.',
    }),
  })

/**
 * BoundingBoxOutputWithLabels
 */
export const zSchemaFlorence2LargeDenseRegionCaptionOutput = z.object({
  image: z.optional(zSchemaImage),
  results: zSchemaBoundingBoxes,
})

/**
 * ImageInput
 */
export const zSchemaFlorence2LargeDenseRegionCaptionInput = z.object({
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to be processed.',
  }),
})

/**
 * Era3DOutput
 */
export const zSchemaEra3dOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Images with background removed',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for random number generation',
  }),
  normal_images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Normal images with background removed',
  }),
})

/**
 * Era3DInput
 */
export const zSchemaEra3dInput = z.object({
  cfg: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(4),
  background_removal: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Background removal',
      }),
    )
    .default(true),
  steps: z
    .optional(
      z.int().gte(1).lte(200).register(z.globalRegistry, {
        description: 'Number of steps to run the model for',
      }),
    )
    .default(40),
  crop_size: z
    .optional(
      z.int().gte(256).lte(512).register(z.globalRegistry, {
        description: 'Size of the image to crop to',
      }),
    )
    .default(400),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Seed for random number generation',
      }),
    )
    .default(-1),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to remove background from',
  }),
})

/**
 * Output
 */
export const zSchemaSdxlControlnetUnionImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * ImageToImageControlNetUnionInput
 */
export const zSchemaSdxlControlnetUnionImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  depth_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to preprocess the depth image.',
      }),
    )
    .default(true),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
      z.null(),
    ]),
  ),
  normal_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL of the control image.',
    }),
  ),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description: 'The list of embeddings to use.',
      }),
    )
    .default([]),
  teed_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL of the control image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description: 'The list of LoRA weights to use.',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(7.5),
  canny_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL of the control image.',
    }),
  ),
  segmentation_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to preprocess the segmentation image.',
      }),
    )
    .default(true),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the image to use as a starting point for the generation.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  segmentation_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL of the control image.',
    }),
  ),
  openpose_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL of the control image.',
    }),
  ),
  canny_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to preprocess the canny image.',
      }),
    )
    .default(true),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  depth_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL of the control image.',
    }),
  ),
  normal_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to preprocess the normal image.',
      }),
    )
    .default(true),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  preserve_aspect_ratio: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n        If set to true, the aspect ratio of the generated image will be preserved even\n        if the image size is too large. However, if the image is not a multiple of 32\n        in width or height, it will be resized to the nearest multiple of 32. By default,\n        this snapping to the nearest multiple of 32 will not preserve the aspect ratio.\n        Set crop_output to True, to crop the output to the proper aspect ratio\n        after generating.\n        ',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  crop_output: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n        If set to true, the output cropped to the proper aspect ratio after generating.\n        ',
      }),
    )
    .default(false),
  teed_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to preprocess the teed image.',
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  controlnet_conditioning_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The scale of the controlnet conditioning.',
      }),
    )
    .default(0.5),
  strength: z
    .optional(
      z.number().gte(0.05).lte(1).register(z.globalRegistry, {
        description:
          'determines how much the generated image resembles the initial image',
      }),
    )
    .default(0.95),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  openpose_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to preprocess the openpose image.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(70).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(35),
})

/**
 * Output
 */
export const zSchemaSdxlControlnetUnionInpaintingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * InpaintingControlNetUnionInput
 */
export const zSchemaSdxlControlnetUnionInpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  depth_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to preprocess the depth image.',
      }),
    )
    .default(true),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
      z.null(),
    ]),
  ),
  normal_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL of the control image.',
    }),
  ),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description: 'The list of embeddings to use.',
      }),
    )
    .default([]),
  teed_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL of the control image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description: 'The list of LoRA weights to use.',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(7.5),
  canny_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL of the control image.',
    }),
  ),
  segmentation_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to preprocess the segmentation image.',
      }),
    )
    .default(true),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the image to use as a starting point for the generation.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  mask_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the mask to use for inpainting.',
  }),
  segmentation_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL of the control image.',
    }),
  ),
  openpose_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL of the control image.',
    }),
  ),
  canny_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to preprocess the canny image.',
      }),
    )
    .default(true),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  depth_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL of the control image.',
    }),
  ),
  normal_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to preprocess the normal image.',
      }),
    )
    .default(true),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  teed_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to preprocess the teed image.',
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  controlnet_conditioning_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The scale of the controlnet conditioning.',
      }),
    )
    .default(0.5),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'determines how much the generated image resembles the initial image',
      }),
    )
    .default(0.95),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  openpose_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to preprocess the openpose image.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(70).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(35),
})

/**
 * Output
 */
export const zSchemaFluxLoraImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * ImageToImageInput
 */
export const zSchemaFluxLoraImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'The number of images to generate. This is always set to 1 for streaming output.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use for inpainting. or img2img',
  }),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.',
      }),
    )
    .default(0.85),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaFluxGeneralDifferentialDiffusionOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * ControlNetUnionInput
 */
export const zSchemaControlNetUnionInput = z.object({
  conditioning_scale: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description:
          '\n            The scale of the control net weight. This is used to scale the control net weight\n            before merging it with the base model.\n        ',
      }),
    )
    .default(1),
  mask_threshold: z
    .optional(
      z.number().gte(0.01).lte(0.99).register(z.globalRegistry, {
        description: 'Threshold for mask.',
      }),
    )
    .default(0.5),
  end_percentage: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The percentage of the image to end applying the controlnet in terms of the total timesteps.\n        ',
      }),
    )
    .default(1),
  mask_image_url: z.optional(z.union([z.string(), z.null()])),
  control_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be used as the control image.',
  }),
  control_mode: z
    .enum(['canny', 'tile', 'depth', 'blur', 'pose', 'gray', 'low-quality'])
    .register(z.globalRegistry, {
      description:
        'Control Mode for Flux Controlnet Union. Supported values are:\n        - canny: Uses the edges for guided generation.\n        - tile: Uses the tiles for guided generation.\n        - depth: Utilizes a grayscale depth map for guided generation.\n        - blur: Adds a blur to the image.\n        - pose: Uses the pose of the image for guided generation.\n        - gray: Converts the image to grayscale.\n        - low-quality: Converts the image to a low-quality image.',
    }),
  start_percentage: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The percentage of the image to start applying the controlnet in terms of the total timesteps.\n        ',
      }),
    )
    .default(0),
})

/**
 * ControlNetUnion
 */
export const zSchemaControlNetUnion = z.object({
  controls: z.array(zSchemaControlNetUnionInput).register(z.globalRegistry, {
    description: 'The control images and modes to use for the control net.',
  }),
  path: z.string().register(z.globalRegistry, {
    description: 'URL or the path to the control net weights.',
  }),
  variant: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The optional variant if a Hugging Face repo key is used.',
    }),
  ),
  config_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'optional URL to the controlnet config.json file.',
    }),
  ),
})

/**
 * ImageFillInput
 */
export const zSchemaImageFillInput = z.object({
  fill_image_url: z.optional(z.union([z.string(), z.array(z.string())])),
})

/**
 * EasyControlWeight
 */
export const zSchemaEasyControlWeight = z.object({
  scale: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description: 'Scale for the control method.',
      }),
    )
    .default(1),
  image_control_type: z
    .enum(['subject', 'spatial'])
    .register(z.globalRegistry, {
      description:
        'Control type of the image. Must be one of `spatial` or `subject`.',
    }),
  control_method_url: z.string().register(z.globalRegistry, {
    description:
      'URL to safetensor weights of control method to be applied. Can also be one of `canny`, `depth`, `hedsketch`, `inpainting`, `pose`, `seg`, `subject`, `ghibli` ',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of an image to use as a control',
  }),
})

/**
 * ControlLoraWeight
 */
export const zSchemaControlLoraWeight = z.object({
  path: z.string().register(z.globalRegistry, {
    description: 'URL or the path to the LoRA weights.',
  }),
  scale: z.optional(
    z.union([z.record(z.string(), z.unknown()), z.number().gte(-4).lte(4)]),
  ),
  control_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be used as the control image.',
  }),
  preprocess: z.optional(
    z.enum(['canny', 'depth', 'None']).register(z.globalRegistry, {
      description: 'Type of preprocessing to apply to the input image.',
    }),
  ),
})

/**
 * DifferentialDiffusionInput
 */
export const zSchemaFluxGeneralDifferentialDiffusionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  nag_end: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          '\n            The proportion of steps to apply NAG. After the specified proportion\n            of steps has been iterated, the remaining steps will use original\n            attention processors in FLUX.\n        ',
      }),
    )
    .default(0.25),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  control_loras: z
    .optional(
      z.array(zSchemaControlLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation which use a control image. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  scheduler: z.optional(
    z.enum(['euler', 'dpmpp_2m']).register(z.globalRegistry, {
      description: 'Scheduler for the denoising process.',
    }),
  ),
  easycontrols: z
    .optional(
      z.array(zSchemaEasyControlWeight).register(z.globalRegistry, {
        description:
          '\n        EasyControl Inputs to use for image generation.\n        ',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  real_cfg_scale: z
    .optional(
      z.number().gte(0).lte(5).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  use_cfg_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            Uses CFG-zero init sampling as in https://arxiv.org/abs/2503.18886.\n        ',
      }),
    )
    .default(false),
  fill_image: z.optional(zSchemaImageFillInput),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  sigma_schedule: z.optional(
    z.enum(['sgm_uniform']).register(z.globalRegistry, {
      description: 'Sigmas schedule for the denoising process.',
    }),
  ),
  reference_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The percentage of the total timesteps when the reference guidance is to be ended.\n        ',
      }),
    )
    .default(1),
  reference_strength: z
    .optional(
      z.number().gte(-3).lte(3).register(z.globalRegistry, {
        description:
          'Strength of reference_only generation. Only used if a reference image is provided.',
      }),
    )
    .default(0.65),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use as initial image.',
  }),
  nag_scale: z
    .optional(
      z.number().lte(10).register(z.globalRegistry, {
        description:
          '\n            The scale for NAG. Higher values will result in a image that is more distant\n            to the negative prompt.\n        ',
      }),
    )
    .default(3),
  reference_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of Image for Reference-Only',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  controlnet_unions: z
    .optional(
      z.array(zSchemaControlNetUnion).register(z.globalRegistry, {
        description:
          '\n            The controlnet unions to use for the image generation. Only one controlnet is supported at the moment.\n        ',
      }),
    )
    .default([]),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            Negative prompt to steer the image generation away from unwanted features.\n            By default, we will be using NAG for processing the negative prompt.\n        ',
      }),
    )
    .default(''),
  nag_tau: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          '\n            The tau for NAG. Controls the normalization of the hidden state.\n            Higher values will result in a less aggressive normalization,\n            but may also lead to unexpected changes with respect to the original image.\n            Not recommended to change this value.\n        ',
      }),
    )
    .default(2.5),
  change_map_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of change map.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'The number of images to generate. This is always set to 1 for streaming output.',
      }),
    )
    .default(1),
  use_beta_schedule: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Specifies whether beta sigmas ought to be used.',
      }),
    )
    .default(false),
  ip_adapters: z
    .optional(
      z.array(zSchemaIpAdapter).register(z.globalRegistry, {
        description:
          '\n        IP-Adapter to use for image generation.\n        ',
      }),
    )
    .default([]),
  base_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: 'Base shift for the scheduled timesteps',
      }),
    )
    .default(0.5),
  nag_alpha: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          '\n            The alpha value for NAG. This value is used as a final weighting\n            factor for steering the normalized guidance (positive and negative prompts)\n            in the direction of the positive prompt. Higher values will result in less\n            steering on the normalized guidance where lower values will result in\n            considering the positive prompt guidance more.\n        ',
      }),
    )
    .default(0.25),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength to use for differential diffusion. 1.0 is completely remakes the image while 0.0 preserves the original.',
      }),
    )
    .default(0.85),
  max_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: 'Max shift for the scheduled timesteps',
      }),
    )
    .default(1.15),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  controlnets: z
    .optional(
      z.array(zSchemaControlNet).register(z.globalRegistry, {
        description:
          '\n            The controlnets to use for the image generation. Only one controlnet is supported at the moment.\n        ',
      }),
    )
    .default([]),
  reference_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The percentage of the total timesteps when the reference guidance is to bestarted.\n        ',
      }),
    )
    .default(0),
  use_real_cfg: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            Uses classical CFG as in SD1.5, SDXL, etc. Increases generation times and price when set to be true.\n            If using XLabs IP-Adapter v1, this will be turned on!.\n        ',
      }),
    )
    .default(false),
})

/**
 * Output
 */
export const zSchemaFluxGeneralInpaintingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * InpaintInput
 */
export const zSchemaFluxGeneralInpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  nag_end: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          '\n            The proportion of steps to apply NAG. After the specified proportion\n            of steps has been iterated, the remaining steps will use original\n            attention processors in FLUX.\n        ',
      }),
    )
    .default(0.25),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  control_loras: z
    .optional(
      z.array(zSchemaControlLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation which use a control image. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  scheduler: z.optional(
    z.enum(['euler', 'dpmpp_2m']).register(z.globalRegistry, {
      description: 'Scheduler for the denoising process.',
    }),
  ),
  easycontrols: z
    .optional(
      z.array(zSchemaEasyControlWeight).register(z.globalRegistry, {
        description:
          '\n        EasyControl Inputs to use for image generation.\n        ',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  real_cfg_scale: z
    .optional(
      z.number().gte(0).lte(5).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  use_cfg_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            Uses CFG-zero init sampling as in https://arxiv.org/abs/2503.18886.\n        ',
      }),
    )
    .default(false),
  fill_image: z.optional(zSchemaImageFillInput),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  sigma_schedule: z.optional(
    z.enum(['sgm_uniform']).register(z.globalRegistry, {
      description: 'Sigmas schedule for the denoising process.',
    }),
  ),
  reference_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The percentage of the total timesteps when the reference guidance is to be ended.\n        ',
      }),
    )
    .default(1),
  reference_strength: z
    .optional(
      z.number().gte(-3).lte(3).register(z.globalRegistry, {
        description:
          'Strength of reference_only generation. Only used if a reference image is provided.',
      }),
    )
    .default(0.65),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  mask_url: z.string().register(z.globalRegistry, {
    description: '\n            The mask to area to Inpaint in.\n        ',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use for inpainting. or img2img',
  }),
  nag_scale: z
    .optional(
      z.number().lte(10).register(z.globalRegistry, {
        description:
          '\n            The scale for NAG. Higher values will result in a image that is more distant\n            to the negative prompt.\n        ',
      }),
    )
    .default(3),
  reference_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of Image for Reference-Only',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  controlnet_unions: z
    .optional(
      z.array(zSchemaControlNetUnion).register(z.globalRegistry, {
        description:
          '\n            The controlnet unions to use for the image generation. Only one controlnet is supported at the moment.\n        ',
      }),
    )
    .default([]),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            Negative prompt to steer the image generation away from unwanted features.\n            By default, we will be using NAG for processing the negative prompt.\n        ',
      }),
    )
    .default(''),
  nag_tau: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          '\n            The tau for NAG. Controls the normalization of the hidden state.\n            Higher values will result in a less aggressive normalization,\n            but may also lead to unexpected changes with respect to the original image.\n            Not recommended to change this value.\n        ',
      }),
    )
    .default(2.5),
  num_images: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'The number of images to generate. This is always set to 1 for streaming output.',
      }),
    )
    .default(1),
  use_beta_schedule: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Specifies whether beta sigmas ought to be used.',
      }),
    )
    .default(false),
  ip_adapters: z
    .optional(
      z.array(zSchemaIpAdapter).register(z.globalRegistry, {
        description:
          '\n        IP-Adapter to use for image generation.\n        ',
      }),
    )
    .default([]),
  base_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: 'Base shift for the scheduled timesteps',
      }),
    )
    .default(0.5),
  nag_alpha: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          '\n            The alpha value for NAG. This value is used as a final weighting\n            factor for steering the normalized guidance (positive and negative prompts)\n            in the direction of the positive prompt. Higher values will result in less\n            steering on the normalized guidance where lower values will result in\n            considering the positive prompt guidance more.\n        ',
      }),
    )
    .default(0.25),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.',
      }),
    )
    .default(0.85),
  max_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: 'Max shift for the scheduled timesteps',
      }),
    )
    .default(1.15),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  controlnets: z
    .optional(
      z.array(zSchemaControlNet).register(z.globalRegistry, {
        description:
          '\n            The controlnets to use for the image generation. Only one controlnet is supported at the moment.\n        ',
      }),
    )
    .default([]),
  reference_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The percentage of the total timesteps when the reference guidance is to bestarted.\n        ',
      }),
    )
    .default(0),
  use_real_cfg: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            Uses classical CFG as in SD1.5, SDXL, etc. Increases generation times and price when set to be true.\n            If using XLabs IP-Adapter v1, this will be turned on!.\n        ',
      }),
    )
    .default(false),
})

/**
 * Output
 */
export const zSchemaFluxGeneralImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * ImageToImageInput
 */
export const zSchemaFluxGeneralImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  nag_end: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          '\n            The proportion of steps to apply NAG. After the specified proportion\n            of steps has been iterated, the remaining steps will use original\n            attention processors in FLUX.\n        ',
      }),
    )
    .default(0.25),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  control_loras: z
    .optional(
      z.array(zSchemaControlLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation which use a control image. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  scheduler: z.optional(
    z.enum(['euler', 'dpmpp_2m']).register(z.globalRegistry, {
      description: 'Scheduler for the denoising process.',
    }),
  ),
  easycontrols: z
    .optional(
      z.array(zSchemaEasyControlWeight).register(z.globalRegistry, {
        description:
          '\n        EasyControl Inputs to use for image generation.\n        ',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  real_cfg_scale: z
    .optional(
      z.number().gte(0).lte(5).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  use_cfg_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            Uses CFG-zero init sampling as in https://arxiv.org/abs/2503.18886.\n        ',
      }),
    )
    .default(false),
  fill_image: z.optional(zSchemaImageFillInput),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  sigma_schedule: z.optional(
    z.enum(['sgm_uniform']).register(z.globalRegistry, {
      description: 'Sigmas schedule for the denoising process.',
    }),
  ),
  reference_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The percentage of the total timesteps when the reference guidance is to be ended.\n        ',
      }),
    )
    .default(1),
  reference_strength: z
    .optional(
      z.number().gte(-3).lte(3).register(z.globalRegistry, {
        description:
          'Strength of reference_only generation. Only used if a reference image is provided.',
      }),
    )
    .default(0.65),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use for inpainting. or img2img',
  }),
  nag_scale: z
    .optional(
      z.number().lte(10).register(z.globalRegistry, {
        description:
          '\n            The scale for NAG. Higher values will result in a image that is more distant\n            to the negative prompt.\n        ',
      }),
    )
    .default(3),
  reference_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of Image for Reference-Only',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  controlnet_unions: z
    .optional(
      z.array(zSchemaControlNetUnion).register(z.globalRegistry, {
        description:
          '\n            The controlnet unions to use for the image generation. Only one controlnet is supported at the moment.\n        ',
      }),
    )
    .default([]),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            Negative prompt to steer the image generation away from unwanted features.\n            By default, we will be using NAG for processing the negative prompt.\n        ',
      }),
    )
    .default(''),
  nag_tau: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          '\n            The tau for NAG. Controls the normalization of the hidden state.\n            Higher values will result in a less aggressive normalization,\n            but may also lead to unexpected changes with respect to the original image.\n            Not recommended to change this value.\n        ',
      }),
    )
    .default(2.5),
  num_images: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'The number of images to generate. This is always set to 1 for streaming output.',
      }),
    )
    .default(1),
  use_beta_schedule: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Specifies whether beta sigmas ought to be used.',
      }),
    )
    .default(false),
  ip_adapters: z
    .optional(
      z.array(zSchemaIpAdapter).register(z.globalRegistry, {
        description:
          '\n        IP-Adapter to use for image generation.\n        ',
      }),
    )
    .default([]),
  base_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: 'Base shift for the scheduled timesteps',
      }),
    )
    .default(0.5),
  nag_alpha: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          '\n            The alpha value for NAG. This value is used as a final weighting\n            factor for steering the normalized guidance (positive and negative prompts)\n            in the direction of the positive prompt. Higher values will result in less\n            steering on the normalized guidance where lower values will result in\n            considering the positive prompt guidance more.\n        ',
      }),
    )
    .default(0.25),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.',
      }),
    )
    .default(0.85),
  max_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: 'Max shift for the scheduled timesteps',
      }),
    )
    .default(1.15),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  controlnets: z
    .optional(
      z.array(zSchemaControlNet).register(z.globalRegistry, {
        description:
          '\n            The controlnets to use for the image generation. Only one controlnet is supported at the moment.\n        ',
      }),
    )
    .default([]),
  reference_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The percentage of the total timesteps when the reference guidance is to bestarted.\n        ',
      }),
    )
    .default(0),
  use_real_cfg: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            Uses classical CFG as in SD1.5, SDXL, etc. Increases generation times and price when set to be true.\n            If using XLabs IP-Adapter v1, this will be turned on!.\n        ',
      }),
    )
    .default(false),
})

/**
 * SAM2ImageOutput
 */
export const zSchemaSam2ImageOutput = z.object({
  image: zSchemaImage,
})

/**
 * BoxPrompt
 */
export const zSchemaBoxPrompt = z.object({
  y_min: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Y Min Coordinate of the box',
      }),
    )
    .default(0),
  frame_index: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'The frame index to interact with.',
      }),
    )
    .default(0),
  x_max: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'X Max Coordinate of the prompt',
      }),
    )
    .default(0),
  x_min: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'X Min Coordinate of the box',
      }),
    )
    .default(0),
  y_max: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Y Max Coordinate of the prompt',
      }),
    )
    .default(0),
})

/**
 * PointPrompt
 */
export const zSchemaPointPrompt = z.object({
  y: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Y Coordinate of the prompt',
      }),
    )
    .default(350),
  label: z.optional(
    z.union([z.literal(0), z.literal(1)]).register(z.globalRegistry, {
      description: 'Label of the prompt. 1 for foreground, 0 for background',
    }),
  ),
  frame_index: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'The frame index to interact with.',
      }),
    )
    .default(0),
  x: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'X Coordinate of the prompt',
      }),
    )
    .default(305),
})

/**
 * SAM2ImageInput
 */
export const zSchemaSam2ImageInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  prompts: z
    .optional(
      z.array(zSchemaPointPrompt).register(z.globalRegistry, {
        description: 'List of prompts to segment the image',
      }),
    )
    .default([]),
  box_prompts: z
    .optional(
      z.array(zSchemaBoxPrompt).register(z.globalRegistry, {
        description: 'Coordinates for boxes',
      }),
    )
    .default([]),
  apply_mask: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Apply the mask on the image.',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be segmented',
  }),
})

/**
 * PiDiOutput
 */
export const zSchemaImagePreprocessorsPidiOutput = z.object({
  image: zSchemaImage,
})

/**
 * PiDiInput
 */
export const zSchemaImagePreprocessorsPidiInput = z.object({
  safe: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to use the safe version of the Pidi detector',
      }),
    )
    .default(false),
  apply_filter: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to apply the filter to the image.',
      }),
    )
    .default(false),
  scribble: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to use the scribble version of the Pidi detector',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to process',
  }),
})

/**
 * ZoeOutput
 */
export const zSchemaImagePreprocessorsZoeOutput = z.object({
  image: zSchemaImage,
})

/**
 * ZoeInput
 */
export const zSchemaImagePreprocessorsZoeInput = z.object({
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to process',
  }),
})

/**
 * LineartOutput
 */
export const zSchemaImagePreprocessorsLineartOutput = z.object({
  image: zSchemaImage,
})

/**
 * LineartInput
 */
export const zSchemaImagePreprocessorsLineartInput = z.object({
  coarse: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to use the coarse model',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to process',
  }),
})

/**
 * TeeDOutput
 */
export const zSchemaImagePreprocessorsTeedOutput = z.object({
  image: zSchemaImage,
})

/**
 * TeeDInput
 */
export const zSchemaImagePreprocessorsTeedInput = z.object({
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to process',
  }),
})

/**
 * MiDaSOutput
 */
export const zSchemaImagePreprocessorsMidasOutput = z.object({
  normal_map: zSchemaImage,
  depth_map: zSchemaImage,
})

/**
 * MiDaSInput
 */
export const zSchemaImagePreprocessorsMidasInput = z.object({
  a: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'A parameter for the MiDaS detector',
      }),
    )
    .default(6.283185307179586),
  background_threshold: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'Background threshold for the MiDaS detector',
      }),
    )
    .default(0.1),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to process',
  }),
})

/**
 * SamOutput
 */
export const zSchemaImagePreprocessorsSamOutput = z.object({
  image: zSchemaImage,
})

/**
 * SamInput
 */
export const zSchemaImagePreprocessorsSamInput = z.object({
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to process',
  }),
})

/**
 * MLSDOutput
 */
export const zSchemaImagePreprocessorsMlsdOutput = z.object({
  image: zSchemaImage,
})

/**
 * MLSDInput
 */
export const zSchemaImagePreprocessorsMlsdInput = z.object({
  distance_threshold: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'Distance threshold for the MLSD detector',
      }),
    )
    .default(0.1),
  score_threshold: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'Score threshold for the MLSD detector',
      }),
    )
    .default(0.1),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to process',
  }),
})

/**
 * ScribbleOutput
 */
export const zSchemaImagePreprocessorsScribbleOutput = z.object({
  image: zSchemaImage,
})

/**
 * ScribbleInput
 */
export const zSchemaImagePreprocessorsScribbleInput = z.object({
  model: z.optional(
    z.enum(['HED', 'PiDi']).register(z.globalRegistry, {
      description: 'The model to use for the Scribble detector',
    }),
  ),
  safe: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to use the safe version of the Scribble detector',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to process',
  }),
})

/**
 * DepthAnythingV2Output
 */
export const zSchemaImagePreprocessorsDepthAnythingV2Output = z.object({
  image: zSchemaImage,
})

/**
 * DepthAnythingV2Input
 */
export const zSchemaImagePreprocessorsDepthAnythingV2Input = z.object({
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to process',
  }),
})

/**
 * HEDOutput
 */
export const zSchemaImagePreprocessorsHedOutput = z.object({
  image: zSchemaImage,
})

/**
 * HEDInput
 */
export const zSchemaImagePreprocessorsHedInput = z.object({
  safe: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to use the safe version of the HED detector',
      }),
    )
    .default(false),
  scribble: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to use the scribble version of the HED detector',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to process',
  }),
})

/**
 * Output
 */
export const zSchemaFluxGeneralRfInversionOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * RFInversionInput
 */
export const zSchemaFluxGeneralRfInversionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image with',
  }),
  nag_end: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          '\n            The proportion of steps to apply NAG. After the specified proportion\n            of steps has been iterated, the remaining steps will use original\n            attention processors in FLUX.\n        ',
      }),
    )
    .default(0.25),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
      z.null(),
    ]),
  ),
  control_loras: z
    .optional(
      z.array(zSchemaControlLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation which use a control image. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  controller_guidance_reverse: z
    .optional(
      z.number().gte(0.01).lte(3).register(z.globalRegistry, {
        description:
          'The controller guidance (eta) used in the denoising process.Using values closer to 1 will result in an image closer to input.',
      }),
    )
    .default(0.75),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  reverse_guidance_start: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Timestep to start guidance during reverse process.',
      }),
    )
    .default(0),
  easycontrols: z
    .optional(
      z.array(zSchemaEasyControlWeight).register(z.globalRegistry, {
        description:
          '\n        EasyControl Inputs to use for image generation.\n        ',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  scheduler: z.optional(
    z.enum(['euler', 'dpmpp_2m']).register(z.globalRegistry, {
      description: 'Scheduler for the denoising process.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  use_cfg_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            Uses CFG-zero init sampling as in https://arxiv.org/abs/2503.18886.\n        ',
      }),
    )
    .default(false),
  reference_strength: z
    .optional(
      z.number().gte(-3).lte(3).register(z.globalRegistry, {
        description:
          'Strength of reference_only generation. Only used if a reference image is provided.',
      }),
    )
    .default(0.65),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  sigma_schedule: z.optional(
    z.enum(['sgm_uniform']).register(z.globalRegistry, {
      description: 'Sigmas schedule for the denoising process.',
    }),
  ),
  reference_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The percentage of the total timesteps when the reference guidance is to be ended.\n        ',
      }),
    )
    .default(1),
  controller_guidance_forward: z
    .optional(
      z.number().gte(0.01).lte(3).register(z.globalRegistry, {
        description:
          'The controller guidance (gamma) used in the creation of structured noise.',
      }),
    )
    .default(0.6),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to be edited',
  }),
  fill_image: z.optional(zSchemaImageFillInput),
  nag_scale: z
    .optional(
      z.number().lte(10).register(z.globalRegistry, {
        description:
          '\n            The scale for NAG. Higher values will result in a image that is more distant\n            to the negative prompt.\n        ',
      }),
    )
    .default(3),
  reverse_guidance_schedule: z.optional(
    z
      .enum(['constant', 'linear_increase', 'linear_decrease'])
      .register(z.globalRegistry, {
        description: 'Scheduler for applying reverse guidance.',
      }),
  ),
  reference_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of Image for Reference-Only',
    }),
  ),
  reverse_guidance_end: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Timestep to stop guidance during reverse process.',
      }),
    )
    .default(8),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  controlnet_unions: z
    .optional(
      z.array(zSchemaControlNetUnion).register(z.globalRegistry, {
        description:
          '\n            The controlnet unions to use for the image generation. Only one controlnet is supported at the moment.\n        ',
      }),
    )
    .default([]),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            Negative prompt to steer the image generation away from unwanted features.\n            By default, we will be using NAG for processing the negative prompt.\n        ',
      }),
    )
    .default(''),
  nag_tau: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          '\n            The tau for NAG. Controls the normalization of the hidden state.\n            Higher values will result in a less aggressive normalization,\n            but may also lead to unexpected changes with respect to the original image.\n            Not recommended to change this value.\n        ',
      }),
    )
    .default(2.5),
  num_images: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'The number of images to generate. This is always set to 1 for streaming output.',
      }),
    )
    .default(1),
  use_beta_schedule: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Specifies whether beta sigmas ought to be used.',
      }),
    )
    .default(false),
  nag_alpha: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          '\n            The alpha value for NAG. This value is used as a final weighting\n            factor for steering the normalized guidance (positive and negative prompts)\n            in the direction of the positive prompt. Higher values will result in less\n            steering on the normalized guidance where lower values will result in\n            considering the positive prompt guidance more.\n        ',
      }),
    )
    .default(0.25),
  base_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: 'Base shift for the scheduled timesteps',
      }),
    )
    .default(0.5),
  max_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: 'Max shift for the scheduled timesteps',
      }),
    )
    .default(1.15),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  reference_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The percentage of the total timesteps when the reference guidance is to bestarted.\n        ',
      }),
    )
    .default(0),
  controlnets: z
    .optional(
      z.array(zSchemaControlNet).register(z.globalRegistry, {
        description:
          '\n            The controlnets to use for the image generation. Only one controlnet is supported at the moment.\n        ',
      }),
    )
    .default([]),
})

/**
 * LivePortraitImageOutput
 */
export const zSchemaLivePortraitImageOutput = z.object({
  image: zSchemaImage,
})

/**
 * LivePortraitImageInput
 */
export const zSchemaLivePortraitImageInput = z.object({
  smile: z
    .optional(
      z.number().gte(-2).lte(2).register(z.globalRegistry, {
        description: 'Amount to smile',
      }),
    )
    .default(0),
  eyebrow: z
    .optional(
      z.number().gte(-30).lte(30).register(z.globalRegistry, {
        description: 'Amount to raise or lower eyebrows',
      }),
    )
    .default(0),
  rotate_roll: z
    .optional(
      z.number().gte(-45).lte(45).register(z.globalRegistry, {
        description: 'Amount to rotate the face in roll',
      }),
    )
    .default(0),
  wink: z
    .optional(
      z.number().gte(0).lte(25).register(z.globalRegistry, {
        description: 'Amount to wink',
      }),
    )
    .default(0),
  rotate_pitch: z
    .optional(
      z.number().gte(-45).lte(45).register(z.globalRegistry, {
        description: 'Amount to rotate the face in pitch',
      }),
    )
    .default(0),
  blink: z
    .optional(
      z.number().gte(-30).lte(30).register(z.globalRegistry, {
        description: 'Amount to blink the eyes',
      }),
    )
    .default(0),
  dsize: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Size of the output image.',
      }),
    )
    .default(512),
  vy_ratio: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          'Vertical offset ratio for face crop. Positive values move up, negative values move down.',
      }),
    )
    .default(-0.125),
  scale: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'Scaling factor for the face crop.',
      }),
    )
    .default(2.3),
  pupil_x: z
    .optional(
      z.number().gte(-45).lte(45).register(z.globalRegistry, {
        description: 'Amount to move pupils horizontally',
      }),
    )
    .default(0),
  flag_pasteback: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to paste-back/stitch the animated face cropping from the face-cropping space to the original image space.',
      }),
    )
    .default(true),
  eee: z
    .optional(
      z.number().gte(-40).lte(40).register(z.globalRegistry, {
        description: "Amount to shape mouth in 'eee' position",
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n        Whether to enable the safety checker. If enabled, the model will check if the input image contains a face before processing it.\n        The safety checker will process the input image\n        ',
      }),
    )
    .default(false),
  vx_ratio: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'Horizontal offset ratio for face crop.',
      }),
    )
    .default(0),
  pupil_y: z
    .optional(
      z.number().gte(-45).lte(45).register(z.globalRegistry, {
        description: 'Amount to move pupils vertically',
      }),
    )
    .default(0),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'Output format',
    }),
  ),
  rotate_yaw: z
    .optional(
      z.number().gte(-45).lte(45).register(z.globalRegistry, {
        description: 'Amount to rotate the face in yaw',
      }),
    )
    .default(0),
  flag_do_rot: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to conduct the rotation when flag_do_crop is True.',
      }),
    )
    .default(true),
  woo: z
    .optional(
      z.number().gte(-100).lte(100).register(z.globalRegistry, {
        description: "Amount to shape mouth in 'woo' position",
      }),
    )
    .default(0),
  aaa: z
    .optional(
      z.number().gte(-200).lte(200).register(z.globalRegistry, {
        description: "Amount to open mouth in 'aaa' shape",
      }),
    )
    .default(0),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be animated',
  }),
  flag_do_crop: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to crop the source portrait to the face-cropping space.',
      }),
    )
    .default(true),
  flag_lip_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to set the lip to closed state before animation. Only takes effect when flag_eye_retargeting and flag_lip_retargeting are False.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaBirefnetV2Output = z.object({
  image: zSchemaImageFile,
  mask_image: z.optional(zSchemaImageFile),
})

/**
 * InputV2
 */
export const zSchemaBirefnetV2Input = z.object({
  operating_resolution: z.optional(
    z.enum(['1024x1024', '2048x2048', '2304x2304']).register(z.globalRegistry, {
      description:
        "The resolution to operate on. The higher the resolution, the more accurate the output will be for high res input images. The '2304x2304' option is only available for the 'General Use (Dynamic)' model.",
    }),
  ),
  output_format: z.optional(
    z.enum(['webp', 'png', 'gif']).register(z.globalRegistry, {
      description: 'The format of the output image',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to remove background from',
  }),
  model: z.optional(
    z
      .enum([
        'General Use (Light)',
        'General Use (Light 2K)',
        'General Use (Heavy)',
        'Matting',
        'Portrait',
        'General Use (Dynamic)',
      ])
      .register(z.globalRegistry, {
        description:
          "\n            Model to use for background removal.\n            The 'General Use (Light)' model is the original model used in the BiRefNet repository.\n            The 'General Use (Light 2K)' model is the original model used in the BiRefNet repository but trained with 2K images.\n            The 'General Use (Heavy)' model is a slower but more accurate model.\n            The 'Matting' model is a model trained specifically for matting images.\n            The 'Portrait' model is a model trained specifically for portrait images.\n            The 'General Use (Dynamic)' model supports dynamic resolutions from 256x256 to 2304x2304.\n            The 'General Use (Light)' model is recommended for most use cases.\n\n            The corresponding models are as follows:\n            - 'General Use (Light)': BiRefNet\n            - 'General Use (Light 2K)': BiRefNet_lite-2K\n            - 'General Use (Heavy)': BiRefNet_lite\n            - 'Matting': BiRefNet-matting\n            - 'Portrait': BiRefNet-portrait\n            - 'General Use (Dynamic)': BiRefNet_dynamic\n        ",
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  output_mask: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to output the mask used to remove the background',
      }),
    )
    .default(false),
  refine_foreground: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to refine the foreground using the estimated mask',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaFluxPulidOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * FluxPulidInput
 */
export const zSchemaFluxPulidInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  id_weight: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The weight of the ID loss.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  start_step: z
    .optional(
      z.int().gte(0).lte(50).register(z.globalRegistry, {
        description: 'The number of steps to start the CFG from.',
      }),
    )
    .default(0),
  reference_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use for inpainting.',
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  max_sequence_length: z.optional(
    z.enum(['128', '256', '512']).register(z.globalRegistry, {
      description: 'The maximum sequence length for the model.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(20),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The prompt to generate an image from.',
      }),
    )
    .default(''),
  true_cfg: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: 'The weight of the CFG loss.',
      }),
    )
    .default(1),
})

/**
 * Output
 */
export const zSchemaFluxDifferentialDiffusionOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * DiffInput
 */
export const zSchemaFluxDifferentialDiffusionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use as initial image.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength to use for image-to-image. 1.0 is completely remakes the image while 0.0 preserves the original.',
      }),
    )
    .default(0.85),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  change_map_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of change map.',
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
})

/**
 * Output
 */
export const zSchemaIclightV2Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseInput
 */
export const zSchemaIclightV2Input = z.object({
  initial_latent: z.optional(
    z
      .enum(['None', 'Left', 'Right', 'Top', 'Bottom'])
      .register(z.globalRegistry, {
        description:
          '\n            Provide lighting conditions for the model\n        ',
      }),
  ),
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  background_threshold: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'Threshold for the background removal algorithm. A high threshold will produce sharper masks. Note: This parameter is currently deprecated and has no effect on the output.',
      }),
    )
    .default(0.67),
  mask_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of mask to be used for ic-light conditioning image',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(5),
  lowres_denoise: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description: 'Strength for low-resolution pass.',
      }),
    )
    .default(0.98),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative Prompt for the image',
      }),
    )
    .default(''),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  hr_downscale: z.optional(z.number().gte(0.01).lte(1)).default(0.5),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to be used for relighting',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  highres_denoise: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'Strength for high-resolution pass. Only used if enable_hr_fix is True.',
      }),
    )
    .default(0.95),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enable_hr_fix: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Use HR fix',
      }),
    )
    .default(false),
  cfg: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description:
          'The real classifier-free-guidance scale for the generation.',
      }),
    )
    .default(1),
})

/**
 * Output
 */
export const zSchemaKolorsImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * KolorsImg2ImgInput
 */
export const zSchemaKolorsImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use for image to image',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and\n            uploaded before returning the response. This will increase the latency of\n            the function but it allows you to get the image directly in the response\n            without going through the CDN.\n        ',
      }),
    )
    .default(false),
  scheduler: z.optional(
    z
      .enum([
        'EulerDiscreteScheduler',
        'EulerAncestralDiscreteScheduler',
        'DPMSolverMultistepScheduler',
        'DPMSolverMultistepScheduler_SDE_karras',
        'UniPCMultistepScheduler',
        'DEISMultistepScheduler',
      ])
      .register(z.globalRegistry, {
        description: 'The scheduler to use for the model.',
      }),
  ),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength to use for image-to-image. 1.0 is completely remakes the image while 0.0 preserves the original.',
      }),
    )
    .default(0.85),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show\n            you.\n        ',
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(150).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(50),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Seed',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small\n            details (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable safety checker.',
      }),
    )
    .default(true),
})

/**
 * Image
 */
export const zSchemaRegistryImageFastSdxlModelsImage = z.object({
  height: z.int(),
  content_type: z.optional(z.string()).default('image/jpeg'),
  url: z.string(),
  width: z.int(),
})

/**
 * Output
 */
export const zSchemaFluxProV1FillOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z
    .array(zSchemaRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: 'The generated image files info.',
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * FluxProFillInput
 */
export const zSchemaFluxProV1FillInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to fill the masked part of the image.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The image URL to generate an image from. Needs to match the dimensions of the mask.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  mask_url: z.string().register(z.globalRegistry, {
    description:
      'The mask URL to inpaint the image. Needs to match the dimensions of the input image.',
  }),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enhance the prompt for better results.',
      }),
    )
    .default(false),
})

/**
 * Output
 */
export const zSchemaFluxLoraDepthOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * DepthInput
 */
export const zSchemaFluxLoraDepthInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'The number of images to generate. This is always set to 1 for streaming output.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use for depth input',
  }),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaFluxProV11UltraReduxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z
    .array(zSchemaRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: 'The generated image files info.',
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * FluxProUltraTextToImageInputRedux
 */
export const zSchemaFluxProV11UltraReduxInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The prompt to generate an image from.',
      }),
    )
    .default(''),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z.union([
      z.enum([
        '21:9',
        '16:9',
        '4:3',
        '3:2',
        '1:1',
        '2:3',
        '3:4',
        '9:16',
        '9:21',
      ]),
      z.string(),
    ]),
  ),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enhance the prompt for better results.',
      }),
    )
    .default(false),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The image URL to generate an image from. Needs to match the dimensions of the mask.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.',
    }),
  ),
  image_prompt_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The strength of the image prompt, between 0 and 1.',
      }),
    )
    .default(0.1),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  raw: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Generate less processed, more natural-looking images.',
      }),
    )
    .default(false),
})

/**
 * Output
 */
export const zSchemaFluxDevReduxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseReduxInput
 */
export const zSchemaFluxDevReduxInput = z.object({
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate an image from.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
})

/**
 * Output
 */
export const zSchemaFluxProV11ReduxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z
    .array(zSchemaRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: 'The generated image files info.',
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * FluxProRedux
 */
export const zSchemaFluxProV11ReduxInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The prompt to generate an image from.',
      }),
    )
    .default(''),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The image URL to generate an image from. Needs to match the dimensions of the mask.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enhance the prompt for better results.',
      }),
    )
    .default(false),
})

/**
 * Output
 */
export const zSchemaFluxSchnellReduxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * SchnellReduxInput
 */
export const zSchemaFluxSchnellReduxInput = z.object({
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate an image from.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(12).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(4),
})

/**
 * Output
 */
export const zSchemaIdeogramV2RemixOutput = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for the random number generator',
  }),
})

/**
 * RemixImageInput
 */
export const zSchemaIdeogramV2RemixInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to remix the image with',
  }),
  aspect_ratio: z.optional(
    z
      .enum([
        '10:16',
        '16:10',
        '9:16',
        '16:9',
        '4:3',
        '3:4',
        '1:1',
        '1:3',
        '3:1',
        '3:2',
        '2:3',
      ])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image',
      }),
  ),
  style: z.optional(
    z
      .enum(['auto', 'general', 'realistic', 'design', 'render_3D', 'anime'])
      .register(z.globalRegistry, {
        description: 'The style of the generated image',
      }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to expand the prompt with MagicPrompt functionality.',
      }),
    )
    .default(true),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The image URL to remix',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description: 'Strength of the input image in the remix',
      }),
    )
    .default(0.8),
  seed: z.optional(z.union([z.int(), z.unknown()])),
})

/**
 * Output
 */
export const zSchemaIdeogramV2TurboRemixOutput = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for the random number generator',
  }),
})

/**
 * RemixImageInput
 */
export const zSchemaIdeogramV2TurboRemixInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to remix the image with',
  }),
  aspect_ratio: z.optional(
    z
      .enum([
        '10:16',
        '16:10',
        '9:16',
        '16:9',
        '4:3',
        '3:4',
        '1:1',
        '1:3',
        '3:1',
        '3:2',
        '2:3',
      ])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image',
      }),
  ),
  style: z.optional(
    z
      .enum(['auto', 'general', 'realistic', 'design', 'render_3D', 'anime'])
      .register(z.globalRegistry, {
        description: 'The style of the generated image',
      }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to expand the prompt with MagicPrompt functionality.',
      }),
    )
    .default(true),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The image URL to remix',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description: 'Strength of the input image in the remix',
      }),
    )
    .default(0.8),
  seed: z.optional(z.union([z.int(), z.unknown()])),
})

/**
 * Output
 */
export const zSchemaIdeogramV2TurboEditOutput = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for the random number generator',
  }),
})

/**
 * EditImageInput
 */
export const zSchemaIdeogramV2TurboEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to fill the masked part of the image.',
  }),
  style: z.optional(
    z
      .enum(['auto', 'general', 'realistic', 'design', 'render_3D', 'anime'])
      .register(z.globalRegistry, {
        description: 'The style of the generated image',
      }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to expand the prompt with MagicPrompt functionality.',
      }),
    )
    .default(true),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The image URL to generate an image from. Needs to match the dimensions of the mask.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  mask_url: z.string().register(z.globalRegistry, {
    description:
      'The mask URL to inpaint the image. Needs to match the dimensions of the input image.',
  }),
})

/**
 * Output
 */
export const zSchemaIdeogramV2EditOutput = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for the random number generator',
  }),
})

/**
 * EditImageInput
 */
export const zSchemaIdeogramV2EditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to fill the masked part of the image.',
  }),
  style: z.optional(
    z
      .enum(['auto', 'general', 'realistic', 'design', 'render_3D', 'anime'])
      .register(z.globalRegistry, {
        description: 'The style of the generated image',
      }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to expand the prompt with MagicPrompt functionality.',
      }),
    )
    .default(true),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The image URL to generate an image from. Needs to match the dimensions of the mask.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  mask_url: z.string().register(z.globalRegistry, {
    description:
      'The mask URL to inpaint the image. Needs to match the dimensions of the input image.',
  }),
})

/**
 * VTONOutput
 */
export const zSchemaLeffaVirtualTryonOutput = z.object({
  image: zSchemaImage,
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed for the inference.',
  }),
  has_nsfw_concepts: z.boolean().register(z.globalRegistry, {
    description: 'Whether the image contains NSFW concepts.',
  }),
})

/**
 * VTONInput
 */
export const zSchemaLeffaVirtualTryonInput = z.object({
  garment_image_url: z.string().register(z.globalRegistry, {
    description: 'Url to the garment image.',
  }),
  human_image_url: z.string().register(z.globalRegistry, {
    description: 'Url for the human image.',
  }),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  garment_type: z
    .enum(['upper_body', 'lower_body', 'dresses'])
    .register(z.globalRegistry, {
      description: 'The type of the garment used for virtual try-on.',
    }),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your input when generating the image.\n        ',
      }),
    )
    .default(2.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(50),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same input given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * PoseTransferOutput
 */
export const zSchemaLeffaPoseTransferOutput = z.object({
  image: zSchemaImage,
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed for the inference.',
  }),
  has_nsfw_concepts: z.boolean().register(z.globalRegistry, {
    description: 'Whether the image contains NSFW concepts.',
  }),
})

/**
 * PoseTransferInput
 */
export const zSchemaLeffaPoseTransferInput = z.object({
  pose_image_url: z.string().register(z.globalRegistry, {
    description: 'Url for the human image.',
  }),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your input when generating the image.\n        ',
      }),
    )
    .default(2.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(50),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same input given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  person_image_url: z.string().register(z.globalRegistry, {
    description: 'Url to the garment image.',
  }),
})

/**
 * CATVTONOutput
 */
export const zSchemaCatVtonOutput = z.object({
  image: zSchemaImage,
})

/**
 * CATVTONInput
 */
export const zSchemaCatVtonInput = z.object({
  garment_image_url: z.string().register(z.globalRegistry, {
    description: 'Url to the garment image.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  human_image_url: z.string().register(z.globalRegistry, {
    description: 'Url for the human image.',
  }),
  cloth_type: z
    .enum(['upper', 'lower', 'overall', 'inner', 'outer'])
    .register(z.globalRegistry, {
      description:
        '\n        Type of the Cloth to be tried on.\n\n        Options:\n        upper: Upper body cloth\n        lower: Lower body cloth\n        overall: Full body cloth\n        inner: Inner cloth, like T-shirt inside a jacket\n        outer: Outer cloth, like a jacket over a T-shirt\n        ',
    }),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(2.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same input given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * BGRemoveOutput
 */
export const zSchemaBriaBackgroundRemoveOutput = z.object({
  image: zSchemaImage,
})

/**
 * BGRemoveInput
 */
export const zSchemaBriaBackgroundRemoveInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Input Image to erase from',
  }),
})

/**
 * ProductShotOutput
 */
export const zSchemaBriaProductShotOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images',
  }),
})

/**
 * ProductShotInput
 */
export const zSchemaBriaProductShotInput = z.object({
  ref_image_url: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The URL of the reference image to be used for generating the new scene or background for the product shot. Use "" to leave empty.Either ref_image_url or scene_description has to be provided but not both. If both ref_image_url and ref_image_file are provided, ref_image_url will be used. Accepted formats are jpeg, jpg, png, webp.',
      }),
    )
    .default(''),
  manual_placement_selection: z.optional(
    z
      .enum([
        'upper_left',
        'upper_right',
        'bottom_left',
        'bottom_right',
        'right_center',
        'left_center',
        'upper_center',
        'bottom_center',
        'center_vertical',
        'center_horizontal',
      ])
      .register(z.globalRegistry, {
        description:
          "If you've selected placement_type=manual_placement, you should use this parameter to specify which placements/positions you would like to use from the list. You can select more than one placement in one request.",
      }),
  ),
  num_results: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'The number of lifestyle product shots you would like to generate. You will get num_results x 10 results when placement_type=automatic and according to the number of required placements x num_results if placement_type=manual_placement.',
      }),
    )
    .default(1),
  padding_values: z.optional(
    z.array(z.int()).register(z.globalRegistry, {
      description:
        'The desired padding in pixels around the product, when using placement_type=manual_padding. The order of the values is [left, right, top, bottom]. For optimal results, the total number of pixels, including padding, should be around 1,000,000. It is recommended to first use the product cutout API, get the cutout and understand the size of the result, and then define the required padding and use the cutout as an input for this API.',
    }),
  ),
  shot_size: z
    .optional(
      z.array(z.int()).register(z.globalRegistry, {
        description:
          'The desired size of the final product shot. For optimal results, the total number of pixels should be around 1,000,000. This parameter is only relevant when placement_type=automatic or placement_type=manual_placement.',
      }),
    )
    .default([1000, 1000]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  placement_type: z.optional(
    z
      .enum(['original', 'automatic', 'manual_placement', 'manual_padding'])
      .register(z.globalRegistry, {
        description:
          "This parameter allows you to control the positioning of the product in the image. Choosing 'original' will preserve the original position of the product in the image. Choosing 'automatic' will generate results with the 10 recommended positions for the product. Choosing 'manual_placement' will allow you to select predefined positions (using the parameter 'manual_placement_selection'). Selecting 'manual_padding' will allow you to control the position and size of the image by defining the desired padding in pixels around the product.",
      }),
  ),
  original_quality: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "This flag is only relevant when placement_type=original. If true, the output image retains the original input image's size; otherwise, the image is scaled to 1 megapixel (1MP) while preserving its aspect ratio.",
      }),
    )
    .default(false),
  fast: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to use the fast model',
      }),
    )
    .default(true),
  optimize_description: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to optimize the scene description',
      }),
    )
    .default(true),
  scene_description: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Text description of the new scene or background for the provided product shot. Bria currently supports prompts in English only, excluding special characters.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the product shot to be placed in a lifestyle shot. If both image_url and image_file are provided, image_url will be used. Accepted formats are jpeg, jpg, png, webp. Maximum file size 12MB.',
  }),
})

/**
 * EraserOutput
 */
export const zSchemaBriaEraserOutput = z.object({
  image: zSchemaImage,
})

/**
 * EraserInput
 */
export const zSchemaBriaEraserInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  preserve_alpha: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, attempts to preserve the alpha channel of the input image.\n        ',
      }),
    )
    .default(false),
  mask_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the binary mask image that represents the area that will be cleaned.',
  }),
  mask_type: z.optional(
    z.enum(['manual', 'automatic']).register(z.globalRegistry, {
      description:
        "You can use this parameter to specify the type of the input mask from the list. 'manual' opttion should be used in cases in which the mask had been generated by a user (e.g. with a brush tool), and 'automatic' mask type should be used when mask had been generated by an algorithm like 'SAM'.",
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Input Image to erase from',
  }),
})

/**
 * BGReplaceOutput
 */
export const zSchemaBriaBackgroundReplaceOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
})

/**
 * BGReplaceInput
 */
export const zSchemaBriaBackgroundReplaceInput = z.object({
  prompt: z.optional(
    z.string().min(1).register(z.globalRegistry, {
      description: 'The prompt you would like to use to generate images.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'Number of Images to generate.',
      }),
    )
    .default(1),
  ref_image_url: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The URL of the reference image to be used for generating the new background. Use "" to leave empty. Either ref_image_url or bg_prompt has to be provided but not both. If both ref_image_url and ref_image_file are provided, ref_image_url will be used. Accepted formats are jpeg, jpg, png, webp.',
      }),
    )
    .default(''),
  refine_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to refine prompt',
      }),
    )
    .default(true),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Input Image to erase from',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  fast: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to use the fast model',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().gte(0).lte(2147483647).register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The negative prompt you would like to use to generate images.',
      }),
    )
    .default(''),
})

/**
 * Output
 */
export const zSchemaFluxLoraFillOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * FillInput
 */
export const zSchemaFluxLoraFillInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The prompt to generate an image from.',
      }),
    )
    .default(''),
  resize_to_original: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Resizes the image back to the original size. Use when you wish to preserve the exact image size as the originally provided image.',
      }),
    )
    .default(false),
  paste_back: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Specifies whether to paste-back the original image onto to the non-inpainted areas of the output',
      }),
    )
    .default(true),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(28).lte(35).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(30),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'The number of images to generate. This is always set to 1 for streaming output.',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use for fill operation',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  fill_image: z.optional(zSchemaImageFillInput),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  mask_url: z.string().register(z.globalRegistry, {
    description: '\n            The mask to area to Inpaint in.\n        ',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * GenFillOutput
 */
export const zSchemaBriaGenfillOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Generated Images',
  }),
})

/**
 * GenFillInput
 */
export const zSchemaBriaGenfillInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt you would like to use to generate images.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'Number of Images to generate.',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Input Image to erase from',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().gte(0).lte(2147483647).register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  mask_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the binary mask image that represents the area that will be cleaned.',
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The negative prompt you would like to use to generate images.',
      }),
    )
    .default(''),
})

/**
 * ImageExpansionOutput
 */
export const zSchemaBriaExpandOutput = z.object({
  image: zSchemaImage,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
})

/**
 * ImageExpansionInput
 */
export const zSchemaBriaExpandInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Text on which you wish to base the image expansion. This parameter is optional. Bria currently supports prompts in English only, excluding special characters.',
      }),
    )
    .default(''),
  aspect_ratio: z.optional(
    z
      .enum(['1:1', '2:3', '3:2', '3:4', '4:3', '4:5', '5:4', '9:16', '16:9'])
      .register(z.globalRegistry, {
        description:
          'The desired aspect ratio of the final image. Will be used over original_image_size and original_image_location if provided.',
      }),
  ),
  original_image_location: z.optional(
    z.array(z.int()).register(z.globalRegistry, {
      description:
        'The desired location of the original image, inside the full canvas. Provide the location of the upper left corner of the original image. The location can also be outside the canvas (the original image will be cropped). Will be ignored if aspect_ratio is provided.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the input image.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  original_image_size: z.optional(
    z.array(z.int()).register(z.globalRegistry, {
      description:
        'The desired size of the original image, inside the full canvas. Ensure that the ratio of input image foreground or main subject to the canvas area is greater than 15% to achieve optimal results. Will be ignored if aspect_ratio is provided.',
    }),
  ),
  canvas_size: z.array(z.int()).register(z.globalRegistry, {
    description:
      'The desired size of the final image, after the expansion. should have an area of less than 5000x5000 pixels.',
  }),
  seed: z.optional(
    z.int().gte(0).lte(2147483647).register(z.globalRegistry, {
      description:
        'You can choose whether you want your generated expension to be random or predictable. You can recreate the same result in the future by using the seed value of a result from the response. You can exclude this parameter if you are not interested in recreating your results. This parameter is optional.',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The negative prompt you would like to use to generate images.',
      }),
    )
    .default(''),
})

/**
 * DetectionOutput
 */
export const zSchemaMoondreamNextDetectionOutput = z.object({
  image: z.optional(zSchemaImage),
  text_output: z.string().register(z.globalRegistry, {
    description: 'Detection results as text',
  }),
})

/**
 * DetectionInput
 */
export const zSchemaMoondreamNextDetectionInput = z.object({
  detection_prompt: z.string().register(z.globalRegistry, {
    description: 'Text description of what to detect',
  }),
  use_ensemble: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to use ensemble for gaze detection',
      }),
    )
    .default(false),
  task_type: z
    .enum(['bbox_detection', 'point_detection', 'gaze_detection'])
    .register(z.globalRegistry, {
      description: 'Type of detection to perform',
    }),
  show_visualization: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to show visualization for detection',
      }),
    )
    .default(true),
  combine_points: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to combine points into a single point for point detection. This has no effect for bbox detection or gaze detection.',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image URL to be processed',
  }),
})

/**
 * Output
 */
export const zSchemaFluxProV1FillFinetunedOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z
    .array(zSchemaRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: 'The generated image files info.',
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * FluxProFillFinetunedInput
 */
export const zSchemaFluxProV1FillFinetunedInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to fill the masked part of the image.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  finetune_strength: z.number().gte(0).lte(2).register(z.globalRegistry, {
    description:
      "\n        Controls finetune influence.\n        Increase this value if your target concept isn't showing up strongly enough.\n        The optimal setting depends on your finetune and prompt\n        ",
  }),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  finetune_id: z.string().register(z.globalRegistry, {
    description: 'References your specific model',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The image URL to generate an image from. Needs to match the dimensions of the mask.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  mask_url: z.string().register(z.globalRegistry, {
    description:
      'The mask URL to inpaint the image. Needs to match the dimensions of the input image.',
  }),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enhance the prompt for better results.',
      }),
    )
    .default(false),
})

/**
 * Output
 */
export const zSchemaFluxLoraCannyOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * CannyInput
 */
export const zSchemaFluxLoraCannyInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use for canny input',
  }),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(20).lte(40).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(30),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * TryOnOutput
 */
export const zSchemaKlingV15KolorsVirtualTryOnOutput = z.object({
  image: zSchemaImage,
})

/**
 * TryOnRequest
 */
export const zSchemaKlingV15KolorsVirtualTryOnInput = z.object({
  garment_image_url: z.string().register(z.globalRegistry, {
    description: 'Url to the garment image.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If true, the function will return the image in the response.',
      }),
    )
    .default(false),
  human_image_url: z.string().register(z.globalRegistry, {
    description: 'Url for the human image.',
  }),
})

/**
 * ConformerOutput
 */
export const zSchemaCodeformerOutput = z.object({
  image: zSchemaImage,
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * CodeformerInput
 */
export const zSchemaCodeformerInput = z.object({
  aligned: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Should faces etc should be aligned.',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to be used for relighting',
  }),
  upscale_factor: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'Upscaling factor',
      }),
    )
    .default(2),
  fidelity: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'Weight of the fidelity factor.',
      }),
    )
    .default(0.5),
  face_upscale: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Should faces be upscaled',
      }),
    )
    .default(true),
  only_center_face: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Should only center face be restored',
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducible generation.',
    }),
  ),
})

/**
 * UpscaleOutput
 */
export const zSchemaIdeogramUpscaleOutput = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for the random number generator',
  }),
})

/**
 * UpscaleImageInput
 */
export const zSchemaIdeogramUpscaleInput = z.object({
  prompt: z.optional(z.union([z.string(), z.unknown()])),
  detail: z
    .optional(
      z.int().gte(1).lte(100).register(z.globalRegistry, {
        description: 'The detail of the upscaled image',
      }),
    )
    .default(50),
  resemblance: z
    .optional(
      z.int().gte(1).lte(100).register(z.globalRegistry, {
        description:
          'The resemblance of the upscaled image to the original image',
      }),
    )
    .default(50),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to expand the prompt with MagicPrompt functionality.',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The image URL to upscale',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
})

/**
 * Output
 */
export const zSchemaFluxControlLoraCannyImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * ImageToImageInput
 */
export const zSchemaFluxControlLoraCannyImageToImageInput = z.object({
  control_lora_strength: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description: 'The strength of the control lora.',
      }),
    )
    .default(1),
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use for inpainting. or img2img',
  }),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.',
      }),
    )
    .default(0.85),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  control_lora_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The image to use for control lora. This is used to control the style of the generated image.\n        ',
    }),
  ),
})

/**
 * Ben2OutputImage
 */
export const zSchemaBenV2ImageOutput = z.object({
  image: zSchemaImage,
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * Ben2InputImage
 */
export const zSchemaBenV2ImageInput = z.object({
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducible generation.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to be used for background removal',
  }),
})

/**
 * Output
 */
export const zSchemaFluxControlLoraDepthImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * ImageToImageInput
 */
export const zSchemaFluxControlLoraDepthImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  control_lora_strength: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description: 'The strength of the control lora.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use for inpainting. or img2img',
  }),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.',
      }),
    )
    .default(0.85),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  control_lora_image_url: z.string().register(z.globalRegistry, {
    description:
      '\n            The image to use for control lora. This is used to control the style of the generated image.\n        ',
  }),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * FlowEditOutput
 */
export const zSchemaFloweditOutput = z.object({
  image: zSchemaImage,
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * FlowEditInput
 */
export const zSchemaFloweditInput = z.object({
  src_guidance_scale: z
    .optional(
      z.int().gte(0).lte(30).register(z.globalRegistry, {
        description: 'Guidance scale for the source.',
      }),
    )
    .default(1.5),
  n_min: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Minimum step for improved style edits',
      }),
    )
    .default(0),
  n_max: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Control the strength of the edit',
      }),
    )
    .default(23),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to be used for relighting',
  }),
  source_prompt: z.string().register(z.globalRegistry, {
    description: 'Prompt of the image to be used.',
  }),
  tar_guidance_scale: z
    .optional(
      z.int().gte(0).lte(30).register(z.globalRegistry, {
        description: 'Guidance scale for target.',
      }),
    )
    .default(5.5),
  target_prompt: z.string().register(z.globalRegistry, {
    description: 'Prompt of the image to be made.',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducible generation. If set none, a random seed will be used.',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Steps for which the model should run.',
      }),
    )
    .default(28),
  n_avg: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Average step count',
      }),
    )
    .default(1),
})

/**
 * ProcessedOutput
 */
export const zSchemaPostProcessingOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The processed images',
  }),
})

/**
 * ImageProcessingInput
 */
export const zSchemaPostProcessingInput = z.object({
  blue_shift: z
    .optional(
      z.int().gte(-20).lte(20).register(z.globalRegistry, {
        description: 'Blue channel shift amount',
      }),
    )
    .default(0),
  vertex_y: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Vertex Y position',
      }),
    )
    .default(0.5),
  green_direction: z.optional(
    z.enum(['horizontal', 'vertical']).register(z.globalRegistry, {
      description: 'Green channel shift direction',
    }),
  ),
  enable_glow: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable glow effect',
      }),
    )
    .default(false),
  dodge_burn_mode: z.optional(
    z
      .enum([
        'dodge',
        'burn',
        'dodge_and_burn',
        'burn_and_dodge',
        'color_dodge',
        'color_burn',
        'linear_dodge',
        'linear_burn',
      ])
      .register(z.globalRegistry, {
        description: 'Dodge and burn mode',
      }),
  ),
  glow_intensity: z
    .optional(
      z.number().gte(0).lte(5).register(z.globalRegistry, {
        description: 'Glow intensity',
      }),
    )
    .default(1),
  blur_sigma: z
    .optional(
      z.number().gte(0.1).lte(10).register(z.globalRegistry, {
        description: 'Sigma for Gaussian blur',
      }),
    )
    .default(1),
  desaturate_method: z.optional(
    z
      .enum([
        'luminance (Rec.709)',
        'luminance (Rec.601)',
        'average',
        'lightness',
      ])
      .register(z.globalRegistry, {
        description: 'Desaturation method',
      }),
  ),
  enable_blur: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable blur effect',
      }),
    )
    .default(false),
  blur_radius: z
    .optional(
      z.int().gte(0).lte(31).register(z.globalRegistry, {
        description: 'Blur radius',
      }),
    )
    .default(3),
  grain_style: z.optional(
    z
      .enum(['modern', 'analog', 'kodak', 'fuji', 'cinematic', 'newspaper'])
      .register(z.globalRegistry, {
        description: 'Style of film grain to apply',
      }),
  ),
  cas_amount: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'CAS sharpening amount',
      }),
    )
    .default(0.8),
  gamma: z
    .optional(
      z.number().gte(0.2).lte(2.2).register(z.globalRegistry, {
        description: 'Gamma adjustment',
      }),
    )
    .default(1),
  tint_mode: z.optional(
    z
      .enum([
        'sepia',
        'red',
        'green',
        'blue',
        'cyan',
        'magenta',
        'yellow',
        'purple',
        'orange',
        'warm',
        'cool',
        'lime',
        'navy',
        'vintage',
        'rose',
        'teal',
        'maroon',
        'peach',
        'lavender',
        'olive',
      ])
      .register(z.globalRegistry, {
        description: 'Tint color mode',
      }),
  ),
  blur_type: z.optional(
    z.enum(['gaussian', 'kuwahara']).register(z.globalRegistry, {
      description: 'Type of blur to apply',
    }),
  ),
  enable_vignette: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable vignette effect',
      }),
    )
    .default(false),
  dissolve_image_url: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'URL of second image for dissolve',
      }),
    )
    .default(''),
  red_shift: z
    .optional(
      z.int().gte(-20).lte(20).register(z.globalRegistry, {
        description: 'Red channel shift amount',
      }),
    )
    .default(0),
  enable_desaturate: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable desaturation effect',
      }),
    )
    .default(false),
  grain_intensity: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Film grain intensity (when enabled)',
      }),
    )
    .default(0.4),
  dodge_burn_intensity: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Dodge and burn intensity',
      }),
    )
    .default(0.5),
  smart_sharpen_strength: z
    .optional(
      z.number().gte(0).lte(25).register(z.globalRegistry, {
        description: 'Smart sharpen strength',
      }),
    )
    .default(5),
  red_direction: z.optional(
    z.enum(['horizontal', 'vertical']).register(z.globalRegistry, {
      description: 'Red channel shift direction',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to process',
  }),
  vertex_x: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Vertex X position',
      }),
    )
    .default(0.5),
  tint_strength: z
    .optional(
      z.number().gte(0.1).lte(1).register(z.globalRegistry, {
        description: 'Tint strength',
      }),
    )
    .default(1),
  enable_dissolve: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable dissolve effect',
      }),
    )
    .default(false),
  enable_parabolize: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable parabolize effect',
      }),
    )
    .default(false),
  enable_grain: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable film grain effect',
      }),
    )
    .default(false),
  solarize_threshold: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Solarize threshold',
      }),
    )
    .default(0.5),
  enable_sharpen: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable sharpen effect',
      }),
    )
    .default(false),
  enable_dodge_burn: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable dodge and burn effect',
      }),
    )
    .default(false),
  glow_radius: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Glow blur radius',
      }),
    )
    .default(5),
  sharpen_alpha: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Sharpen strength (for basic mode)',
      }),
    )
    .default(1),
  enable_color_correction: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable color correction',
      }),
    )
    .default(false),
  contrast: z
    .optional(
      z.number().gte(-100).lte(100).register(z.globalRegistry, {
        description: 'Contrast adjustment',
      }),
    )
    .default(0),
  enable_solarize: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable solarize effect',
      }),
    )
    .default(false),
  noise_radius: z
    .optional(
      z.int().gte(1).lte(25).register(z.globalRegistry, {
        description: 'Noise radius for smart sharpen',
      }),
    )
    .default(7),
  grain_scale: z
    .optional(
      z.number().gte(1).lte(100).register(z.globalRegistry, {
        description: 'Film grain scale (when enabled)',
      }),
    )
    .default(10),
  temperature: z
    .optional(
      z.number().gte(-100).lte(100).register(z.globalRegistry, {
        description: 'Color temperature adjustment',
      }),
    )
    .default(0),
  brightness: z
    .optional(
      z.number().gte(-100).lte(100).register(z.globalRegistry, {
        description: 'Brightness adjustment',
      }),
    )
    .default(0),
  blue_direction: z.optional(
    z.enum(['horizontal', 'vertical']).register(z.globalRegistry, {
      description: 'Blue channel shift direction',
    }),
  ),
  dissolve_factor: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Dissolve blend factor',
      }),
    )
    .default(0.5),
  sharpen_mode: z.optional(
    z.enum(['basic', 'smart', 'cas']).register(z.globalRegistry, {
      description: 'Type of sharpening to apply',
    }),
  ),
  vignette_strength: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Vignette strength (when enabled)',
      }),
    )
    .default(0.5),
  sharpen_radius: z
    .optional(
      z.int().gte(1).lte(15).register(z.globalRegistry, {
        description: 'Sharpen radius (for basic mode)',
      }),
    )
    .default(1),
  parabolize_coeff: z
    .optional(
      z.number().gte(-10).lte(10).register(z.globalRegistry, {
        description: 'Parabolize coefficient',
      }),
    )
    .default(1),
  saturation: z
    .optional(
      z.number().gte(-100).lte(100).register(z.globalRegistry, {
        description: 'Saturation adjustment',
      }),
    )
    .default(0),
  enable_tint: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable color tint effect',
      }),
    )
    .default(false),
  green_shift: z
    .optional(
      z.int().gte(-20).lte(20).register(z.globalRegistry, {
        description: 'Green channel shift amount',
      }),
    )
    .default(0),
  preserve_edges: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Edge preservation factor',
      }),
    )
    .default(0.75),
  desaturate_factor: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Desaturation factor',
      }),
    )
    .default(1),
  smart_sharpen_ratio: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Smart sharpen blend ratio',
      }),
    )
    .default(0.5),
  enable_chromatic: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable chromatic aberration',
      }),
    )
    .default(false),
})

/**
 * NafnetOutputDenoise
 */
export const zSchemaNafnetDenoiseOutput = z.object({
  image: zSchemaImage,
})

/**
 * NafnetInputDenoise
 */
export const zSchemaNafnetDenoiseInput = z.object({
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'seed to be used for generation',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to be used for relighting',
  }),
})

/**
 * NafnetOutput
 */
export const zSchemaNafnetDeblurOutput = z.object({
  image: zSchemaImage,
})

/**
 * NafnetInput
 */
export const zSchemaNafnetDeblurInput = z.object({
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'seed to be used for generation',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to be used for relighting',
  }),
})

/**
 * Output
 */
export const zSchemaDrctSuperResolutionOutput = z.object({
  image: zSchemaImage,
})

/**
 * Input
 */
export const zSchemaDrctSuperResolutionInput = z.object({
  upscale_factor: z.optional(
    z.literal(4).register(z.globalRegistry, {
      description: 'Upscaling factor.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to upscale.',
  }),
})

/**
 * SAM2AutomaticSegmentationOutput
 */
export const zSchemaSam2AutoSegmentOutput = z.object({
  combined_mask: zSchemaImage,
  individual_masks: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Individual segmentation masks.',
  }),
})

/**
 * SAM2AutomaticSegmentationInput
 */
export const zSchemaSam2AutoSegmentInput = z.object({
  points_per_side: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Number of points to sample along each side of the image.',
      }),
    )
    .default(32),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  min_mask_region_area: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Minimum area of a mask region.',
      }),
    )
    .default(100),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be automatically segmented',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  pred_iou_thresh: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'Threshold for predicted IOU score.',
      }),
    )
    .default(0.88),
  stability_score_thresh: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'Threshold for stability score.',
      }),
    )
    .default(0.95),
})

/**
 * DDColorOutput
 */
export const zSchemaDdcolorOutput = z.object({
  image: zSchemaImage,
})

/**
 * DDColorInput
 */
export const zSchemaDdcolorInput = z.object({
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'seed to be used for generation',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to be used for relighting',
  }),
})

/**
 * ImageOutput
 */
export const zSchemaEvfSamOutput = z.object({
  image: zSchemaFile,
})

/**
 * ImageInput
 */
export const zSchemaEvfSamInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate segmentation from.',
  }),
  use_grounding_dino: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Use GroundingDINO instead of SAM for segmentation',
      }),
    )
    .default(false),
  semantic_type: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Enable semantic level segmentation for body parts, background or multi objects',
      }),
    )
    .default(false),
  fill_holes: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Fill holes in the mask using morphological operations',
      }),
    )
    .default(false),
  expand_mask: z
    .optional(
      z.int().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Expand/dilate the mask by specified pixels',
      }),
    )
    .default(0),
  mask_only: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Output only the binary mask instead of masked image',
      }),
    )
    .default(true),
  revert_mask: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Invert the mask (background becomes foreground and vice versa)',
      }),
    )
    .default(false),
  blur_mask: z
    .optional(
      z.int().gte(0).lte(50).register(z.globalRegistry, {
        description:
          'Apply Gaussian blur to the mask. Value determines kernel size (must be odd number)',
      }),
    )
    .default(0),
  negative_prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Areas to exclude from segmentation (will be subtracted from prompt results)',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the input image',
  }),
})

/**
 * Output
 */
export const zSchemaIdeogramV2aTurboRemixOutput = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for the random number generator',
  }),
})

/**
 * RemixImageInput
 */
export const zSchemaIdeogramV2aTurboRemixInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to remix the image with',
  }),
  aspect_ratio: z.optional(
    z
      .enum([
        '10:16',
        '16:10',
        '9:16',
        '16:9',
        '4:3',
        '3:4',
        '1:1',
        '1:3',
        '3:1',
        '3:2',
        '2:3',
      ])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image',
      }),
  ),
  style: z.optional(
    z
      .enum(['auto', 'general', 'realistic', 'design', 'render_3D', 'anime'])
      .register(z.globalRegistry, {
        description: 'The style of the generated image',
      }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to expand the prompt with MagicPrompt functionality.',
      }),
    )
    .default(true),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The image URL to remix',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description: 'Strength of the input image in the remix',
      }),
    )
    .default(0.8),
  seed: z.optional(z.union([z.int(), z.unknown()])),
})

/**
 * Output
 */
export const zSchemaIdeogramV2aRemixOutput = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for the random number generator',
  }),
})

/**
 * RemixImageInput
 */
export const zSchemaIdeogramV2aRemixInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to remix the image with',
  }),
  aspect_ratio: z.optional(
    z
      .enum([
        '10:16',
        '16:10',
        '9:16',
        '16:9',
        '4:3',
        '3:4',
        '1:1',
        '1:3',
        '3:1',
        '3:2',
        '2:3',
      ])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image',
      }),
  ),
  style: z.optional(
    z
      .enum(['auto', 'general', 'realistic', 'design', 'render_3D', 'anime'])
      .register(z.globalRegistry, {
        description: 'The style of the generated image',
      }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to expand the prompt with MagicPrompt functionality.',
      }),
    )
    .default(true),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The image URL to remix',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description: 'Strength of the input image in the remix',
      }),
    )
    .default(0.8),
  seed: z.optional(z.union([z.int(), z.unknown()])),
})

/**
 * SwinSrOutput
 */
export const zSchemaSwin2SrOutput = z.object({
  image: zSchemaImage,
})

/**
 * SwinSrInput
 */
export const zSchemaSwin2SrInput = z.object({
  task: z.optional(
    z
      .enum(['classical_sr', 'compressed_sr', 'real_sr'])
      .register(z.globalRegistry, {
        description: 'Task to perform',
      }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'seed to be used for generation',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to be used for image enhancement',
  }),
})

/**
 * DocResOutput
 */
export const zSchemaDocresOutput = z.object({
  image: zSchemaImage,
})

/**
 * DocResInput
 */
export const zSchemaDocresInput = z.object({
  task: z
    .enum(['deshadowing', 'appearance', 'deblurring', 'binarization'])
    .register(z.globalRegistry, {
      description: 'Task to perform',
    }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to be used for relighting',
  }),
})

/**
 * DocResOutput
 */
export const zSchemaDocresDewarpOutput = z.object({
  image: zSchemaImage,
})

/**
 * DocResInputDewarp
 */
export const zSchemaDocresDewarpInput = z.object({
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to be used for relighting',
  }),
})

/**
 * Output
 */
export const zSchemaJuggernautFluxBaseImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * DevImageToImageInput
 */
export const zSchemaJuggernautFluxBaseImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate an image from.',
  }),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength of the initial image. Higher strength values are better for this model.',
      }),
    )
    .default(0.95),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(40),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaJuggernautFluxProImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * DevImageToImageInput
 */
export const zSchemaJuggernautFluxProImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate an image from.',
  }),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength of the initial image. Higher strength values are better for this model.',
      }),
    )
    .default(0.95),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(40),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * WatermarkOutput
 */
export const zSchemaInvisibleWatermarkOutput = z.object({
  image: z.optional(zSchemaImage),
  extracted_watermark: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The extracted watermark text (when decoding)',
    }),
  ),
  length: z
    .optional(
      z.int().register(z.globalRegistry, {
        description:
          'Length of the watermark bits used (helpful for future decoding)',
      }),
    )
    .default(0),
})

/**
 * WatermarkInput
 */
export const zSchemaInvisibleWatermarkInput = z.object({
  decode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to decode a watermark from the image instead of encoding',
      }),
    )
    .default(false),
  watermark: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Text to use as watermark (for encoding only)',
      }),
    )
    .default('watermark'),
  length: z
    .optional(
      z.int().register(z.globalRegistry, {
        description:
          'Length of watermark bits to decode (required when decode=True)',
      }),
    )
    .default(0),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to be watermarked or decoded',
  }),
})

/**
 * GeminiImageOutput
 */
export const zSchemaGeminiFlashEditOutput = z.object({
  description: z.string().register(z.globalRegistry, {
    description: 'Text description or response from Gemini',
  }),
  image: zSchemaImage,
})

/**
 * GeminiImageRequest
 */
export const zSchemaGeminiFlashEditInput = z.object({
  prompt: z.string().min(3).max(5000).register(z.globalRegistry, {
    description: 'The prompt for image generation or editing',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'Optional URL of an input image for editing. If not provided, generates a new image.',
  }),
})

/**
 * GeminiImageOutput
 */
export const zSchemaGeminiFlashEditMultiOutput = z.object({
  description: z.string().register(z.globalRegistry, {
    description: 'Text description or response from Gemini',
  }),
  image: zSchemaImage,
})

/**
 * GeminiMultiImageRequest
 */
export const zSchemaGeminiFlashEditMultiInput = z.object({
  prompt: z.string().min(3).max(5000).register(z.globalRegistry, {
    description: 'The prompt for image generation or editing',
  }),
  input_image_urls: z
    .array(z.string())
    .min(1)
    .max(10)
    .register(z.globalRegistry, {
      description: 'List of URLs of input images for editing',
    }),
})

/**
 * MixDehazeNetOutput
 */
export const zSchemaMixDehazeNetOutput = z.object({
  image: zSchemaImage,
})

/**
 * MixDehazeNetInput
 */
export const zSchemaMixDehazeNetInput = z.object({
  model: z.optional(
    z.enum(['indoor', 'outdoor']).register(z.globalRegistry, {
      description: 'Model to be used for dehazing',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'seed to be used for generation',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to be used for image enhancement',
  }),
})

/**
 * TheraOutput
 */
export const zSchemaTheraOutput = z.object({
  image: zSchemaImage,
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TheraInput
 */
export const zSchemaTheraInput = z.object({
  upscale_factor: z
    .optional(
      z.number().gte(1).lte(6).register(z.globalRegistry, {
        description: 'The upscaling factor for the image.',
      }),
    )
    .default(2),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducible generation.',
    }),
  ),
  backbone: z.enum(['edsr', 'rdn']).register(z.globalRegistry, {
    description: 'Backbone to use for upscaling',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to be used for upscaling',
  }),
})

/**
 * Output
 */
export const zSchemaGhiblifyOutput = z.object({
  image: zSchemaImage,
})

/**
 * Input
 */
export const zSchemaGhiblifyInput = z.object({
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable the safety checker.',
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to upscale.',
  }),
})

/**
 * StarVectorOutput
 */
export const zSchemaStarVectorOutput = z.object({
  image: zSchemaFile,
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * StarVectorInput
 */
export const zSchemaStarVectorInput = z.object({
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'seed to be used for generation',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to be used for relighting',
  }),
})

/**
 * EraseOutput
 */
export const zSchemaFinegrainEraserOutput = z.object({
  image: zSchemaFile,
  used_seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation',
  }),
})

/**
 * PromptEraseRequest
 */
export const zSchemaFinegrainEraserInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text description of what to erase',
  }),
  mode: z.optional(
    z.enum(['express', 'standard', 'premium']).register(z.globalRegistry, {
      description: 'Erase quality mode',
    }),
  ),
  seed: z.optional(
    z.int().gte(0).lte(999).register(z.globalRegistry, {
      description: 'Random seed for reproducible generation',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to edit',
  }),
})

/**
 * BoxPromptBase
 */
export const zSchemaBoxPromptBase = z.object({
  y_min: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Y Min Coordinate of the box',
      }),
    )
    .default(0),
  x_max: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'X Max Coordinate of the prompt',
      }),
    )
    .default(0),
  x_min: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'X Min Coordinate of the box',
      }),
    )
    .default(0),
  y_max: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Y Max Coordinate of the prompt',
      }),
    )
    .default(0),
})

/**
 * EraseOutput
 */
export const zSchemaFinegrainEraserBboxOutput = z.object({
  image: zSchemaFile,
  used_seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation',
  }),
})

/**
 * BBoxEraseRequest
 */
export const zSchemaFinegrainEraserBboxInput = z.object({
  mode: z.optional(
    z.enum(['express', 'standard', 'premium']).register(z.globalRegistry, {
      description: 'Erase quality mode',
    }),
  ),
  seed: z.optional(
    z.int().gte(0).lte(999).register(z.globalRegistry, {
      description: 'Random seed for reproducible generation',
    }),
  ),
  box_prompts: z.array(zSchemaBoxPromptBase).register(z.globalRegistry, {
    description:
      'List of bounding box coordinates to erase (only one box prompt is supported)',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to edit',
  }),
})

/**
 * EraseOutput
 */
export const zSchemaFinegrainEraserMaskOutput = z.object({
  image: zSchemaFile,
  used_seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation',
  }),
})

/**
 * MaskEraseRequest
 */
export const zSchemaFinegrainEraserMaskInput = z.object({
  mode: z.optional(
    z.enum(['express', 'standard', 'premium']).register(z.globalRegistry, {
      description: 'Erase quality mode',
    }),
  ),
  seed: z.optional(
    z.int().gte(0).lte(999).register(z.globalRegistry, {
      description: 'Random seed for reproducible generation',
    }),
  ),
  mask_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the mask image. Should be a binary mask where white (255) indicates areas to erase',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to edit',
  }),
})

/**
 * Output
 */
export const zSchemaCartoonifyOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * CartoonifyInput
 */
export const zSchemaCartoonifyInput = z.object({
  use_cfg_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to use CFG zero',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to apply Pixar style to',
  }),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for the generation',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps',
      }),
    )
    .default(28),
  scale: z
    .optional(
      z.number().gte(0.1).lte(2).register(z.globalRegistry, {
        description: 'Scale factor for the Pixar effect',
      }),
    )
    .default(1),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable the safety checker',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed for image generation. Same seed with same parameters will generate same image.',
    }),
  ),
})

/**
 * ImageOutput
 */
export const zSchemaInstantCharacterOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaInstantCharacterInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  scale: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description:
          'The scale of the subject image. Higher values will make the subject image more prominent in the generated image.',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The image URL to generate an image from. Needs to match the dimensions of the mask.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaPlushifyOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * PlushifyInput
 */
export const zSchemaPlushifyInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Prompt for the generation. Default is empty which is usually best, but sometimes it can help to add a description of the subject.',
      }),
    )
    .default(''),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'Number of images to generate',
      }),
    )
    .default(1),
  use_cfg_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to use CFG zero',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to apply cartoon style to',
  }),
  scale: z
    .optional(
      z.number().gte(0.1).lte(2).register(z.globalRegistry, {
        description: 'Scale factor for the Cartoon effect',
      }),
    )
    .default(1),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps',
      }),
    )
    .default(28),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for the generation',
      }),
    )
    .default(3.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable the safety checker',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed for image generation. Same seed with same parameters will generate same image.',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaFashnTryonV15Output = z.object({
  images: z.array(zSchemaFile),
})

/**
 * Input
 */
export const zSchemaFashnTryonV15Input = z.object({
  model_image: z.string().register(z.globalRegistry, {
    description: 'URL or base64 of the model image',
  }),
  moderation_level: z.optional(
    z.enum(['none', 'permissive', 'conservative']).register(z.globalRegistry, {
      description:
        "Content moderation level for garment images. 'none' disables moderation, 'permissive' blocks only explicit content, 'conservative' also blocks underwear and swimwear.",
    }),
  ),
  garment_photo_type: z.optional(
    z.enum(['auto', 'model', 'flat-lay']).register(z.globalRegistry, {
      description:
        "Specifies the type of garment photo to optimize internal parameters for better performance. 'model' is for photos of garments on a model, 'flat-lay' is for flat-lay or ghost mannequin images, and 'auto' attempts to automatically detect the photo type.",
    }),
  ),
  garment_image: z.string().register(z.globalRegistry, {
    description: 'URL or base64 of the garment image',
  }),
  category: z.optional(
    z
      .enum(['tops', 'bottoms', 'one-pieces', 'auto'])
      .register(z.globalRegistry, {
        description:
          "Category of the garment to try-on. 'auto' will attempt to automatically detect the category of the garment.",
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  segmentation_free: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Disables human parsing on the model image.',
      }),
    )
    .default(true),
  num_samples: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'Number of images to generate in a single run. Image generation has a random element in it, so trying multiple images at once increases the chances of getting a good result.',
      }),
    )
    .default(1),
  mode: z.optional(
    z.enum(['performance', 'balanced', 'quality']).register(z.globalRegistry, {
      description:
        "Specifies the mode of operation. 'performance' mode is faster but may sacrifice quality, 'balanced' mode is a balance between speed and quality, and 'quality' mode is slower but produces higher quality results.",
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Sets random operations to a fixed state. Use the same seed to reproduce results with the same inputs, or different seed to force different results.',
    }),
  ),
  output_format: z.optional(
    z.enum(['png', 'jpeg']).register(z.globalRegistry, {
      description:
        "Output format of the generated images. 'png' is highest quality, while 'jpeg' is faster",
    }),
  ),
})

/**
 * Output
 */
export const zSchemaJuggernautFluxLoraInpaintingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * InpaintInput
 */
export const zSchemaJuggernautFluxLoraInpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use for inpainting. or img2img',
  }),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.',
      }),
    )
    .default(0.85),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  mask_url: z.string().register(z.globalRegistry, {
    description: '\n            The mask to area to Inpaint in.\n        ',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * EditImageResponse
 */
export const zSchemaGptImage1EditImageOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
})

/**
 * EditImageRequest
 */
export const zSchemaGptImage1EditImageInput = z.object({
  prompt: z.string().min(2).register(z.globalRegistry, {
    description: 'The prompt for image generation',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'Number of images to generate',
      }),
    )
    .default(1),
  image_size: z.optional(
    z
      .enum(['auto', '1024x1024', '1536x1024', '1024x1536'])
      .register(z.globalRegistry, {
        description: 'Aspect ratio for the generated image',
      }),
  ),
  background: z.optional(
    z.enum(['auto', 'transparent', 'opaque']).register(z.globalRegistry, {
      description: 'Background for the generated image',
    }),
  ),
  quality: z.optional(
    z.enum(['auto', 'low', 'medium', 'high']).register(z.globalRegistry, {
      description: 'Quality for the generated image',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'Output format for the images',
    }),
  ),
  input_fidelity: z.optional(
    z.enum(['low', 'high']).register(z.globalRegistry, {
      description: 'Input fidelity for the generated image',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The URLs of the images to use as a reference for the generation.',
  }),
})

/**
 * UNOOutput
 */
export const zSchemaUnoOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used to generate the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The URLs of the generated images.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * UNOInput
 */
export const zSchemaUnoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  input_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: 'URL of images to use while generating the image.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducible generation. If set none, a random seed will be used.',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Image2SVGOutput
 */
export const zSchemaImage2SvgOutput = z.object({
  images: z.array(zSchemaFile).register(z.globalRegistry, {
    description: 'The converted SVG file',
  }),
})

/**
 * Image2SVGInput
 */
export const zSchemaImage2SvgInput = z.object({
  splice_threshold: z
    .optional(
      z.int().gte(0).lte(90).register(z.globalRegistry, {
        description: 'Splice threshold for joining paths',
      }),
    )
    .default(45),
  hierarchical: z.optional(
    z.enum(['stacked', 'cutout']).register(z.globalRegistry, {
      description: 'Hierarchical mode: stacked or cutout',
    }),
  ),
  color_precision: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description: 'Color quantization level',
      }),
    )
    .default(6),
  colormode: z.optional(
    z.enum(['color', 'binary']).register(z.globalRegistry, {
      description: 'Choose between color or binary (black and white) output',
    }),
  ),
  max_iterations: z
    .optional(
      z.int().gte(1).lte(20).register(z.globalRegistry, {
        description: 'Maximum number of iterations for optimization',
      }),
    )
    .default(10),
  length_threshold: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Length threshold for curves/lines',
      }),
    )
    .default(4),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The image to convert to SVG',
  }),
  mode: z.optional(
    z.enum(['spline', 'polygon']).register(z.globalRegistry, {
      description: 'Mode: spline (curved) or polygon (straight lines)',
    }),
  ),
  corner_threshold: z
    .optional(
      z.int().gte(0).lte(180).register(z.globalRegistry, {
        description: 'Corner detection threshold in degrees',
      }),
    )
    .default(60),
  path_precision: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description: 'Decimal precision for path coordinates',
      }),
    )
    .default(3),
  filter_speckle: z
    .optional(
      z.int().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Filter out small speckles and noise',
      }),
    )
    .default(4),
  layer_difference: z
    .optional(
      z.int().gte(1).lte(32).register(z.globalRegistry, {
        description: 'Layer difference threshold for hierarchical mode',
      }),
    )
    .default(16),
})

/**
 * ImageOutput
 */
export const zSchemaStep1xEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaStep1xEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The image URL to generate an image from. Needs to match the dimensions of the mask.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(30),
})

/**
 * EditOutputV3
 */
export const zSchemaIdeogramV3EditOutput = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for the random number generator',
  }),
})

/**
 * RGBColor
 */
export const zSchemaRgbColor = z.object({
  r: z
    .optional(
      z.int().gte(0).lte(255).register(z.globalRegistry, {
        description: 'Red color value',
      }),
    )
    .default(0),
  b: z
    .optional(
      z.int().gte(0).lte(255).register(z.globalRegistry, {
        description: 'Blue color value',
      }),
    )
    .default(0),
  g: z
    .optional(
      z.int().gte(0).lte(255).register(z.globalRegistry, {
        description: 'Green color value',
      }),
    )
    .default(0),
})

/**
 * ColorPaletteMember
 */
export const zSchemaColorPaletteMember = z.object({
  color_weight: z.optional(z.union([z.number().gte(0.05).lte(1), z.unknown()])),
  rgb: zSchemaRgbColor,
})

/**
 * ColorPalette
 */
export const zSchemaColorPalette = z.object({
  members: z.optional(
    z.union([z.array(zSchemaColorPaletteMember), z.unknown()]),
  ),
  name: z.optional(
    z.union([
      z.enum([
        'EMBER',
        'FRESH',
        'JUNGLE',
        'MAGIC',
        'MELON',
        'MOSAIC',
        'PASTEL',
        'ULTRAMARINE',
      ]),
      z.unknown(),
    ]),
  ),
})

/**
 * EditImageInputV3
 */
export const zSchemaIdeogramV3EditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to fill the masked part of the image.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'Number of images to generate.',
      }),
    )
    .default(1),
  style_preset: z.optional(
    z.union([
      z.enum([
        '80S_ILLUSTRATION',
        '90S_NOSTALGIA',
        'ABSTRACT_ORGANIC',
        'ANALOG_NOSTALGIA',
        'ART_BRUT',
        'ART_DECO',
        'ART_POSTER',
        'AURA',
        'AVANT_GARDE',
        'BAUHAUS',
        'BLUEPRINT',
        'BLURRY_MOTION',
        'BRIGHT_ART',
        'C4D_CARTOON',
        'CHILDRENS_BOOK',
        'COLLAGE',
        'COLORING_BOOK_I',
        'COLORING_BOOK_II',
        'CUBISM',
        'DARK_AURA',
        'DOODLE',
        'DOUBLE_EXPOSURE',
        'DRAMATIC_CINEMA',
        'EDITORIAL',
        'EMOTIONAL_MINIMAL',
        'ETHEREAL_PARTY',
        'EXPIRED_FILM',
        'FLAT_ART',
        'FLAT_VECTOR',
        'FOREST_REVERIE',
        'GEO_MINIMALIST',
        'GLASS_PRISM',
        'GOLDEN_HOUR',
        'GRAFFITI_I',
        'GRAFFITI_II',
        'HALFTONE_PRINT',
        'HIGH_CONTRAST',
        'HIPPIE_ERA',
        'ICONIC',
        'JAPANDI_FUSION',
        'JAZZY',
        'LONG_EXPOSURE',
        'MAGAZINE_EDITORIAL',
        'MINIMAL_ILLUSTRATION',
        'MIXED_MEDIA',
        'MONOCHROME',
        'NIGHTLIFE',
        'OIL_PAINTING',
        'OLD_CARTOONS',
        'PAINT_GESTURE',
        'POP_ART',
        'RETRO_ETCHING',
        'RIVIERA_POP',
        'SPOTLIGHT_80S',
        'STYLIZED_RED',
        'SURREAL_COLLAGE',
        'TRAVEL_POSTER',
        'VINTAGE_GEO',
        'VINTAGE_POSTER',
        'WATERCOLOR',
        'WEIRD',
        'WOODBLOCK_PRINT',
      ]),
      z.unknown(),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Determine if MagicPrompt should be used in generating the request or not.',
      }),
    )
    .default(true),
  rendering_speed: z.optional(
    z.enum(['TURBO', 'BALANCED', 'QUALITY']).register(z.globalRegistry, {
      description: 'The rendering speed to use.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  color_palette: z.optional(z.union([zSchemaColorPalette, z.unknown()])),
  style_codes: z.optional(z.union([z.array(z.string()), z.unknown()])),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The image URL to generate an image from. MUST have the exact same dimensions (width and height) as the mask image.',
  }),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  image_urls: z.optional(z.union([z.array(z.string()), z.unknown()])),
  mask_url: z.string().register(z.globalRegistry, {
    description:
      'The mask URL to inpaint the image. MUST have the exact same dimensions (width and height) as the input image.',
  }),
})

/**
 * RemixOutputV3
 */
export const zSchemaIdeogramV3RemixOutput = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for the random number generator',
  }),
})

/**
 * RemixImageInputV3
 */
export const zSchemaIdeogramV3RemixInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to remix the image with',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
      z.unknown(),
    ]),
  ),
  style: z.optional(
    z.union([z.enum(['AUTO', 'GENERAL', 'REALISTIC', 'DESIGN']), z.unknown()]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Determine if MagicPrompt should be used in generating the request or not.',
      }),
    )
    .default(true),
  rendering_speed: z.optional(
    z.enum(['TURBO', 'BALANCED', 'QUALITY']).register(z.globalRegistry, {
      description: 'The rendering speed to use.',
    }),
  ),
  image_urls: z.optional(z.union([z.array(z.string()), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Description of what to exclude from an image. Descriptions in the prompt take precedence to descriptions in the negative prompt.',
      }),
    )
    .default(''),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'Number of images to generate.',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The image URL to remix',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  color_palette: z.optional(z.union([zSchemaColorPalette, z.unknown()])),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description: 'Strength of the input image in the remix',
      }),
    )
    .default(0.8),
  style_codes: z.optional(z.union([z.array(z.string()), z.unknown()])),
  seed: z.optional(z.union([z.int(), z.unknown()])),
})

/**
 * ReplaceBackgroundOutputV3
 */
export const zSchemaIdeogramV3ReplaceBackgroundOutput = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for the random number generator',
  }),
})

/**
 * ReplaceBackgroundInputV3
 */
export const zSchemaIdeogramV3ReplaceBackgroundInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Cyber punk city with neon lights and skyscrappers',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'Number of images to generate.',
      }),
    )
    .default(1),
  style: z.optional(
    z.union([z.enum(['AUTO', 'GENERAL', 'REALISTIC', 'DESIGN']), z.unknown()]),
  ),
  style_preset: z.optional(
    z.union([
      z.enum([
        '80S_ILLUSTRATION',
        '90S_NOSTALGIA',
        'ABSTRACT_ORGANIC',
        'ANALOG_NOSTALGIA',
        'ART_BRUT',
        'ART_DECO',
        'ART_POSTER',
        'AURA',
        'AVANT_GARDE',
        'BAUHAUS',
        'BLUEPRINT',
        'BLURRY_MOTION',
        'BRIGHT_ART',
        'C4D_CARTOON',
        'CHILDRENS_BOOK',
        'COLLAGE',
        'COLORING_BOOK_I',
        'COLORING_BOOK_II',
        'CUBISM',
        'DARK_AURA',
        'DOODLE',
        'DOUBLE_EXPOSURE',
        'DRAMATIC_CINEMA',
        'EDITORIAL',
        'EMOTIONAL_MINIMAL',
        'ETHEREAL_PARTY',
        'EXPIRED_FILM',
        'FLAT_ART',
        'FLAT_VECTOR',
        'FOREST_REVERIE',
        'GEO_MINIMALIST',
        'GLASS_PRISM',
        'GOLDEN_HOUR',
        'GRAFFITI_I',
        'GRAFFITI_II',
        'HALFTONE_PRINT',
        'HIGH_CONTRAST',
        'HIPPIE_ERA',
        'ICONIC',
        'JAPANDI_FUSION',
        'JAZZY',
        'LONG_EXPOSURE',
        'MAGAZINE_EDITORIAL',
        'MINIMAL_ILLUSTRATION',
        'MIXED_MEDIA',
        'MONOCHROME',
        'NIGHTLIFE',
        'OIL_PAINTING',
        'OLD_CARTOONS',
        'PAINT_GESTURE',
        'POP_ART',
        'RETRO_ETCHING',
        'RIVIERA_POP',
        'SPOTLIGHT_80S',
        'STYLIZED_RED',
        'SURREAL_COLLAGE',
        'TRAVEL_POSTER',
        'VINTAGE_GEO',
        'VINTAGE_POSTER',
        'WATERCOLOR',
        'WEIRD',
        'WOODBLOCK_PRINT',
      ]),
      z.unknown(),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Determine if MagicPrompt should be used in generating the request or not.',
      }),
    )
    .default(true),
  rendering_speed: z.optional(
    z.enum(['TURBO', 'BALANCED', 'QUALITY']).register(z.globalRegistry, {
      description: 'The rendering speed to use.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  color_palette: z.optional(z.union([zSchemaColorPalette, z.unknown()])),
  style_codes: z.optional(z.union([z.array(z.string()), z.unknown()])),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The image URL whose background needs to be replaced',
  }),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  image_urls: z.optional(z.union([z.array(z.string()), z.unknown()])),
})

/**
 * ReframeOutputV3
 */
export const zSchemaIdeogramV3ReframeOutput = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for the random number generator',
  }),
})

/**
 * ReframeImageInputV3
 */
export const zSchemaIdeogramV3ReframeInput = z.object({
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'Number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.union([
    zSchemaImageSize,
    z.enum([
      'square_hd',
      'square',
      'portrait_4_3',
      'portrait_16_9',
      'landscape_4_3',
      'landscape_16_9',
    ]),
  ]),
  style: z.optional(
    z.union([z.enum(['AUTO', 'GENERAL', 'REALISTIC', 'DESIGN']), z.unknown()]),
  ),
  style_preset: z.optional(
    z.union([
      z.enum([
        '80S_ILLUSTRATION',
        '90S_NOSTALGIA',
        'ABSTRACT_ORGANIC',
        'ANALOG_NOSTALGIA',
        'ART_BRUT',
        'ART_DECO',
        'ART_POSTER',
        'AURA',
        'AVANT_GARDE',
        'BAUHAUS',
        'BLUEPRINT',
        'BLURRY_MOTION',
        'BRIGHT_ART',
        'C4D_CARTOON',
        'CHILDRENS_BOOK',
        'COLLAGE',
        'COLORING_BOOK_I',
        'COLORING_BOOK_II',
        'CUBISM',
        'DARK_AURA',
        'DOODLE',
        'DOUBLE_EXPOSURE',
        'DRAMATIC_CINEMA',
        'EDITORIAL',
        'EMOTIONAL_MINIMAL',
        'ETHEREAL_PARTY',
        'EXPIRED_FILM',
        'FLAT_ART',
        'FLAT_VECTOR',
        'FOREST_REVERIE',
        'GEO_MINIMALIST',
        'GLASS_PRISM',
        'GOLDEN_HOUR',
        'GRAFFITI_I',
        'GRAFFITI_II',
        'HALFTONE_PRINT',
        'HIGH_CONTRAST',
        'HIPPIE_ERA',
        'ICONIC',
        'JAPANDI_FUSION',
        'JAZZY',
        'LONG_EXPOSURE',
        'MAGAZINE_EDITORIAL',
        'MINIMAL_ILLUSTRATION',
        'MIXED_MEDIA',
        'MONOCHROME',
        'NIGHTLIFE',
        'OIL_PAINTING',
        'OLD_CARTOONS',
        'PAINT_GESTURE',
        'POP_ART',
        'RETRO_ETCHING',
        'RIVIERA_POP',
        'SPOTLIGHT_80S',
        'STYLIZED_RED',
        'SURREAL_COLLAGE',
        'TRAVEL_POSTER',
        'VINTAGE_GEO',
        'VINTAGE_POSTER',
        'WATERCOLOR',
        'WEIRD',
        'WOODBLOCK_PRINT',
      ]),
      z.unknown(),
    ]),
  ),
  rendering_speed: z.optional(
    z.enum(['TURBO', 'BALANCED', 'QUALITY']).register(z.globalRegistry, {
      description: 'The rendering speed to use.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  color_palette: z.optional(z.union([zSchemaColorPalette, z.unknown()])),
  style_codes: z.optional(z.union([z.array(z.string()), z.unknown()])),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The image URL to reframe',
  }),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  image_urls: z.optional(z.union([z.array(z.string()), z.unknown()])),
})

/**
 * Img2ImgOutput
 */
export const zSchemaHidreamI1FullImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * ImageToImageInput
 */
export const zSchemaHidreamI1FullImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The image URL to generate an image from.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          'A list of LoRAs to apply to the model. Each LoRA specifies its path, scale, and optional weight name.',
      }),
    )
    .default([]),
  strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Denoising strength for image-to-image generation.',
      }),
    )
    .default(0.75),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(50),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * MiniMaxTextToImageWithReferenceOutput
 */
export const zSchemaMinimaxImage01SubjectReferenceOutput = z.object({
  images: z.array(zSchemaFile).register(z.globalRegistry, {
    description: 'Generated images',
  }),
})

/**
 * MiniMaxTextToImageWithReferenceRequest
 */
export const zSchemaMinimaxImage01SubjectReferenceInput = z.object({
  prompt_optimizer: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable automatic prompt optimization',
      }),
    )
    .default(false),
  aspect_ratio: z.optional(
    z
      .enum(['1:1', '16:9', '4:3', '3:2', '2:3', '3:4', '9:16', '21:9'])
      .register(z.globalRegistry, {
        description: 'Aspect ratio of the generated image',
      }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(9).register(z.globalRegistry, {
        description: 'Number of images to generate (1-9)',
      }),
    )
    .default(1),
  prompt: z.string().min(1).max(1500).register(z.globalRegistry, {
    description: 'Text prompt for image generation (max 1500 characters)',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the subject reference image to use for consistent character appearance',
  }),
})

/**
 * ImageToImageOutput
 */
export const zSchemaRecraftV3ImageToImageOutput = z.object({
  images: z.array(zSchemaFile).register(z.globalRegistry, {
    description: 'The generated images',
  }),
})

/**
 * ImageToImageInput
 */
export const zSchemaRecraftV3ImageToImageInput = z.object({
  prompt: z.string().max(1000).register(z.globalRegistry, {
    description: 'A text description of areas to change.',
  }),
  style: z.optional(
    z
      .enum([
        'any',
        'realistic_image',
        'digital_illustration',
        'vector_illustration',
        'realistic_image/b_and_w',
        'realistic_image/hard_flash',
        'realistic_image/hdr',
        'realistic_image/natural_light',
        'realistic_image/studio_portrait',
        'realistic_image/enterprise',
        'realistic_image/motion_blur',
        'realistic_image/evening_light',
        'realistic_image/faded_nostalgia',
        'realistic_image/forest_life',
        'realistic_image/mystic_naturalism',
        'realistic_image/natural_tones',
        'realistic_image/organic_calm',
        'realistic_image/real_life_glow',
        'realistic_image/retro_realism',
        'realistic_image/retro_snapshot',
        'realistic_image/urban_drama',
        'realistic_image/village_realism',
        'realistic_image/warm_folk',
        'digital_illustration/pixel_art',
        'digital_illustration/hand_drawn',
        'digital_illustration/grain',
        'digital_illustration/infantile_sketch',
        'digital_illustration/2d_art_poster',
        'digital_illustration/handmade_3d',
        'digital_illustration/hand_drawn_outline',
        'digital_illustration/engraving_color',
        'digital_illustration/2d_art_poster_2',
        'digital_illustration/antiquarian',
        'digital_illustration/bold_fantasy',
        'digital_illustration/child_book',
        'digital_illustration/child_books',
        'digital_illustration/cover',
        'digital_illustration/crosshatch',
        'digital_illustration/digital_engraving',
        'digital_illustration/expressionism',
        'digital_illustration/freehand_details',
        'digital_illustration/grain_20',
        'digital_illustration/graphic_intensity',
        'digital_illustration/hard_comics',
        'digital_illustration/long_shadow',
        'digital_illustration/modern_folk',
        'digital_illustration/multicolor',
        'digital_illustration/neon_calm',
        'digital_illustration/noir',
        'digital_illustration/nostalgic_pastel',
        'digital_illustration/outline_details',
        'digital_illustration/pastel_gradient',
        'digital_illustration/pastel_sketch',
        'digital_illustration/pop_art',
        'digital_illustration/pop_renaissance',
        'digital_illustration/street_art',
        'digital_illustration/tablet_sketch',
        'digital_illustration/urban_glow',
        'digital_illustration/urban_sketching',
        'digital_illustration/vanilla_dreams',
        'digital_illustration/young_adult_book',
        'digital_illustration/young_adult_book_2',
        'vector_illustration/bold_stroke',
        'vector_illustration/chemistry',
        'vector_illustration/colored_stencil',
        'vector_illustration/contour_pop_art',
        'vector_illustration/cosmics',
        'vector_illustration/cutout',
        'vector_illustration/depressive',
        'vector_illustration/editorial',
        'vector_illustration/emotional_flat',
        'vector_illustration/infographical',
        'vector_illustration/marker_outline',
        'vector_illustration/mosaic',
        'vector_illustration/naivector',
        'vector_illustration/roundish_flat',
        'vector_illustration/segmented_colors',
        'vector_illustration/sharp_contrast',
        'vector_illustration/thin',
        'vector_illustration/vector_photo',
        'vector_illustration/vivid_shapes',
        'vector_illustration/engraving',
        'vector_illustration/line_art',
        'vector_illustration/line_circuit',
        'vector_illustration/linocut',
      ])
      .register(z.globalRegistry, {
        description:
          'The style of the generated images. Vector images cost 2X as much.',
      }),
  ),
  style_id: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The ID of the custom style reference (optional)',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the image to modify. Must be less than 5 MB in size, have resolution less than 16 MP and max dimension less than 4096 pixels.',
  }),
  strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Defines the difference with the original image, should lie in [0, 1], where 0 means almost identical, and 1 means miserable similarity',
      }),
    )
    .default(0.5),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  colors: z
    .optional(
      z.array(zSchemaRgbColor).register(z.globalRegistry, {
        description: 'An array of preferable colors',
      }),
    )
    .default([]),
  negative_prompt: z.optional(
    z.string().max(1000).register(z.globalRegistry, {
      description: 'A text description of undesired elements on an image',
    }),
  ),
})

/**
 * UpscaleOutput
 */
export const zSchemaRecraftUpscaleCrispOutput = z.object({
  image: zSchemaFile,
})

/**
 * UpscaleInput
 */
export const zSchemaRecraftUpscaleCrispInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to be upscaled. Must be in PNG format.',
  }),
})

/**
 * UpscaleOutput
 */
export const zSchemaRecraftUpscaleCreativeOutput = z.object({
  image: zSchemaFile,
})

/**
 * UpscaleInput
 */
export const zSchemaRecraftUpscaleCreativeInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to be upscaled. Must be in PNG format.',
  }),
})

/**
 * ImageOutput
 */
export const zSchemaRembgEnhanceOutput = z.object({
  image: zSchemaFile,
})

/**
 * ImageInput
 */
export const zSchemaRembgEnhanceInput = z.object({
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the input image',
  }),
})

/**
 * ImageEditOutput
 */
export const zSchemaBagelEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The edited images.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * ImageEditInput
 */
export const zSchemaBagelEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image with.',
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed to use for the generation.',
    }),
  ),
  use_thought: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to use thought tokens for generation. If set to true, the model will "think" to potentially improve generation quality. Increases generation time and increases the cost by 20%.',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The image to edit.',
  }),
})

/**
 * KontextEditOutput
 */
export const zSchemaFluxKontextDevOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * BaseKontextEditInput
 */
export const zSchemaFluxKontextDevInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image.',
  }),
  resolution_mode: z.optional(
    z
      .enum([
        'auto',
        'match_input',
        '1:1',
        '16:9',
        '21:9',
        '3:2',
        '2:3',
        '4:5',
        '5:4',
        '3:4',
        '4:3',
        '9:16',
        '9:21',
      ])
      .register(z.globalRegistry, {
        description:
          "\n             Determines how the output resolution is set for image editing.\n             - `auto`: The model selects an optimal resolution from a predefined set that best matches the input image's aspect ratio. This is the recommended setting for most use cases as it's what the model was trained on.\n             - `match_input`: The model will attempt to use the same resolution as the input image. The resolution will be adjusted to be compatible with the model's requirements (e.g. dimensions must be multiples of 16 and within supported limits).\n             Apart from these, a few aspect ratios are also supported.\n             ",
      }),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'Output format',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to edit.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(2.5),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
})

/**
 * Image
 *
 * Represents an image file.
 */
export const zSchemaFalToolkitImageImageImage = z
  .object({
    file_size: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The size of the file in bytes.',
      }),
    ),
    height: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The height of the image in pixels.',
      }),
    ),
    url: z.string().register(z.globalRegistry, {
      description: 'The URL where the file can be downloaded from.',
    }),
    width: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The width of the image in pixels.',
      }),
    ),
    file_name: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The name of the file. It will be auto-generated if not provided.',
      }),
    ),
    content_type: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The mime type of the file.',
      }),
    ),
    file_data: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'File data',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Represents an image file.',
  })

/**
 * FluxKontextOutput
 */
export const zSchemaFluxProKontextMaxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaFalToolkitImageImageImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * FluxKontextInput
 */
export const zSchemaFluxProKontextMaxInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image prompt for the omni model.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enhance the prompt for better results.',
      }),
    )
    .default(false),
})

/**
 * Output
 */
export const zSchemaFluxProKontextMultiOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z
    .array(zSchemaRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: 'The generated image files info.',
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * FluxKontextMultiInput
 */
export const zSchemaFluxProKontextMultiInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: 'Image prompt for the omni model.',
  }),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enhance the prompt for better results.',
      }),
    )
    .default(false),
})

/**
 * Output
 */
export const zSchemaFluxProKontextMaxMultiOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z
    .array(zSchemaRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: 'The generated image files info.',
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * FluxKontextMultiInput
 */
export const zSchemaFluxProKontextMaxMultiInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: 'Image prompt for the omni model.',
  }),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enhance the prompt for better results.',
      }),
    )
    .default(false),
})

/**
 * AgeProgressionOutput
 */
export const zSchemaImageEditingAgeProgressionOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * AgeProgressionInput
 */
export const zSchemaImageEditingAgeProgressionInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The age change to apply.',
      }),
    )
    .default('20 years older'),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image prompt for the omni model.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps for sampling.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The same seed and the same prompt given to the same version of the model will output the same image every time.',
    }),
  ),
})

/**
 * BackgroundChangeOutput
 */
export const zSchemaImageEditingBackgroundChangeOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * BackgroundChangeInput
 */
export const zSchemaImageEditingBackgroundChangeInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The desired background to apply.',
      }),
    )
    .default('beach sunset with palm trees'),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image prompt for the omni model.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps for sampling.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The same seed and the same prompt given to the same version of the model will output the same image every time.',
    }),
  ),
})

/**
 * CartoonifyOutput
 */
export const zSchemaImageEditingCartoonifyOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * BaseInput
 */
export const zSchemaImageEditingCartoonifyInput = z.object({
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image prompt for the omni model.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps for sampling.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The same seed and the same prompt given to the same version of the model will output the same image every time.',
    }),
  ),
})

/**
 * ColorCorrectionOutput
 */
export const zSchemaImageEditingColorCorrectionOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * BaseInput
 */
export const zSchemaImageEditingColorCorrectionInput = z.object({
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image prompt for the omni model.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps for sampling.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The same seed and the same prompt given to the same version of the model will output the same image every time.',
    }),
  ),
})

/**
 * ExpressionChangeOutput
 */
export const zSchemaImageEditingExpressionChangeOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * ExpressionChangeInput
 */
export const zSchemaImageEditingExpressionChangeInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The desired facial expression to apply.',
      }),
    )
    .default('sad'),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image prompt for the omni model.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps for sampling.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The same seed and the same prompt given to the same version of the model will output the same image every time.',
    }),
  ),
})

/**
 * FaceEnhancementOutput
 */
export const zSchemaImageEditingFaceEnhancementOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * BaseInput
 */
export const zSchemaImageEditingFaceEnhancementInput = z.object({
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image prompt for the omni model.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps for sampling.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The same seed and the same prompt given to the same version of the model will output the same image every time.',
    }),
  ),
})

/**
 * HairChangeOutput
 */
export const zSchemaImageEditingHairChangeOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * HairChangeInput
 */
export const zSchemaImageEditingHairChangeInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The desired hair style to apply.',
      }),
    )
    .default('bald'),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image prompt for the omni model.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps for sampling.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The same seed and the same prompt given to the same version of the model will output the same image every time.',
    }),
  ),
})

/**
 * ObjectRemovalOutput
 */
export const zSchemaImageEditingObjectRemovalOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * ObjectRemovalInput
 */
export const zSchemaImageEditingObjectRemovalInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Specify which objects to remove from the image.',
      }),
    )
    .default('background people'),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image prompt for the omni model.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps for sampling.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The same seed and the same prompt given to the same version of the model will output the same image every time.',
    }),
  ),
})

/**
 * ProfessionalPhotoOutput
 */
export const zSchemaImageEditingProfessionalPhotoOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * BaseInput
 */
export const zSchemaImageEditingProfessionalPhotoInput = z.object({
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image prompt for the omni model.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps for sampling.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The same seed and the same prompt given to the same version of the model will output the same image every time.',
    }),
  ),
})

/**
 * SceneCompositionOutput
 */
export const zSchemaImageEditingSceneCompositionOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * SceneCompositionInput
 */
export const zSchemaImageEditingSceneCompositionInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Describe the scene where you want to place the subject.',
      }),
    )
    .default('enchanted forest'),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image prompt for the omni model.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps for sampling.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The same seed and the same prompt given to the same version of the model will output the same image every time.',
    }),
  ),
})

/**
 * StyleTransferOutput
 */
export const zSchemaImageEditingStyleTransferOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * StyleTransferInput
 */
export const zSchemaImageEditingStyleTransferInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The artistic style to apply.',
      }),
    )
    .default("Van Gogh's Starry Night"),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image prompt for the omni model.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps for sampling.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The same seed and the same prompt given to the same version of the model will output the same image every time.',
    }),
  ),
})

/**
 * TimeOfDayOutput
 */
export const zSchemaImageEditingTimeOfDayOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * TimeOfDayInput
 */
export const zSchemaImageEditingTimeOfDayInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The time of day to transform the scene to.',
      }),
    )
    .default('golden hour'),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image prompt for the omni model.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps for sampling.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The same seed and the same prompt given to the same version of the model will output the same image every time.',
    }),
  ),
})

/**
 * WeatherEffectOutput
 */
export const zSchemaImageEditingWeatherEffectOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * WeatherEffectInput
 */
export const zSchemaImageEditingWeatherEffectInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The weather effect to apply.',
      }),
    )
    .default('heavy snowfall'),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image prompt for the omni model.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps for sampling.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The same seed and the same prompt given to the same version of the model will output the same image every time.',
    }),
  ),
})

/**
 * PhotoRestorationOutput
 */
export const zSchemaImageEditingPhotoRestorationOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * PhotoRestorationInput
 *
 * Input model for photo restoration endpoint.
 */
export const zSchemaImageEditingPhotoRestorationInput = z
  .object({
    aspect_ratio: z.optional(
      z
        .enum([
          '21:9',
          '16:9',
          '4:3',
          '3:2',
          '1:1',
          '2:3',
          '3:4',
          '9:16',
          '9:21',
        ])
        .register(z.globalRegistry, {
          description: 'The aspect ratio of the generated image.',
        }),
    ),
    output_format: z.optional(
      z.enum(['jpeg', 'png']).register(z.globalRegistry, {
        description: 'The format of the generated image.',
      }),
    ),
    image_url: z.string().register(z.globalRegistry, {
      description: 'URL of the old or damaged photo to restore.',
    }),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
        }),
      )
      .default(false),
    safety_tolerance: z.optional(
      z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
        description:
          'The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.',
      }),
    ),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
        }),
      )
      .default(3.5),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'Number of inference steps for sampling.',
        }),
      )
      .default(30),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          'The same seed and the same prompt given to the same version of the model will output the same image every time.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Input model for photo restoration endpoint.',
  })

/**
 * TextRemovalOutput
 */
export const zSchemaImageEditingTextRemovalOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * TextRemovalInput
 *
 * Input model for text removal endpoint.
 */
export const zSchemaImageEditingTextRemovalInput = z
  .object({
    aspect_ratio: z.optional(
      z
        .enum([
          '21:9',
          '16:9',
          '4:3',
          '3:2',
          '1:1',
          '2:3',
          '3:4',
          '9:16',
          '9:21',
        ])
        .register(z.globalRegistry, {
          description: 'The aspect ratio of the generated image.',
        }),
    ),
    output_format: z.optional(
      z.enum(['jpeg', 'png']).register(z.globalRegistry, {
        description: 'The format of the generated image.',
      }),
    ),
    image_url: z.string().register(z.globalRegistry, {
      description: 'URL of the image containing text to be removed.',
    }),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
        }),
      )
      .default(false),
    safety_tolerance: z.optional(
      z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
        description:
          'The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.',
      }),
    ),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
        }),
      )
      .default(3.5),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'Number of inference steps for sampling.',
        }),
      )
      .default(30),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          'The same seed and the same prompt given to the same version of the model will output the same image every time.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Input model for text removal endpoint.',
  })

/**
 * Output
 */
export const zSchemaFlux1DevImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseFlux1ImageToInput
 */
export const zSchemaFlux1DevImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate an image from.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength of the initial image. Higher strength values are better for this model.',
      }),
    )
    .default(0.95),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(40),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ',
      }),
    )
    .default(3.5),
})

/**
 * Output
 */
export const zSchemaFlux1DevReduxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseFlux1ReduxInput
 */
export const zSchemaFlux1DevReduxInput = z.object({
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate an image from.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ',
      }),
    )
    .default(3.5),
})

/**
 * Output
 */
export const zSchemaFlux1SchnellReduxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * SchnellFlux1ReduxInput
 */
export const zSchemaFlux1SchnellReduxInput = z.object({
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate an image from.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(12).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(4),
  seed: z.optional(z.union([z.int(), z.unknown()])),
})

/**
 * T2IOutput
 */
export const zSchemaLumaPhotonReframeOutput = z.object({
  images: z.array(zSchemaFile).register(z.globalRegistry, {
    description: 'The generated image',
  }),
})

/**
 * ReframeImageRequest
 */
export const zSchemaLumaPhotonReframeInput = z.object({
  prompt: z.optional(
    z.string().min(3).max(5000).register(z.globalRegistry, {
      description: 'Optional prompt for reframing',
    }),
  ),
  aspect_ratio: z
    .enum(['1:1', '16:9', '9:16', '4:3', '3:4', '21:9', '9:21'])
    .register(z.globalRegistry, {
      description: 'The aspect ratio of the reframed image',
    }),
  y_start: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Start Y coordinate for reframing',
    }),
  ),
  x_end: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'End X coordinate for reframing',
    }),
  ),
  y_end: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'End Y coordinate for reframing',
    }),
  ),
  grid_position_y: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Y position of the grid for reframing',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the input image to reframe',
  }),
  grid_position_x: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'X position of the grid for reframing',
    }),
  ),
  x_start: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Start X coordinate for reframing',
    }),
  ),
})

/**
 * T2IOutput
 */
export const zSchemaLumaPhotonFlashReframeOutput = z.object({
  images: z.array(zSchemaFile).register(z.globalRegistry, {
    description: 'The generated image',
  }),
})

/**
 * ReframeImageRequest
 */
export const zSchemaLumaPhotonFlashReframeInput = z.object({
  prompt: z.optional(
    z.string().min(3).max(5000).register(z.globalRegistry, {
      description: 'Optional prompt for reframing',
    }),
  ),
  aspect_ratio: z
    .enum(['1:1', '16:9', '9:16', '4:3', '3:4', '21:9', '9:21'])
    .register(z.globalRegistry, {
      description: 'The aspect ratio of the reframed image',
    }),
  y_start: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Start Y coordinate for reframing',
    }),
  ),
  x_end: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'End X coordinate for reframing',
    }),
  ),
  y_end: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'End Y coordinate for reframing',
    }),
  ),
  grid_position_y: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Y position of the grid for reframing',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the input image to reframe',
  }),
  grid_position_x: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'X position of the grid for reframing',
    }),
  ),
  x_start: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Start X coordinate for reframing',
    }),
  ),
})

/**
 * BabyVersionOutput
 */
export const zSchemaImageEditingBabyVersionOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * BabyVersionInput
 *
 * Input model for baby version endpoint.
 */
export const zSchemaImageEditingBabyVersionInput = z
  .object({
    aspect_ratio: z.optional(
      z
        .enum([
          '21:9',
          '16:9',
          '4:3',
          '3:2',
          '1:1',
          '2:3',
          '3:4',
          '9:16',
          '9:21',
        ])
        .register(z.globalRegistry, {
          description: 'The aspect ratio of the generated image.',
        }),
    ),
    output_format: z.optional(
      z.enum(['jpeg', 'png']).register(z.globalRegistry, {
        description: 'The format of the generated image.',
      }),
    ),
    image_url: z.string().register(z.globalRegistry, {
      description: 'URL of the image to transform into a baby version.',
    }),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
        }),
      )
      .default(false),
    safety_tolerance: z.optional(
      z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
        description:
          'The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.',
      }),
    ),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
        }),
      )
      .default(3.5),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'Number of inference steps for sampling.',
        }),
      )
      .default(30),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          'The same seed and the same prompt given to the same version of the model will output the same image every time.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Input model for baby version endpoint.',
  })

/**
 * ReframeOutput
 */
export const zSchemaImageEditingReframeOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * ReframeInput
 */
export const zSchemaImageEditingReframeInput = z.object({
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The desired aspect ratio for the reframed image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the old or damaged photo to restore.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 6 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps for sampling.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The same seed and the same prompt given to the same version of the model will output the same image every time.',
    }),
  ),
})

/**
 * T2IOutput
 */
export const zSchemaLumaPhotonModifyOutput = z.object({
  images: z.array(zSchemaFile).register(z.globalRegistry, {
    description: 'The generated image',
  }),
})

/**
 * ModifyImageRequest
 */
export const zSchemaLumaPhotonModifyInput = z.object({
  prompt: z.optional(
    z.string().min(3).max(5000).register(z.globalRegistry, {
      description: 'Instruction for modifying the image',
    }),
  ),
  aspect_ratio: z
    .enum(['1:1', '16:9', '9:16', '4:3', '3:4', '21:9', '9:21'])
    .register(z.globalRegistry, {
      description: 'The aspect ratio of the reframed image',
    }),
  strength: z.number().gte(0).lte(1).register(z.globalRegistry, {
    description:
      'The strength of the initial image. Higher strength values are corresponding to more influence of the initial image on the output.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the input image to reframe',
  }),
})

/**
 * T2IOutput
 */
export const zSchemaLumaPhotonFlashModifyOutput = z.object({
  images: z.array(zSchemaFile).register(z.globalRegistry, {
    description: 'The generated image',
  }),
})

/**
 * ModifyImageRequest
 */
export const zSchemaLumaPhotonFlashModifyInput = z.object({
  prompt: z.optional(
    z.string().min(3).max(5000).register(z.globalRegistry, {
      description: 'Instruction for modifying the image',
    }),
  ),
  aspect_ratio: z
    .enum(['1:1', '16:9', '9:16', '4:3', '3:4', '21:9', '9:21'])
    .register(z.globalRegistry, {
      description: 'The aspect ratio of the reframed image',
    }),
  strength: z.number().gte(0).lte(1).register(z.globalRegistry, {
    description:
      'The strength of the initial image. Higher strength values are corresponding to more influence of the initial image on the output.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the input image to reframe',
  }),
})

/**
 * FrameOutput
 */
export const zSchemaFfmpegApiExtractFrameOutput = z.object({
  images: z.array(zSchemaImage),
})

/**
 * FrameInput
 */
export const zSchemaFfmpegApiExtractFrameInput = z.object({
  video_url: z.string().register(z.globalRegistry, {
    description: 'URL of the video file to use as the video track',
  }),
  frame_type: z.optional(
    z.enum(['first', 'middle', 'last']).register(z.globalRegistry, {
      description:
        'Type of frame to extract: first, middle, or last frame of the video',
    }),
  ),
})

/**
 * VectorizeOutput
 */
export const zSchemaRecraftVectorizeOutput = z.object({
  image: zSchemaFile,
})

/**
 * VectorizeInput
 */
export const zSchemaRecraftVectorizeInput = z.object({
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the image to be vectorized. Must be in PNG, JPG or WEBP format, less than 5 MB in size, have resolution less than 16 MP and max dimension less than 4096 pixels, min dimension more than 256 pixels.',
  }),
})

/**
 * Output
 */
export const zSchemaObjectRemovalOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images with objects removed.',
  }),
})

/**
 * PromptInput
 */
export const zSchemaObjectRemovalInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text description of the object to remove.',
  }),
  mask_expansion: z
    .optional(
      z.int().gte(0).lte(50).register(z.globalRegistry, {
        description: 'Amount of pixels to expand the mask by. Range: 0-50',
      }),
    )
    .default(15),
  model: z.optional(
    z.enum(['low_quality', 'medium_quality', 'high_quality', 'best_quality']),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to remove objects from.',
  }),
})

/**
 * Output
 */
export const zSchemaObjectRemovalMaskOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images with objects removed.',
  }),
})

/**
 * MaskInput
 */
export const zSchemaObjectRemovalMaskInput = z.object({
  model: z.optional(
    z.enum(['low_quality', 'medium_quality', 'high_quality', 'best_quality']),
  ),
  mask_expansion: z
    .optional(
      z.int().gte(0).lte(50).register(z.globalRegistry, {
        description: 'Amount of pixels to expand the mask by. Range: 0-50',
      }),
    )
    .default(15),
  mask_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the mask image. White pixels (255) indicate areas to remove.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to remove objects from.',
  }),
})

/**
 * BBoxPromptBase
 */
export const zSchemaBBoxPromptBase = z.object({
  y_min: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Y Min Coordinate of the box (0-1)',
      }),
    )
    .default(0),
  x_max: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'X Max Coordinate of the prompt (0-1)',
      }),
    )
    .default(0),
  x_min: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'X Min Coordinate of the box (0-1)',
      }),
    )
    .default(0),
  y_max: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Y Max Coordinate of the prompt (0-1)',
      }),
    )
    .default(0),
})

/**
 * Output
 */
export const zSchemaObjectRemovalBboxOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images with objects removed.',
  }),
})

/**
 * BboxInput
 */
export const zSchemaObjectRemovalBboxInput = z.object({
  model: z.optional(
    z.enum(['low_quality', 'medium_quality', 'high_quality', 'best_quality']),
  ),
  mask_expansion: z
    .optional(
      z.int().gte(0).lte(50).register(z.globalRegistry, {
        description: 'Amount of pixels to expand the mask by. Range: 0-50',
      }),
    )
    .default(15),
  box_prompts: z
    .optional(
      z.array(zSchemaBBoxPromptBase).register(z.globalRegistry, {
        description:
          'List of bounding box coordinates to erase (only one box prompt is supported)',
      }),
    )
    .default([]),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to remove objects from.',
  }),
})

/**
 * Output
 */
export const zSchemaPasdOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated super-resolved images',
  }),
  timings: z.optional(
    z.record(z.string(), z.number()).register(z.globalRegistry, {
      description: 'Timing information for different processing stages',
    }),
  ),
})

/**
 * Input
 */
export const zSchemaPasdInput = z.object({
  conditioning_scale: z
    .optional(
      z.number().gte(0.1).lte(1).register(z.globalRegistry, {
        description: 'ControlNet conditioning scale (0.1-1.0)',
      }),
    )
    .default(0.8),
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Additional prompt to guide super-resolution',
      }),
    )
    .default(''),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Input image to super-resolve',
  }),
  steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps (10-50)',
      }),
    )
    .default(25),
  scale: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'Upscaling factor (1-4x)',
      }),
    )
    .default(2),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for diffusion (1.0-20.0)',
      }),
    )
    .default(7),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt to avoid unwanted artifacts',
      }),
    )
    .default(
      'blurry, dirty, messy, frames, deformed, dotted, noise, raster lines, unclear, lowres, over-smoothed, painting, ai generated',
    ),
})

/**
 * Output
 */
export const zSchemaChainOfZoomOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'List of intermediate images',
  }),
  zoom_center: z.array(z.number()).register(z.globalRegistry, {
    description: 'Center coordinates used for zoom',
  }),
  scale: z.number().register(z.globalRegistry, {
    description: 'Actual linear zoom scale applied',
  }),
})

/**
 * Input
 */
export const zSchemaChainOfZoomInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  center_y: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Y coordinate of zoom center (0-1)',
      }),
    )
    .default(0.5),
  scale: z
    .optional(
      z.number().gte(1).lte(8).register(z.globalRegistry, {
        description: 'Zoom scale in powers of 2',
      }),
    )
    .default(5),
  center_x: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'X coordinate of zoom center (0-1)',
      }),
    )
    .default(0.5),
  user_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Additional prompt text to guide the zoom enhancement',
      }),
    )
    .default(''),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Input image to zoom into',
  }),
})

/**
 * V16Output
 */
export const zSchemaFashnTryonV16Output = z.object({
  images: z.array(zSchemaFile),
})

/**
 * V16Input
 */
export const zSchemaFashnTryonV16Input = z.object({
  model_image: z.string().register(z.globalRegistry, {
    description: 'URL or base64 of the model image',
  }),
  moderation_level: z.optional(
    z.enum(['none', 'permissive', 'conservative']).register(z.globalRegistry, {
      description:
        "Content moderation level for garment images. 'none' disables moderation, 'permissive' blocks only explicit content, 'conservative' also blocks underwear and swimwear.",
    }),
  ),
  garment_photo_type: z.optional(
    z.enum(['auto', 'model', 'flat-lay']).register(z.globalRegistry, {
      description:
        "Specifies the type of garment photo to optimize internal parameters for better performance. 'model' is for photos of garments on a model, 'flat-lay' is for flat-lay or ghost mannequin images, and 'auto' attempts to automatically detect the photo type.",
    }),
  ),
  garment_image: z.string().register(z.globalRegistry, {
    description: 'URL or base64 of the garment image',
  }),
  category: z.optional(
    z
      .enum(['tops', 'bottoms', 'one-pieces', 'auto'])
      .register(z.globalRegistry, {
        description:
          "Category of the garment to try-on. 'auto' will attempt to automatically detect the category of the garment.",
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  segmentation_free: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Disables human parsing on the model image.',
      }),
    )
    .default(true),
  num_samples: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'Number of images to generate in a single run. Image generation has a random element in it, so trying multiple images at once increases the chances of getting a good result.',
      }),
    )
    .default(1),
  mode: z.optional(
    z.enum(['performance', 'balanced', 'quality']).register(z.globalRegistry, {
      description:
        "Specifies the mode of operation. 'performance' mode is faster but may sacrifice quality, 'balanced' mode is a balance between speed and quality, and 'quality' mode is slower but produces higher quality results.",
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Sets random operations to a fixed state. Use the same seed to reproduce results with the same inputs, or different seed to force different results.',
    }),
  ),
  output_format: z.optional(
    z.enum(['png', 'jpeg']).register(z.globalRegistry, {
      description:
        "Output format of the generated images. 'png' is highest quality, while 'jpeg' is faster",
    }),
  ),
})

/**
 * KontextEditOutput
 */
export const zSchemaFluxKontextLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseKontextEditInput
 */
export const zSchemaFluxKontextLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  resolution_mode: z.optional(
    z
      .enum([
        'auto',
        'match_input',
        '1:1',
        '16:9',
        '21:9',
        '3:2',
        '2:3',
        '4:5',
        '5:4',
        '3:4',
        '4:3',
        '9:16',
        '9:21',
      ])
      .register(z.globalRegistry, {
        description:
          "\n            Determines how the output resolution is set for image editing.\n            - `auto`: The model selects an optimal resolution from a predefined set that best matches the input image's aspect ratio. This is the recommended setting for most use cases as it's what the model was trained on.\n            - `match_input`: The model will attempt to use the same resolution as the input image. The resolution will be adjusted to be compatible with the model's requirements (e.g. dimensions must be multiples of 16 and within supported limits).\n            Apart from these, a few aspect ratios are also supported.\n            ",
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the image to edit.\n\nMax width: 14142px, Max height: 14142px, Timeout: 20s',
  }),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(2.5),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(30),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * PlushieStyleOutput
 */
export const zSchemaImageEditingPlushieStyleOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * PlushieStyleInput
 *
 * Input model for plushie style endpoint.
 */
export const zSchemaImageEditingPlushieStyleInput = z
  .object({
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(1),
    image_url: z.string().register(z.globalRegistry, {
      description: 'URL of the image to convert to plushie style.',
    }),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
        }),
      )
      .default(3.5),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          'The same seed and the same prompt given to the same version of the model will output the same image every time.',
      }),
    ),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'Number of inference steps for sampling.',
        }),
      )
      .default(30),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: 'Input model for plushie style endpoint.',
  })

/**
 * WojakStyleOutput
 */
export const zSchemaImageEditingWojakStyleOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * WojakStyleInput
 *
 * Input model for wojak style endpoint.
 */
export const zSchemaImageEditingWojakStyleInput = z
  .object({
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(1),
    image_url: z.string().register(z.globalRegistry, {
      description: 'URL of the image to convert to wojak style.',
    }),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
        }),
      )
      .default(3.5),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          'The same seed and the same prompt given to the same version of the model will output the same image every time.',
      }),
    ),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'Number of inference steps for sampling.',
        }),
      )
      .default(30),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: 'Input model for wojak style endpoint.',
  })

/**
 * BroccoliHaircutOutput
 */
export const zSchemaImageEditingBroccoliHaircutOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * BroccoliHaircutInput
 *
 * Input model for broccoli haircut endpoint.
 */
export const zSchemaImageEditingBroccoliHaircutInput = z
  .object({
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(1),
    image_url: z.string().register(z.globalRegistry, {
      description: 'URL of the image to apply broccoli haircut style.',
    }),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
        }),
      )
      .default(3.5),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          'The same seed and the same prompt given to the same version of the model will output the same image every time.',
      }),
    ),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'Number of inference steps for sampling.',
        }),
      )
      .default(30),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: 'Input model for broccoli haircut endpoint.',
  })

/**
 * ImageUpscaleOutput
 */
export const zSchemaTopazUpscaleImageOutput = z.object({
  image: zSchemaFile,
})

/**
 * ImageUpscaleRequest
 */
export const zSchemaTopazUpscaleImageInput = z.object({
  face_enhancement_creativity: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Creativity level for face enhancement. 0.0 means no creativity, 1.0 means maximum creativity. Ignored if face ehnancement is disabled.',
      }),
    )
    .default(0),
  face_enhancement_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Strength of the face enhancement. 0.0 means no enhancement, 1.0 means maximum enhancement. Ignored if face ehnancement is disabled.',
      }),
    )
    .default(0.8),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'Output format of the upscaled image.',
    }),
  ),
  face_enhancement: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to apply face enhancement to the image.',
      }),
    )
    .default(true),
  subject_detection: z.optional(
    z.enum(['All', 'Foreground', 'Background']).register(z.globalRegistry, {
      description: 'Subject detection mode for the image enhancement.',
    }),
  ),
  model: z.optional(
    z
      .enum([
        'Low Resolution V2',
        'Standard V2',
        'CGI',
        'High Fidelity V2',
        'Text Refine',
        'Recovery',
        'Redefine',
        'Recovery V2',
      ])
      .register(z.globalRegistry, {
        description: 'Model to use for image enhancement.',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Url of the image to be upscaled',
  }),
  upscale_factor: z
    .optional(
      z.number().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'Factor to upscale the video by (e.g. 2.0 doubles width and height)',
      }),
    )
    .default(2),
  crop_to_fill: z.optional(z.boolean()).default(false),
})

/**
 * YouTubeThumbnailsOutput
 */
export const zSchemaImageEditingYoutubeThumbnailsOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * YouTubeThumbnailsInput
 *
 * Input model for YouTube thumbnails endpoint.
 */
export const zSchemaImageEditingYoutubeThumbnailsInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The text to include in the YouTube thumbnail.',
        }),
      )
      .default('Generate youtube thumbnails'),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(0.5),
    image_url: z.string().register(z.globalRegistry, {
      description: 'URL of the image to convert to YouTube thumbnail style.',
    }),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
        }),
      )
      .default(3.5),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          'The same seed and the same prompt given to the same version of the model will output the same image every time.',
      }),
    ),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'Number of inference steps for sampling.',
        }),
      )
      .default(30),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: 'Input model for YouTube thumbnails endpoint.',
  })

/**
 * BlurOutput
 */
export const zSchemaPostProcessingBlurOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The processed images with blur effect',
  }),
})

/**
 * BlurInput
 */
export const zSchemaPostProcessingBlurInput = z.object({
  blur_sigma: z
    .optional(
      z.number().gte(0.1).lte(10).register(z.globalRegistry, {
        description: 'Sigma for Gaussian blur',
      }),
    )
    .default(1),
  blur_radius: z
    .optional(
      z.int().gte(0).lte(31).register(z.globalRegistry, {
        description: 'Blur radius',
      }),
    )
    .default(3),
  blur_type: z.optional(
    z.enum(['gaussian', 'kuwahara']).register(z.globalRegistry, {
      description: 'Type of blur to apply',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to process',
  }),
})

/**
 * ChromaticAberrationOutput
 */
export const zSchemaPostProcessingChromaticAberrationOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The processed images with chromatic aberration effect',
  }),
})

/**
 * ChromaticAberrationInput
 */
export const zSchemaPostProcessingChromaticAberrationInput = z.object({
  blue_shift: z
    .optional(
      z.int().gte(-20).lte(20).register(z.globalRegistry, {
        description: 'Blue channel shift amount',
      }),
    )
    .default(0),
  red_shift: z
    .optional(
      z.int().gte(-20).lte(20).register(z.globalRegistry, {
        description: 'Red channel shift amount',
      }),
    )
    .default(0),
  green_direction: z.optional(
    z.enum(['horizontal', 'vertical']).register(z.globalRegistry, {
      description: 'Green channel shift direction',
    }),
  ),
  blue_direction: z.optional(
    z.enum(['horizontal', 'vertical']).register(z.globalRegistry, {
      description: 'Blue channel shift direction',
    }),
  ),
  red_direction: z.optional(
    z.enum(['horizontal', 'vertical']).register(z.globalRegistry, {
      description: 'Red channel shift direction',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to process',
  }),
  green_shift: z
    .optional(
      z.int().gte(-20).lte(20).register(z.globalRegistry, {
        description: 'Green channel shift amount',
      }),
    )
    .default(0),
})

/**
 * ColorCorrectionOutput
 */
export const zSchemaPostProcessingColorCorrectionOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The processed images with color correction',
  }),
})

/**
 * ColorCorrectionInput
 */
export const zSchemaPostProcessingColorCorrectionInput = z.object({
  gamma: z
    .optional(
      z.number().gte(0.2).lte(2.2).register(z.globalRegistry, {
        description: 'Gamma adjustment',
      }),
    )
    .default(1),
  saturation: z
    .optional(
      z.number().gte(-100).lte(100).register(z.globalRegistry, {
        description: 'Saturation adjustment',
      }),
    )
    .default(0),
  temperature: z
    .optional(
      z.number().gte(-100).lte(100).register(z.globalRegistry, {
        description: 'Color temperature adjustment',
      }),
    )
    .default(0),
  brightness: z
    .optional(
      z.number().gte(-100).lte(100).register(z.globalRegistry, {
        description: 'Brightness adjustment',
      }),
    )
    .default(0),
  contrast: z
    .optional(
      z.number().gte(-100).lte(100).register(z.globalRegistry, {
        description: 'Contrast adjustment',
      }),
    )
    .default(0),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to process',
  }),
})

/**
 * ColorTintOutput
 */
export const zSchemaPostProcessingColorTintOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The processed images with color tint effect',
  }),
})

/**
 * ColorTintInput
 */
export const zSchemaPostProcessingColorTintInput = z.object({
  tint_strength: z
    .optional(
      z.number().gte(0.1).lte(1).register(z.globalRegistry, {
        description: 'Tint strength',
      }),
    )
    .default(1),
  tint_mode: z.optional(
    z
      .enum([
        'sepia',
        'red',
        'green',
        'blue',
        'cyan',
        'magenta',
        'yellow',
        'purple',
        'orange',
        'warm',
        'cool',
        'lime',
        'navy',
        'vintage',
        'rose',
        'teal',
        'maroon',
        'peach',
        'lavender',
        'olive',
      ])
      .register(z.globalRegistry, {
        description: 'Tint color mode',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to process',
  }),
})

/**
 * DesaturateOutput
 */
export const zSchemaPostProcessingDesaturateOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The processed images with desaturation effect',
  }),
})

/**
 * DesaturateInput
 */
export const zSchemaPostProcessingDesaturateInput = z.object({
  desaturate_method: z.optional(
    z
      .enum([
        'luminance (Rec.709)',
        'luminance (Rec.601)',
        'average',
        'lightness',
      ])
      .register(z.globalRegistry, {
        description: 'Desaturation method',
      }),
  ),
  desaturate_factor: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Desaturation factor',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to process',
  }),
})

/**
 * DissolveOutput
 */
export const zSchemaPostProcessingDissolveOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The processed images with dissolve effect',
  }),
})

/**
 * DissolveInput
 */
export const zSchemaPostProcessingDissolveInput = z.object({
  dissolve_factor: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Dissolve blend factor',
      }),
    )
    .default(0.5),
  dissolve_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of second image for dissolve',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to process',
  }),
})

/**
 * DodgeBurnOutput
 */
export const zSchemaPostProcessingDodgeBurnOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The processed images with dodge and burn effect',
  }),
})

/**
 * DodgeBurnInput
 */
export const zSchemaPostProcessingDodgeBurnInput = z.object({
  dodge_burn_mode: z.optional(
    z
      .enum([
        'dodge',
        'burn',
        'dodge_and_burn',
        'burn_and_dodge',
        'color_dodge',
        'color_burn',
        'linear_dodge',
        'linear_burn',
      ])
      .register(z.globalRegistry, {
        description: 'Dodge and burn mode',
      }),
  ),
  dodge_burn_intensity: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Dodge and burn intensity',
      }),
    )
    .default(0.5),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to process',
  }),
})

/**
 * GrainOutput
 */
export const zSchemaPostProcessingGrainOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The processed images with grain effect',
  }),
})

/**
 * GrainInput
 */
export const zSchemaPostProcessingGrainInput = z.object({
  grain_style: z.optional(
    z
      .enum(['modern', 'analog', 'kodak', 'fuji', 'cinematic', 'newspaper'])
      .register(z.globalRegistry, {
        description: 'Style of film grain to apply',
      }),
  ),
  grain_intensity: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Film grain intensity',
      }),
    )
    .default(0.4),
  grain_scale: z
    .optional(
      z.number().gte(1).lte(100).register(z.globalRegistry, {
        description: 'Film grain scale',
      }),
    )
    .default(10),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to process',
  }),
})

/**
 * ParabolizeOutput
 */
export const zSchemaPostProcessingParabolizeOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The processed images with parabolize effect',
  }),
})

/**
 * ParabolizeInput
 */
export const zSchemaPostProcessingParabolizeInput = z.object({
  parabolize_coeff: z
    .optional(
      z.number().gte(-10).lte(10).register(z.globalRegistry, {
        description: 'Parabolize coefficient',
      }),
    )
    .default(1),
  vertex_y: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Vertex Y position',
      }),
    )
    .default(0.5),
  vertex_x: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Vertex X position',
      }),
    )
    .default(0.5),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to process',
  }),
})

/**
 * SharpenOutput
 */
export const zSchemaPostProcessingSharpenOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The processed images with sharpen effect',
  }),
})

/**
 * SharpenInput
 */
export const zSchemaPostProcessingSharpenInput = z.object({
  sharpen_mode: z.optional(
    z.enum(['basic', 'smart', 'cas']).register(z.globalRegistry, {
      description: 'Type of sharpening to apply',
    }),
  ),
  sharpen_alpha: z
    .optional(
      z.number().gte(0.1).lte(5).register(z.globalRegistry, {
        description: 'Sharpen strength (for basic mode)',
      }),
    )
    .default(1),
  noise_radius: z
    .optional(
      z.int().gte(1).lte(25).register(z.globalRegistry, {
        description: 'Noise radius for smart sharpen',
      }),
    )
    .default(7),
  sharpen_radius: z
    .optional(
      z.int().gte(1).lte(15).register(z.globalRegistry, {
        description: 'Sharpen radius (for basic mode)',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to process',
  }),
  smart_sharpen_strength: z
    .optional(
      z.number().gte(0).lte(25).register(z.globalRegistry, {
        description: 'Smart sharpen strength',
      }),
    )
    .default(5),
  cas_amount: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'CAS sharpening amount',
      }),
    )
    .default(0.8),
  preserve_edges: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Edge preservation factor',
      }),
    )
    .default(0.75),
  smart_sharpen_ratio: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Smart sharpen blend ratio',
      }),
    )
    .default(0.5),
})

/**
 * SolarizeOutput
 */
export const zSchemaPostProcessingSolarizeOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The processed images with solarize effect',
  }),
})

/**
 * SolarizeInput
 */
export const zSchemaPostProcessingSolarizeInput = z.object({
  solarize_threshold: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Solarize threshold',
      }),
    )
    .default(0.5),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to process',
  }),
})

/**
 * VignetteOutput
 */
export const zSchemaPostProcessingVignetteOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The processed images with vignette effect',
  }),
})

/**
 * VignetteInput
 */
export const zSchemaPostProcessingVignetteInput = z.object({
  vignette_strength: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Vignette strength',
      }),
    )
    .default(0.5),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to process',
  }),
})

/**
 * RealismOutput
 */
export const zSchemaImageEditingRealismOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * RealismInput
 *
 * Input model for realism enhancement endpoint.
 */
export const zSchemaImageEditingRealismInput = z
  .object({
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(0.6),
    image_url: z.string().register(z.globalRegistry, {
      description: 'URL of the image to enhance with realism details.',
    }),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
        }),
      )
      .default(3.5),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          'The same seed and the same prompt given to the same version of the model will output the same image every time.',
      }),
    ),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'Number of inference steps for sampling.',
        }),
      )
      .default(30),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: 'Input model for realism enhancement endpoint.',
  })

/**
 * ReimagineOutput
 */
export const zSchemaBriaReimagineOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
})

/**
 * ReimagineInput
 */
export const zSchemaBriaReimagineInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt you would like to use to generate images.',
  }),
  num_results: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'How many images you would like to generate. When using any Guidance Method, Value is set to 1.',
      }),
    )
    .default(1),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  structure_ref_influence: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          'The influence of the structure reference on the generated image.',
      }),
    )
    .default(0.75),
  fast: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to use the fast model',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().gte(0).lte(2147483647).register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description:
          'The number of iterations the model goes through to refine the generated image. This parameter is optional.',
      }),
    )
    .default(30),
  structure_image_url: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The URL of the structure reference image. Use "" to leave empty. Accepted formats are jpeg, jpg, png, webp.',
      }),
    )
    .default(''),
})

/**
 * Output
 */
export const zSchemaCalligrapherOutput = z.object({
  images: z.array(zSchemaImage),
})

/**
 * Input
 */
export const zSchemaCalligrapherInput = z.object({
  use_context: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to prepend context reference to the input',
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'How many images to generate',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  auto_mask_generation: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to automatically generate mask from detected text',
      }),
    )
    .default(false),
  reference_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Optional base64 reference image for style',
    }),
  ),
  source_image_url: z.string().register(z.globalRegistry, {
    description: 'Base64-encoded source image with drawn mask layers',
  }),
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text prompt to inpaint or customize',
  }),
  mask_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Base64-encoded mask image (optional if using auto_mask_generation)',
    }),
  ),
  source_text: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Source text to replace (if empty, masks all detected text)',
      }),
    )
    .default(''),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps (1-100)',
      }),
    )
    .default(50),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducibility',
    }),
  ),
  cfg_scale: z
    .optional(
      z.number().gte(0).lte(5).register(z.globalRegistry, {
        description: 'Guidance or strength scale for the model',
      }),
    )
    .default(1),
})

/**
 * VideoFile
 */
export const zSchemaVideoFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  duration: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The duration of the video',
    }),
  ),
  height: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The height of the video',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  width: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The width of the video',
    }),
  ),
  fps: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'The FPS of the video',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  num_frames: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The number of frames in the video',
    }),
  ),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * FILMImageOutput
 */
export const zSchemaFilmOutput = z.object({
  images: z
    .optional(
      z.array(zSchemaImageFile).register(z.globalRegistry, {
        description: 'The generated frames as individual images.',
      }),
    )
    .default([]),
  video: z.optional(zSchemaVideoFile),
})

/**
 * FILMImageInput
 */
export const zSchemaFilmInput = z.object({
  video_write_mode: z.optional(
    z.enum(['fast', 'balanced', 'small']).register(z.globalRegistry, {
      description:
        "The write mode of the output video. Only applicable if output_type is 'video'.",
    }),
  ),
  num_frames: z
    .optional(
      z.int().gte(1).lte(64).register(z.globalRegistry, {
        description:
          'The number of frames to generate between the input images.',
      }),
    )
    .default(1),
  include_start: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to include the start image in the output.',
      }),
    )
    .default(false),
  video_quality: z.optional(
    z.enum(['low', 'medium', 'high', 'maximum']).register(z.globalRegistry, {
      description:
        "The quality of the output video. Only applicable if output_type is 'video'.",
    }),
  ),
  include_end: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to include the end image in the output.',
      }),
    )
    .default(false),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  fps: z
    .optional(
      z.int().gte(1).lte(60).register(z.globalRegistry, {
        description:
          "Frames per second for the output video. Only applicable if output_type is 'video'.",
      }),
    )
    .default(8),
  start_image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the first image to use as the starting point for interpolation.',
  }),
  end_image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the second image to use as the ending point for interpolation.',
  }),
  image_format: z.optional(
    z.enum(['png', 'jpeg']).register(z.globalRegistry, {
      description:
        "The format of the output images. Only applicable if output_type is 'images'.",
    }),
  ),
  output_type: z.optional(
    z.enum(['images', 'video']).register(z.globalRegistry, {
      description:
        'The type of output to generate; either individual images or a video.',
    }),
  ),
})

/**
 * RIFEImageOutput
 */
export const zSchemaRifeOutput = z.object({
  images: z
    .optional(
      z.array(zSchemaImage).register(z.globalRegistry, {
        description: 'The generated frames as individual images.',
      }),
    )
    .default([]),
  video: z.optional(zSchemaFile),
})

/**
 * RIFEImageInput
 */
export const zSchemaRifeInput = z.object({
  output_format: z.optional(
    z.enum(['png', 'jpeg']).register(z.globalRegistry, {
      description:
        "The format of the output images. Only applicable if output_type is 'images'.",
    }),
  ),
  fps: z
    .optional(
      z.int().gte(1).lte(60).register(z.globalRegistry, {
        description:
          "Frames per second for the output video. Only applicable if output_type is 'video'.",
      }),
    )
    .default(8),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  include_end: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to include the end image in the output.',
      }),
    )
    .default(false),
  include_start: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to include the start image in the output.',
      }),
    )
    .default(false),
  num_frames: z
    .optional(
      z.int().gte(1).lte(64).register(z.globalRegistry, {
        description:
          'The number of frames to generate between the input images.',
      }),
    )
    .default(1),
  end_image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the second image to use as the ending point for interpolation.',
  }),
  output_type: z.optional(
    z.enum(['images', 'video']).register(z.globalRegistry, {
      description:
        'The type of output to generate; either individual images or a video.',
    }),
  ),
  start_image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the first image to use as the starting point for interpolation.',
  }),
})

/**
 * Output
 */
export const zSchemaHidreamE11Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseInput
 */
export const zSchemaHidreamE11Input = z.object({
  prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The prompt to generate an image from.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your initial image when looking for a related image to show you.\n        ',
      }),
    )
    .default(2),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of an input image to edit.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(50),
  target_image_description: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The description of the target image after your edits have been made. Leave this blank to allow the model to use its own imagination.',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default('low resolution, blur'),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * RetouchOutput
 */
export const zSchemaImageEditingRetouchOutput = z.object({
  images: z.array(zSchemaImage),
  seed: z.int(),
})

/**
 * RetouchInput
 *
 * Input model for retouch endpoint.
 */
export const zSchemaImageEditingRetouchInput = z
  .object({
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(1),
    image_url: z.string().register(z.globalRegistry, {
      description: 'URL of the image to retouch.',
    }),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If set to true, the function will wait for the image to be generated and uploaded before returning the response. This will increase the latency of the function but it allows you to get the image directly in the response without going through the CDN.',
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
        }),
      )
      .default(3.5),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          'The same seed and the same prompt given to the same version of the model will output the same image every time.',
      }),
    ),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'Number of inference steps for sampling.',
        }),
      )
      .default(30),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: 'Input model for retouch endpoint.',
  })

/**
 * ImageToPanoramaResponse
 */
export const zSchemaHunyuanWorldOutput = z.object({
  image: zSchemaImage,
})

/**
 * ImageToPanoramaRequest
 */
export const zSchemaHunyuanWorldInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to use for the panorama generation.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to convert to a panorama.',
  }),
})

/**
 * KontextInpaintOutput
 */
export const zSchemaFluxKontextLoraInpaintOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseKontextInpaintInput
 */
export const zSchemaFluxKontextLoraInpaintInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt for the image to image task.',
  }),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  reference_image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the reference image for inpainting.',
  }),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(2.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to be inpainted.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength of the initial image. Higher strength values are better for this model.',
      }),
    )
    .default(0.88),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(30),
  mask_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the mask for inpainting.',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * KreaReduxOutput
 */
export const zSchemaFlux1KreaReduxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseKreaFlux1ReduxInput
 */
export const zSchemaFlux1KreaReduxInput = z.object({
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate an image from.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ',
      }),
    )
    .default(4.5),
})

/**
 * KreaOutput
 */
export const zSchemaFlux1KreaImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseKreaFlux1ImageToInput
 */
export const zSchemaFlux1KreaImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate an image from.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength of the initial image. Higher strength values are better for this model.',
      }),
    )
    .default(0.95),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(40),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ',
      }),
    )
    .default(4.5),
})

/**
 * KreaReduxOutput
 */
export const zSchemaFluxKreaReduxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseKreaReduxInput
 */
export const zSchemaFluxKreaReduxInput = z.object({
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate an image from.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ',
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
})

/**
 * Output
 */
export const zSchemaFluxKreaImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseKreaImageToInput
 */
export const zSchemaFluxKreaImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate an image from.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength of the initial image. Higher strength values are better for this model.',
      }),
    )
    .default(0.95),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ',
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(40),
})

/**
 * Output
 */
export const zSchemaFluxKreaLoraImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * ImageToImageInput
 */
export const zSchemaFluxKreaLoraImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'The number of images to generate. This is always set to 1 for streaming output.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use for inpainting. or img2img',
  }),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.',
      }),
    )
    .default(0.85),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaFluxKreaLoraInpaintingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * InpaintInput
 */
export const zSchemaFluxKreaLoraInpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'The number of images to generate. This is always set to 1 for streaming output.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use for inpainting. or img2img',
  }),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.',
      }),
    )
    .default(0.85),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  mask_url: z.string().register(z.globalRegistry, {
    description: '\n            The mask to area to Inpaint in.\n        ',
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * CharacterRemixOutputV3
 */
export const zSchemaIdeogramCharacterRemixOutput = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for the random number generator',
  }),
})

/**
 * CharacterRemixInputV3
 */
export const zSchemaIdeogramCharacterRemixInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to remix the image with',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
      z.unknown(),
    ]),
  ),
  style: z.optional(
    z.enum(['AUTO', 'REALISTIC', 'FICTION']).register(z.globalRegistry, {
      description:
        'The style type to generate with. Cannot be used with style_codes.',
    }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Determine if MagicPrompt should be used in generating the request or not.',
      }),
    )
    .default(true),
  rendering_speed: z.optional(
    z.enum(['TURBO', 'BALANCED', 'QUALITY']).register(z.globalRegistry, {
      description: 'The rendering speed to use.',
    }),
  ),
  reference_mask_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'A set of masks to apply to the character references. Currently only 1 mask is supported, rest will be ignored. (maximum total size 10MB across all character references). The masks should be in JPEG, PNG or WebP format',
    }),
  ),
  reference_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'A set of images to use as character references. Currently only 1 image is supported, rest will be ignored. (maximum total size 10MB across all character references). The images should be in JPEG, PNG or WebP format',
  }),
  image_urls: z.optional(z.union([z.array(z.string()), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Description of what to exclude from an image. Descriptions in the prompt take precedence to descriptions in the negative prompt.',
      }),
    )
    .default(''),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'Number of images to generate.',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The image URL to remix',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  color_palette: z.optional(z.union([zSchemaColorPalette, z.unknown()])),
  style_codes: z.optional(z.union([z.array(z.string()), z.unknown()])),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description: 'Strength of the input image in the remix',
      }),
    )
    .default(0.8),
  seed: z.optional(z.union([z.int(), z.unknown()])),
})

/**
 * CharacterOutputV3
 */
export const zSchemaIdeogramCharacterOutput = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for the random number generator',
  }),
})

/**
 * BaseCharacterInputV3
 */
export const zSchemaIdeogramCharacterInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to fill the masked part of the image.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
      z.unknown(),
    ]),
  ),
  style: z.optional(
    z.enum(['AUTO', 'REALISTIC', 'FICTION']).register(z.globalRegistry, {
      description:
        'The style type to generate with. Cannot be used with style_codes.',
    }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Determine if MagicPrompt should be used in generating the request or not.',
      }),
    )
    .default(true),
  rendering_speed: z.optional(
    z.enum(['TURBO', 'BALANCED', 'QUALITY']).register(z.globalRegistry, {
      description: 'The rendering speed to use.',
    }),
  ),
  reference_mask_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'A set of masks to apply to the character references. Currently only 1 mask is supported, rest will be ignored. (maximum total size 10MB across all character references). The masks should be in JPEG, PNG or WebP format',
    }),
  ),
  reference_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'A set of images to use as character references. Currently only 1 image is supported, rest will be ignored. (maximum total size 10MB across all character references). The images should be in JPEG, PNG or WebP format',
  }),
  image_urls: z.optional(z.union([z.array(z.string()), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Description of what to exclude from an image. Descriptions in the prompt take precedence to descriptions in the negative prompt.',
      }),
    )
    .default(''),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'Number of images to generate.',
      }),
    )
    .default(1),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  color_palette: z.optional(z.union([zSchemaColorPalette, z.unknown()])),
  style_codes: z.optional(z.union([z.array(z.string()), z.unknown()])),
  seed: z.optional(z.union([z.int(), z.unknown()])),
})

/**
 * CharacterEditOutputV3
 */
export const zSchemaIdeogramCharacterEditOutput = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for the random number generator',
  }),
})

/**
 * CharacterEditInputV3
 */
export const zSchemaIdeogramCharacterEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to fill the masked part of the image.',
  }),
  style: z.optional(
    z.enum(['AUTO', 'REALISTIC', 'FICTION']).register(z.globalRegistry, {
      description:
        'The style type to generate with. Cannot be used with style_codes.',
    }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Determine if MagicPrompt should be used in generating the request or not.',
      }),
    )
    .default(true),
  rendering_speed: z.optional(
    z.enum(['TURBO', 'BALANCED', 'QUALITY']).register(z.globalRegistry, {
      description: 'The rendering speed to use.',
    }),
  ),
  reference_mask_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'A set of masks to apply to the character references. Currently only 1 mask is supported, rest will be ignored. (maximum total size 10MB across all character references). The masks should be in JPEG, PNG or WebP format',
    }),
  ),
  reference_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'A set of images to use as character references. Currently only 1 image is supported, rest will be ignored. (maximum total size 10MB across all character references). The images should be in JPEG, PNG or WebP format',
  }),
  image_urls: z.optional(z.union([z.array(z.string()), z.unknown()])),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'Number of images to generate.',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The image URL to generate an image from. MUST have the exact same dimensions (width and height) as the mask image.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  color_palette: z.optional(z.union([zSchemaColorPalette, z.unknown()])),
  style_codes: z.optional(z.union([z.array(z.string()), z.unknown()])),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  mask_url: z.string().register(z.globalRegistry, {
    description:
      'The mask URL to inpaint the image. MUST have the exact same dimensions (width and height) as the input image.',
  }),
})

/**
 * QwenImageOutput
 */
export const zSchemaQwenImageEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseQwenEditImageInput
 */
export const zSchemaQwenImageEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the image with',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.",
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to edit.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt for the generation',
      }),
    )
    .default(' '),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * NextStepResponse
 */
export const zSchemaNextstep1Output = z.object({
  image: z
    .object({
      file_size: z.optional(z.union([z.int(), z.unknown()])),
      height: z.optional(z.union([z.int(), z.unknown()])),
      file_name: z.optional(z.union([z.string(), z.unknown()])),
      content_type: z.optional(z.union([z.string(), z.unknown()])),
      url: z.string().register(z.globalRegistry, {
        description: 'The URL where the file can be downloaded from.',
      }),
      width: z.optional(z.union([z.int(), z.unknown()])),
    })
    .register(z.globalRegistry, {
      description: 'Generated image',
    }),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for random number generation',
  }),
})

/**
 * NextStepEditRequest
 */
export const zSchemaNextstep1Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image.',
  }),
  negative_prompt: z.string().register(z.globalRegistry, {
    description:
      "The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n        ",
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to edit.',
  }),
})

/**
 * NanoBananaImageToImageOutput
 */
export const zSchemaNanoBananaEditOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The edited images.',
  }),
  description: z.string().register(z.globalRegistry, {
    description: 'The description of the generated images.',
  }),
})

/**
 * NanoBananaImageToImageInput
 */
export const zSchemaNanoBananaEditInput = z.object({
  prompt: z.string().min(3).max(50000).register(z.globalRegistry, {
    description: 'The prompt for image editing.',
  }),
  aspect_ratio: z.optional(
    z
      .enum([
        'auto',
        '21:9',
        '16:9',
        '3:2',
        '4:3',
        '5:4',
        '1:1',
        '4:5',
        '3:4',
        '2:3',
        '9:16',
      ])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The URLs of the images to use for image-to-image generation or image editing.',
  }),
  limit_generations: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.',
      }),
    )
    .default(false),
})

/**
 * OutputModel
 */
export const zSchemaReimagine32Output = z.object({
  image: zSchemaImage,
})

/**
 * InputModel
 */
export const zSchemaReimagine32Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Prompt for image generation.',
  }),
  depth_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Depth image preprocess.',
      }),
    )
    .default(true),
  canny_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Canny image preprocess.',
      }),
    )
    .default(true),
  depth_image_url: z.optional(z.union([z.string(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: 'Guidance scale for text.',
      }),
    )
    .default(5),
  canny_image_url: z.optional(z.union([z.string(), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for image generation.',
      }),
    )
    .default(
      'Logo,Watermark,Ugly,Morbid,Extra fingers,Poorly drawn hands,Mutation,Blurry,Extra limbs,Gross proportions,Missing arms,Mutated hands,Long neck,Duplicate,Mutilated,Mutilated hands,Poorly drawn face,Deformed,Bad anatomy,Cloned face,Malformed limbs,Missing legs,Too many fingers',
    ),
  depth_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Depth control strength (0.0 to 1.0).',
      }),
    )
    .default(0.5),
  aspect_ratio: z.optional(
    z
      .enum(['1:1', '2:3', '3:2', '3:4', '4:3', '4:5', '5:4', '9:16', '16:9'])
      .register(z.globalRegistry, {
        description:
          'Aspect ratio. Options: 1:1, 2:3, 3:2, 3:4, 4:3, 4:5, 5:4, 9:16, 16:9',
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If true, returns the image directly in the response (increases latency).',
      }),
    )
    .default(false),
  prompt_enhancer: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to improve the prompt.',
      }),
    )
    .default(true),
  truncate_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to truncate the prompt.',
      }),
    )
    .default(true),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Random seed for reproducibility.',
      }),
    )
    .default(5555),
  canny_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Canny edge control strength (0.0 to 1.0).',
      }),
    )
    .default(0.5),
  num_inference_steps: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps.',
      }),
    )
    .default(30),
})

/**
 * QwenImageI2IOutput
 */
export const zSchemaQwenImageImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * QwenImageI2IInput
 */
export const zSchemaQwenImageImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the image with',
  }),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular', 'high'. Higher acceleration increases speed. 'regular' balances speed and quality. 'high' is recommended for images without text.",
    }),
  ),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use up to 3 LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(2.5),
  use_turbo: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Enable turbo mode for faster generation with high quality. When enabled, uses optimized settings (10 steps, CFG=1.2).',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt for the generation',
      }),
    )
    .default(' '),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The reference image to guide the generation.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Denoising strength. 1.0 = fully remake; 0.0 = preserve original.',
      }),
    )
    .default(0.6),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(250).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * NanoBananaImageToImageOutput
 */
export const zSchemaGemini25FlashImageEditOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The edited images.',
  }),
  description: z.string().register(z.globalRegistry, {
    description: 'The description of the generated images.',
  }),
})

/**
 * NanoBananaImageToImageInput
 */
export const zSchemaGemini25FlashImageEditInput = z.object({
  prompt: z.string().min(3).max(50000).register(z.globalRegistry, {
    description: 'The prompt for image editing.',
  }),
  aspect_ratio: z.optional(
    z
      .enum([
        'auto',
        '21:9',
        '16:9',
        '3:2',
        '4:3',
        '5:4',
        '1:1',
        '4:5',
        '3:4',
        '2:3',
        '9:16',
      ])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The URLs of the images to use for image-to-image generation or image editing.',
  }),
  limit_generations: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.',
      }),
    )
    .default(false),
})

/**
 * USOOutputImage
 */
export const zSchemaUsoOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description:
      'The generated images with applied style and/or subject customization',
  }),
  timings: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: 'Performance timings for different stages',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'NSFW detection results for each generated image',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation',
  }),
})

/**
 * USOInputImage
 */
export const zSchemaUsoInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Text prompt for generation. Can be empty for pure style transfer.',
      }),
    )
    .default(''),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'Number of images to generate in parallel.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description:
        'Output image format. PNG preserves transparency, JPEG is smaller.',
    }),
  ),
  keep_size: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Preserve the layout and dimensions of the input content image. Useful for style transfer.',
      }),
    )
    .default(false),
  input_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'List of image URLs in order: [content_image, style_image, extra_style_image].',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If true, wait for generation and upload before returning. Increases latency but provides immediate access to images.',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'How closely to follow the prompt. Higher values stick closer to the prompt.',
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description:
          'Number of denoising steps. More steps can improve quality but increase generation time.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducible generation. Use same seed for consistent results.',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "What you don't want in the image. Use it to exclude unwanted elements, styles, or artifacts.",
      }),
    )
    .default(''),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable NSFW content detection and filtering.',
      }),
    )
    .default(true),
})

/**
 * WanI2IResponse
 */
export const zSchemaWanV22A14bImageToImageOutput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The text prompt used for image generation.',
      }),
    )
    .default(''),
  image: zSchemaFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
})

/**
 * WanI2IRequest
 */
export const zSchemaWanV22A14bImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide image generation.',
  }),
  shift: z.optional(z.number().gte(1).lte(10)).default(2),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular']).register(z.globalRegistry, {
      description:
        "Acceleration level to use. The more acceleration, the faster the generation, but with lower quality. The recommended value is 'regular'.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, input data will be checked for safety before processing.',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: 'Classifier-free guidance scale.',
      }),
    )
    .default(3.5),
  image_format: z.optional(
    z.enum(['png', 'jpeg']).register(z.globalRegistry, {
      description: 'The format of the output image.',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for video generation.',
      }),
    )
    .default(''),
  aspect_ratio: z.optional(
    z.enum(['auto', '16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description:
        "Aspect ratio of the generated image. If 'auto', the aspect ratio will be determined automatically based on the input image.",
    }),
  ),
  enable_output_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, output video will be checked for safety after generation.',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the input image.',
  }),
  strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Denoising strength. 1.0 = fully remake; 0.0 = preserve original.',
      }),
    )
    .default(0.5),
  guidance_scale_2: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Guidance scale for the second stage of the model. This is used to control the adherence to the prompt in the second stage of the model.',
      }),
    )
    .default(4),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(40).register(z.globalRegistry, {
        description:
          'Number of inference steps for sampling. Higher values give better quality but take longer.',
      }),
    )
    .default(27),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If None, a random seed is chosen.',
    }),
  ),
})

/**
 * SeedDream4EditOutput
 */
export const zSchemaBytedanceSeedreamV4EditOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Generated images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation',
  }),
})

/**
 * SeedDream4EditInput
 */
export const zSchemaBytedanceSeedreamV4EditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt used to edit the image',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(6).register(z.globalRegistry, {
        description:
          'Number of separate model generations to be run with the prompt.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
        'auto',
        'auto_2K',
        'auto_4K',
      ]),
    ]),
  ),
  enhance_prompt_mode: z.optional(
    z.enum(['standard', 'fast']).register(z.globalRegistry, {
      description:
        'The mode to use for enhancing prompt enhancement. Standard mode provides higher quality results but takes longer to generate. Fast mode provides average quality results but takes less time to generate.',
    }),
  ),
  max_images: z
    .optional(
      z.int().gte(1).lte(6).register(z.globalRegistry, {
        description:
          'If set to a number greater than one, enables multi-image generation. The model will potentially return up to `max_images` images every generation, and in total, `num_images` generations will be carried out. In total, the number of images generated will be between `num_images` and `max_images*num_images`. The total number of images (image inputs + image outputs) must not exceed 15',
      }),
    )
    .default(1),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed to control the stochasticity of image generation.',
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'List of URLs of input images for editing. Presently, up to 10 image inputs are allowed. If over 10 images are sent, only the last 10 will be used.',
  }),
})

/**
 * ReferenceToImageOutput
 */
export const zSchemaViduReferenceToImageOutput = z.object({
  image: zSchemaImage,
})

/**
 * ReferenceToImageRequest
 */
export const zSchemaViduReferenceToImageInput = z.object({
  prompt: z.string().max(1500).register(z.globalRegistry, {
    description: 'Text prompt for video generation, max 1500 characters',
  }),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description: 'The aspect ratio of the output video',
    }),
  ),
  reference_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'URLs of the reference images to use for consistent subject appearance',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for generation',
    }),
  ),
})

/**
 * QwenImageOutput
 */
export const zSchemaQwenImageEditLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseQwenEditImageLoRAInput
 */
export const zSchemaQwenImageEditLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the image with',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.",
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to edit.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use up to 3 LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt for the generation',
      }),
    )
    .default(' '),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaFlux1SrpoImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseSRPOFlux1ImageToInput
 */
export const zSchemaFlux1SrpoImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate an image from.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength of the initial image. Higher strength values are better for this model.',
      }),
    )
    .default(0.95),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(40),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ',
      }),
    )
    .default(4.5),
})

/**
 * Output
 */
export const zSchemaFluxSrpoImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseSRPOImageToInput
 */
export const zSchemaFluxSrpoImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate an image from.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength of the initial image. Higher strength values are better for this model.',
      }),
    )
    .default(0.95),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ',
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(40),
})

/**
 * QwenImageInpaintOutput
 */
export const zSchemaQwenImageEditInpaintOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseQwenEditInpaintImageInput
 */
export const zSchemaQwenImageEditInpaintInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the image with',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.",
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt for the generation',
      }),
    )
    .default(' '),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to edit.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description: 'Strength of noising process for inpainting',
      }),
    )
    .default(0.93),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  mask_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the mask for inpainting',
  }),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(30),
})

/**
 * MakeupApplicationOutput
 */
export const zSchemaImageAppsV2MakeupApplicationOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Portrait with applied makeup',
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: 'Total inference time in milliseconds',
  }),
})

/**
 * AspectRatio
 *
 * Aspect ratio model that calculates 4K resolution dimensions
 */
export const zSchemaAspectRatio = z
  .object({
    ratio: z.optional(
      z.enum(['1:1', '16:9', '9:16', '4:3', '3:4']).register(z.globalRegistry, {
        description: 'Aspect ratio for 4K resolution output',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Aspect ratio model that calculates 4K resolution dimensions',
  })

/**
 * MakeupApplicationInput
 */
export const zSchemaImageAppsV2MakeupApplicationInput = z.object({
  aspect_ratio: z.optional(zSchemaAspectRatio),
  intensity: z.optional(z.enum(['light', 'medium', 'heavy', 'dramatic'])),
  makeup_style: z.optional(
    z.enum([
      'natural',
      'glamorous',
      'smoky_eyes',
      'bold_lips',
      'no_makeup',
      'remove_makeup',
      'dramatic',
      'bridal',
      'professional',
      'korean_style',
      'artistic',
    ]),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Portrait image URL for makeup application',
  }),
})

/**
 * AgeModifyOutput
 */
export const zSchemaImageAppsV2AgeModifyOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Portrait with modified age',
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: 'Total inference time in milliseconds',
  }),
})

/**
 * AgeModifyInput
 */
export const zSchemaImageAppsV2AgeModifyInput = z.object({
  image_url: z.string().register(z.globalRegistry, {
    description: 'Portrait image URL for age modification',
  }),
  aspect_ratio: z.optional(zSchemaAspectRatio),
  preserve_identity: z.optional(z.boolean()).default(true),
  target_age: z.optional(z.int().gte(6).lte(100)).default(30),
})

/**
 * CityTeleportOutput
 */
export const zSchemaImageAppsV2CityTeleportOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Person teleported to city location',
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: 'Total inference time in milliseconds',
  }),
})

/**
 * CityTeleportInput
 */
export const zSchemaImageAppsV2CityTeleportInput = z.object({
  city_image_url: z.optional(z.union([z.string(), z.unknown()])),
  aspect_ratio: z.optional(zSchemaAspectRatio),
  city_name: z.string().register(z.globalRegistry, {
    description: 'City name (used when city_image_url is not provided)',
  }),
  photo_shot: z.optional(
    z
      .enum([
        'extreme_close_up',
        'close_up',
        'medium_close_up',
        'medium_shot',
        'medium_long_shot',
        'long_shot',
        'extreme_long_shot',
        'full_body',
      ])
      .register(z.globalRegistry, {
        description: 'Type of photo shot',
      }),
  ),
  camera_angle: z.optional(
    z
      .enum([
        'eye_level',
        'low_angle',
        'high_angle',
        'dutch_angle',
        'birds_eye_view',
        'worms_eye_view',
        'overhead',
        'side_angle',
      ])
      .register(z.globalRegistry, {
        description: 'Camera angle for the shot',
      }),
  ),
  person_image_url: z.string().register(z.globalRegistry, {
    description: 'Person photo URL',
  }),
})

/**
 * ExpressionChangeOutput
 */
export const zSchemaImageAppsV2ExpressionChangeOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Portrait with changed expression',
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: 'Total inference time in milliseconds',
  }),
})

/**
 * ExpressionChangeInput
 */
export const zSchemaImageAppsV2ExpressionChangeInput = z.object({
  aspect_ratio: z.optional(zSchemaAspectRatio),
  target_expression: z.optional(
    z.enum([
      'smile',
      'surprise',
      'glare',
      'panic',
      'shyness',
      'laugh',
      'cry',
      'angry',
      'sad',
      'happy',
      'excited',
      'shocked',
      'confused',
      'focused',
      'dreamy',
      'serious',
      'playful',
      'mysterious',
      'confident',
      'thoughtful',
    ]),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Portrait image URL for expression change',
  }),
})

/**
 * HairChangeOutput
 */
export const zSchemaImageAppsV2HairChangeOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Portrait with changed hair',
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: 'Total inference time in milliseconds',
  }),
})

/**
 * HairChangeInput
 */
export const zSchemaImageAppsV2HairChangeInput = z.object({
  target_hairstyle: z.optional(
    z.enum([
      'short_hair',
      'medium_long_hair',
      'long_hair',
      'curly_hair',
      'wavy_hair',
      'high_ponytail',
      'bun',
      'bob_cut',
      'pixie_cut',
      'braids',
      'straight_hair',
      'afro',
      'dreadlocks',
      'buzz_cut',
      'mohawk',
      'bangs',
      'side_part',
      'middle_part',
    ]),
  ),
  aspect_ratio: z.optional(zSchemaAspectRatio),
  hair_color: z.optional(
    z.enum([
      'black',
      'dark_brown',
      'light_brown',
      'blonde',
      'platinum_blonde',
      'red',
      'auburn',
      'gray',
      'silver',
      'blue',
      'green',
      'purple',
      'pink',
      'rainbow',
      'natural',
      'highlights',
      'ombre',
      'balayage',
    ]),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Portrait image URL for hair change',
  }),
})

/**
 * HeadshotOutput
 */
export const zSchemaImageAppsV2HeadshotPhotoOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Professional headshot image',
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: 'Total inference time in milliseconds',
  }),
})

/**
 * HeadshotInput
 */
export const zSchemaImageAppsV2HeadshotPhotoInput = z.object({
  aspect_ratio: z.optional(zSchemaAspectRatio),
  background_style: z.optional(
    z.enum(['professional', 'corporate', 'clean', 'gradient']),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Portrait image URL to convert to professional headshot',
  }),
})

/**
 * ObjectRemovalOutput
 */
export const zSchemaImageAppsV2ObjectRemovalOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Image with object removed',
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: 'Total inference time in milliseconds',
  }),
})

/**
 * ObjectRemovalInput
 */
export const zSchemaImageAppsV2ObjectRemovalInput = z.object({
  aspect_ratio: z.optional(zSchemaAspectRatio),
  object_to_remove: z.string().register(z.globalRegistry, {
    description: 'Object to remove',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image URL containing object to remove',
  }),
})

/**
 * PerspectiveOutput
 */
export const zSchemaImageAppsV2PerspectiveOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Image with changed perspective',
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: 'Total inference time in milliseconds',
  }),
})

/**
 * PerspectiveInput
 */
export const zSchemaImageAppsV2PerspectiveInput = z.object({
  aspect_ratio: z.optional(zSchemaAspectRatio),
  target_perspective: z.optional(
    z.enum([
      'front',
      'left_side',
      'right_side',
      'back',
      'top_down',
      'bottom_up',
      'birds_eye',
      'three_quarter_left',
      'three_quarter_right',
    ]),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image URL for perspective change',
  }),
})

/**
 * PhotographyEffectsOutput
 */
export const zSchemaImageAppsV2PhotographyEffectsOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Image with photography effects',
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: 'Total inference time in milliseconds',
  }),
})

/**
 * PhotographyEffectsInput
 */
export const zSchemaImageAppsV2PhotographyEffectsInput = z.object({
  effect_type: z.optional(
    z.enum([
      'film',
      'vintage_film',
      'portrait_photography',
      'fashion_photography',
      'street_photography',
      'sepia_tone',
      'film_grain',
      'light_leaks',
      'vignette_effect',
      'instant_camera',
      'golden_hour',
      'dramatic_lighting',
      'soft_focus',
      'bokeh_effect',
      'high_contrast',
      'double_exposure',
    ]),
  ),
  aspect_ratio: z.optional(zSchemaAspectRatio),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image URL for photography effects',
  }),
})

/**
 * PortraitOutput
 */
export const zSchemaImageAppsV2PortraitEnhanceOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Enhanced portrait',
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: 'Total inference time in milliseconds',
  }),
})

/**
 * PortraitInput
 */
export const zSchemaImageAppsV2PortraitEnhanceInput = z.object({
  aspect_ratio: z.optional(zSchemaAspectRatio),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Portrait image URL to enhance',
  }),
})

/**
 * PhotoRestorationOutput
 */
export const zSchemaImageAppsV2PhotoRestorationOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Restored photo',
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: 'Total inference time in milliseconds',
  }),
})

/**
 * PhotoRestorationInput
 */
export const zSchemaImageAppsV2PhotoRestorationInput = z.object({
  enhance_resolution: z.optional(z.boolean()).default(true),
  aspect_ratio: z.optional(zSchemaAspectRatio),
  remove_scratches: z.optional(z.boolean()).default(true),
  fix_colors: z.optional(z.boolean()).default(true),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Old or damaged photo URL to restore',
  }),
})

/**
 * StyleTransferOutput
 */
export const zSchemaImageAppsV2StyleTransferOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Image with transferred style',
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: 'Total inference time in milliseconds',
  }),
})

/**
 * StyleTransferInput
 */
export const zSchemaImageAppsV2StyleTransferInput = z.object({
  target_style: z.optional(
    z.enum([
      'anime_character',
      'cartoon_3d',
      'hand_drawn_animation',
      'cyberpunk_future',
      'anime_game_style',
      'comic_book_animation',
      'animated_series',
      'cartoon_animation',
      'lofi_aesthetic',
      'cottagecore',
      'dark_academia',
      'y2k',
      'vaporwave',
      'liminal_space',
      'weirdcore',
      'dreamcore',
      'synthwave',
      'outrun',
      'photorealistic',
      'hyperrealistic',
      'digital_art',
      'concept_art',
      'impressionist',
      'anime',
      'pixel_art',
      'claymation',
    ]),
  ),
  aspect_ratio: z.optional(zSchemaAspectRatio),
  style_reference_image_url: z.optional(z.union([z.string(), z.unknown()])),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image URL for style transfer',
  }),
})

/**
 * RelightingOutput
 */
export const zSchemaImageAppsV2RelightingOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Image with new lighting',
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: 'Total inference time in milliseconds',
  }),
})

/**
 * RelightingInput
 */
export const zSchemaImageAppsV2RelightingInput = z.object({
  aspect_ratio: z.optional(zSchemaAspectRatio),
  lighting_style: z.optional(
    z.enum([
      'natural',
      'studio',
      'golden_hour',
      'blue_hour',
      'dramatic',
      'soft',
      'hard',
      'backlight',
      'side_light',
      'front_light',
      'rim_light',
      'sunset',
      'sunrise',
      'neon',
      'candlelight',
      'moonlight',
      'spotlight',
      'ambient',
    ]),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image URL for relighting',
  }),
})

/**
 * TextureTransformOutput
 */
export const zSchemaImageAppsV2TextureTransformOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Image with transformed texture',
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: 'Total inference time in milliseconds',
  }),
})

/**
 * TextureTransformInput
 */
export const zSchemaImageAppsV2TextureTransformInput = z.object({
  target_texture: z.optional(
    z.enum([
      'cotton',
      'denim',
      'wool',
      'felt',
      'wood',
      'leather',
      'velvet',
      'stone',
      'marble',
      'ceramic',
      'concrete',
      'brick',
      'clay',
      'foam',
      'glass',
      'metal',
      'silk',
      'fabric',
      'crystal',
      'rubber',
      'plastic',
      'lace',
    ]),
  ),
  aspect_ratio: z.optional(zSchemaAspectRatio),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image URL for texture transformation',
  }),
})

/**
 * VirtualTryOnOutput
 */
export const zSchemaImageAppsV2VirtualTryOnOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Person wearing the virtual clothing',
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: 'Total inference time in milliseconds',
  }),
})

/**
 * VirtualTryOnInput
 */
export const zSchemaImageAppsV2VirtualTryOnInput = z.object({
  preserve_pose: z.optional(z.boolean()).default(true),
  aspect_ratio: z.optional(zSchemaAspectRatio),
  clothing_image_url: z.string().register(z.globalRegistry, {
    description: 'Clothing photo URL',
  }),
  person_image_url: z.string().register(z.globalRegistry, {
    description: 'Person photo URL',
  }),
})

/**
 * ProductPhotographyOutput
 */
export const zSchemaImageAppsV2ProductPhotographyOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Professional studio product photography',
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: 'Total inference time in milliseconds',
  }),
})

/**
 * ProductPhotographyInput
 */
export const zSchemaImageAppsV2ProductPhotographyInput = z.object({
  aspect_ratio: z.optional(zSchemaAspectRatio),
  product_image_url: z.string().register(z.globalRegistry, {
    description:
      'Image URL of the product to create professional studio photography',
  }),
})

/**
 * ProductHoldingOutput
 */
export const zSchemaImageAppsV2ProductHoldingOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Person holding the product naturally',
  }),
  inference_time_ms: z.int().register(z.globalRegistry, {
    description: 'Total inference time in milliseconds',
  }),
})

/**
 * ProductHoldingInput
 */
export const zSchemaImageAppsV2ProductHoldingInput = z.object({
  aspect_ratio: z.optional(zSchemaAspectRatio),
  product_image_url: z.string().register(z.globalRegistry, {
    description: 'Image URL of the product to be held by the person',
  }),
  person_image_url: z.string().register(z.globalRegistry, {
    description: 'Image URL of the person who will hold the product',
  }),
})

/**
 * SeedVRImageOutput
 */
export const zSchemaSeedvrUpscaleImageOutput = z.object({
  image: zSchemaImageFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'The random seed used for the generation process.',
  }),
})

/**
 * SeedVRImageInput
 */
export const zSchemaSeedvrUpscaleImageInput = z.object({
  upscale_mode: z.optional(
    z.enum(['target', 'factor']).register(z.globalRegistry, {
      description:
        "The mode to use for the upscale. If 'target', the upscale factor will be calculated based on the target resolution. If 'factor', the upscale factor will be used directly.",
    }),
  ),
  noise_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The noise scale to use for the generation process.',
      }),
    )
    .default(0.1),
  output_format: z.optional(
    z.enum(['png', 'jpg', 'webp']).register(z.globalRegistry, {
      description: 'The format of the output image.',
    }),
  ),
  target_resolution: z.optional(
    z.enum(['720p', '1080p', '1440p', '2160p']).register(z.globalRegistry, {
      description:
        'The target resolution to upscale to when `upscale_mode` is `target`.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The input image to be processed',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  upscale_factor: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Upscaling factor to be used. Will multiply the dimensions with this factor when `upscale_mode` is `factor`.',
      }),
    )
    .default(2),
  seed: z.optional(z.union([z.int(), z.unknown()])),
})

/**
 * QwenImageOutput
 */
export const zSchemaQwenImageEditPlusOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * BaseQwenEditImagePlusInput
 */
export const zSchemaQwenImageEditPlusInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the image with',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular']).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: 'The URLs of the images to edit.',
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt for the generation',
      }),
    )
    .default(' '),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(100).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(50),
})

/**
 * ImageToImageOutput
 *
 * Output for image editing
 */
export const zSchemaWan25PreviewImageToImageOutput = z
  .object({
    images: z.array(zSchemaImageFile).register(z.globalRegistry, {
      description: 'The edited images',
    }),
    seeds: z.array(z.int()).register(z.globalRegistry, {
      description: 'The seeds used for each generated image',
    }),
    actual_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The original prompt (prompt expansion is not available for image editing)',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Output for image editing',
  })

/**
 * ImageToImageInput
 *
 * Input for image editing
 */
export const zSchemaWan25PreviewImageToImageInput = z
  .object({
    prompt: z.string().min(1).register(z.globalRegistry, {
      description:
        'The text prompt describing how to edit the image. Max 2000 characters.',
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate. Values from 1 to 4.',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
      ]),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'If set to true, the safety checker will be enabled.',
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          'Random seed for reproducibility. If None, a random seed is chosen.',
      }),
    ),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        'URLs of images to edit. For single-image editing, provide 1 URL. For multi-reference generation, provide up to 2 URLs. If more than 2 URLs are provided, only the first 2 will be used.',
    }),
    negative_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'Negative prompt to describe content to avoid. Max 500 characters.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Input for image editing',
  })

/**
 * QwenImageOutput
 */
export const zSchemaQwenImageEditImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseQwenEditImg2ImgInput
 */
export const zSchemaQwenImageEditImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the image with',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.",
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to edit.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'Strength of the image-to-image transformation. Lower values preserve more of the original image.',
      }),
    )
    .default(0.94),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(30),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt for the generation',
      }),
    )
    .default(' '),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * LucidFluxResponse
 */
export const zSchemaLucidfluxOutput = z.object({
  image: zSchemaImage,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for random number generation',
  }),
})

/**
 * LucidFluxRequest
 */
export const zSchemaLucidfluxInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image.',
  }),
  guidance: z
    .optional(
      z.number().gte(1).lte(30).register(z.globalRegistry, {
        description: 'The guidance to use for the diffusion process.',
      }),
    )
    .default(4),
  target_height: z
    .optional(
      z.int().gte(512).lte(1024).register(z.globalRegistry, {
        description: 'The height of the output image.',
      }),
    )
    .default(1024),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to edit.',
  }),
  target_width: z
    .optional(
      z.int().gte(512).lte(1024).register(z.globalRegistry, {
        description: 'The width of the output image.',
      }),
    )
    .default(1024),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description:
          'Number of inference steps for sampling. Higher values give better quality but take longer.',
      }),
    )
    .default(50),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Seed used for random number generation',
      }),
    )
    .default(42),
})

/**
 * QwenImageOutput
 */
export const zSchemaQwenImageEditPlusLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * BaseQwenEditImagePlusLoRAInput
 */
export const zSchemaQwenImageEditPlusLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the image with',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular']).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use up to 3 LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: 'The URLs of the images to edit.',
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt for the generation',
      }),
    )
    .default(' '),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * DreamOmni2Response
 */
export const zSchemaDreamomni2EditOutput = z.object({
  image: zSchemaImage,
})

/**
 * DreamOmni2Request
 */
export const zSchemaDreamomni2EditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image.',
  }),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: 'List of URLs of input images for editing.',
  }),
})

/**
 * Image2PixelOutput
 */
export const zSchemaImage2PixelOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description:
      'The processed pixel-art image (PNG) and the scaled image (PNG).',
  }),
  num_colors: z.int().register(z.globalRegistry, {
    description: 'The number of colors in the processed media.',
  }),
  palette: z.array(z.string()).register(z.globalRegistry, {
    description: 'The palette of the processed media.',
  }),
  pixel_scale: z.int().register(z.globalRegistry, {
    description: 'The detected pixel scale of the input.',
  }),
})

/**
 * Image2PixelInput
 */
export const zSchemaImage2PixelInput = z.object({
  cleanup_morph: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Apply morphological operations to remove noise.',
      }),
    )
    .default(false),
  auto_color_detect: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable automatic detection of optimal number of colors.',
      }),
    )
    .default(false),
  alpha_threshold: z
    .optional(
      z.int().gte(0).lte(255).register(z.globalRegistry, {
        description: 'Alpha binarization threshold (0-255).',
      }),
    )
    .default(128),
  snap_grid: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Align output to the pixel grid.',
      }),
    )
    .default(true),
  fixed_palette: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        "Optional fixed color palette as hex strings (e.g., ['#000000', '#ffffff']).",
    }),
  ),
  scale: z.optional(
    z.int().gte(1).lte(64).register(z.globalRegistry, {
      description: 'Force a specific pixel scale. If None, auto-detect.',
    }),
  ),
  cleanup_jaggy: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Remove isolated diagonal pixels (jaggy edge cleanup).',
      }),
    )
    .default(false),
  trim_borders: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Trim borders of the image.',
      }),
    )
    .default(false),
  background_tolerance: z
    .optional(
      z.int().gte(0).lte(255).register(z.globalRegistry, {
        description: 'Background tolerance (0-255).',
      }),
    )
    .default(0),
  detect_method: z.optional(
    z.enum(['auto', 'runs', 'edge']).register(z.globalRegistry, {
      description: 'Scale detection method to use.',
    }),
  ),
  transparent_background: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Remove background of the image. This will check for contiguous color regions from the edges after correction and make them transparent.',
      }),
    )
    .default(false),
  downscale_method: z.optional(
    z
      .enum(['dominant', 'median', 'mode', 'mean', 'content-adaptive'])
      .register(z.globalRegistry, {
        description: 'Downscaling method to produce the pixel-art output.',
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The image URL to process into improved pixel art',
  }),
  background_mode: z.optional(
    z.enum(['edges', 'corners', 'midpoints']).register(z.globalRegistry, {
      description:
        'Controls where to flood-fill from when removing the background.',
    }),
  ),
  max_colors: z
    .optional(
      z.int().gte(1).lte(256).register(z.globalRegistry, {
        description:
          'Maximum number of colors in the output palette. Set None to disable limit.',
      }),
    )
    .default(32),
  dominant_color_threshold: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Dominant color threshold (0.0-1.0).',
      }),
    )
    .default(0.05),
})

/**
 * ReveEditOutput
 *
 * Output for Reve image editing
 */
export const zSchemaReveEditOutput = z
  .object({
    images: z.array(zSchemaImage).register(z.globalRegistry, {
      description: 'The edited images',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Output for Reve image editing',
  })

/**
 * ReveEditInput
 *
 * Input for Reve image editing
 */
export const zSchemaReveEditInput = z
  .object({
    prompt: z.string().min(1).max(2560).register(z.globalRegistry, {
      description: 'The text description of how to edit the provided image.',
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'Output format for the generated image.',
      }),
    ),
    image_url: z.string().register(z.globalRegistry, {
      description:
        'URL of the reference image to edit. Must be publicly accessible or base64 data URI. Supports PNG, JPEG, WebP, AVIF, and HEIF formats.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Input for Reve image editing',
  })

/**
 * ReveRemixOutput
 *
 * Output for Reve image remixing
 */
export const zSchemaReveRemixOutput = z
  .object({
    images: z.array(zSchemaImage).register(z.globalRegistry, {
      description: 'The remixed images',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Output for Reve image remixing',
  })

/**
 * ReveRemixInput
 *
 * Input for Reve image remixing
 */
export const zSchemaReveRemixInput = z
  .object({
    prompt: z.string().min(1).max(2560).register(z.globalRegistry, {
      description:
        'The text description of the desired image. May include XML img tags like <img>0</img> to refer to specific images by their index in the image_urls list.',
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    aspect_ratio: z.optional(
      z
        .enum(['16:9', '9:16', '3:2', '2:3', '4:3', '3:4', '1:1'])
        .register(z.globalRegistry, {
          description:
            'The desired aspect ratio of the generated image. If not provided, will be smartly chosen by the model.',
        }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        'List of URLs of reference images. Must provide between 1 and 6 images (inclusive). Each image must be less than 10 MB. Supports PNG, JPEG, WebP, AVIF, and HEIF formats.',
    }),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'Output format for the generated image.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Input for Reve image remixing',
  })

/**
 * EditImageResponseMini
 */
export const zSchemaGptImage1MiniEditOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
})

/**
 * EditImageRequestMini
 */
export const zSchemaGptImage1MiniEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt for image generation',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'Number of images to generate',
      }),
    )
    .default(1),
  image_size: z.optional(
    z
      .enum(['auto', '1024x1024', '1536x1024', '1024x1536'])
      .register(z.globalRegistry, {
        description: 'Aspect ratio for the generated image',
      }),
  ),
  background: z.optional(
    z.enum(['auto', 'transparent', 'opaque']).register(z.globalRegistry, {
      description: 'Background for the generated image',
    }),
  ),
  quality: z.optional(
    z.enum(['auto', 'low', 'medium', 'high']).register(z.globalRegistry, {
      description: 'Quality for the generated image',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'Output format for the images',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The URLs of the images to use as a reference for the generation.',
  }),
})

/**
 * ChronoEditOutput
 *
 * Unified output model for all ChronoEdit operations
 */
export const zSchemaChronoEditOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'The prompt used for the inference.',
    }),
    images: z.array(zSchemaImageFile).register(z.globalRegistry, {
      description: 'The edited image.',
    }),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed for the inference.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Unified output model for all ChronoEdit operations',
  })

/**
 * ChronoEditInput
 *
 * Input model for ChronoEdit standard editing operations
 */
export const zSchemaChronoEditInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'The prompt to edit the image.',
    }),
    resolution: z.optional(
      z.enum(['480p', '720p']).register(z.globalRegistry, {
        description: 'The resolution of the output image.',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to enable the safety checker.',
        }),
      )
      .default(true),
    output_format: z.optional(
      z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image.',
      }),
    ),
    image_url: z.string().register(z.globalRegistry, {
      description: 'The image to edit.',
    }),
    turbo_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Enable turbo mode to use for faster inference.',
        }),
      )
      .default(true),
    num_temporal_reasoning_steps: z
      .optional(
        z.int().gte(2).lte(12).register(z.globalRegistry, {
          description: 'The number of temporal reasoning steps to perform.',
        }),
      )
      .default(8),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to return the image in sync mode.',
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(10).register(z.globalRegistry, {
          description: 'The guidance scale for the inference.',
        }),
      )
      .default(1),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(8),
    enable_temporal_reasoning: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to enable temporal reasoning.',
        }),
      )
      .default(false),
    enable_prompt_expansion: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to enable prompt expansion.',
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The seed for the inference.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Input model for ChronoEdit standard editing operations',
  })

/**
 * Emu35EditOutput
 */
export const zSchemaEmu35ImageEditImageOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The edited image.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed for the inference.',
  }),
})

/**
 * Emu35ImageEditInput
 */
export const zSchemaEmu35ImageEditImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image.',
  }),
  resolution: z.optional(
    z.enum(['480p', '720p']).register(z.globalRegistry, {
      description: 'The resolution of the output image.',
    }),
  ),
  aspect_ratio: z.optional(
    z
      .enum([
        'auto',
        '21:9',
        '16:9',
        '4:3',
        '3:2',
        '1:1',
        '2:3',
        '3:4',
        '9:16',
        '9:21',
      ])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the output image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the output image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The image to edit.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to return the image in sync mode.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable the safety checker.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed for the inference.',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaFluxVisionUpscalerOutput = z.object({
  image: zSchemaImage,
  caption: z.string().register(z.globalRegistry, {
    description: 'The VLM-generated caption describing the upscaled image.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used to generate the image.',
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'The timings of the different steps in the workflow.',
  }),
})

/**
 * Input
 */
export const zSchemaFluxVisionUpscalerInput = z.object({
  guidance: z
    .optional(
      z.number().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'CFG/guidance scale (1-4). Controls how closely the model follows the prompt.',
      }),
    )
    .default(1),
  creativity: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'The creativity of the model. The higher the creativity, the more the model will deviate from the original. Refers to the denoise strength of the sampling.',
      }),
    )
    .default(0.3),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to upscale.',
  }),
  upscale_factor: z
    .optional(
      z.number().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The upscale factor (1-4x).',
      }),
    )
    .default(2),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable the safety checker.',
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps (4-50).',
      }),
    )
    .default(20),
})

/**
 * OutpaintOutput
 */
export const zSchemaImageAppsV2OutpaintOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Outpainted image with extended scene',
  }),
})

/**
 * OutpaintInput
 */
export const zSchemaImageAppsV2OutpaintInput = z.object({
  prompt: z
    .optional(
      z.string().max(500).register(z.globalRegistry, {
        description:
          "Optional prompt to guide the outpainting. If provided, it will be appended to the base outpaint instruction. Example: 'with a beautiful sunset in the background'",
      }),
    )
    .default(''),
  expand_right: z
    .optional(
      z.int().gte(0).lte(700).register(z.globalRegistry, {
        description:
          'Number of pixels to add as black margin on the right side (0-700).',
      }),
    )
    .default(0),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'Number of images to generate.',
      }),
    )
    .default(1),
  zoom_out_percentage: z
    .optional(
      z.number().gte(0).lte(90).register(z.globalRegistry, {
        description:
          'Percentage to zoom out the image. If set, the image will be scaled down by this percentage and black margins will be added to maintain original size. Example: 50 means the image will be 50% of original size with black margins filling the rest.',
      }),
    )
    .default(20),
  output_format: z.optional(
    z.enum(['png', 'jpeg', 'jpg', 'webp']).register(z.globalRegistry, {
      description: 'The format of the output image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image URL to outpaint',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If True, the function will wait for the image to be generated and uploaded before returning the response. If False, the function will return immediately and the image will be generated asynchronously.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  expand_left: z
    .optional(
      z.int().gte(0).lte(700).register(z.globalRegistry, {
        description:
          'Number of pixels to add as black margin on the left side (0-700).',
      }),
    )
    .default(0),
  expand_bottom: z
    .optional(
      z.int().gte(0).lte(700).register(z.globalRegistry, {
        description:
          'Number of pixels to add as black margin on the bottom side (0-700).',
      }),
    )
    .default(400),
  expand_top: z
    .optional(
      z.int().gte(0).lte(700).register(z.globalRegistry, {
        description:
          'Number of pixels to add as black margin on the top side (0-700).',
      }),
    )
    .default(0),
})

/**
 * ReveFastEditOutput
 *
 * Output for Reve fast image editing
 */
export const zSchemaReveFastEditOutput = z
  .object({
    images: z.array(zSchemaImage).register(z.globalRegistry, {
      description: 'The edited images',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Output for Reve fast image editing',
  })

/**
 * ReveFastEditInput
 *
 * Input for Reve fast image editing
 */
export const zSchemaReveFastEditInput = z
  .object({
    prompt: z.string().min(1).max(2560).register(z.globalRegistry, {
      description: 'The text description of how to edit the provided image.',
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'Output format for the generated image.',
      }),
    ),
    image_url: z.string().register(z.globalRegistry, {
      description:
        'URL of the reference image to edit. Must be publicly accessible or base64 data URI. Supports PNG, JPEG, WebP, AVIF, and HEIF formats.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Input for Reve fast image editing',
  })

/**
 * ReveRemixOutput
 *
 * Output for Reve image remixing
 */
export const zSchemaReveFastRemixOutput = z
  .object({
    images: z.array(zSchemaImage).register(z.globalRegistry, {
      description: 'The remixed images',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Output for Reve image remixing',
  })

/**
 * ReveRemixInput
 *
 * Input for Reve image remixing
 */
export const zSchemaReveFastRemixInput = z
  .object({
    prompt: z.string().min(1).max(2560).register(z.globalRegistry, {
      description:
        'The text description of the desired image. May include XML img tags like <img>0</img> to refer to specific images by their index in the image_urls list.',
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    aspect_ratio: z.optional(
      z
        .enum(['16:9', '9:16', '3:2', '2:3', '4:3', '3:4', '1:1'])
        .register(z.globalRegistry, {
          description:
            'The desired aspect ratio of the generated image. If not provided, will be smartly chosen by the model.',
        }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        'List of URLs of reference images. Must provide between 1 and 6 images (inclusive). Each image must be less than 10 MB. Supports PNG, JPEG, WebP, AVIF, and HEIF formats.',
    }),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'Output format for the generated image.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Input for Reve image remixing',
  })

/**
 * AddBackgroundOutput
 */
export const zSchemaQwenImageEditPlusLoraGalleryAddBackgroundOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated/edited images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * AddBackgroundInput
 *
 * Input model for Add Background endpoint - Remove white background and add a realistic scene
 */
export const zSchemaQwenImageEditPlusLoraGalleryAddBackgroundInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'Describe the background/scene you want to add behind the object. The model will remove the white background and add the specified environment.',
        }),
      )
      .default(
        'Remove white background and add a realistic scene behind the object',
      ),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        'The URLs of the images to edit. Provide an image with a white or clean background.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Add Background endpoint - Remove white background and add a realistic scene',
  })

/**
 * FaceToFullPortraitOutput
 */
export const zSchemaQwenImageEditPlusLoraGalleryFaceToFullPortraitOutput =
  z.object({
    images: z.array(zSchemaImage).register(z.globalRegistry, {
      description: 'The generated/edited images',
    }),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
  })

/**
 * FaceToFullPortraitInput
 *
 * Input model for Face to Full Portrait endpoint - Generate full portrait from a cropped face image
 */
export const zSchemaQwenImageEditPlusLoraGalleryFaceToFullPortraitInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'Describe the full portrait you want to generate from the face. Include clothing, setting, pose, and style details.',
        }),
      )
      .default(
        'Photography. A portrait of the person in professional attire with natural lighting',
      ),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        'The URL of the cropped face image. Provide a close-up face photo.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Face to Full Portrait endpoint - Generate full portrait from a cropped face image',
  })

/**
 * GroupPhotoOutput
 */
export const zSchemaQwenImageEditPlusLoraGalleryGroupPhotoOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated/edited images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * GroupPhotoInput
 *
 * Input model for Group Photo endpoint - Create composite group photos with vintage/retro style
 */
export const zSchemaQwenImageEditPlusLoraGalleryGroupPhotoInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'Describe the group photo scene, setting, and style. The model will maintain character consistency and add vintage effects like grain, blur, and retro filters.',
        }),
      )
      .default(
        'Two people standing next to each other outside with a landscape background',
      ),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        'The URLs of the images to combine into a group photo. Provide 2 or more individual portrait images.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Group Photo endpoint - Create composite group photos with vintage/retro style',
  })

/**
 * IntegrateProductOutput
 */
export const zSchemaQwenImageEditPlusLoraGalleryIntegrateProductOutput =
  z.object({
    images: z.array(zSchemaImage).register(z.globalRegistry, {
      description: 'The generated/edited images',
    }),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
  })

/**
 * IntegrateProductInput
 *
 * Input model for Integrate Product endpoint - Blend and integrate products/elements into backgrounds
 */
export const zSchemaQwenImageEditPlusLoraGalleryIntegrateProductInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'Describe how to blend and integrate the product/element into the background. The model will automatically correct perspective, lighting and shadows for natural integration.',
        }),
      )
      .default('Blend and integrate the product into the background'),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        'The URL of the image with product to integrate into background.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Integrate Product endpoint - Blend and integrate products/elements into backgrounds',
  })

/**
 * NextSceneOutput
 */
export const zSchemaQwenImageEditPlusLoraGalleryNextSceneOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated/edited images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * NextSceneInput
 *
 * Input model for Next Scene endpoint - Create cinematic shot progressions and scene transitions
 */
export const zSchemaQwenImageEditPlusLoraGalleryNextSceneInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe the camera movement, framing change, or scene transition. Start with 'Next Scene:' for best results. Examples: camera movements (dolly, push-in, pull-back), framing changes (wide to close-up), new elements entering frame.",
        }),
      )
      .default(
        'Next Scene: The camera moves forward revealing more of the scene',
      ),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: 'The URL of the image to create the next scene from.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Next Scene endpoint - Create cinematic shot progressions and scene transitions',
  })

/**
 * RemoveElementOutput
 */
export const zSchemaQwenImageEditPlusLoraGalleryRemoveElementOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated/edited images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * RemoveElementInput
 *
 * Input model for Remove Element endpoint - Remove/delete elements (objects, people, text) from the image
 */
export const zSchemaQwenImageEditPlusLoraGalleryRemoveElementInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'Specify what element(s) to remove from the image (objects, people, text, etc.). The model will cleanly remove the element while maintaining consistency of the rest of the image.',
        }),
      )
      .default('Remove the specified element from the scene'),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: 'The URL of the image containing elements to remove.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Remove Element endpoint - Remove/delete elements (objects, people, text) from the image',
  })

/**
 * RemoveLightingOutput
 */
export const zSchemaQwenImageEditPlusLoraGalleryRemoveLightingOutput = z.object(
  {
    images: z.array(zSchemaImage).register(z.globalRegistry, {
      description: 'The generated/edited images',
    }),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
  },
)

/**
 * RemoveLightingInput
 *
 * Input model for Remove Lighting endpoint - Remove existing lighting and apply soft even lighting
 */
export const zSchemaQwenImageEditPlusLoraGalleryRemoveLightingInput = z
  .object({
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: 'The URL of the image with lighting/shadows to remove.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Remove Lighting endpoint - Remove existing lighting and apply soft even lighting',
  })

/**
 * ShirtDesignOutput
 */
export const zSchemaQwenImageEditPlusLoraGalleryShirtDesignOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated/edited images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * ShirtDesignInput
 *
 * Input model for Shirt Design endpoint - Put designs/graphics on people's shirts
 */
export const zSchemaQwenImageEditPlusLoraGalleryShirtDesignInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe what design to put on the shirt. The model will apply the design from your input image onto the person's shirt.",
        }),
      )
      .default('Put this design on their shirt'),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        'The URLs of the images: first image is the person wearing a shirt, second image is the design/logo to put on the shirt.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Shirt Design endpoint - Put designs/graphics on people's shirts",
  })

/**
 * MultipleAnglesOutput
 */
export const zSchemaQwenImageEditPlusLoraGalleryMultipleAnglesOutput = z.object(
  {
    images: z.array(zSchemaImage).register(z.globalRegistry, {
      description: 'The generated/edited images',
    }),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
  },
)

/**
 * MultipleAnglesInput
 *
 * Input model for Multiple Angles endpoint - Camera control with precise adjustments
 */
export const zSchemaQwenImageEditPlusLoraGalleryMultipleAnglesInput = z
  .object({
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    wide_angle_lens: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Enable wide-angle lens effect',
        }),
      )
      .default(false),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: 'The URL of the image to adjust camera angle for.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    vertical_angle: z
      .optional(
        z.number().gte(-1).lte(1).register(z.globalRegistry, {
          description:
            "Adjust vertical camera angle (-1=bird's-eye view/looking down, 0=neutral, 1=worm's-eye view/looking up)",
        }),
      )
      .default(0),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    move_forward: z
      .optional(
        z.number().gte(0).lte(10).register(z.globalRegistry, {
          description: 'Move camera forward (0=no movement, 10=close-up)',
        }),
      )
      .default(0),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    rotate_right_left: z
      .optional(
        z.number().gte(-90).lte(90).register(z.globalRegistry, {
          description:
            'Rotate camera left (positive) or right (negative) in degrees. Positive values rotate left, negative values rotate right.',
        }),
      )
      .default(0),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the camera control effect.',
        }),
      )
      .default(1.25),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Multiple Angles endpoint - Camera control with precise adjustments',
  })

/**
 * NanoBananaImageToImageOutput
 */
export const zSchemaNanoBananaProEditOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The edited images.',
  }),
  description: z.string().register(z.globalRegistry, {
    description: 'The description of the generated images.',
  }),
})

/**
 * NanoBananaImageToImageInput
 */
export const zSchemaNanoBananaProEditInput = z.object({
  prompt: z.string().min(3).max(50000).register(z.globalRegistry, {
    description: 'The prompt for image editing.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  enable_web_search: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Enable web search for the image generation task. This will allow the model to use the latest information from the web to generate the image.',
      }),
    )
    .default(false),
  aspect_ratio: z.optional(
    z
      .enum([
        'auto',
        '21:9',
        '16:9',
        '3:2',
        '4:3',
        '5:4',
        '1:1',
        '4:5',
        '3:4',
        '2:3',
        '9:16',
      ])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  resolution: z.optional(
    z.enum(['1K', '2K', '4K']).register(z.globalRegistry, {
      description: 'The resolution of the image to generate.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed for the random number generator.',
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The URLs of the images to use for image-to-image generation or image editing.',
  }),
  limit_generations: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.',
      }),
    )
    .default(false),
})

/**
 * NanoBananaImageToImageOutput
 */
export const zSchemaGemini3ProImagePreviewEditOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The edited images.',
  }),
  description: z.string().register(z.globalRegistry, {
    description: 'The description of the generated images.',
  }),
})

/**
 * NanoBananaImageToImageInput
 */
export const zSchemaGemini3ProImagePreviewEditInput = z.object({
  prompt: z.string().min(3).max(50000).register(z.globalRegistry, {
    description: 'The prompt for image editing.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  enable_web_search: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Enable web search for the image generation task. This will allow the model to use the latest information from the web to generate the image.',
      }),
    )
    .default(false),
  resolution: z.optional(
    z.enum(['1K', '2K', '4K']).register(z.globalRegistry, {
      description: 'The resolution of the image to generate.',
    }),
  ),
  aspect_ratio: z.optional(
    z
      .enum([
        'auto',
        '21:9',
        '16:9',
        '3:2',
        '4:3',
        '5:4',
        '1:1',
        '4:5',
        '3:4',
        '2:3',
        '9:16',
      ])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed for the random number generator.',
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The URLs of the images to use for image-to-image generation or image editing.',
  }),
  limit_generations: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.',
      }),
    )
    .default(false),
})

/**
 * MaskMetadata
 */
export const zSchemaMaskMetadata = z.object({
  box: z.optional(
    z.array(z.number()).register(z.globalRegistry, {
      description:
        'Bounding box for the mask in normalized cxcywh coordinates.',
    }),
  ),
  score: z.optional(
    z.number().register(z.globalRegistry, {
      description: 'Score for this mask.',
    }),
  ),
  index: z.int().register(z.globalRegistry, {
    description: 'Index of the mask inside the model output.',
  }),
})

/**
 * SAM3ImageOutput
 */
export const zSchemaSam3ImageOutput = z.object({
  image: z.optional(zSchemaImage),
  metadata: z.optional(
    z.array(zSchemaMaskMetadata).register(z.globalRegistry, {
      description: 'Per-mask metadata including scores and boxes.',
    }),
  ),
  masks: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Segmented mask images.',
  }),
  scores: z.optional(
    z.array(z.number()).register(z.globalRegistry, {
      description: 'Per-mask confidence scores when requested.',
    }),
  ),
  boxes: z.optional(
    z.array(z.array(z.number())).register(z.globalRegistry, {
      description:
        'Per-mask normalized bounding boxes [cx, cy, w, h] when requested.',
    }),
  ),
})

/**
 * SAM3ImageInput
 */
export const zSchemaSam3ImageInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Text prompt for segmentation',
      }),
    )
    .default('wheel'),
  include_boxes: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to include bounding boxes for each mask (when available).',
      }),
    )
    .default(false),
  box_prompts: z
    .optional(
      z.array(zSchemaBoxPrompt).register(z.globalRegistry, {
        description:
          'Box prompt coordinates (x_min, y_min, x_max, y_max). Multiple boxes supported - use object_id to group boxes for the same object or leave empty for separate objects.',
      }),
    )
    .default([]),
  return_multiple_masks: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If True, upload and return multiple generated masks as defined by `max_masks`.',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be segmented',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If True, the media will be returned as a data URI.',
      }),
    )
    .default(false),
  point_prompts: z
    .optional(
      z.array(zSchemaPointPrompt).register(z.globalRegistry, {
        description: 'List of point prompts',
      }),
    )
    .default([]),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  max_masks: z
    .optional(
      z.int().gte(1).lte(32).register(z.globalRegistry, {
        description:
          'Maximum number of masks to return when `return_multiple_masks` is enabled.',
      }),
    )
    .default(3),
  include_scores: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to include mask confidence scores.',
      }),
    )
    .default(false),
  apply_mask: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Apply the mask on the image.',
      }),
    )
    .default(true),
  text_prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "[DEPRECATED] Use 'prompt' instead. Kept for backward compatibility.",
    }),
  ),
})

/**
 * SAM3RLEOutput
 */
export const zSchemaSam3ImageRleOutput = z.object({
  rle: z.union([z.string(), z.array(z.string())]),
  metadata: z.optional(
    z.array(zSchemaMaskMetadata).register(z.globalRegistry, {
      description: 'Per-mask metadata when multiple RLEs are returned.',
    }),
  ),
  scores: z.optional(
    z.array(z.number()).register(z.globalRegistry, {
      description: 'Per-mask confidence scores when requested.',
    }),
  ),
  boundingbox_frames_zip: z.optional(zSchemaFile),
  boxes: z.optional(
    z.array(z.array(z.number())).register(z.globalRegistry, {
      description:
        'Per-mask normalized bounding boxes [cx, cy, w, h] when requested.',
    }),
  ),
})

/**
 * SAM3ImageInput
 */
export const zSchemaSam3ImageRleInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Text prompt for segmentation',
      }),
    )
    .default('wheel'),
  include_boxes: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to include bounding boxes for each mask (when available).',
      }),
    )
    .default(false),
  box_prompts: z
    .optional(
      z.array(zSchemaBoxPrompt).register(z.globalRegistry, {
        description:
          'Box prompt coordinates (x_min, y_min, x_max, y_max). Multiple boxes supported - use object_id to group boxes for the same object or leave empty for separate objects.',
      }),
    )
    .default([]),
  return_multiple_masks: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If True, upload and return multiple generated masks as defined by `max_masks`.',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be segmented',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If True, the media will be returned as a data URI.',
      }),
    )
    .default(false),
  point_prompts: z
    .optional(
      z.array(zSchemaPointPrompt).register(z.globalRegistry, {
        description: 'List of point prompts',
      }),
    )
    .default([]),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  max_masks: z
    .optional(
      z.int().gte(1).lte(32).register(z.globalRegistry, {
        description:
          'Maximum number of masks to return when `return_multiple_masks` is enabled.',
      }),
    )
    .default(3),
  include_scores: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to include mask confidence scores.',
      }),
    )
    .default(false),
  apply_mask: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Apply the mask on the image.',
      }),
    )
    .default(true),
  text_prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "[DEPRECATED] Use 'prompt' instead. Kept for backward compatibility.",
    }),
  ),
})

/**
 * ChronoEditOutput
 *
 * Unified output model for all ChronoEdit operations
 */
export const zSchemaChronoEditLoraGalleryUpscalerOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'The prompt used for the inference.',
    }),
    images: z.array(zSchemaImageFile).register(z.globalRegistry, {
      description: 'The edited image.',
    }),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed for the inference.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Unified output model for all ChronoEdit operations',
  })

/**
 * ChronoLoraWeight
 */
export const zSchemaChronoLoraWeight = z.object({
  path: z.string().register(z.globalRegistry, {
    description: 'URL or path to the LoRA weights (Safetensors).',
  }),
  scale: z
    .optional(
      z.number().gte(0).lte(4).register(z.globalRegistry, {
        description: 'Scale factor controlling LoRA strength.',
      }),
    )
    .default(1),
})

/**
 * ChronoEditUpscalerInput
 *
 * Input for upscaler mode
 */
export const zSchemaChronoEditLoraGalleryUpscalerInput = z
  .object({
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: 'The scale factor for the LoRA adapter.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image.',
      }),
    ),
    image_url: z.string().register(z.globalRegistry, {
      description: 'The image to upscale.',
    }),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to return the image in sync mode.',
        }),
      )
      .default(false),
    loras: z
      .optional(
        z.array(zSchemaChronoLoraWeight).register(z.globalRegistry, {
          description: 'Optional additional LoRAs to merge (max 3).',
        }),
      )
      .default([]),
    upscale_factor: z
      .optional(
        z.number().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Target scale factor for the output resolution.',
        }),
      )
      .default(2),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(10).register(z.globalRegistry, {
          description: 'The guidance scale for the inference.',
        }),
      )
      .default(1),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'Number of inference steps for the upscaling pass.',
        }),
      )
      .default(30),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The seed for the inference.',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to enable the safety checker.',
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: 'Input for upscaler mode',
  })

/**
 * ChronoEditOutput
 *
 * Unified output model for all ChronoEdit operations
 */
export const zSchemaChronoEditLoraGalleryPaintbrushOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'The prompt used for the inference.',
    }),
    images: z.array(zSchemaImageFile).register(z.globalRegistry, {
      description: 'The edited image.',
    }),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed for the inference.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Unified output model for all ChronoEdit operations',
  })

/**
 * ChronoEditPaintBrushInput
 *
 * Input for paintbrush mode
 */
export const zSchemaChronoEditLoraGalleryPaintbrushInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'Describe how to transform the sketched regions.',
    }),
    resolution: z.optional(
      z.enum(['480p', '720p']).register(z.globalRegistry, {
        description: 'The resolution of the output image.',
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: 'The scale factor for the LoRA adapter.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image.',
      }),
    ),
    image_url: z.string().register(z.globalRegistry, {
      description: 'The image to edit.',
    }),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to return the image in sync mode.',
        }),
      )
      .default(false),
    turbo_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Enable turbo mode to use faster inference.',
        }),
      )
      .default(true),
    loras: z
      .optional(
        z.array(zSchemaChronoLoraWeight).register(z.globalRegistry, {
          description: 'Optional additional LoRAs to merge (max 3).',
        }),
      )
      .default([]),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(10).register(z.globalRegistry, {
          description: 'Classifier-free guidance scale.',
        }),
      )
      .default(1),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'Number of denoising steps to run.',
        }),
      )
      .default(8),
    mask_url: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'Optional mask image where black areas indicate regions to sketch/paint.',
      }),
    ),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The seed for the inference.',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to enable the safety checker.',
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: 'Input for paintbrush mode',
  })

/**
 * ChronoEditOutput
 *
 * Unified output model for all ChronoEdit operations
 */
export const zSchemaChronoEditLoraOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'The prompt used for the inference.',
    }),
    images: z.array(zSchemaImageFile).register(z.globalRegistry, {
      description: 'The edited image.',
    }),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed for the inference.',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Unified output model for all ChronoEdit operations',
  })

/**
 * ChronoEditLoRAInput
 *
 * ChronoEdit input with optional custom LoRAs.
 */
export const zSchemaChronoEditLoraInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'The prompt to edit the image.',
    }),
    loras: z
      .optional(
        z.array(zSchemaChronoLoraWeight).register(z.globalRegistry, {
          description:
            'Optional additional LoRAs to merge for this request (max 3).',
        }),
      )
      .default([]),
    turbo_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Enable turbo mode to use for faster inference.',
        }),
      )
      .default(true),
    enable_temporal_reasoning: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to enable temporal reasoning.',
        }),
      )
      .default(false),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to enable the safety checker.',
        }),
      )
      .default(true),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(10).register(z.globalRegistry, {
          description: 'The guidance scale for the inference.',
        }),
      )
      .default(1),
    resolution: z.optional(
      z.enum(['480p', '720p']).register(z.globalRegistry, {
        description: 'The resolution of the output image.',
      }),
    ),
    output_format: z.optional(
      z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image.',
      }),
    ),
    num_temporal_reasoning_steps: z
      .optional(
        z.int().gte(2).lte(12).register(z.globalRegistry, {
          description: 'The number of temporal reasoning steps to perform.',
        }),
      )
      .default(8),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to return the image in sync mode.',
        }),
      )
      .default(false),
    image_url: z.string().register(z.globalRegistry, {
      description: 'The image to edit.',
    }),
    enable_prompt_expansion: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to enable prompt expansion.',
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(8),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The seed for the inference.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'ChronoEdit input with optional custom LoRAs.',
  })

/**
 * Flux2FlexEditOutput
 */
export const zSchemaFlux2FlexEditOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for the generation.',
  }),
})

/**
 * Flux2FlexImageEditInput
 */
export const zSchemaFlux2FlexEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  guidance_scale: z
    .optional(
      z.number().gte(1.5).lte(10).register(z.globalRegistry, {
        description: 'The guidance scale to use for the generation.',
      }),
    )
    .default(3.5),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'auto',
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.',
    }),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to expand the prompt using the model's own knowledge.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: 'List of URLs of input images for editing',
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable the safety checker.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed to use for the generation.',
    }),
  ),
})

/**
 * CrystalUpscaleOutput
 */
export const zSchemaCrystalUpscalerOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'List of upscaled images',
  }),
})

/**
 * CrystalUpscaleInput
 */
export const zSchemaCrystalUpscalerInput = z.object({
  creativity: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Creativity level for upscaling',
      }),
    )
    .default(0),
  scale_factor: z
    .optional(
      z.number().gte(1).lte(200).register(z.globalRegistry, {
        description: 'Scale factor',
      }),
    )
    .default(2),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL to the input image',
  }),
})

/**
 * AddBackgroundOutput
 */
export const zSchemaFlux2LoraGalleryAddBackgroundOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images with added background',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * AddBackgroundInput
 *
 * Input model for Add Background endpoint - Add background to images
 */
export const zSchemaFlux2LoraGalleryAddBackgroundInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "The prompt describing the background to add. Must start with 'Add Background' followed by your description.",
        }),
      )
      .default('Add Background forest'),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: 'The strength of the add background effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        'The URLs of the images. Provide an image with a white or clean background.',
    }),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Add Background endpoint - Add background to images',
  })

/**
 * ApartmentStagingOutput
 */
export const zSchemaFlux2LoraGalleryApartmentStagingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated furnished room images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * ApartmentStagingInput
 *
 * Input model for Apartment Staging endpoint - Furnish rooms
 */
export const zSchemaFlux2LoraGalleryApartmentStagingInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description:
        "The prompt to generate a furnished room. Use 'furnish this room' for best results.",
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: 'The strength of the apartment staging effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: 'The URL of the empty room image to furnish.',
    }),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description: 'Input model for Apartment Staging endpoint - Furnish rooms',
  })

/**
 * FaceToFullPortraitOutput
 */
export const zSchemaFlux2LoraGalleryFaceToFullPortraitOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated full portrait images from face',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * FaceToFullPortraitInput
 *
 * Input model for Face to Full Portrait endpoint - Generate full portrait from face
 */
export const zSchemaFlux2LoraGalleryFaceToFullPortraitInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'The prompt describing the full portrait to generate from the face.',
        }),
      )
      .default('Face to full portrait'),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: 'The strength of the face to full portrait effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: 'The URL of the cropped face image.',
    }),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Face to Full Portrait endpoint - Generate full portrait from face',
  })

/**
 * MultipleAnglesOutput
 */
export const zSchemaFlux2LoraGalleryMultipleAnglesOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images with multiple camera angles',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * MultipleAnglesInput
 *
 * Input model for Multiple Angles endpoint - Camera control with precise adjustments using <sks> trigger word. Prompt is built automatically from slider values.
 */
export const zSchemaFlux2LoraGalleryMultipleAnglesInput = z
  .object({
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description: 'Acceleration level for image generation.',
      }),
    ),
    horizontal_angle: z
      .optional(
        z.number().gte(0).lte(360).register(z.globalRegistry, {
          description:
            'Horizontal rotation angle around the object in degrees. 0=front view, 90=right side, 180=back view, 270=left side, 360=front view again.',
        }),
      )
      .default(0),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description: 'The CFG (Classifier Free Guidance) scale.',
        }),
      )
      .default(2.5),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to enable the safety checker.',
        }),
      )
      .default(true),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: 'The URL of the image to adjust camera angle for.',
    }),
    zoom: z
      .optional(
        z.number().gte(0).lte(10).register(z.globalRegistry, {
          description:
            'Camera zoom/distance. 0=wide shot (far away), 5=medium shot (normal), 10=close-up (very close).',
        }),
      )
      .default(5),
    vertical_angle: z
      .optional(
        z.number().gte(0).lte(60).register(z.globalRegistry, {
          description:
            'Vertical camera angle in degrees. 0=eye-level shot, 30=elevated shot, 60=high-angle shot (looking down from above).',
        }),
      )
      .default(0),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate.',
        }),
      )
      .default(1),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: 'The strength of the multiple angles effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image.',
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'If True, the media will be returned as a data URI.',
        }),
      )
      .default(false),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(40),
    seed: z.optional(z.union([z.int(), z.unknown()])),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Multiple Angles endpoint - Camera control with precise adjustments using <sks> trigger word. Prompt is built automatically from slider values.',
  })

/**
 * VirtualTryonOutput
 */
export const zSchemaFlux2LoraGalleryVirtualTryonOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated virtual try-on images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * VirtualTryonInput
 *
 * Input model for Virtual Try-on endpoint - Generate virtual try-on images
 */
export const zSchemaFlux2LoraGalleryVirtualTryonInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'The prompt to generate a virtual try-on image.',
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: 'The strength of the virtual try-on effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        'The URLs of the images for virtual try-on. Provide person image and clothing image.',
    }),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Virtual Try-on endpoint - Generate virtual try-on images',
  })

/**
 * OmniImageElementInput
 */
export const zSchemaOmniImageElementInput = z.object({
  reference_image_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'Additional reference images from different angles. 1-3 images supported. At least one image is required.',
    }),
  ),
  frontal_image_url: z.string().register(z.globalRegistry, {
    description: 'The frontal image of the element (main view).',
  }),
})

/**
 * OmniImageOutput
 */
export const zSchemaKlingImageO1Output = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Generated images',
  }),
})

/**
 * OmniImageRequest
 */
export const zSchemaKlingImageO1Input = z.object({
  prompt: z.string().max(2500).register(z.globalRegistry, {
    description:
      'Text prompt for image generation. Reference images using @Image1, @Image2, etc. (or @Image if only one image). Max 2500 characters.',
  }),
  aspect_ratio: z.optional(
    z
      .enum(['auto', '16:9', '9:16', '1:1', '4:3', '3:4', '3:2', '2:3', '21:9'])
      .register(z.globalRegistry, {
        description:
          "Aspect ratio of generated images. 'auto' intelligently determines based on input content.",
      }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(9).register(z.globalRegistry, {
        description: 'Number of images to generate (1-9).',
      }),
    )
    .default(1),
  resolution: z.optional(
    z.enum(['1K', '2K']).register(z.globalRegistry, {
      description: 'Image generation resolution. 1K: standard, 2K: high-res.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  elements: z.optional(
    z.array(zSchemaOmniImageElementInput).register(z.globalRegistry, {
      description:
        'Elements (characters/objects) to include in the image. Reference in prompt as @Element1, @Element2, etc. Maximum 10 total (elements + reference images).',
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'List of reference images. Reference images in prompt using @Image1, @Image2, etc. (1-indexed). Max 10 images.',
  }),
})

/**
 * ReferenceToImageOutput
 */
export const zSchemaViduQ2ReferenceToImageOutput = z.object({
  image: zSchemaImage,
})

/**
 * ReferenceToImageRequest
 */
export const zSchemaViduQ2ReferenceToImageInput = z.object({
  prompt: z.string().max(1500).register(z.globalRegistry, {
    description: 'Text prompt for video generation, max 1500 characters',
  }),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description: 'The aspect ratio of the output video',
    }),
  ),
  reference_image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'URLs of the reference images to use for consistent subject appearance',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for generation',
    }),
  ),
})

/**
 * SeedDream45EditOutput
 */
export const zSchemaBytedanceSeedreamV45EditOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Generated images',
  }),
})

/**
 * SeedDream45EditInput
 */
export const zSchemaBytedanceSeedreamV45EditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt used to edit the image',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(6).register(z.globalRegistry, {
        description:
          'Number of separate model generations to be run with the prompt.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
        'auto_2K',
        'auto_4K',
      ]),
    ]),
  ),
  max_images: z
    .optional(
      z.int().gte(1).lte(6).register(z.globalRegistry, {
        description:
          'If set to a number greater than one, enables multi-image generation. The model will potentially return up to `max_images` images every generation, and in total, `num_images` generations will be carried out. In total, the number of images generated will be between `num_images` and `max_images*num_images`. The total number of images (image inputs + image outputs) must not exceed 15',
      }),
    )
    .default(1),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed to control the stochasticity of image generation.',
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'List of URLs of input images for editing. Presently, up to 10 image inputs are allowed. If over 10 images are sent, only the last 10 will be used.',
  }),
})

/**
 * ImageToImageOutput
 */
export const zSchemaLongcatImageEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * EditImageInput
 */
export const zSchemaLongcatImageEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image with.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to edit.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: 'The guidance scale to use for the image generation.',
      }),
    )
    .default(4.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * ZImageTurboImageToImageOutput
 */
export const zSchemaZImageTurboImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      'Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'The timings of the generation process.',
  }),
})

/**
 * ZImageTurboImageToImageInput
 */
export const zSchemaZImageTurboImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
        'auto',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of Image for Image-to-Image generation.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The strength of the image-to-image conditioning.',
      }),
    )
    .default(0.6),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(8),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * ZImageTurboImageToImageOutput
 */
export const zSchemaZImageTurboImageToImageLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      'Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'The timings of the generation process.',
  }),
})

/**
 * LoRAInput
 *
 * LoRA weight configuration.
 */
export const zSchemaLoRaInput = z
  .object({
    path: z.string().register(z.globalRegistry, {
      description: 'URL, HuggingFace repo ID (owner/repo) to lora weights.',
    }),
    scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description: 'Scale factor for LoRA application (0.0 to 4.0).',
        }),
      )
      .default(1),
  })
  .register(z.globalRegistry, {
    description: 'LoRA weight configuration.',
  })

/**
 * ZImageTurboImageToImageLoRAInput
 */
export const zSchemaZImageTurboImageToImageLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
        'auto',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of Image for Image-to-Image generation.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoRaInput).register(z.globalRegistry, {
        description: 'List of LoRA weights to apply (maximum 3).',
      }),
    )
    .default([]),
  strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The strength of the image-to-image conditioning.',
      }),
    )
    .default(0.6),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * ZImageTurboControlNetOutput
 */
export const zSchemaZImageTurboControlnetOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      'Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'The timings of the generation process.',
  }),
})

/**
 * ZImageTurboControlNetInput
 */
export const zSchemaZImageTurboControlnetInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
        'auto',
      ]),
    ]),
  ),
  control_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The end of the controlnet conditioning.',
      }),
    )
    .default(0.8),
  control_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The start of the controlnet conditioning.',
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of Image for ControlNet generation.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  control_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The scale of the controlnet conditioning.',
      }),
    )
    .default(0.75),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  preprocess: z.optional(
    z.enum(['none', 'canny', 'depth', 'pose']).register(z.globalRegistry, {
      description: 'What kind of preprocessing to apply to the image, if any.',
    }),
  ),
})

/**
 * ZImageTurboControlNetOutput
 */
export const zSchemaZImageTurboControlnetLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      'Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'The timings of the generation process.',
  }),
})

/**
 * ZImageTurboControlNetLoRAInput
 */
export const zSchemaZImageTurboControlnetLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
        'auto',
      ]),
    ]),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoRaInput).register(z.globalRegistry, {
        description: 'List of LoRA weights to apply (maximum 3).',
      }),
    )
    .default([]),
  control_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The end of the controlnet conditioning.',
      }),
    )
    .default(0.8),
  control_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The start of the controlnet conditioning.',
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of Image for ControlNet generation.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  control_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The scale of the controlnet conditioning.',
      }),
    )
    .default(0.75),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  preprocess: z.optional(
    z.enum(['none', 'canny', 'depth', 'pose']).register(z.globalRegistry, {
      description: 'What kind of preprocessing to apply to the image, if any.',
    }),
  ),
})

/**
 * ImageOutput
 */
export const zSchemaStepxEdit2Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  best_info: z.optional(
    z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
      description:
        'Reflection analysis (only available when reflection mode is enabled).',
    }),
  ),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  timings: z.record(z.string(), z.number()),
  reformat_prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "The model's interpretation of your instruction (only available when thinking mode is enabled).",
    }),
  ),
  think_info: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'Reasoning process details (only available when thinking mode is enabled).',
    }),
  ),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * ImageToImageInput
 */
export const zSchemaStepxEdit2Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enable_reflection_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Enable reflection mode. Reviews outputs, corrects unintended changes, and determines when editing is complete.',
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The image URL to generate an image from. Needs to match the dimensions of the mask.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The true CFG scale. Controls how closely the model follows the prompt.\n        ',
      }),
    )
    .default(6),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(100).register(z.globalRegistry, {
        description:
          'The number of inference steps to perform. Recommended: 50.',
      }),
    )
    .default(50),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  enable_thinking_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Enable thinking mode. Uses multimodal language model knowledge to interpret abstract editing instructions.',
      }),
    )
    .default(true),
})

/**
 * Schema referenced but not defined by fal.ai (missing from source OpenAPI spec)
 */
export const zSchemaPoint = z
  .record(z.string(), z.unknown())
  .register(z.globalRegistry, {
    description:
      'Schema referenced but not defined by fal.ai (missing from source OpenAPI spec)',
  })

/**
 * UsageInfo
 */
export const zSchemaUsageInfo = z.object({
  output_tokens: z.int().register(z.globalRegistry, {
    description: 'Number of output tokens generated',
  }),
  decode_time_ms: z.number().register(z.globalRegistry, {
    description: 'Time taken for decoding in milliseconds',
  }),
  input_tokens: z.int().register(z.globalRegistry, {
    description: 'Number of input tokens processed',
  }),
  ttft_ms: z.number().register(z.globalRegistry, {
    description: 'Time to first token in milliseconds',
  }),
  prefill_time_ms: z.number().register(z.globalRegistry, {
    description: 'Time taken for prefill in milliseconds',
  }),
})

/**
 * Object
 */
export const zSchemaObject = z.object({
  y_min: z.number().register(z.globalRegistry, {
    description: 'Top boundary of detection box in normalized format (0 to 1)',
  }),
  x_max: z.number().register(z.globalRegistry, {
    description:
      'Right boundary of detection box in normalized format (0 to 1)',
  }),
  x_min: z.number().register(z.globalRegistry, {
    description: 'Left boundary of detection box in normalized format (0 to 1)',
  }),
  y_max: z.number().register(z.globalRegistry, {
    description:
      'Bottom boundary of detection box in normalized format (0 to 1)',
  }),
})

/**
 * SegmentSamplingSettings
 */
export const zSchemaSegmentSamplingSettings = z.object({
  top_p: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Nucleus sampling probability mass to use, between 0 and 1.',
      }),
    )
    .default(1),
  max_tokens: z.optional(
    z.int().gte(1).register(z.globalRegistry, {
      description: 'Maximum number of tokens to generate.',
    }),
  ),
  temperature: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'Sampling temperature to use. Higher values will make the output more random, while lower values will make it more focused and deterministic.',
      }),
    )
    .default(1),
})

/**
 * MoondreamSegementationOutput
 */
export const zSchemaMoondream3PreviewSegmentOutput = z.object({
  finish_reason: z.string().register(z.globalRegistry, {
    description: 'Reason for finishing the output generation',
  }),
  image: z.optional(zSchemaImageFile),
  bbox: z.optional(zSchemaObject),
  path: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'SVG path data representing the segmentation mask. If not detected, will be null.',
    }),
  ),
  usage_info: zSchemaUsageInfo,
})

/**
 * MoondreamSegementationInput
 */
export const zSchemaMoondream3PreviewSegmentInput = z.object({
  spatial_references: z.optional(
    z
      .array(z.union([zSchemaPoint, z.array(z.number())]))
      .register(z.globalRegistry, {
        description:
          'Spatial references to guide the segmentation. By feeding in references you can help the segmentation process. Must be either list of Point object with x and y members, or list of arrays containing either 2 floats (x,y) or 4 floats (x1,y1,x2,y2). \n**NOTE**: You can also use the [**point endpoint**](https://fal.ai/models/fal-ai/moondream3-preview/point) to get points for the objects, and pass them in here.',
      }),
  ),
  settings: z.optional(zSchemaSegmentSamplingSettings),
  object: z.string().register(z.globalRegistry, {
    description: 'Object to be segmented in the image',
  }),
  preview: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to preview the output and return a binary mask of the image',
      }),
    )
    .default(false),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'URL of the image to be processed\n\nMax width: 7000px, Max height: 7000px, Timeout: 20.0s',
  }),
})

/**
 * LightingRestorationOutput
 */
export const zSchemaQwenImageEditPlusLoraGalleryLightingRestorationOutput =
  z.object({
    images: z.array(zSchemaImage).register(z.globalRegistry, {
      description: 'The generated/edited images',
    }),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
  })

/**
 * LightingRestorationInput
 *
 * Input model for Lighting Restoration endpoint - Restore natural lighting by removing harsh shadows and light spots
 */
export const zSchemaQwenImageEditPlusLoraGalleryLightingRestorationInput = z
  .object({
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: 'The URL of the image to restore lighting for.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Lighting Restoration endpoint - Restore natural lighting by removing harsh shadows and light spots',
  })

/**
 * QwenImageOutput
 */
export const zSchemaQwenImageEdit2509Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * BaseQwenEditImagePlusInput
 */
export const zSchemaQwenImageEdit2509Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the image with',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular']).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: 'The URLs of the images to edit.',
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt for the generation',
      }),
    )
    .default(' '),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(100).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(50),
})

/**
 * QwenImageOutput
 */
export const zSchemaQwenImageEdit2509LoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * BaseQwenEditImagePlusLoRAInput
 */
export const zSchemaQwenImageEdit2509LoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the image with',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular']).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular'. Higher acceleration increases speed. 'regular' balances speed and quality.",
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use up to 3 LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: 'The URLs of the images to edit.',
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt for the generation',
      }),
    )
    .default(' '),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * MultipleAnglesOutput
 */
export const zSchemaQwenImageEdit2509LoraGalleryMultipleAnglesOutput = z.object(
  {
    images: z.array(zSchemaImage).register(z.globalRegistry, {
      description: 'The generated/edited images',
    }),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
  },
)

/**
 * MultipleAnglesInput
 *
 * Input model for Multiple Angles endpoint - Camera control with precise adjustments
 */
export const zSchemaQwenImageEdit2509LoraGalleryMultipleAnglesInput = z
  .object({
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    wide_angle_lens: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Enable wide-angle lens effect',
        }),
      )
      .default(false),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: 'The URL of the image to adjust camera angle for.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    vertical_angle: z
      .optional(
        z.number().gte(-1).lte(1).register(z.globalRegistry, {
          description:
            "Adjust vertical camera angle (-1=bird's-eye view/looking down, 0=neutral, 1=worm's-eye view/looking up)",
        }),
      )
      .default(0),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    move_forward: z
      .optional(
        z.number().gte(0).lte(10).register(z.globalRegistry, {
          description: 'Move camera forward (0=no movement, 10=close-up)',
        }),
      )
      .default(0),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    rotate_right_left: z
      .optional(
        z.number().gte(-90).lte(90).register(z.globalRegistry, {
          description:
            'Rotate camera left (positive) or right (negative) in degrees. Positive values rotate left, negative values rotate right.',
        }),
      )
      .default(0),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the camera control effect.',
        }),
      )
      .default(1.25),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Multiple Angles endpoint - Camera control with precise adjustments',
  })

/**
 * NextSceneOutput
 */
export const zSchemaQwenImageEdit2509LoraGalleryNextSceneOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated/edited images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * NextSceneInput
 *
 * Input model for Next Scene endpoint - Create cinematic shot progressions and scene transitions
 */
export const zSchemaQwenImageEdit2509LoraGalleryNextSceneInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe the camera movement, framing change, or scene transition. Start with 'Next Scene:' for best results. Examples: camera movements (dolly, push-in, pull-back), framing changes (wide to close-up), new elements entering frame.",
        }),
      )
      .default(
        'Next Scene: The camera moves forward revealing more of the scene',
      ),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: 'The URL of the image to create the next scene from.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Next Scene endpoint - Create cinematic shot progressions and scene transitions',
  })

/**
 * AddBackgroundOutput
 */
export const zSchemaQwenImageEdit2509LoraGalleryAddBackgroundOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated/edited images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * AddBackgroundInput
 *
 * Input model for Add Background endpoint - Remove white background and add a realistic scene
 */
export const zSchemaQwenImageEdit2509LoraGalleryAddBackgroundInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'Describe the background/scene you want to add behind the object. The model will remove the white background and add the specified environment.',
        }),
      )
      .default(
        'Remove white background and add a realistic scene behind the object',
      ),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        'The URLs of the images to edit. Provide an image with a white or clean background.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Add Background endpoint - Remove white background and add a realistic scene',
  })

/**
 * FaceToFullPortraitOutput
 */
export const zSchemaQwenImageEdit2509LoraGalleryFaceToFullPortraitOutput =
  z.object({
    images: z.array(zSchemaImage).register(z.globalRegistry, {
      description: 'The generated/edited images',
    }),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
  })

/**
 * FaceToFullPortraitInput
 *
 * Input model for Face to Full Portrait endpoint - Generate full portrait from a cropped face image
 */
export const zSchemaQwenImageEdit2509LoraGalleryFaceToFullPortraitInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'Describe the full portrait you want to generate from the face. Include clothing, setting, pose, and style details.',
        }),
      )
      .default(
        'Photography. A portrait of the person in professional attire with natural lighting',
      ),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        'The URL of the cropped face image. Provide a close-up face photo.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Face to Full Portrait endpoint - Generate full portrait from a cropped face image',
  })

/**
 * GroupPhotoOutput
 */
export const zSchemaQwenImageEdit2509LoraGalleryGroupPhotoOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated/edited images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * GroupPhotoInput
 *
 * Input model for Group Photo endpoint - Create composite group photos with vintage/retro style
 */
export const zSchemaQwenImageEdit2509LoraGalleryGroupPhotoInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'Describe the group photo scene, setting, and style. The model will maintain character consistency and add vintage effects like grain, blur, and retro filters.',
        }),
      )
      .default(
        'Two people standing next to each other outside with a landscape background',
      ),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        'The URLs of the images to combine into a group photo. Provide 2 or more individual portrait images.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Group Photo endpoint - Create composite group photos with vintage/retro style',
  })

/**
 * IntegrateProductOutput
 */
export const zSchemaQwenImageEdit2509LoraGalleryIntegrateProductOutput =
  z.object({
    images: z.array(zSchemaImage).register(z.globalRegistry, {
      description: 'The generated/edited images',
    }),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
  })

/**
 * IntegrateProductInput
 *
 * Input model for Integrate Product endpoint - Blend and integrate products/elements into backgrounds
 */
export const zSchemaQwenImageEdit2509LoraGalleryIntegrateProductInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'Describe how to blend and integrate the product/element into the background. The model will automatically correct perspective, lighting and shadows for natural integration.',
        }),
      )
      .default('Blend and integrate the product into the background'),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        'The URL of the image with product to integrate into background.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Integrate Product endpoint - Blend and integrate products/elements into backgrounds',
  })

/**
 * LightingRestorationOutput
 */
export const zSchemaQwenImageEdit2509LoraGalleryLightingRestorationOutput =
  z.object({
    images: z.array(zSchemaImage).register(z.globalRegistry, {
      description: 'The generated/edited images',
    }),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
  })

/**
 * LightingRestorationInput
 *
 * Input model for Lighting Restoration endpoint - Restore natural lighting by removing harsh shadows and light spots
 */
export const zSchemaQwenImageEdit2509LoraGalleryLightingRestorationInput = z
  .object({
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: 'The URL of the image to restore lighting for.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Lighting Restoration endpoint - Restore natural lighting by removing harsh shadows and light spots',
  })

/**
 * RemoveElementOutput
 */
export const zSchemaQwenImageEdit2509LoraGalleryRemoveElementOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated/edited images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * RemoveElementInput
 *
 * Input model for Remove Element endpoint - Remove/delete elements (objects, people, text) from the image
 */
export const zSchemaQwenImageEdit2509LoraGalleryRemoveElementInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'Specify what element(s) to remove from the image (objects, people, text, etc.). The model will cleanly remove the element while maintaining consistency of the rest of the image.',
        }),
      )
      .default('Remove the specified element from the scene'),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: 'The URL of the image containing elements to remove.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Remove Element endpoint - Remove/delete elements (objects, people, text) from the image',
  })

/**
 * RemoveLightingOutput
 */
export const zSchemaQwenImageEdit2509LoraGalleryRemoveLightingOutput = z.object(
  {
    images: z.array(zSchemaImage).register(z.globalRegistry, {
      description: 'The generated/edited images',
    }),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
  },
)

/**
 * RemoveLightingInput
 *
 * Input model for Remove Lighting endpoint - Remove existing lighting and apply soft even lighting
 */
export const zSchemaQwenImageEdit2509LoraGalleryRemoveLightingInput = z
  .object({
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: 'The URL of the image with lighting/shadows to remove.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Remove Lighting endpoint - Remove existing lighting and apply soft even lighting',
  })

/**
 * ShirtDesignOutput
 */
export const zSchemaQwenImageEdit2509LoraGalleryShirtDesignOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated/edited images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * ShirtDesignInput
 *
 * Input model for Shirt Design endpoint - Put designs/graphics on people's shirts
 */
export const zSchemaQwenImageEdit2509LoraGalleryShirtDesignInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            "Describe what design to put on the shirt. The model will apply the design from your input image onto the person's shirt.",
        }),
      )
      .default('Put this design on their shirt'),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
        z.unknown(),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the LoRA effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(1),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        'The URLs of the images: first image is the person wearing a shirt, second image is the design/logo to put on the shirt.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(' '),
    num_inference_steps: z
      .optional(
        z.int().gte(2).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(6),
  })
  .register(z.globalRegistry, {
    description:
      "Input model for Shirt Design endpoint - Put designs/graphics on people's shirts",
  })

/**
 * FluxSingleIDOutput
 */
export const zSchemaAiBabyAndAgingGeneratorSingleOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The final prompt used for generation',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * SingleFluxIDInput
 *
 * Input schema for single mode generation
 */
export const zSchemaAiBabyAndAgingGeneratorSingleInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'Text prompt to guide the image generation',
        }),
      )
      .default('a newborn baby, well dressed'),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
      ]),
    ),
    id_image_urls: z.array(z.string()).min(1).register(z.globalRegistry, {
      description:
        'List of ID images for single mode (or general reference images)',
    }),
    output_format: z.optional(
      z.enum(['jpeg', 'png']).register(z.globalRegistry, {
        description:
          "The format of the generated image. Choose from: 'jpeg' or 'png'.",
      }),
    ),
    age_group: z
      .enum([
        'baby',
        'toddler',
        'preschool',
        'gradeschooler',
        'teen',
        'adult',
        'mid',
        'senior',
      ])
      .register(z.globalRegistry, {
        description:
          "Age group for the generated image. Choose from: 'baby' (0-12 months), 'toddler' (1-3 years), 'preschool' (3-5 years), 'gradeschooler' (6-12 years), 'teen' (13-19 years), 'adult' (20-40 years), 'mid' (40-60 years), 'senior' (60+ years).",
      }),
    gender: z.enum(['male', 'female']).register(z.globalRegistry, {
      description:
        "Gender for the generated image. Choose from: 'male' or 'female'.",
    }),
    seed: z.optional(z.union([z.int(), z.unknown()])),
  })
  .register(z.globalRegistry, {
    description: 'Input schema for single mode generation',
  })

/**
 * FluxMultiIDOutput
 */
export const zSchemaAiBabyAndAgingGeneratorMultiOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The final prompt used for generation',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * MultiFluxIDInput
 *
 * Input schema for multi mode generation
 */
export const zSchemaAiBabyAndAgingGeneratorMultiInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'Text prompt to guide the image generation',
        }),
      )
      .default('a newborn baby, well dressed'),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
      ]),
    ),
    father_weight: z
      .optional(
        z.number().gte(0).lte(1).register(z.globalRegistry, {
          description:
            "Weight of the father's influence in multi mode generation",
        }),
      )
      .default(0.5),
    mother_image_urls: z.array(z.string()).min(1).register(z.globalRegistry, {
      description: 'List of mother images for multi mode',
    }),
    output_format: z.optional(
      z.enum(['jpeg', 'png']).register(z.globalRegistry, {
        description:
          "The format of the generated image. Choose from: 'jpeg' or 'png'.",
      }),
    ),
    age_group: z
      .enum([
        'baby',
        'toddler',
        'preschool',
        'gradeschooler',
        'teen',
        'adult',
        'mid',
        'senior',
      ])
      .register(z.globalRegistry, {
        description:
          "Age group for the generated image. Choose from: 'baby' (0-12 months), 'toddler' (1-3 years), 'preschool' (3-5 years), 'gradeschooler' (6-12 years), 'teen' (13-19 years), 'adult' (20-40 years), 'mid' (40-60 years), 'senior' (60+ years).",
      }),
    gender: z.enum(['male', 'female']).register(z.globalRegistry, {
      description:
        "Gender for the generated image. Choose from: 'male' or 'female'.",
    }),
    father_image_urls: z.array(z.string()).min(1).register(z.globalRegistry, {
      description: 'List of father images for multi mode',
    }),
    seed: z.optional(z.union([z.int(), z.unknown()])),
  })
  .register(z.globalRegistry, {
    description: 'Input schema for multi mode generation',
  })

/**
 * Flux2MaxEditOutput
 */
export const zSchemaFlux2MaxEditOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for the generation.',
  }),
})

/**
 * Flux2MaxImageEditInput
 */
export const zSchemaFlux2MaxEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'auto',
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable the safety checker.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed to use for the generation.',
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: 'List of URLs of input images for editing',
  }),
})

/**
 * Flux2TurboEditImageOutput
 */
export const zSchemaFlux2TurboEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The edited images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * Flux2TurboEditImageInput
 */
export const zSchemaFlux2TurboEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(2.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The URLs of the images for editing. A maximum of 4 images are allowed, if more are provided, only the first 4 will be used.',
  }),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded for better results.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * EditImageResponse
 */
export const zSchemaGptImage15EditOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
})

/**
 * EditImageRequest
 */
export const zSchemaGptImage15EditInput = z.object({
  input_fidelity: z.optional(
    z.enum(['low', 'high']).register(z.globalRegistry, {
      description: 'Input fidelity for the generated image',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'Number of images to generate',
      }),
    )
    .default(1),
  image_size: z.optional(
    z
      .enum(['auto', '1024x1024', '1536x1024', '1024x1536'])
      .register(z.globalRegistry, {
        description: 'Aspect ratio for the generated image',
      }),
  ),
  prompt: z.string().min(2).register(z.globalRegistry, {
    description: 'The prompt for image generation',
  }),
  quality: z.optional(
    z.enum(['low', 'medium', 'high']).register(z.globalRegistry, {
      description: 'Quality for the generated image',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'Output format for the images',
    }),
  ),
  background: z.optional(
    z.enum(['auto', 'transparent', 'opaque']).register(z.globalRegistry, {
      description: 'Background for the generated image',
    }),
  ),
  mask_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The URL of the mask image to use for the generation. This indicates what part of the image to edit.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The URLs of the images to use as a reference for the generation.',
  }),
})

/**
 * Flux2FlashEditImageOutput
 */
export const zSchemaFlux2FlashEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The edited images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * Flux2FlashEditImageInput
 */
export const zSchemaFlux2FlashEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(2.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The URLs of the images for editing. A maximum of 4 images are allowed, if more are provided, only the first 4 will be used.',
  }),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded for better results.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * ZImageTurboInpaintOutput
 */
export const zSchemaZImageTurboInpaintOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      'Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'The timings of the generation process.',
  }),
})

/**
 * ZImageTurboInpaintInput
 */
export const zSchemaZImageTurboInpaintInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
        'auto',
      ]),
    ]),
  ),
  mask_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of Mask for Inpaint generation.',
  }),
  control_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The end of the controlnet conditioning.',
      }),
    )
    .default(0.8),
  control_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The start of the controlnet conditioning.',
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of Image for Inpaint generation.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The strength of the inpaint conditioning.',
      }),
    )
    .default(1),
  control_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The scale of the controlnet conditioning.',
      }),
    )
    .default(0.75),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * ZImageTurboInpaintOutput
 */
export const zSchemaZImageTurboInpaintLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      'Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'The timings of the generation process.',
  }),
})

/**
 * ZImageTurboInpaintLoRAInput
 */
export const zSchemaZImageTurboInpaintLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
        'auto',
      ]),
    ]),
  ),
  mask_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of Mask for Inpaint generation.',
  }),
  loras: z
    .optional(
      z.array(zSchemaLoRaInput).register(z.globalRegistry, {
        description: 'List of LoRA weights to apply (maximum 3).',
      }),
    )
    .default([]),
  control_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The end of the controlnet conditioning.',
      }),
    )
    .default(0.8),
  control_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The start of the controlnet conditioning.',
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of Image for Inpaint generation.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The strength of the inpaint conditioning.',
      }),
    )
    .default(1),
  control_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The scale of the controlnet conditioning.',
      }),
    )
    .default(0.75),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * QwenImageLayeredOutput
 */
export const zSchemaQwenImageLayeredOutput = z.object({
  prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The prompt used to generate the image.',
    }),
  ),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaQwenImageLayeredInput = z.object({
  prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'A caption for the input image.',
    }),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  num_layers: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description: 'The number of layers to generate.',
      }),
    )
    .default(4),
  output_format: z.optional(
    z.enum(['png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the input image.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: 'The guidance scale to use for the image generation.',
      }),
    )
    .default(5),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to generate an image from.',
      }),
    )
    .default(''),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * ImageToImageOutput
 */
export const zSchemaQwenImageEdit2511Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * EditImageInput
 */
export const zSchemaQwenImageEdit2511Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image with.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If `True`, the media will be returned as a data URI.',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: 'The guidance scale to use for the image generation.',
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: 'The URLs of the images to edit.',
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to generate an image from.',
      }),
    )
    .default(''),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The same seed and the same prompt given to the same version of the model will output the same image every time.',
    }),
  ),
})

/**
 * ImageEditOutput
 *
 * Output for Wan 2.6 image editing
 */
export const zSchemaV26ImageToImageOutput = z
  .object({
    images: z.array(zSchemaFile).register(z.globalRegistry, {
      description: 'Generated images in PNG format',
    }),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Output for Wan 2.6 image editing',
  })

/**
 * ImageEditInput
 *
 * Input for Wan 2.6 image editing with reference images (enable_interleave=false)
 */
export const zSchemaV26ImageToImageInput = z
  .object({
    prompt: z.string().min(1).register(z.globalRegistry, {
      description:
        "Text prompt describing the desired image. Supports Chinese and English. Max 2000 characters. Example: 'Generate an image using the style of image 1 and background of image 2'.",
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description:
            'Number of images to generate (1-4). Directly affects billing cost.',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
      ]),
    ),
    enable_prompt_expansion: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Enable LLM prompt optimization. Significantly improves results for simple prompts but adds 3-4 seconds processing time.',
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          'Random seed for reproducibility (0-2147483647). Same seed produces more consistent results.',
      }),
    ),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        "Reference images for editing (1-3 images required). Order matters: reference as 'image 1', 'image 2', 'image 3' in prompt. Resolution: 384-5000px each dimension. Max size: 10MB each. Formats: JPEG, JPG, PNG (no alpha), BMP, WEBP.",
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'Content to avoid in the generated image. Max 500 characters.',
        }),
      )
      .default(''),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Enable content moderation for input and output.',
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description:
      'Input for Wan 2.6 image editing with reference images (enable_interleave=false)',
  })

/**
 * QwenImageLayeredOutput
 */
export const zSchemaQwenImageLayeredLoraOutput = z.object({
  prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The prompt used to generate the image.',
    }),
  ),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageLoRAInput
 */
export const zSchemaQwenImageLayeredLoraInput = z.object({
  prompt: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'A caption for the input image.',
    }),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  num_layers: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description: 'The number of layers to generate.',
      }),
    )
    .default(4),
  output_format: z.optional(
    z.enum(['png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the input image.',
  }),
  loras: z
    .optional(
      z.array(zSchemaLoRaInput).register(z.globalRegistry, {
        description: 'List of LoRA weights to apply (maximum 3).',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: 'The guidance scale to use for the image generation.',
      }),
    )
    .default(5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to generate an image from.',
      }),
    )
    .default(''),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * ArchEditOutput
 */
export const zSchemaAiHomeEditOutput = z.object({
  image: zSchemaImage,
  status: z.string().register(z.globalRegistry, {
    description: 'Status message with processing details',
  }),
})

/**
 * ArchEditInput
 */
export const zSchemaAiHomeEditInput = z.object({
  input_image_url: z.string().max(512).register(z.globalRegistry, {
    description: 'URL of the image to do architectural editing',
  }),
  editing_type: z
    .enum(['structural editing', 'virtual staging', 'both'])
    .register(z.globalRegistry, {
      description:
        'Type of editing. Structural editing only edits structural elements such as windows, walls etc. Virtual staging edits your furniture. Both do full editing including structural and furniture',
    }),
  style: z
    .enum([
      'minimalistic-interior',
      'farmhouse-interior',
      'luxury-interior',
      'modern-interior',
      'zen-interior',
      'mid century-interior',
      'airbnb-interior',
      'cozy-interior',
      'rustic-interior',
      'christmas-interior',
      'bohemian-interior',
      'tropical-interior',
      'industrial-interior',
      'japanese-interior',
      'vintage-interior',
      'loft-interior',
      'halloween-interior',
      'soho-interior',
      'baroque-interior',
      'kids room-interior',
      'girls room-interior',
      'boys room-interior',
      'scandinavian-interior',
      'french country-interior',
      'mediterranean-interior',
      'cyberpunk-interior',
      'hot pink-interior',
      'biophilic-interior',
      'ancient egypt-interior',
      'pixel-interior',
      'art deco-interior',
      'modern-exterior',
      'minimalistic-exterior',
      'farmhouse-exterior',
      'cozy-exterior',
      'luxury-exterior',
      'colonial-exterior',
      'zen-exterior',
      'asian-exterior',
      'creepy-exterior',
      'airstone-exterior',
      'ancient greek-exterior',
      'art deco-exterior',
      'brutalist-exterior',
      'christmas lights-exterior',
      'contemporary-exterior',
      'cottage-exterior',
      'dutch colonial-exterior',
      'federal colonial-exterior',
      'fire-exterior',
      'french provincial-exterior',
      'full glass-exterior',
      'georgian colonial-exterior',
      'gothic-exterior',
      'greek revival-exterior',
      'ice-exterior',
      'italianate-exterior',
      'mediterranean-exterior',
      'midcentury-exterior',
      'middle eastern-exterior',
      'minecraft-exterior',
      'morocco-exterior',
      'neoclassical-exterior',
      'spanish-exterior',
      'tudor-exterior',
      'underwater-exterior',
      'winter-exterior',
      'yard lighting-exterior',
    ])
    .register(z.globalRegistry, {
      description: 'Style for furniture and decor',
    }),
  additional_elements: z.optional(z.union([z.string().max(200), z.unknown()])),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description:
        "The format of the generated image. Choose from: 'jpeg' or 'png'.",
    }),
  ),
  architecture_type: z
    .enum([
      'living room-interior',
      'bedroom-interior',
      'kitchen-interior',
      'dining room-interior',
      'bathroom-interior',
      'laundry room-interior',
      'home office-interior',
      'study room-interior',
      'dorm room-interior',
      'coffee shop-interior',
      'gaming room-interior',
      'restaurant-interior',
      'office-interior',
      'attic-interior',
      'toilet-interior',
      'other-interior',
      'house-exterior',
      'villa-exterior',
      'backyard-exterior',
      'courtyard-exterior',
      'ranch-exterior',
      'office-exterior',
      'retail-exterior',
      'tower-exterior',
      'apartment-exterior',
      'school-exterior',
      'museum-exterior',
      'commercial-exterior',
      'residential-exterior',
      'other-exterior',
    ])
    .register(z.globalRegistry, {
      description: 'Type of architecture for appropriate furniture selection',
    }),
  color_palette: z
    .enum([
      'surprise me',
      'golden beige',
      'refined blues',
      'dusky elegance',
      'emerald charm',
      'crimson luxury',
      'golden sapphire',
      'soft pastures',
      'candy sky',
      'peach meadow',
      'muted sands',
      'ocean breeze',
      'frosted pastels',
      'spring bloom',
      'gentle horizon',
      'seaside breeze',
      'azure coast',
      'golden shore',
      'mediterranean gem',
      'ocean serenity',
      'serene blush',
      'muted horizon',
      'pastel shores',
      'dusky calm',
      'woodland retreat',
      'meadow glow',
      'forest canopy',
      'riverbank calm',
      'earthy tones',
      'earthy neutrals',
      'arctic mist',
      'aqua drift',
      'blush bloom',
      'coral haze',
      'retro rust',
      'autumn glow',
      'rustic charm',
      'vintage sage',
      'faded plum',
      'electric lime',
      'violet pulse',
      'neon sorbet',
      'aqua glow',
      'fluorescent sunset',
      'lavender bloom',
      'petal fresh',
      'meadow light',
      'sunny pastures',
      'frosted mauve',
      'snowy hearth',
      'icy blues',
      'winter twilight',
      'earthy hues',
      'stone balance',
      'neutral sands',
      'slate shades',
    ])
    .register(z.globalRegistry, {
      description: 'Color palette for furniture and decor',
    }),
  custom_prompt: z
    .optional(
      z.string().max(300).register(z.globalRegistry, {
        description:
          'Custom prompt for architectural editing, it overrides above options when used',
      }),
    )
    .default(''),
})

/**
 * ArchStyleOutput
 */
export const zSchemaAiHomeStyleOutput = z.object({
  image: zSchemaImage,
  status: z.string().register(z.globalRegistry, {
    description: 'Status message with processing details',
  }),
})

/**
 * ArchStyleInput
 */
export const zSchemaAiHomeStyleInput = z.object({
  input_image_url: z.string().max(512).register(z.globalRegistry, {
    description: 'URL of the image to do architectural styling',
  }),
  input_image_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Strength of the input image',
      }),
    )
    .default(0.85),
  additional_elements: z.optional(z.union([z.string().max(200), z.unknown()])),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description:
        "The format of the generated image. Choose from: 'jpeg' or 'png'.",
    }),
  ),
  style: z
    .enum([
      'minimalistic-interior',
      'farmhouse-interior',
      'luxury-interior',
      'modern-interior',
      'zen-interior',
      'mid century-interior',
      'airbnb-interior',
      'cozy-interior',
      'rustic-interior',
      'christmas-interior',
      'bohemian-interior',
      'tropical-interior',
      'industrial-interior',
      'japanese-interior',
      'vintage-interior',
      'loft-interior',
      'halloween-interior',
      'soho-interior',
      'baroque-interior',
      'kids room-interior',
      'girls room-interior',
      'boys room-interior',
      'scandinavian-interior',
      'french country-interior',
      'mediterranean-interior',
      'cyberpunk-interior',
      'hot pink-interior',
      'biophilic-interior',
      'ancient egypt-interior',
      'pixel-interior',
      'art deco-interior',
      'modern-exterior',
      'minimalistic-exterior',
      'farmhouse-exterior',
      'cozy-exterior',
      'luxury-exterior',
      'colonial-exterior',
      'zen-exterior',
      'asian-exterior',
      'creepy-exterior',
      'airstone-exterior',
      'ancient greek-exterior',
      'art deco-exterior',
      'brutalist-exterior',
      'christmas lights-exterior',
      'contemporary-exterior',
      'cottage-exterior',
      'dutch colonial-exterior',
      'federal colonial-exterior',
      'fire-exterior',
      'french provincial-exterior',
      'full glass-exterior',
      'georgian colonial-exterior',
      'gothic-exterior',
      'greek revival-exterior',
      'ice-exterior',
      'italianate-exterior',
      'mediterranean-exterior',
      'midcentury-exterior',
      'middle eastern-exterior',
      'minecraft-exterior',
      'morocco-exterior',
      'neoclassical-exterior',
      'spanish-exterior',
      'tudor-exterior',
      'underwater-exterior',
      'winter-exterior',
      'yard lighting-exterior',
    ])
    .register(z.globalRegistry, {
      description: 'Style for furniture and decor',
    }),
  architecture_type: z
    .enum([
      'living room-interior',
      'bedroom-interior',
      'kitchen-interior',
      'dining room-interior',
      'bathroom-interior',
      'laundry room-interior',
      'home office-interior',
      'study room-interior',
      'dorm room-interior',
      'coffee shop-interior',
      'gaming room-interior',
      'restaurant-interior',
      'office-interior',
      'attic-interior',
      'toilet-interior',
      'other-interior',
      'house-exterior',
      'villa-exterior',
      'backyard-exterior',
      'courtyard-exterior',
      'ranch-exterior',
      'office-exterior',
      'retail-exterior',
      'tower-exterior',
      'apartment-exterior',
      'school-exterior',
      'museum-exterior',
      'commercial-exterior',
      'residential-exterior',
      'other-exterior',
    ])
    .register(z.globalRegistry, {
      description: 'Type of architecture for appropriate furniture selection',
    }),
  color_palette: z
    .enum([
      'surprise me',
      'golden beige',
      'refined blues',
      'dusky elegance',
      'emerald charm',
      'crimson luxury',
      'golden sapphire',
      'soft pastures',
      'candy sky',
      'peach meadow',
      'muted sands',
      'ocean breeze',
      'frosted pastels',
      'spring bloom',
      'gentle horizon',
      'seaside breeze',
      'azure coast',
      'golden shore',
      'mediterranean gem',
      'ocean serenity',
      'serene blush',
      'muted horizon',
      'pastel shores',
      'dusky calm',
      'woodland retreat',
      'meadow glow',
      'forest canopy',
      'riverbank calm',
      'earthy tones',
      'earthy neutrals',
      'arctic mist',
      'aqua drift',
      'blush bloom',
      'coral haze',
      'retro rust',
      'autumn glow',
      'rustic charm',
      'vintage sage',
      'faded plum',
      'electric lime',
      'violet pulse',
      'neon sorbet',
      'aqua glow',
      'fluorescent sunset',
      'lavender bloom',
      'petal fresh',
      'meadow light',
      'sunny pastures',
      'frosted mauve',
      'snowy hearth',
      'icy blues',
      'winter twilight',
      'earthy hues',
      'stone balance',
      'neutral sands',
      'slate shades',
    ])
    .register(z.globalRegistry, {
      description: 'Color palette for furniture and decor',
    }),
  style_image_url: z.optional(z.union([z.string().max(512), z.unknown()])),
  custom_prompt: z
    .optional(
      z.string().max(300).register(z.globalRegistry, {
        description:
          'Custom prompt for architectural editing, it overrides above options when used',
      }),
    )
    .default(''),
  enhanced_rendering: z.optional(z.union([z.boolean(), z.unknown()])),
})

/**
 * ImageToImageOutput
 */
export const zSchemaQwenImageEdit2511LoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * EditImageLoraInput
 */
export const zSchemaQwenImageEdit2511LoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image with.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If `True`, the media will be returned as a data URI.',
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          'The LoRAs to use for the image generation. You can use up to 3 LoRAs and they will be merged together to generate the final image.',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: 'The guidance scale to use for the image generation.',
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: 'The URLs of the images to edit.',
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to generate an image from.',
      }),
    )
    .default(''),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The same seed and the same prompt given to the same version of the model will output the same image every time.',
    }),
  ),
})

/**
 * MultipleAnglesOutput
 *
 * Output model for Multiple Angles endpoint
 */
export const zSchemaQwenImageEdit2511MultipleAnglesOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'The constructed prompt used for generation',
    }),
    images: z.array(zSchemaImage).register(z.globalRegistry, {
      description: 'The generated/edited images',
    }),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Output model for Multiple Angles endpoint',
  })

/**
 * MultipleAnglesInput
 *
 * Input model for Multiple Angles endpoint - Camera control with precise adjustments using <sks> trigger word.
 * Prompt is built automatically from slider values.
 */
export const zSchemaQwenImageEdit2511MultipleAnglesInput = z
  .object({
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description: 'Acceleration level for image generation.',
      }),
    ),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
      ]),
    ),
    horizontal_angle: z
      .optional(
        z.number().gte(0).lte(360).register(z.globalRegistry, {
          description:
            'Horizontal rotation angle around the object in degrees. 0=front view, 90=right side, 180=back view, 270=left side, 360=front view again.',
        }),
      )
      .default(0),
    guidance_scale: z
      .optional(
        z.number().gte(1).lte(20).register(z.globalRegistry, {
          description: 'The CFG (Classifier Free Guidance) scale.',
        }),
      )
      .default(4.5),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to enable the safety checker.',
        }),
      )
      .default(true),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description: 'The URL of the image to adjust camera angle for.',
    }),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description: 'The negative prompt for the generation',
        }),
      )
      .default(''),
    zoom: z
      .optional(
        z.number().gte(0).lte(10).register(z.globalRegistry, {
          description:
            'Camera zoom/distance. 0=wide shot (far away), 5=medium shot (normal), 10=close-up (very close).',
        }),
      )
      .default(5),
    vertical_angle: z
      .optional(
        z.number().gte(-30).lte(90).register(z.globalRegistry, {
          description:
            "Vertical camera angle in degrees. -30=low-angle shot (looking up), 0=eye-level, 30=elevated, 60=high-angle, 90=bird's-eye view (looking down).",
        }),
      )
      .default(0),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description:
            'The scale factor for the LoRA model. Controls the strength of the camera control effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    additional_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'Additional text to append to the automatically generated prompt.',
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'If `True`, the media will be returned as a data URI.',
        }),
      )
      .default(false),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(28),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'Random seed for reproducibility.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Multiple Angles endpoint - Camera control with precise adjustments using <sks> trigger word.\nPrompt is built automatically from slider values.',
  })

/**
 * GlmImageToImageOutput
 */
export const zSchemaGlmImageImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'List of URLs to the generated images.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * GlmImageToImageInput
 */
export const zSchemaGlmImageImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text prompt for image generation.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'Number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
        'portrait_3_2',
        'landscape_3_2',
        'portrait_hd',
        'landscape_hd',
      ]),
    ]),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable NSFW safety checking on the generated images.',
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'Output image format.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If True, the image will be returned as a base64 data URI instead of a URL.',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher values make the model follow the prompt more closely.',
      }),
    )
    .default(1.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. The same seed with the same prompt will produce the same image.',
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'URL(s) of the condition image(s) for image-to-image generation. Supports up to 4 URLs for multi-image references.',
  }),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If True, the prompt will be enhanced using an LLM for more detailed and higher quality results.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(100).register(z.globalRegistry, {
        description:
          'Number of diffusion denoising steps. More steps generally produce higher quality images.',
      }),
    )
    .default(30),
})

/**
 * Klein9BDistilledEditOutput
 */
export const zSchemaFlux2Klein9bEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The edited images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * Klein9BDistilledEditInput
 */
export const zSchemaFlux2Klein9bEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If `True`, the media will be returned as a data URI. Output is not stored when this is True.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(8).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(4),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The URLs of the images for editing. A maximum of 4 images are allowed.',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
})

/**
 * Klein4BDistilledEditOutput
 */
export const zSchemaFlux2Klein4bEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The edited images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * KleinDistilledEditInput
 */
export const zSchemaFlux2Klein4bEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If `True`, the media will be returned as a data URI. Output is not stored when this is True.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(8).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(4),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The URLs of the images for editing. A maximum of 4 images are allowed.',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
})

/**
 * Klein9BBaseEditOutput
 */
export const zSchemaFlux2Klein9bBaseEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The edited images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * Klein9BEditImageInput
 */
export const zSchemaFlux2Klein9bBaseEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use for image generation.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for classifier-free guidance.',
      }),
    )
    .default(5),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If `True`, the media will be returned as a data URI. Output is not stored when this is True.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The URLs of the images for editing. A maximum of 4 images are allowed.',
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Negative prompt for classifier-free guidance. Describes what to avoid in the image.',
      }),
    )
    .default(''),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
})

/**
 * Klein4BBaseEditOutput
 */
export const zSchemaFlux2Klein4bBaseEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The edited images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * Klein4BBaseEditInput
 */
export const zSchemaFlux2Klein4bBaseEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use for image generation.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for classifier-free guidance.',
      }),
    )
    .default(5),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If `True`, the media will be returned as a data URI. Output is not stored when this is True.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The URLs of the images for editing. A maximum of 4 images are allowed.',
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Negative prompt for classifier-free guidance. Describes what to avoid in the image.',
      }),
    )
    .default(''),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
})

/**
 * KleinT2IOutput
 */
export const zSchemaFlux2Klein4bBaseEditLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * LoRAInput
 */
export const zSchemaFalAiFlux2KleinLoRaInput = z.object({
  path: z.string().register(z.globalRegistry, {
    description:
      'URL, HuggingFace repo ID (owner/repo), or local path to LoRA weights.',
  }),
  scale: z
    .optional(
      z.number().gte(0).lte(4).register(z.globalRegistry, {
        description: 'Scale factor for LoRA application (0.0 to 4.0).',
      }),
    )
    .default(1),
})

/**
 * KleinBaseEditLoRAInput
 */
export const zSchemaFlux2Klein4bBaseEditLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use for image generation.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for classifier-free guidance.',
      }),
    )
    .default(5),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaFalAiFlux2KleinLoRaInput).register(z.globalRegistry, {
        description: 'List of LoRA weights to apply (maximum 3).',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If `True`, the media will be returned as a data URI. Output is not stored when this is True.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The URLs of the images for editing. A maximum of 4 images are allowed.',
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Negative prompt for classifier-free guidance. Describes what to avoid in the image.',
      }),
    )
    .default(''),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
})

/**
 * KleinT2IOutput
 */
export const zSchemaFlux2Klein9bBaseEditLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * KleinBaseEditLoRAInput
 */
export const zSchemaFlux2Klein9bBaseEditLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use for image generation.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for classifier-free guidance.',
      }),
    )
    .default(5),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaFalAiFlux2KleinLoRaInput).register(z.globalRegistry, {
        description: 'List of LoRA weights to apply (maximum 3).',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If `True`, the media will be returned as a data URI. Output is not stored when this is True.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The URLs of the images for editing. A maximum of 4 images are allowed.',
  }),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Negative prompt for classifier-free guidance. Describes what to avoid in the image.',
      }),
    )
    .default(''),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
})

/**
 * FiboEditExtraEPOutputModel
 */
export const zSchemaFiboEditColorizeOutput = z.object({
  images: z
    .optional(
      z.array(zSchemaImage).register(z.globalRegistry, {
        description: 'Generated images.',
      }),
    )
    .default([]),
  image: zSchemaImage,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: 'Current instruction.',
    }),
})

/**
 * ColorizeInput
 */
export const zSchemaFiboEditColorizeInput = z.object({
  color: z
    .enum([
      'contemporary color',
      'vivid color',
      'black and white colors',
      'sepia vintage',
    ])
    .register(z.globalRegistry, {
      description: 'Select the color palette or aesthetic for the output image',
    }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The source image.',
  }),
})

/**
 * FiboEditExtraEPOutputModel
 */
export const zSchemaFiboEditBlendOutput = z.object({
  images: z
    .optional(
      z.array(zSchemaImage).register(z.globalRegistry, {
        description: 'Generated images.',
      }),
    )
    .default([]),
  image: zSchemaImage,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: 'Current instruction.',
    }),
})

/**
 * BlendingInput
 */
export const zSchemaFiboEditBlendInput = z.object({
  instruction: z.string().register(z.globalRegistry, {
    description:
      'Instruct what elements you would like to blend in your image.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The source image.',
  }),
})

/**
 * FiboEditExtraEPOutputModel
 */
export const zSchemaFiboEditAddObjectByTextOutput = z.object({
  images: z
    .optional(
      z.array(zSchemaImage).register(z.globalRegistry, {
        description: 'Generated images.',
      }),
    )
    .default([]),
  image: zSchemaImage,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: 'Current instruction.',
    }),
})

/**
 * AddObjectByTextInput
 */
export const zSchemaFiboEditAddObjectByTextInput = z.object({
  instruction: z.string().register(z.globalRegistry, {
    description:
      'The full natural language command describing what to add and where.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The source image.',
  }),
})

/**
 * Lighting
 */
export const zSchemaLighting = z.object({
  shadows: z.optional(z.union([z.string(), z.unknown()])),
  conditions: z.optional(z.union([z.string(), z.unknown()])),
  direction: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * Aesthetics
 */
export const zSchemaAesthetics = z.object({
  composition: z.optional(z.union([z.string(), z.unknown()])),
  mood_atmosphere: z.optional(z.union([z.string(), z.unknown()])),
  color_scheme: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * PhotographicCharacteristics
 */
export const zSchemaPhotographicCharacteristics = z.object({
  focus: z.optional(z.union([z.string(), z.unknown()])),
  lens_focal_length: z.optional(z.union([z.string(), z.unknown()])),
  camera_angle: z.optional(z.union([z.string(), z.unknown()])),
  depth_of_field: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * PromptObject
 */
export const zSchemaPromptObject = z.object({
  relative_size: z.optional(z.union([z.string(), z.unknown()])),
  description: z.optional(z.union([z.string(), z.unknown()])),
  skin_tone_and_texture: z.optional(z.union([z.string(), z.unknown()])),
  appearance_details: z.optional(z.union([z.string(), z.unknown()])),
  number_of_objects: z.optional(z.union([z.int(), z.unknown()])),
  expression: z.optional(z.union([z.string(), z.unknown()])),
  pose: z.optional(z.union([z.string(), z.unknown()])),
  shape_and_color: z.optional(z.union([z.string(), z.unknown()])),
  relationship: z.string().register(z.globalRegistry, {
    description:
      'The relationship of the object to other objects in the image.',
  }),
  texture: z.optional(z.union([z.string(), z.unknown()])),
  gender: z.optional(z.union([z.string(), z.unknown()])),
  clothing: z.optional(z.union([z.string(), z.unknown()])),
  location: z.optional(z.union([z.string(), z.unknown()])),
  orientation: z.optional(z.union([z.string(), z.unknown()])),
  action: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * StructuredInstruction
 */
export const zSchemaStructuredInstruction = z.object({
  background_setting: z.optional(z.union([z.string(), z.unknown()])),
  artistic_style: z.optional(z.union([z.string(), z.unknown()])),
  style_medium: z.optional(z.union([z.string(), z.unknown()])),
  text_render: z.optional(z.union([z.array(z.unknown()), z.unknown()])),
  objects: z.optional(z.union([z.array(zSchemaPromptObject), z.unknown()])),
  context: z.optional(z.union([z.string(), z.unknown()])),
  photographic_characteristics: z.optional(
    z.union([zSchemaPhotographicCharacteristics, z.unknown()]),
  ),
  aesthetics: z.optional(z.union([zSchemaAesthetics, z.unknown()])),
  lighting: z.optional(z.union([zSchemaLighting, z.unknown()])),
  short_description: z.optional(z.union([z.string(), z.unknown()])),
  edit_instruction: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * FiboEditOutputModel
 */
export const zSchemaFiboEditEditOutput = z.object({
  images: z
    .optional(
      z.array(zSchemaImage).register(z.globalRegistry, {
        description: 'Generated images.',
      }),
    )
    .default([]),
  image: zSchemaImage,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: 'Current instruction.',
    }),
})

/**
 * FiboEditInputModel
 */
export const zSchemaFiboEditEditInput = z.object({
  steps_num: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps.',
      }),
    )
    .default(50),
  instruction: z.optional(z.union([z.string(), z.unknown()])),
  image_url: z.optional(z.union([z.string(), z.unknown()])),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If true, returns the image directly in the response (increases latency).',
      }),
    )
    .default(false),
  guidance_scale: z.optional(z.union([z.number(), z.int()])),
  structured_instruction: z.optional(
    z.union([zSchemaStructuredInstruction, z.unknown()]),
  ),
  mask_url: z.optional(z.union([z.string(), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for image generation.',
      }),
    )
    .default(''),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Random seed for reproducibility.',
      }),
    )
    .default(5555),
})

/**
 * FiboEditExtraEPOutputModel
 */
export const zSchemaFiboEditEraseByTextOutput = z.object({
  images: z
    .optional(
      z.array(zSchemaImage).register(z.globalRegistry, {
        description: 'Generated images.',
      }),
    )
    .default([]),
  image: zSchemaImage,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: 'Current instruction.',
    }),
})

/**
 * EraseByTextInput
 */
export const zSchemaFiboEditEraseByTextInput = z.object({
  object_name: z.string().register(z.globalRegistry, {
    description: 'The name of the object to remove.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The source image.',
  }),
})

/**
 * FiboEditExtraEPOutputModel
 */
export const zSchemaFiboEditRewriteTextOutput = z.object({
  images: z
    .optional(
      z.array(zSchemaImage).register(z.globalRegistry, {
        description: 'Generated images.',
      }),
    )
    .default([]),
  image: zSchemaImage,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: 'Current instruction.',
    }),
})

/**
 * RewriteTextInput
 */
export const zSchemaFiboEditRewriteTextInput = z.object({
  new_text: z.string().register(z.globalRegistry, {
    description: 'The new text string to appear in the image.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The source image.',
  }),
})

/**
 * FiboEditExtraEPOutputModel
 */
export const zSchemaFiboEditRestyleOutput = z.object({
  images: z
    .optional(
      z.array(zSchemaImage).register(z.globalRegistry, {
        description: 'Generated images.',
      }),
    )
    .default([]),
  image: zSchemaImage,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: 'Current instruction.',
    }),
})

/**
 * RestyletInput
 */
export const zSchemaFiboEditRestyleInput = z.object({
  style: z
    .enum([
      '3D Render',
      'Cubism',
      'Oil Painting',
      'Anime',
      'Cartoon',
      'Coloring Book',
      'Retro Ad',
      'Pop Art Halftone',
      'Vector Art',
      'Story Board',
      'Art Nouveau',
      'Cross Etching',
      'Wood Cut',
    ])
    .register(z.globalRegistry, {
      description: 'Select the desired artistic style for the output image.',
    }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The source image.',
  }),
})

/**
 * FiboEditExtraEPOutputModel
 */
export const zSchemaFiboEditRelightOutput = z.object({
  images: z
    .optional(
      z.array(zSchemaImage).register(z.globalRegistry, {
        description: 'Generated images.',
      }),
    )
    .default([]),
  image: zSchemaImage,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: 'Current instruction.',
    }),
})

/**
 * RelightInput
 */
export const zSchemaFiboEditRelightInput = z.object({
  light_type: z
    .enum([
      'midday',
      'blue hour light',
      'low-angle sunlight',
      'sunrise light',
      'spotlight on subject',
      'overcast light',
      'soft overcast daylight lighting',
      'cloud-filtered lighting',
      'fog-diffused lighting',
      'moonlight lighting',
      'starlight nighttime',
      'soft bokeh lighting',
      'harsh studio lighting',
    ])
    .register(z.globalRegistry, {
      description: 'The quality/style/time of day.',
    }),
  light_direction: z.union([
    z.enum(['front', 'side', 'bottom', 'top-down']),
    z.unknown(),
  ]),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The source image.',
  }),
})

/**
 * FiboEditExtraEPOutputModel
 */
export const zSchemaFiboEditReseasonOutput = z.object({
  images: z
    .optional(
      z.array(zSchemaImage).register(z.globalRegistry, {
        description: 'Generated images.',
      }),
    )
    .default([]),
  image: zSchemaImage,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: 'Current instruction.',
    }),
})

/**
 * ReseasonInput
 */
export const zSchemaFiboEditReseasonInput = z.object({
  season: z
    .enum(['spring', 'summer', 'autumn', 'winter'])
    .register(z.globalRegistry, {
      description: 'The desired season.',
    }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The source image.',
  }),
})

/**
 * FiboEditExtraEPOutputModel
 */
export const zSchemaFiboEditRestoreOutput = z.object({
  images: z
    .optional(
      z.array(zSchemaImage).register(z.globalRegistry, {
        description: 'Generated images.',
      }),
    )
    .default([]),
  image: zSchemaImage,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: 'Current instruction.',
    }),
})

/**
 * RestoreInput
 */
export const zSchemaFiboEditRestoreInput = z.object({
  image_url: z.string().register(z.globalRegistry, {
    description: 'The source image.',
  }),
})

/**
 * FiboEditExtraEPOutputModel
 */
export const zSchemaFiboEditSketchToColoredImageOutput = z.object({
  images: z
    .optional(
      z.array(zSchemaImage).register(z.globalRegistry, {
        description: 'Generated images.',
      }),
    )
    .default([]),
  image: zSchemaImage,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: 'Current instruction.',
    }),
})

/**
 * SketchColoredImageInput
 */
export const zSchemaFiboEditSketchToColoredImageInput = z.object({
  image_url: z.string().register(z.globalRegistry, {
    description: 'The source image.',
  }),
})

/**
 * FiboEditExtraEPOutputModel
 */
export const zSchemaFiboEditReplaceObjectByTextOutput = z.object({
  images: z
    .optional(
      z.array(zSchemaImage).register(z.globalRegistry, {
        description: 'Generated images.',
      }),
    )
    .default([]),
  image: zSchemaImage,
  structured_instruction: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: 'Current instruction.',
    }),
})

/**
 * ReplaceObjectInput
 */
export const zSchemaFiboEditReplaceObjectByTextInput = z.object({
  instruction: z.string().register(z.globalRegistry, {
    description:
      'The full natural language command describing what to replace.',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The source image.',
  }),
})

/**
 * FaceFusionImageOutput
 *
 * FaceFusion output payload when image content is generated
 */
export const zSchemaAiFaceSwapFaceswapimageOutput = z
  .object({
    image: zSchemaImage,
    processing_time_ms: z.optional(z.union([z.int(), z.unknown()])),
  })
  .register(z.globalRegistry, {
    description: 'FaceFusion output payload when image content is generated',
  })

/**
 * FaceSwapInputImage
 *
 * Input schema for image  image face swap
 */
export const zSchemaAiFaceSwapFaceswapimageInput = z
  .object({
    source_face_url: z.string().register(z.globalRegistry, {
      description: 'Source face image',
    }),
    target_image_url: z.string().register(z.globalRegistry, {
      description: 'Target image URL',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Input schema for image  image face swap',
  })

/**
 * ReplaceBackgroundOutputModel
 */
export const zSchemaReplaceBackgroundOutput = z.object({
  images: z.optional(
    z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
      description: 'Generated images.',
    }),
  ),
  image: zSchemaImage,
})

/**
 * ReplaceBackgroundInputModel
 */
export const zSchemaReplaceBackgroundInput = z.object({
  prompt: z.optional(z.union([z.string(), z.unknown()])),
  steps_num: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Number of inference steps.',
      }),
    )
    .default(30),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If true, returns the image directly in the response (increases latency).',
      }),
    )
    .default(false),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Random seed for reproducibility.',
      }),
    )
    .default(4925634),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for background replacement.',
      }),
    )
    .default(''),
  image_url: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * Output
 */
export const zSchemaClarityUpscalerOutput = z.object({
  image: zSchemaImage,
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used to generate the image.',
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'The timings of the different steps in the workflow.',
  }),
})

/**
 * Input
 */
export const zSchemaClarityUpscalerInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The prompt to use for generating the image. Be as descriptive as possible for best results.',
      }),
    )
    .default('masterpiece, best quality, highres'),
  resemblance: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The resemblance of the upscaled image to the original image. The higher the resemblance, the more the model will try to keep the original image.\n            Refers to the strength of the ControlNet.\n        ',
      }),
    )
    .default(0.6),
  creativity: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The creativity of the model. The higher the creativity, the more the model will deviate from the prompt.\n            Refers to the denoise strength of the sampling.\n        ',
      }),
    )
    .default(0.35),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to upscale.',
  }),
  upscale_factor: z
    .optional(
      z.number().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The upscale factor',
      }),
    )
    .default(2),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(18),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The negative prompt to use. Use it to address details that you don't want in the image.",
      }),
    )
    .default('(worst quality, low quality, normal quality:2)'),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to false, the safety checker will be disabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaAuraSrOutput = z.object({
  image: zSchemaImage,
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'Timings for each step in the pipeline.',
  }),
})

/**
 * Input
 */
export const zSchemaAuraSrInput = z.object({
  overlapping_tiles: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to use overlapping tiles for upscaling. Setting this to true helps remove seams but doubles the inference time.',
      }),
    )
    .default(false),
  checkpoint: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description: 'Checkpoint to use for upscaling. More coming soon.',
    }),
  ),
  upscaling_factor: z.optional(
    z.literal(4).register(z.globalRegistry, {
      description: 'Upscaling factor. More coming soon.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to upscale.',
  }),
})

/**
 * Output
 */
export const zSchemaFluxDevImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseImageToInput
 */
export const zSchemaFluxDevImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the image to generate an image from.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength of the initial image. Higher strength values are better for this model.',
      }),
    )
    .default(0.95),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(40),
})

/**
 * Flux2ProEditOutput
 */
export const zSchemaFlux2ProEditOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for the generation.',
  }),
})

/**
 * Flux2ProImageEditInput
 */
export const zSchemaFlux2ProEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'auto',
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable the safety checker.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed to use for the generation.',
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: 'List of URLs of input images for editing',
  }),
})

/**
 * Flux2EditImageOutput
 */
export const zSchemaFlux2EditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The edited images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * Flux2EditImageInput
 */
export const zSchemaFlux2EditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to edit the image.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use for the image generation.',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(2.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The URLs of the images for editing. A maximum of 4 images are allowed, if more are provided, only the first 4 will be used.',
  }),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded for better results.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
})

/**
 * Flux2EditImageLoRAOutput
 */
export const zSchemaFlux2LoraEditOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The edited images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * Flux2EditImageLoRAInput
 */
export const zSchemaFlux2LoraEditInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use for the image generation.',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoRaInput).register(z.globalRegistry, {
        description:
          'List of LoRA weights to apply (maximum 3). Each LoRA can be a URL, HuggingFace repo ID, or local path.',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(2.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description:
      'The URsL of the images for editing. A maximum of 3 images are allowed, if more are provided, only the first 3 will be used.',
  }),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded for better results.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
})

/**
 * FluxKontextOutput
 */
export const zSchemaFluxProKontextOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaFalToolkitImageImageImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * FluxKontextInput
 */
export const zSchemaFluxProKontextInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Image prompt for the omni model.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enhance the prompt for better results.',
      }),
    )
    .default(false),
})

export const zSchemaQueueStatus = z.object({
  status: z.enum(['IN_QUEUE', 'IN_PROGRESS', 'COMPLETED']),
  request_id: z.string().register(z.globalRegistry, {
    description: 'The request id.',
  }),
  response_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The response url.',
    }),
  ),
  status_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The status url.',
    }),
  ),
  cancel_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The cancel url.',
    }),
  ),
  logs: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The logs.',
    }),
  ),
  metrics: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The metrics.',
    }),
  ),
  queue_position: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The queue position.',
    }),
  ),
})

export const zGetFalAiFluxProKontextRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxProKontextRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxProKontextRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProKontextRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxProKontextData = z.object({
  body: zSchemaFluxProKontextInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxProKontextResponse = zSchemaQueueStatus

export const zGetFalAiFluxProKontextRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxProKontextRequestsByRequestIdResponse =
  zSchemaFluxProKontextOutput

export const zGetFalAiFlux2LoraEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2LoraEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2LoraEditData = z.object({
  body: zSchemaFlux2LoraEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraEditResponse = zSchemaQueueStatus

export const zGetFalAiFlux2LoraEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraEditRequestsByRequestIdResponse =
  zSchemaFlux2LoraEditOutput

export const zGetFalAiFlux2EditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2EditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2EditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2EditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2EditData = z.object({
  body: zSchemaFlux2EditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2EditResponse = zSchemaQueueStatus

export const zGetFalAiFlux2EditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2EditRequestsByRequestIdResponse =
  zSchemaFlux2EditOutput

export const zGetFalAiFlux2ProEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2ProEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2ProEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2ProEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2ProEditData = z.object({
  body: zSchemaFlux2ProEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2ProEditResponse = zSchemaQueueStatus

export const zGetFalAiFlux2ProEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2ProEditRequestsByRequestIdResponse =
  zSchemaFlux2ProEditOutput

export const zGetFalAiFluxDevImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxDevImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxDevImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxDevImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxDevImageToImageData = z.object({
  body: zSchemaFluxDevImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxDevImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiFluxDevImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxDevImageToImageRequestsByRequestIdResponse =
  zSchemaFluxDevImageToImageOutput

export const zGetFalAiAuraSrRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiAuraSrRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiAuraSrRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiAuraSrRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiAuraSrData = z.object({
  body: zSchemaAuraSrInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiAuraSrResponse = zSchemaQueueStatus

export const zGetFalAiAuraSrRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiAuraSrRequestsByRequestIdResponse = zSchemaAuraSrOutput

export const zGetFalAiClarityUpscalerRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiClarityUpscalerRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiClarityUpscalerRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiClarityUpscalerRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiClarityUpscalerData = z.object({
  body: zSchemaClarityUpscalerInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiClarityUpscalerResponse = zSchemaQueueStatus

export const zGetFalAiClarityUpscalerRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiClarityUpscalerRequestsByRequestIdResponse =
  zSchemaClarityUpscalerOutput

export const zGetBriaReplaceBackgroundRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetBriaReplaceBackgroundRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaReplaceBackgroundRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutBriaReplaceBackgroundRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostBriaReplaceBackgroundData = z.object({
  body: zSchemaReplaceBackgroundInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaReplaceBackgroundResponse = zSchemaQueueStatus

export const zGetBriaReplaceBackgroundRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetBriaReplaceBackgroundRequestsByRequestIdResponse =
  zSchemaReplaceBackgroundOutput

export const zGetHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostHalfMoonAiAiFaceSwapFaceswapimageData = z.object({
  body: zSchemaAiFaceSwapFaceswapimageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostHalfMoonAiAiFaceSwapFaceswapimageResponse = zSchemaQueueStatus

export const zGetHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetHalfMoonAiAiFaceSwapFaceswapimageRequestsByRequestIdResponse =
  zSchemaAiFaceSwapFaceswapimageOutput

export const zGetBriaFiboEditReplaceObjectByTextRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetBriaFiboEditReplaceObjectByTextRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaFiboEditReplaceObjectByTextRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditReplaceObjectByTextRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostBriaFiboEditReplaceObjectByTextData = z.object({
  body: zSchemaFiboEditReplaceObjectByTextInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaFiboEditReplaceObjectByTextResponse = zSchemaQueueStatus

export const zGetBriaFiboEditReplaceObjectByTextRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetBriaFiboEditReplaceObjectByTextRequestsByRequestIdResponse =
  zSchemaFiboEditReplaceObjectByTextOutput

export const zGetBriaFiboEditSketchToColoredImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetBriaFiboEditSketchToColoredImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaFiboEditSketchToColoredImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditSketchToColoredImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostBriaFiboEditSketchToColoredImageData = z.object({
  body: zSchemaFiboEditSketchToColoredImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaFiboEditSketchToColoredImageResponse = zSchemaQueueStatus

export const zGetBriaFiboEditSketchToColoredImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetBriaFiboEditSketchToColoredImageRequestsByRequestIdResponse =
  zSchemaFiboEditSketchToColoredImageOutput

export const zGetBriaFiboEditRestoreRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetBriaFiboEditRestoreRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaFiboEditRestoreRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditRestoreRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostBriaFiboEditRestoreData = z.object({
  body: zSchemaFiboEditRestoreInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaFiboEditRestoreResponse = zSchemaQueueStatus

export const zGetBriaFiboEditRestoreRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetBriaFiboEditRestoreRequestsByRequestIdResponse =
  zSchemaFiboEditRestoreOutput

export const zGetBriaFiboEditReseasonRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetBriaFiboEditReseasonRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaFiboEditReseasonRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditReseasonRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostBriaFiboEditReseasonData = z.object({
  body: zSchemaFiboEditReseasonInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaFiboEditReseasonResponse = zSchemaQueueStatus

export const zGetBriaFiboEditReseasonRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetBriaFiboEditReseasonRequestsByRequestIdResponse =
  zSchemaFiboEditReseasonOutput

export const zGetBriaFiboEditRelightRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetBriaFiboEditRelightRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaFiboEditRelightRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditRelightRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostBriaFiboEditRelightData = z.object({
  body: zSchemaFiboEditRelightInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaFiboEditRelightResponse = zSchemaQueueStatus

export const zGetBriaFiboEditRelightRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetBriaFiboEditRelightRequestsByRequestIdResponse =
  zSchemaFiboEditRelightOutput

export const zGetBriaFiboEditRestyleRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetBriaFiboEditRestyleRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaFiboEditRestyleRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditRestyleRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostBriaFiboEditRestyleData = z.object({
  body: zSchemaFiboEditRestyleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaFiboEditRestyleResponse = zSchemaQueueStatus

export const zGetBriaFiboEditRestyleRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetBriaFiboEditRestyleRequestsByRequestIdResponse =
  zSchemaFiboEditRestyleOutput

export const zGetBriaFiboEditRewriteTextRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetBriaFiboEditRewriteTextRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaFiboEditRewriteTextRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditRewriteTextRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostBriaFiboEditRewriteTextData = z.object({
  body: zSchemaFiboEditRewriteTextInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaFiboEditRewriteTextResponse = zSchemaQueueStatus

export const zGetBriaFiboEditRewriteTextRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetBriaFiboEditRewriteTextRequestsByRequestIdResponse =
  zSchemaFiboEditRewriteTextOutput

export const zGetBriaFiboEditEraseByTextRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetBriaFiboEditEraseByTextRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaFiboEditEraseByTextRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditEraseByTextRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostBriaFiboEditEraseByTextData = z.object({
  body: zSchemaFiboEditEraseByTextInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaFiboEditEraseByTextResponse = zSchemaQueueStatus

export const zGetBriaFiboEditEraseByTextRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetBriaFiboEditEraseByTextRequestsByRequestIdResponse =
  zSchemaFiboEditEraseByTextOutput

export const zGetBriaFiboEditEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetBriaFiboEditEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaFiboEditEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostBriaFiboEditEditData = z.object({
  body: zSchemaFiboEditEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaFiboEditEditResponse = zSchemaQueueStatus

export const zGetBriaFiboEditEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetBriaFiboEditEditRequestsByRequestIdResponse =
  zSchemaFiboEditEditOutput

export const zGetBriaFiboEditAddObjectByTextRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetBriaFiboEditAddObjectByTextRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaFiboEditAddObjectByTextRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditAddObjectByTextRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostBriaFiboEditAddObjectByTextData = z.object({
  body: zSchemaFiboEditAddObjectByTextInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaFiboEditAddObjectByTextResponse = zSchemaQueueStatus

export const zGetBriaFiboEditAddObjectByTextRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetBriaFiboEditAddObjectByTextRequestsByRequestIdResponse =
  zSchemaFiboEditAddObjectByTextOutput

export const zGetBriaFiboEditBlendRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetBriaFiboEditBlendRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaFiboEditBlendRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditBlendRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostBriaFiboEditBlendData = z.object({
  body: zSchemaFiboEditBlendInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaFiboEditBlendResponse = zSchemaQueueStatus

export const zGetBriaFiboEditBlendRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetBriaFiboEditBlendRequestsByRequestIdResponse =
  zSchemaFiboEditBlendOutput

export const zGetBriaFiboEditColorizeRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetBriaFiboEditColorizeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaFiboEditColorizeRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutBriaFiboEditColorizeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostBriaFiboEditColorizeData = z.object({
  body: zSchemaFiboEditColorizeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaFiboEditColorizeResponse = zSchemaQueueStatus

export const zGetBriaFiboEditColorizeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetBriaFiboEditColorizeRequestsByRequestIdResponse =
  zSchemaFiboEditColorizeOutput

export const zGetFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlux2Klein9bBaseEditLoraData = z.object({
  body: zSchemaFlux2Klein9bBaseEditLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein9bBaseEditLoraResponse = zSchemaQueueStatus

export const zGetFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein9bBaseEditLoraRequestsByRequestIdResponse =
  zSchemaFlux2Klein9bBaseEditLoraOutput

export const zGetFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlux2Klein4bBaseEditLoraData = z.object({
  body: zSchemaFlux2Klein4bBaseEditLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein4bBaseEditLoraResponse = zSchemaQueueStatus

export const zGetFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein4bBaseEditLoraRequestsByRequestIdResponse =
  zSchemaFlux2Klein4bBaseEditLoraOutput

export const zGetFalAiFlux2Klein4bBaseEditRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein4bBaseEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2Klein4bBaseEditRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein4bBaseEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2Klein4bBaseEditData = z.object({
  body: zSchemaFlux2Klein4bBaseEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein4bBaseEditResponse = zSchemaQueueStatus

export const zGetFalAiFlux2Klein4bBaseEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein4bBaseEditRequestsByRequestIdResponse =
  zSchemaFlux2Klein4bBaseEditOutput

export const zGetFalAiFlux2Klein9bBaseEditRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein9bBaseEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2Klein9bBaseEditRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein9bBaseEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2Klein9bBaseEditData = z.object({
  body: zSchemaFlux2Klein9bBaseEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein9bBaseEditResponse = zSchemaQueueStatus

export const zGetFalAiFlux2Klein9bBaseEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein9bBaseEditRequestsByRequestIdResponse =
  zSchemaFlux2Klein9bBaseEditOutput

export const zGetFalAiFlux2Klein4bEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein4bEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2Klein4bEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein4bEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2Klein4bEditData = z.object({
  body: zSchemaFlux2Klein4bEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein4bEditResponse = zSchemaQueueStatus

export const zGetFalAiFlux2Klein4bEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein4bEditRequestsByRequestIdResponse =
  zSchemaFlux2Klein4bEditOutput

export const zGetFalAiFlux2Klein9bEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein9bEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2Klein9bEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein9bEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2Klein9bEditData = z.object({
  body: zSchemaFlux2Klein9bEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein9bEditResponse = zSchemaQueueStatus

export const zGetFalAiFlux2Klein9bEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein9bEditRequestsByRequestIdResponse =
  zSchemaFlux2Klein9bEditOutput

export const zGetFalAiGlmImageImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiGlmImageImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiGlmImageImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiGlmImageImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiGlmImageImageToImageData = z.object({
  body: zSchemaGlmImageImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiGlmImageImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiGlmImageImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiGlmImageImageToImageRequestsByRequestIdResponse =
  zSchemaGlmImageImageToImageOutput

export const zGetFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEdit2511MultipleAnglesData = z.object({
  body: zSchemaQwenImageEdit2511MultipleAnglesInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2511MultipleAnglesResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2511MultipleAnglesRequestsByRequestIdResponse =
  zSchemaQwenImageEdit2511MultipleAnglesOutput

export const zGetFalAiQwenImageEdit2511LoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2511LoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEdit2511LoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2511LoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiQwenImageEdit2511LoraData = z.object({
  body: zSchemaQwenImageEdit2511LoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2511LoraResponse = zSchemaQueueStatus

export const zGetFalAiQwenImageEdit2511LoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2511LoraRequestsByRequestIdResponse =
  zSchemaQwenImageEdit2511LoraOutput

export const zGetHalfMoonAiAiHomeStyleRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetHalfMoonAiAiHomeStyleRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutHalfMoonAiAiHomeStyleRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutHalfMoonAiAiHomeStyleRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostHalfMoonAiAiHomeStyleData = z.object({
  body: zSchemaAiHomeStyleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostHalfMoonAiAiHomeStyleResponse = zSchemaQueueStatus

export const zGetHalfMoonAiAiHomeStyleRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetHalfMoonAiAiHomeStyleRequestsByRequestIdResponse =
  zSchemaAiHomeStyleOutput

export const zGetHalfMoonAiAiHomeEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetHalfMoonAiAiHomeEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutHalfMoonAiAiHomeEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutHalfMoonAiAiHomeEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostHalfMoonAiAiHomeEditData = z.object({
  body: zSchemaAiHomeEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostHalfMoonAiAiHomeEditResponse = zSchemaQueueStatus

export const zGetHalfMoonAiAiHomeEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetHalfMoonAiAiHomeEditRequestsByRequestIdResponse =
  zSchemaAiHomeEditOutput

export const zGetFalAiQwenImageLayeredLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageLayeredLoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageLayeredLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageLayeredLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiQwenImageLayeredLoraData = z.object({
  body: zSchemaQwenImageLayeredLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageLayeredLoraResponse = zSchemaQueueStatus

export const zGetFalAiQwenImageLayeredLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageLayeredLoraRequestsByRequestIdResponse =
  zSchemaQwenImageLayeredLoraOutput

export const zGetWanV26ImageToImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetWanV26ImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutWanV26ImageToImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutWanV26ImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostWanV26ImageToImageData = z.object({
  body: zSchemaV26ImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostWanV26ImageToImageResponse = zSchemaQueueStatus

export const zGetWanV26ImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetWanV26ImageToImageRequestsByRequestIdResponse =
  zSchemaV26ImageToImageOutput

export const zGetFalAiQwenImageEdit2511RequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2511RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEdit2511RequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2511RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiQwenImageEdit2511Data = z.object({
  body: zSchemaQwenImageEdit2511Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2511Response = zSchemaQueueStatus

export const zGetFalAiQwenImageEdit2511RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2511RequestsByRequestIdResponse =
  zSchemaQwenImageEdit2511Output

export const zGetFalAiQwenImageLayeredRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiQwenImageLayeredRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageLayeredRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageLayeredRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiQwenImageLayeredData = z.object({
  body: zSchemaQwenImageLayeredInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageLayeredResponse = zSchemaQueueStatus

export const zGetFalAiQwenImageLayeredRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageLayeredRequestsByRequestIdResponse =
  zSchemaQwenImageLayeredOutput

export const zGetFalAiZImageTurboInpaintLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiZImageTurboInpaintLoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiZImageTurboInpaintLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageTurboInpaintLoraRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiZImageTurboInpaintLoraData = z.object({
  body: zSchemaZImageTurboInpaintLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiZImageTurboInpaintLoraResponse = zSchemaQueueStatus

export const zGetFalAiZImageTurboInpaintLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiZImageTurboInpaintLoraRequestsByRequestIdResponse =
  zSchemaZImageTurboInpaintLoraOutput

export const zGetFalAiZImageTurboInpaintRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiZImageTurboInpaintRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiZImageTurboInpaintRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageTurboInpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiZImageTurboInpaintData = z.object({
  body: zSchemaZImageTurboInpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiZImageTurboInpaintResponse = zSchemaQueueStatus

export const zGetFalAiZImageTurboInpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiZImageTurboInpaintRequestsByRequestIdResponse =
  zSchemaZImageTurboInpaintOutput

export const zGetFalAiFlux2FlashEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2FlashEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2FlashEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2FlashEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2FlashEditData = z.object({
  body: zSchemaFlux2FlashEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2FlashEditResponse = zSchemaQueueStatus

export const zGetFalAiFlux2FlashEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2FlashEditRequestsByRequestIdResponse =
  zSchemaFlux2FlashEditOutput

export const zGetFalAiGptImage15EditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiGptImage15EditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiGptImage15EditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiGptImage15EditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiGptImage15EditData = z.object({
  body: zSchemaGptImage15EditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiGptImage15EditResponse = zSchemaQueueStatus

export const zGetFalAiGptImage15EditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiGptImage15EditRequestsByRequestIdResponse =
  zSchemaGptImage15EditOutput

export const zGetFalAiFlux2TurboEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2TurboEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2TurboEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2TurboEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2TurboEditData = z.object({
  body: zSchemaFlux2TurboEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2TurboEditResponse = zSchemaQueueStatus

export const zGetFalAiFlux2TurboEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2TurboEditRequestsByRequestIdResponse =
  zSchemaFlux2TurboEditOutput

export const zGetFalAiFlux2MaxEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2MaxEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2MaxEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2MaxEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2MaxEditData = z.object({
  body: zSchemaFlux2MaxEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2MaxEditResponse = zSchemaQueueStatus

export const zGetFalAiFlux2MaxEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2MaxEditRequestsByRequestIdResponse =
  zSchemaFlux2MaxEditOutput

export const zGetHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostHalfMoonAiAiBabyAndAgingGeneratorMultiData = z.object({
  body: zSchemaAiBabyAndAgingGeneratorMultiInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostHalfMoonAiAiBabyAndAgingGeneratorMultiResponse =
  zSchemaQueueStatus

export const zGetHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetHalfMoonAiAiBabyAndAgingGeneratorMultiRequestsByRequestIdResponse =
  zSchemaAiBabyAndAgingGeneratorMultiOutput

export const zGetHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostHalfMoonAiAiBabyAndAgingGeneratorSingleData = z.object({
  body: zSchemaAiBabyAndAgingGeneratorSingleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostHalfMoonAiAiBabyAndAgingGeneratorSingleResponse =
  zSchemaQueueStatus

export const zGetHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetHalfMoonAiAiBabyAndAgingGeneratorSingleRequestsByRequestIdResponse =
  zSchemaAiBabyAndAgingGeneratorSingleOutput

export const zGetFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEdit2509LoraGalleryShirtDesignData = z.object({
  body: zSchemaQwenImageEdit2509LoraGalleryShirtDesignInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryShirtDesignResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryShirtDesignRequestsByRequestIdResponse =
  zSchemaQwenImageEdit2509LoraGalleryShirtDesignOutput

export const zGetFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEdit2509LoraGalleryRemoveLightingData =
  z.object({
    body: zSchemaQwenImageEdit2509LoraGalleryRemoveLightingInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  })

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryRemoveLightingResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryRemoveLightingRequestsByRequestIdResponse =
  zSchemaQwenImageEdit2509LoraGalleryRemoveLightingOutput

export const zGetFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEdit2509LoraGalleryRemoveElementData = z.object(
  {
    body: zSchemaQwenImageEdit2509LoraGalleryRemoveElementInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  },
)

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryRemoveElementResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryRemoveElementRequestsByRequestIdResponse =
  zSchemaQwenImageEdit2509LoraGalleryRemoveElementOutput

export const zGetFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEdit2509LoraGalleryLightingRestorationData =
  z.object({
    body: zSchemaQwenImageEdit2509LoraGalleryLightingRestorationInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  })

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryLightingRestorationResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryLightingRestorationRequestsByRequestIdResponse =
  zSchemaQwenImageEdit2509LoraGalleryLightingRestorationOutput

export const zGetFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEdit2509LoraGalleryIntegrateProductData =
  z.object({
    body: zSchemaQwenImageEdit2509LoraGalleryIntegrateProductInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  })

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryIntegrateProductResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryIntegrateProductRequestsByRequestIdResponse =
  zSchemaQwenImageEdit2509LoraGalleryIntegrateProductOutput

export const zGetFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEdit2509LoraGalleryGroupPhotoData = z.object({
  body: zSchemaQwenImageEdit2509LoraGalleryGroupPhotoInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryGroupPhotoResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryGroupPhotoRequestsByRequestIdResponse =
  zSchemaQwenImageEdit2509LoraGalleryGroupPhotoOutput

export const zGetFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitData =
  z.object({
    body: zSchemaQwenImageEdit2509LoraGalleryFaceToFullPortraitInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  })

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryFaceToFullPortraitRequestsByRequestIdResponse =
  zSchemaQwenImageEdit2509LoraGalleryFaceToFullPortraitOutput

export const zGetFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEdit2509LoraGalleryAddBackgroundData = z.object(
  {
    body: zSchemaQwenImageEdit2509LoraGalleryAddBackgroundInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  },
)

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryAddBackgroundResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryAddBackgroundRequestsByRequestIdResponse =
  zSchemaQwenImageEdit2509LoraGalleryAddBackgroundOutput

export const zGetFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEdit2509LoraGalleryNextSceneData = z.object({
  body: zSchemaQwenImageEdit2509LoraGalleryNextSceneInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryNextSceneResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryNextSceneRequestsByRequestIdResponse =
  zSchemaQwenImageEdit2509LoraGalleryNextSceneOutput

export const zGetFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEdit2509LoraGalleryMultipleAnglesData =
  z.object({
    body: zSchemaQwenImageEdit2509LoraGalleryMultipleAnglesInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  })

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraGalleryMultipleAnglesResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraGalleryMultipleAnglesRequestsByRequestIdResponse =
  zSchemaQwenImageEdit2509LoraGalleryMultipleAnglesOutput

export const zGetFalAiQwenImageEdit2509LoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509LoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEdit2509LoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509LoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiQwenImageEdit2509LoraData = z.object({
  body: zSchemaQwenImageEdit2509LoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509LoraResponse = zSchemaQueueStatus

export const zGetFalAiQwenImageEdit2509LoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509LoraRequestsByRequestIdResponse =
  zSchemaQwenImageEdit2509LoraOutput

export const zGetFalAiQwenImageEdit2509RequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiQwenImageEdit2509RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEdit2509RequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEdit2509RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiQwenImageEdit2509Data = z.object({
  body: zSchemaQwenImageEdit2509Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageEdit2509Response = zSchemaQueueStatus

export const zGetFalAiQwenImageEdit2509RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEdit2509RequestsByRequestIdResponse =
  zSchemaQwenImageEdit2509Output

export const zGetFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEditPlusLoraGalleryLightingRestorationData =
  z.object({
    body: zSchemaQwenImageEditPlusLoraGalleryLightingRestorationInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  })

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryLightingRestorationResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryLightingRestorationRequestsByRequestIdResponse =
  zSchemaQwenImageEditPlusLoraGalleryLightingRestorationOutput

export const zGetFalAiMoondream3PreviewSegmentRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiMoondream3PreviewSegmentRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiMoondream3PreviewSegmentRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiMoondream3PreviewSegmentRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiMoondream3PreviewSegmentData = z.object({
  body: zSchemaMoondream3PreviewSegmentInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiMoondream3PreviewSegmentResponse = zSchemaQueueStatus

export const zGetFalAiMoondream3PreviewSegmentRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiMoondream3PreviewSegmentRequestsByRequestIdResponse =
  zSchemaMoondream3PreviewSegmentOutput

export const zGetFalAiStepxEdit2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiStepxEdit2RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiStepxEdit2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiStepxEdit2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiStepxEdit2Data = z.object({
  body: zSchemaStepxEdit2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiStepxEdit2Response = zSchemaQueueStatus

export const zGetFalAiStepxEdit2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiStepxEdit2RequestsByRequestIdResponse =
  zSchemaStepxEdit2Output

export const zGetFalAiZImageTurboControlnetLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiZImageTurboControlnetLoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiZImageTurboControlnetLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageTurboControlnetLoraRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiZImageTurboControlnetLoraData = z.object({
  body: zSchemaZImageTurboControlnetLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiZImageTurboControlnetLoraResponse = zSchemaQueueStatus

export const zGetFalAiZImageTurboControlnetLoraRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiZImageTurboControlnetLoraRequestsByRequestIdResponse =
  zSchemaZImageTurboControlnetLoraOutput

export const zGetFalAiZImageTurboControlnetRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiZImageTurboControlnetRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiZImageTurboControlnetRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageTurboControlnetRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiZImageTurboControlnetData = z.object({
  body: zSchemaZImageTurboControlnetInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiZImageTurboControlnetResponse = zSchemaQueueStatus

export const zGetFalAiZImageTurboControlnetRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiZImageTurboControlnetRequestsByRequestIdResponse =
  zSchemaZImageTurboControlnetOutput

export const zGetFalAiZImageTurboImageToImageLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiZImageTurboImageToImageLoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiZImageTurboImageToImageLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageTurboImageToImageLoraRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiZImageTurboImageToImageLoraData = z.object({
  body: zSchemaZImageTurboImageToImageLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiZImageTurboImageToImageLoraResponse = zSchemaQueueStatus

export const zGetFalAiZImageTurboImageToImageLoraRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiZImageTurboImageToImageLoraRequestsByRequestIdResponse =
  zSchemaZImageTurboImageToImageLoraOutput

export const zGetFalAiZImageTurboImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiZImageTurboImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiZImageTurboImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageTurboImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiZImageTurboImageToImageData = z.object({
  body: zSchemaZImageTurboImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiZImageTurboImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiZImageTurboImageToImageRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * Result of the request.
 */
export const zGetFalAiZImageTurboImageToImageRequestsByRequestIdResponse =
  zSchemaZImageTurboImageToImageOutput

export const zGetFalAiLongcatImageEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiLongcatImageEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLongcatImageEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiLongcatImageEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLongcatImageEditData = z.object({
  body: zSchemaLongcatImageEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLongcatImageEditResponse = zSchemaQueueStatus

export const zGetFalAiLongcatImageEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLongcatImageEditRequestsByRequestIdResponse =
  zSchemaLongcatImageEditOutput

export const zGetFalAiBytedanceSeedreamV45EditRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiBytedanceSeedreamV45EditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBytedanceSeedreamV45EditRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiBytedanceSeedreamV45EditRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiBytedanceSeedreamV45EditData = z.object({
  body: zSchemaBytedanceSeedreamV45EditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBytedanceSeedreamV45EditResponse = zSchemaQueueStatus

export const zGetFalAiBytedanceSeedreamV45EditRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiBytedanceSeedreamV45EditRequestsByRequestIdResponse =
  zSchemaBytedanceSeedreamV45EditOutput

export const zGetFalAiViduQ2ReferenceToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiViduQ2ReferenceToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiViduQ2ReferenceToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiViduQ2ReferenceToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiViduQ2ReferenceToImageData = z.object({
  body: zSchemaViduQ2ReferenceToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiViduQ2ReferenceToImageResponse = zSchemaQueueStatus

export const zGetFalAiViduQ2ReferenceToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiViduQ2ReferenceToImageRequestsByRequestIdResponse =
  zSchemaViduQ2ReferenceToImageOutput

export const zGetFalAiKlingImageO1RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiKlingImageO1RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKlingImageO1RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiKlingImageO1RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKlingImageO1Data = z.object({
  body: zSchemaKlingImageO1Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKlingImageO1Response = zSchemaQueueStatus

export const zGetFalAiKlingImageO1RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKlingImageO1RequestsByRequestIdResponse =
  zSchemaKlingImageO1Output

export const zGetFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlux2LoraGalleryVirtualTryonData = z.object({
  body: zSchemaFlux2LoraGalleryVirtualTryonInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGalleryVirtualTryonResponse = zSchemaQueueStatus

export const zGetFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGalleryVirtualTryonRequestsByRequestIdResponse =
  zSchemaFlux2LoraGalleryVirtualTryonOutput

export const zGetFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlux2LoraGalleryMultipleAnglesData = z.object({
  body: zSchemaFlux2LoraGalleryMultipleAnglesInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGalleryMultipleAnglesResponse =
  zSchemaQueueStatus

export const zGetFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGalleryMultipleAnglesRequestsByRequestIdResponse =
  zSchemaFlux2LoraGalleryMultipleAnglesOutput

export const zGetFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlux2LoraGalleryFaceToFullPortraitData = z.object({
  body: zSchemaFlux2LoraGalleryFaceToFullPortraitInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGalleryFaceToFullPortraitResponse =
  zSchemaQueueStatus

export const zGetFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGalleryFaceToFullPortraitRequestsByRequestIdResponse =
  zSchemaFlux2LoraGalleryFaceToFullPortraitOutput

export const zGetFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlux2LoraGalleryApartmentStagingData = z.object({
  body: zSchemaFlux2LoraGalleryApartmentStagingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGalleryApartmentStagingResponse =
  zSchemaQueueStatus

export const zGetFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGalleryApartmentStagingRequestsByRequestIdResponse =
  zSchemaFlux2LoraGalleryApartmentStagingOutput

export const zGetFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlux2LoraGalleryAddBackgroundData = z.object({
  body: zSchemaFlux2LoraGalleryAddBackgroundInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGalleryAddBackgroundResponse =
  zSchemaQueueStatus

export const zGetFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGalleryAddBackgroundRequestsByRequestIdResponse =
  zSchemaFlux2LoraGalleryAddBackgroundOutput

export const zGetClarityaiCrystalUpscalerRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetClarityaiCrystalUpscalerRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutClarityaiCrystalUpscalerRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutClarityaiCrystalUpscalerRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostClarityaiCrystalUpscalerData = z.object({
  body: zSchemaCrystalUpscalerInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostClarityaiCrystalUpscalerResponse = zSchemaQueueStatus

export const zGetClarityaiCrystalUpscalerRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetClarityaiCrystalUpscalerRequestsByRequestIdResponse =
  zSchemaCrystalUpscalerOutput

export const zGetFalAiFlux2FlexEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2FlexEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2FlexEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2FlexEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2FlexEditData = z.object({
  body: zSchemaFlux2FlexEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2FlexEditResponse = zSchemaQueueStatus

export const zGetFalAiFlux2FlexEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2FlexEditRequestsByRequestIdResponse =
  zSchemaFlux2FlexEditOutput

export const zGetFalAiChronoEditLoraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiChronoEditLoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiChronoEditLoraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiChronoEditLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiChronoEditLoraData = z.object({
  body: zSchemaChronoEditLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiChronoEditLoraResponse = zSchemaQueueStatus

export const zGetFalAiChronoEditLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiChronoEditLoraRequestsByRequestIdResponse =
  zSchemaChronoEditLoraOutput

export const zGetFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiChronoEditLoraGalleryPaintbrushData = z.object({
  body: zSchemaChronoEditLoraGalleryPaintbrushInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiChronoEditLoraGalleryPaintbrushResponse =
  zSchemaQueueStatus

export const zGetFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiChronoEditLoraGalleryPaintbrushRequestsByRequestIdResponse =
  zSchemaChronoEditLoraGalleryPaintbrushOutput

export const zGetFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiChronoEditLoraGalleryUpscalerData = z.object({
  body: zSchemaChronoEditLoraGalleryUpscalerInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiChronoEditLoraGalleryUpscalerResponse =
  zSchemaQueueStatus

export const zGetFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiChronoEditLoraGalleryUpscalerRequestsByRequestIdResponse =
  zSchemaChronoEditLoraGalleryUpscalerOutput

export const zGetFalAiSam3ImageRleRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiSam3ImageRleRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSam3ImageRleRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiSam3ImageRleRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSam3ImageRleData = z.object({
  body: zSchemaSam3ImageRleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSam3ImageRleResponse = zSchemaQueueStatus

export const zGetFalAiSam3ImageRleRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSam3ImageRleRequestsByRequestIdResponse =
  zSchemaSam3ImageRleOutput

export const zGetFalAiSam3ImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiSam3ImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSam3ImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiSam3ImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSam3ImageData = z.object({
  body: zSchemaSam3ImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSam3ImageResponse = zSchemaQueueStatus

export const zGetFalAiSam3ImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSam3ImageRequestsByRequestIdResponse =
  zSchemaSam3ImageOutput

export const zGetFalAiGemini3ProImagePreviewEditRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiGemini3ProImagePreviewEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiGemini3ProImagePreviewEditRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiGemini3ProImagePreviewEditRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiGemini3ProImagePreviewEditData = z.object({
  body: zSchemaGemini3ProImagePreviewEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiGemini3ProImagePreviewEditResponse = zSchemaQueueStatus

export const zGetFalAiGemini3ProImagePreviewEditRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiGemini3ProImagePreviewEditRequestsByRequestIdResponse =
  zSchemaGemini3ProImagePreviewEditOutput

export const zGetFalAiNanoBananaProEditRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiNanoBananaProEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiNanoBananaProEditRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiNanoBananaProEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiNanoBananaProEditData = z.object({
  body: zSchemaNanoBananaProEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiNanoBananaProEditResponse = zSchemaQueueStatus

export const zGetFalAiNanoBananaProEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiNanoBananaProEditRequestsByRequestIdResponse =
  zSchemaNanoBananaProEditOutput

export const zGetFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEditPlusLoraGalleryMultipleAnglesData =
  z.object({
    body: zSchemaQwenImageEditPlusLoraGalleryMultipleAnglesInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  })

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryMultipleAnglesResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryMultipleAnglesRequestsByRequestIdResponse =
  zSchemaQwenImageEditPlusLoraGalleryMultipleAnglesOutput

export const zGetFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEditPlusLoraGalleryShirtDesignData = z.object({
  body: zSchemaQwenImageEditPlusLoraGalleryShirtDesignInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryShirtDesignResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryShirtDesignRequestsByRequestIdResponse =
  zSchemaQwenImageEditPlusLoraGalleryShirtDesignOutput

export const zGetFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEditPlusLoraGalleryRemoveLightingData =
  z.object({
    body: zSchemaQwenImageEditPlusLoraGalleryRemoveLightingInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  })

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryRemoveLightingResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryRemoveLightingRequestsByRequestIdResponse =
  zSchemaQwenImageEditPlusLoraGalleryRemoveLightingOutput

export const zGetFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEditPlusLoraGalleryRemoveElementData = z.object(
  {
    body: zSchemaQwenImageEditPlusLoraGalleryRemoveElementInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  },
)

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryRemoveElementResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryRemoveElementRequestsByRequestIdResponse =
  zSchemaQwenImageEditPlusLoraGalleryRemoveElementOutput

export const zGetFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEditPlusLoraGalleryNextSceneData = z.object({
  body: zSchemaQwenImageEditPlusLoraGalleryNextSceneInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryNextSceneResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryNextSceneRequestsByRequestIdResponse =
  zSchemaQwenImageEditPlusLoraGalleryNextSceneOutput

export const zGetFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEditPlusLoraGalleryIntegrateProductData =
  z.object({
    body: zSchemaQwenImageEditPlusLoraGalleryIntegrateProductInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  })

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryIntegrateProductResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryIntegrateProductRequestsByRequestIdResponse =
  zSchemaQwenImageEditPlusLoraGalleryIntegrateProductOutput

export const zGetFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEditPlusLoraGalleryGroupPhotoData = z.object({
  body: zSchemaQwenImageEditPlusLoraGalleryGroupPhotoInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryGroupPhotoResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryGroupPhotoRequestsByRequestIdResponse =
  zSchemaQwenImageEditPlusLoraGalleryGroupPhotoOutput

export const zGetFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitData =
  z.object({
    body: zSchemaQwenImageEditPlusLoraGalleryFaceToFullPortraitInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  })

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryFaceToFullPortraitRequestsByRequestIdResponse =
  zSchemaQwenImageEditPlusLoraGalleryFaceToFullPortraitOutput

export const zGetFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEditPlusLoraGalleryAddBackgroundData = z.object(
  {
    body: zSchemaQwenImageEditPlusLoraGalleryAddBackgroundInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  },
)

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraGalleryAddBackgroundResponse =
  zSchemaQueueStatus

export const zGetFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraGalleryAddBackgroundRequestsByRequestIdResponse =
  zSchemaQwenImageEditPlusLoraGalleryAddBackgroundOutput

export const zGetFalAiReveFastRemixRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiReveFastRemixRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiReveFastRemixRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiReveFastRemixRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiReveFastRemixData = z.object({
  body: zSchemaReveFastRemixInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiReveFastRemixResponse = zSchemaQueueStatus

export const zGetFalAiReveFastRemixRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiReveFastRemixRequestsByRequestIdResponse =
  zSchemaReveFastRemixOutput

export const zGetFalAiReveFastEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiReveFastEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiReveFastEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiReveFastEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiReveFastEditData = z.object({
  body: zSchemaReveFastEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiReveFastEditResponse = zSchemaQueueStatus

export const zGetFalAiReveFastEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiReveFastEditRequestsByRequestIdResponse =
  zSchemaReveFastEditOutput

export const zGetFalAiImageAppsV2OutpaintRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2OutpaintRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageAppsV2OutpaintRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2OutpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImageAppsV2OutpaintData = z.object({
  body: zSchemaImageAppsV2OutpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2OutpaintResponse = zSchemaQueueStatus

export const zGetFalAiImageAppsV2OutpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2OutpaintRequestsByRequestIdResponse =
  zSchemaImageAppsV2OutpaintOutput

export const zGetFalAiFluxVisionUpscalerRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxVisionUpscalerRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxVisionUpscalerRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxVisionUpscalerRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxVisionUpscalerData = z.object({
  body: zSchemaFluxVisionUpscalerInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxVisionUpscalerResponse = zSchemaQueueStatus

export const zGetFalAiFluxVisionUpscalerRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxVisionUpscalerRequestsByRequestIdResponse =
  zSchemaFluxVisionUpscalerOutput

export const zGetFalAiEmu35ImageEditImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiEmu35ImageEditImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiEmu35ImageEditImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiEmu35ImageEditImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiEmu35ImageEditImageData = z.object({
  body: zSchemaEmu35ImageEditImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiEmu35ImageEditImageResponse = zSchemaQueueStatus

export const zGetFalAiEmu35ImageEditImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiEmu35ImageEditImageRequestsByRequestIdResponse =
  zSchemaEmu35ImageEditImageOutput

export const zGetFalAiChronoEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiChronoEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiChronoEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiChronoEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiChronoEditData = z.object({
  body: zSchemaChronoEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiChronoEditResponse = zSchemaQueueStatus

export const zGetFalAiChronoEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiChronoEditRequestsByRequestIdResponse =
  zSchemaChronoEditOutput

export const zGetFalAiGptImage1MiniEditRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiGptImage1MiniEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiGptImage1MiniEditRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiGptImage1MiniEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiGptImage1MiniEditData = z.object({
  body: zSchemaGptImage1MiniEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiGptImage1MiniEditResponse = zSchemaQueueStatus

export const zGetFalAiGptImage1MiniEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiGptImage1MiniEditRequestsByRequestIdResponse =
  zSchemaGptImage1MiniEditOutput

export const zGetFalAiReveRemixRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiReveRemixRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiReveRemixRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiReveRemixRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiReveRemixData = z.object({
  body: zSchemaReveRemixInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiReveRemixResponse = zSchemaQueueStatus

export const zGetFalAiReveRemixRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiReveRemixRequestsByRequestIdResponse =
  zSchemaReveRemixOutput

export const zGetFalAiReveEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiReveEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiReveEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiReveEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiReveEditData = z.object({
  body: zSchemaReveEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiReveEditResponse = zSchemaQueueStatus

export const zGetFalAiReveEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiReveEditRequestsByRequestIdResponse =
  zSchemaReveEditOutput

export const zGetFalAiImage2PixelRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiImage2PixelRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImage2PixelRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiImage2PixelRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImage2PixelData = z.object({
  body: zSchemaImage2PixelInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImage2PixelResponse = zSchemaQueueStatus

export const zGetFalAiImage2PixelRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImage2PixelRequestsByRequestIdResponse =
  zSchemaImage2PixelOutput

export const zGetFalAiDreamomni2EditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiDreamomni2EditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiDreamomni2EditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiDreamomni2EditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiDreamomni2EditData = z.object({
  body: zSchemaDreamomni2EditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiDreamomni2EditResponse = zSchemaQueueStatus

export const zGetFalAiDreamomni2EditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiDreamomni2EditRequestsByRequestIdResponse =
  zSchemaDreamomni2EditOutput

export const zGetFalAiQwenImageEditPlusLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusLoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEditPlusLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiQwenImageEditPlusLoraData = z.object({
  body: zSchemaQwenImageEditPlusLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusLoraResponse = zSchemaQueueStatus

export const zGetFalAiQwenImageEditPlusLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusLoraRequestsByRequestIdResponse =
  zSchemaQwenImageEditPlusLoraOutput

export const zGetFalAiLucidfluxRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiLucidfluxRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLucidfluxRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiLucidfluxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLucidfluxData = z.object({
  body: zSchemaLucidfluxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLucidfluxResponse = zSchemaQueueStatus

export const zGetFalAiLucidfluxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLucidfluxRequestsByRequestIdResponse =
  zSchemaLucidfluxOutput

export const zGetFalAiQwenImageEditImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEditImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiQwenImageEditImageToImageData = z.object({
  body: zSchemaQwenImageEditImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiQwenImageEditImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditImageToImageRequestsByRequestIdResponse =
  zSchemaQwenImageEditImageToImageOutput

export const zGetFalAiWan25PreviewImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiWan25PreviewImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiWan25PreviewImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiWan25PreviewImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiWan25PreviewImageToImageData = z.object({
  body: zSchemaWan25PreviewImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiWan25PreviewImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiWan25PreviewImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiWan25PreviewImageToImageRequestsByRequestIdResponse =
  zSchemaWan25PreviewImageToImageOutput

export const zGetFalAiQwenImageEditPlusRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditPlusRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEditPlusRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditPlusRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiQwenImageEditPlusData = z.object({
  body: zSchemaQwenImageEditPlusInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditPlusResponse = zSchemaQueueStatus

export const zGetFalAiQwenImageEditPlusRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditPlusRequestsByRequestIdResponse =
  zSchemaQwenImageEditPlusOutput

export const zGetFalAiSeedvrUpscaleImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiSeedvrUpscaleImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSeedvrUpscaleImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiSeedvrUpscaleImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSeedvrUpscaleImageData = z.object({
  body: zSchemaSeedvrUpscaleImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSeedvrUpscaleImageResponse = zSchemaQueueStatus

export const zGetFalAiSeedvrUpscaleImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSeedvrUpscaleImageRequestsByRequestIdResponse =
  zSchemaSeedvrUpscaleImageOutput

export const zGetFalAiImageAppsV2ProductHoldingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2ProductHoldingRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageAppsV2ProductHoldingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2ProductHoldingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageAppsV2ProductHoldingData = z.object({
  body: zSchemaImageAppsV2ProductHoldingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2ProductHoldingResponse = zSchemaQueueStatus

export const zGetFalAiImageAppsV2ProductHoldingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2ProductHoldingRequestsByRequestIdResponse =
  zSchemaImageAppsV2ProductHoldingOutput

export const zGetFalAiImageAppsV2ProductPhotographyRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2ProductPhotographyRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageAppsV2ProductPhotographyRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2ProductPhotographyRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageAppsV2ProductPhotographyData = z.object({
  body: zSchemaImageAppsV2ProductPhotographyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2ProductPhotographyResponse =
  zSchemaQueueStatus

export const zGetFalAiImageAppsV2ProductPhotographyRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2ProductPhotographyRequestsByRequestIdResponse =
  zSchemaImageAppsV2ProductPhotographyOutput

export const zGetFalAiImageAppsV2VirtualTryOnRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2VirtualTryOnRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageAppsV2VirtualTryOnRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2VirtualTryOnRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageAppsV2VirtualTryOnData = z.object({
  body: zSchemaImageAppsV2VirtualTryOnInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2VirtualTryOnResponse = zSchemaQueueStatus

export const zGetFalAiImageAppsV2VirtualTryOnRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2VirtualTryOnRequestsByRequestIdResponse =
  zSchemaImageAppsV2VirtualTryOnOutput

export const zGetFalAiImageAppsV2TextureTransformRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2TextureTransformRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageAppsV2TextureTransformRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2TextureTransformRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageAppsV2TextureTransformData = z.object({
  body: zSchemaImageAppsV2TextureTransformInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2TextureTransformResponse = zSchemaQueueStatus

export const zGetFalAiImageAppsV2TextureTransformRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2TextureTransformRequestsByRequestIdResponse =
  zSchemaImageAppsV2TextureTransformOutput

export const zGetFalAiImageAppsV2RelightingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2RelightingRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageAppsV2RelightingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2RelightingRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImageAppsV2RelightingData = z.object({
  body: zSchemaImageAppsV2RelightingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2RelightingResponse = zSchemaQueueStatus

export const zGetFalAiImageAppsV2RelightingRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2RelightingRequestsByRequestIdResponse =
  zSchemaImageAppsV2RelightingOutput

export const zGetFalAiImageAppsV2StyleTransferRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2StyleTransferRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageAppsV2StyleTransferRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2StyleTransferRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageAppsV2StyleTransferData = z.object({
  body: zSchemaImageAppsV2StyleTransferInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2StyleTransferResponse = zSchemaQueueStatus

export const zGetFalAiImageAppsV2StyleTransferRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2StyleTransferRequestsByRequestIdResponse =
  zSchemaImageAppsV2StyleTransferOutput

export const zGetFalAiImageAppsV2PhotoRestorationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2PhotoRestorationRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageAppsV2PhotoRestorationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2PhotoRestorationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageAppsV2PhotoRestorationData = z.object({
  body: zSchemaImageAppsV2PhotoRestorationInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2PhotoRestorationResponse = zSchemaQueueStatus

export const zGetFalAiImageAppsV2PhotoRestorationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2PhotoRestorationRequestsByRequestIdResponse =
  zSchemaImageAppsV2PhotoRestorationOutput

export const zGetFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageAppsV2PortraitEnhanceData = z.object({
  body: zSchemaImageAppsV2PortraitEnhanceInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2PortraitEnhanceResponse = zSchemaQueueStatus

export const zGetFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2PortraitEnhanceRequestsByRequestIdResponse =
  zSchemaImageAppsV2PortraitEnhanceOutput

export const zGetFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageAppsV2PhotographyEffectsData = z.object({
  body: zSchemaImageAppsV2PhotographyEffectsInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2PhotographyEffectsResponse =
  zSchemaQueueStatus

export const zGetFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2PhotographyEffectsRequestsByRequestIdResponse =
  zSchemaImageAppsV2PhotographyEffectsOutput

export const zGetFalAiImageAppsV2PerspectiveRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2PerspectiveRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageAppsV2PerspectiveRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2PerspectiveRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageAppsV2PerspectiveData = z.object({
  body: zSchemaImageAppsV2PerspectiveInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2PerspectiveResponse = zSchemaQueueStatus

export const zGetFalAiImageAppsV2PerspectiveRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2PerspectiveRequestsByRequestIdResponse =
  zSchemaImageAppsV2PerspectiveOutput

export const zGetFalAiImageAppsV2ObjectRemovalRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2ObjectRemovalRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageAppsV2ObjectRemovalRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2ObjectRemovalRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageAppsV2ObjectRemovalData = z.object({
  body: zSchemaImageAppsV2ObjectRemovalInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2ObjectRemovalResponse = zSchemaQueueStatus

export const zGetFalAiImageAppsV2ObjectRemovalRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2ObjectRemovalRequestsByRequestIdResponse =
  zSchemaImageAppsV2ObjectRemovalOutput

export const zGetFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageAppsV2HeadshotPhotoData = z.object({
  body: zSchemaImageAppsV2HeadshotPhotoInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2HeadshotPhotoResponse = zSchemaQueueStatus

export const zGetFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2HeadshotPhotoRequestsByRequestIdResponse =
  zSchemaImageAppsV2HeadshotPhotoOutput

export const zGetFalAiImageAppsV2HairChangeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2HairChangeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageAppsV2HairChangeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2HairChangeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImageAppsV2HairChangeData = z.object({
  body: zSchemaImageAppsV2HairChangeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2HairChangeResponse = zSchemaQueueStatus

export const zGetFalAiImageAppsV2HairChangeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2HairChangeRequestsByRequestIdResponse =
  zSchemaImageAppsV2HairChangeOutput

export const zGetFalAiImageAppsV2ExpressionChangeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2ExpressionChangeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageAppsV2ExpressionChangeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2ExpressionChangeRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageAppsV2ExpressionChangeData = z.object({
  body: zSchemaImageAppsV2ExpressionChangeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2ExpressionChangeResponse = zSchemaQueueStatus

export const zGetFalAiImageAppsV2ExpressionChangeRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2ExpressionChangeRequestsByRequestIdResponse =
  zSchemaImageAppsV2ExpressionChangeOutput

export const zGetFalAiImageAppsV2CityTeleportRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2CityTeleportRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageAppsV2CityTeleportRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2CityTeleportRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageAppsV2CityTeleportData = z.object({
  body: zSchemaImageAppsV2CityTeleportInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2CityTeleportResponse = zSchemaQueueStatus

export const zGetFalAiImageAppsV2CityTeleportRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2CityTeleportRequestsByRequestIdResponse =
  zSchemaImageAppsV2CityTeleportOutput

export const zGetFalAiImageAppsV2AgeModifyRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2AgeModifyRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageAppsV2AgeModifyRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2AgeModifyRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImageAppsV2AgeModifyData = z.object({
  body: zSchemaImageAppsV2AgeModifyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2AgeModifyResponse = zSchemaQueueStatus

export const zGetFalAiImageAppsV2AgeModifyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2AgeModifyRequestsByRequestIdResponse =
  zSchemaImageAppsV2AgeModifyOutput

export const zGetFalAiImageAppsV2MakeupApplicationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageAppsV2MakeupApplicationRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageAppsV2MakeupApplicationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageAppsV2MakeupApplicationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageAppsV2MakeupApplicationData = z.object({
  body: zSchemaImageAppsV2MakeupApplicationInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageAppsV2MakeupApplicationResponse = zSchemaQueueStatus

export const zGetFalAiImageAppsV2MakeupApplicationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageAppsV2MakeupApplicationRequestsByRequestIdResponse =
  zSchemaImageAppsV2MakeupApplicationOutput

export const zGetFalAiQwenImageEditInpaintRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditInpaintRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEditInpaintRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditInpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiQwenImageEditInpaintData = z.object({
  body: zSchemaQwenImageEditInpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditInpaintResponse = zSchemaQueueStatus

export const zGetFalAiQwenImageEditInpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditInpaintRequestsByRequestIdResponse =
  zSchemaQwenImageEditInpaintOutput

export const zGetFalAiFluxSrpoImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxSrpoImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxSrpoImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxSrpoImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxSrpoImageToImageData = z.object({
  body: zSchemaFluxSrpoImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxSrpoImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiFluxSrpoImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxSrpoImageToImageRequestsByRequestIdResponse =
  zSchemaFluxSrpoImageToImageOutput

export const zGetFalAiFlux1SrpoImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux1SrpoImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux1SrpoImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1SrpoImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux1SrpoImageToImageData = z.object({
  body: zSchemaFlux1SrpoImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux1SrpoImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiFlux1SrpoImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux1SrpoImageToImageRequestsByRequestIdResponse =
  zSchemaFlux1SrpoImageToImageOutput

export const zGetFalAiQwenImageEditLoraRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditLoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEditLoraRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiQwenImageEditLoraData = z.object({
  body: zSchemaQwenImageEditLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditLoraResponse = zSchemaQueueStatus

export const zGetFalAiQwenImageEditLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditLoraRequestsByRequestIdResponse =
  zSchemaQwenImageEditLoraOutput

export const zGetFalAiViduReferenceToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiViduReferenceToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiViduReferenceToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiViduReferenceToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiViduReferenceToImageData = z.object({
  body: zSchemaViduReferenceToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiViduReferenceToImageResponse = zSchemaQueueStatus

export const zGetFalAiViduReferenceToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiViduReferenceToImageRequestsByRequestIdResponse =
  zSchemaViduReferenceToImageOutput

export const zGetFalAiBytedanceSeedreamV4EditRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiBytedanceSeedreamV4EditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBytedanceSeedreamV4EditRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiBytedanceSeedreamV4EditRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiBytedanceSeedreamV4EditData = z.object({
  body: zSchemaBytedanceSeedreamV4EditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBytedanceSeedreamV4EditResponse = zSchemaQueueStatus

export const zGetFalAiBytedanceSeedreamV4EditRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * Result of the request.
 */
export const zGetFalAiBytedanceSeedreamV4EditRequestsByRequestIdResponse =
  zSchemaBytedanceSeedreamV4EditOutput

export const zGetFalAiWanV22A14bImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiWanV22A14bImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiWanV22A14bImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiWanV22A14bImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiWanV22A14bImageToImageData = z.object({
  body: zSchemaWanV22A14bImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiWanV22A14bImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiWanV22A14bImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiWanV22A14bImageToImageRequestsByRequestIdResponse =
  zSchemaWanV22A14bImageToImageOutput

export const zGetFalAiUsoRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiUsoRequestsByRequestIdStatusResponse = zSchemaQueueStatus

export const zPutFalAiUsoRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiUsoRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiUsoData = z.object({
  body: zSchemaUsoInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiUsoResponse = zSchemaQueueStatus

export const zGetFalAiUsoRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiUsoRequestsByRequestIdResponse = zSchemaUsoOutput

export const zGetFalAiGemini25FlashImageEditRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiGemini25FlashImageEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiGemini25FlashImageEditRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiGemini25FlashImageEditRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiGemini25FlashImageEditData = z.object({
  body: zSchemaGemini25FlashImageEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiGemini25FlashImageEditResponse = zSchemaQueueStatus

export const zGetFalAiGemini25FlashImageEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiGemini25FlashImageEditRequestsByRequestIdResponse =
  zSchemaGemini25FlashImageEditOutput

export const zGetFalAiQwenImageImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiQwenImageImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiQwenImageImageToImageData = z.object({
  body: zSchemaQwenImageImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiQwenImageImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageImageToImageRequestsByRequestIdResponse =
  zSchemaQwenImageImageToImageOutput

export const zGetBriaReimagine32RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetBriaReimagine32RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaReimagine32RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutBriaReimagine32RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostBriaReimagine32Data = z.object({
  body: zSchemaReimagine32Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaReimagine32Response = zSchemaQueueStatus

export const zGetBriaReimagine32RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetBriaReimagine32RequestsByRequestIdResponse =
  zSchemaReimagine32Output

export const zGetFalAiNanoBananaEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiNanoBananaEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiNanoBananaEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiNanoBananaEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiNanoBananaEditData = z.object({
  body: zSchemaNanoBananaEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiNanoBananaEditResponse = zSchemaQueueStatus

export const zGetFalAiNanoBananaEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiNanoBananaEditRequestsByRequestIdResponse =
  zSchemaNanoBananaEditOutput

export const zGetFalAiNextstep1RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiNextstep1RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiNextstep1RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiNextstep1RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiNextstep1Data = z.object({
  body: zSchemaNextstep1Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiNextstep1Response = zSchemaQueueStatus

export const zGetFalAiNextstep1RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiNextstep1RequestsByRequestIdResponse =
  zSchemaNextstep1Output

export const zGetFalAiQwenImageEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiQwenImageEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiQwenImageEditData = z.object({
  body: zSchemaQwenImageEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageEditResponse = zSchemaQueueStatus

export const zGetFalAiQwenImageEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageEditRequestsByRequestIdResponse =
  zSchemaQwenImageEditOutput

export const zGetFalAiIdeogramCharacterEditRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiIdeogramCharacterEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIdeogramCharacterEditRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramCharacterEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIdeogramCharacterEditData = z.object({
  body: zSchemaIdeogramCharacterEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIdeogramCharacterEditResponse = zSchemaQueueStatus

export const zGetFalAiIdeogramCharacterEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramCharacterEditRequestsByRequestIdResponse =
  zSchemaIdeogramCharacterEditOutput

export const zGetFalAiIdeogramCharacterRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiIdeogramCharacterRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIdeogramCharacterRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramCharacterRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIdeogramCharacterData = z.object({
  body: zSchemaIdeogramCharacterInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIdeogramCharacterResponse = zSchemaQueueStatus

export const zGetFalAiIdeogramCharacterRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramCharacterRequestsByRequestIdResponse =
  zSchemaIdeogramCharacterOutput

export const zGetFalAiIdeogramCharacterRemixRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiIdeogramCharacterRemixRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIdeogramCharacterRemixRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramCharacterRemixRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiIdeogramCharacterRemixData = z.object({
  body: zSchemaIdeogramCharacterRemixInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIdeogramCharacterRemixResponse = zSchemaQueueStatus

export const zGetFalAiIdeogramCharacterRemixRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramCharacterRemixRequestsByRequestIdResponse =
  zSchemaIdeogramCharacterRemixOutput

export const zGetFalAiFluxKreaLoraInpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxKreaLoraInpaintingRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxKreaLoraInpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKreaLoraInpaintingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFluxKreaLoraInpaintingData = z.object({
  body: zSchemaFluxKreaLoraInpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxKreaLoraInpaintingResponse = zSchemaQueueStatus

export const zGetFalAiFluxKreaLoraInpaintingRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxKreaLoraInpaintingRequestsByRequestIdResponse =
  zSchemaFluxKreaLoraInpaintingOutput

export const zGetFalAiFluxKreaLoraImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxKreaLoraImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxKreaLoraImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKreaLoraImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFluxKreaLoraImageToImageData = z.object({
  body: zSchemaFluxKreaLoraImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxKreaLoraImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiFluxKreaLoraImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFluxKreaLoraImageToImageRequestsByRequestIdResponse =
  zSchemaFluxKreaLoraImageToImageOutput

export const zGetFalAiFluxKreaImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxKreaImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxKreaImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKreaImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxKreaImageToImageData = z.object({
  body: zSchemaFluxKreaImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxKreaImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiFluxKreaImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxKreaImageToImageRequestsByRequestIdResponse =
  zSchemaFluxKreaImageToImageOutput

export const zGetFalAiFluxKreaReduxRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxKreaReduxRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxKreaReduxRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKreaReduxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxKreaReduxData = z.object({
  body: zSchemaFluxKreaReduxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxKreaReduxResponse = zSchemaQueueStatus

export const zGetFalAiFluxKreaReduxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxKreaReduxRequestsByRequestIdResponse =
  zSchemaFluxKreaReduxOutput

export const zGetFalAiFlux1KreaImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux1KreaImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux1KreaImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1KreaImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux1KreaImageToImageData = z.object({
  body: zSchemaFlux1KreaImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux1KreaImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiFlux1KreaImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux1KreaImageToImageRequestsByRequestIdResponse =
  zSchemaFlux1KreaImageToImageOutput

export const zGetFalAiFlux1KreaReduxRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux1KreaReduxRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux1KreaReduxRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1KreaReduxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux1KreaReduxData = z.object({
  body: zSchemaFlux1KreaReduxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux1KreaReduxResponse = zSchemaQueueStatus

export const zGetFalAiFlux1KreaReduxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux1KreaReduxRequestsByRequestIdResponse =
  zSchemaFlux1KreaReduxOutput

export const zGetFalAiFluxKontextLoraInpaintRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxKontextLoraInpaintRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxKontextLoraInpaintRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKontextLoraInpaintRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFluxKontextLoraInpaintData = z.object({
  body: zSchemaFluxKontextLoraInpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxKontextLoraInpaintResponse = zSchemaQueueStatus

export const zGetFalAiFluxKontextLoraInpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxKontextLoraInpaintRequestsByRequestIdResponse =
  zSchemaFluxKontextLoraInpaintOutput

export const zGetFalAiHunyuanWorldRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiHunyuanWorldRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuanWorldRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuanWorldRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHunyuanWorldData = z.object({
  body: zSchemaHunyuanWorldInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuanWorldResponse = zSchemaQueueStatus

export const zGetFalAiHunyuanWorldRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHunyuanWorldRequestsByRequestIdResponse =
  zSchemaHunyuanWorldOutput

export const zGetFalAiImageEditingRetouchRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingRetouchRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingRetouchRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingRetouchRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImageEditingRetouchData = z.object({
  body: zSchemaImageEditingRetouchInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingRetouchResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingRetouchRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingRetouchRequestsByRequestIdResponse =
  zSchemaImageEditingRetouchOutput

export const zGetFalAiHidreamE11RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiHidreamE11RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHidreamE11RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiHidreamE11RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHidreamE11Data = z.object({
  body: zSchemaHidreamE11Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHidreamE11Response = zSchemaQueueStatus

export const zGetFalAiHidreamE11RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHidreamE11RequestsByRequestIdResponse =
  zSchemaHidreamE11Output

export const zGetFalAiRifeRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiRifeRequestsByRequestIdStatusResponse = zSchemaQueueStatus

export const zPutFalAiRifeRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiRifeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiRifeData = z.object({
  body: zSchemaRifeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiRifeResponse = zSchemaQueueStatus

export const zGetFalAiRifeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiRifeRequestsByRequestIdResponse = zSchemaRifeOutput

export const zGetFalAiFilmRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFilmRequestsByRequestIdStatusResponse = zSchemaQueueStatus

export const zPutFalAiFilmRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFilmRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFilmData = z.object({
  body: zSchemaFilmInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFilmResponse = zSchemaQueueStatus

export const zGetFalAiFilmRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFilmRequestsByRequestIdResponse = zSchemaFilmOutput

export const zGetFalAiCalligrapherRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiCalligrapherRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiCalligrapherRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiCalligrapherRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiCalligrapherData = z.object({
  body: zSchemaCalligrapherInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiCalligrapherResponse = zSchemaQueueStatus

export const zGetFalAiCalligrapherRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiCalligrapherRequestsByRequestIdResponse =
  zSchemaCalligrapherOutput

export const zGetFalAiBriaReimagineRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiBriaReimagineRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBriaReimagineRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaReimagineRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiBriaReimagineData = z.object({
  body: zSchemaBriaReimagineInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBriaReimagineResponse = zSchemaQueueStatus

export const zGetFalAiBriaReimagineRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiBriaReimagineRequestsByRequestIdResponse =
  zSchemaBriaReimagineOutput

export const zGetFalAiImageEditingRealismRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingRealismRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingRealismRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingRealismRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImageEditingRealismData = z.object({
  body: zSchemaImageEditingRealismInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingRealismResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingRealismRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingRealismRequestsByRequestIdResponse =
  zSchemaImageEditingRealismOutput

export const zGetFalAiPostProcessingVignetteRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiPostProcessingVignetteRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPostProcessingVignetteRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingVignetteRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiPostProcessingVignetteData = z.object({
  body: zSchemaPostProcessingVignetteInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPostProcessingVignetteResponse = zSchemaQueueStatus

export const zGetFalAiPostProcessingVignetteRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingVignetteRequestsByRequestIdResponse =
  zSchemaPostProcessingVignetteOutput

export const zGetFalAiPostProcessingSolarizeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiPostProcessingSolarizeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPostProcessingSolarizeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingSolarizeRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiPostProcessingSolarizeData = z.object({
  body: zSchemaPostProcessingSolarizeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPostProcessingSolarizeResponse = zSchemaQueueStatus

export const zGetFalAiPostProcessingSolarizeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingSolarizeRequestsByRequestIdResponse =
  zSchemaPostProcessingSolarizeOutput

export const zGetFalAiPostProcessingSharpenRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiPostProcessingSharpenRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPostProcessingSharpenRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingSharpenRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiPostProcessingSharpenData = z.object({
  body: zSchemaPostProcessingSharpenInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPostProcessingSharpenResponse = zSchemaQueueStatus

export const zGetFalAiPostProcessingSharpenRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingSharpenRequestsByRequestIdResponse =
  zSchemaPostProcessingSharpenOutput

export const zGetFalAiPostProcessingParabolizeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiPostProcessingParabolizeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPostProcessingParabolizeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingParabolizeRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiPostProcessingParabolizeData = z.object({
  body: zSchemaPostProcessingParabolizeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPostProcessingParabolizeResponse = zSchemaQueueStatus

export const zGetFalAiPostProcessingParabolizeRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingParabolizeRequestsByRequestIdResponse =
  zSchemaPostProcessingParabolizeOutput

export const zGetFalAiPostProcessingGrainRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiPostProcessingGrainRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPostProcessingGrainRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingGrainRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiPostProcessingGrainData = z.object({
  body: zSchemaPostProcessingGrainInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPostProcessingGrainResponse = zSchemaQueueStatus

export const zGetFalAiPostProcessingGrainRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingGrainRequestsByRequestIdResponse =
  zSchemaPostProcessingGrainOutput

export const zGetFalAiPostProcessingDodgeBurnRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiPostProcessingDodgeBurnRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPostProcessingDodgeBurnRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingDodgeBurnRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiPostProcessingDodgeBurnData = z.object({
  body: zSchemaPostProcessingDodgeBurnInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPostProcessingDodgeBurnResponse = zSchemaQueueStatus

export const zGetFalAiPostProcessingDodgeBurnRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingDodgeBurnRequestsByRequestIdResponse =
  zSchemaPostProcessingDodgeBurnOutput

export const zGetFalAiPostProcessingDissolveRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiPostProcessingDissolveRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPostProcessingDissolveRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingDissolveRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiPostProcessingDissolveData = z.object({
  body: zSchemaPostProcessingDissolveInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPostProcessingDissolveResponse = zSchemaQueueStatus

export const zGetFalAiPostProcessingDissolveRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingDissolveRequestsByRequestIdResponse =
  zSchemaPostProcessingDissolveOutput

export const zGetFalAiPostProcessingDesaturateRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiPostProcessingDesaturateRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPostProcessingDesaturateRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingDesaturateRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiPostProcessingDesaturateData = z.object({
  body: zSchemaPostProcessingDesaturateInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPostProcessingDesaturateResponse = zSchemaQueueStatus

export const zGetFalAiPostProcessingDesaturateRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingDesaturateRequestsByRequestIdResponse =
  zSchemaPostProcessingDesaturateOutput

export const zGetFalAiPostProcessingColorTintRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiPostProcessingColorTintRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPostProcessingColorTintRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingColorTintRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiPostProcessingColorTintData = z.object({
  body: zSchemaPostProcessingColorTintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPostProcessingColorTintResponse = zSchemaQueueStatus

export const zGetFalAiPostProcessingColorTintRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingColorTintRequestsByRequestIdResponse =
  zSchemaPostProcessingColorTintOutput

export const zGetFalAiPostProcessingColorCorrectionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiPostProcessingColorCorrectionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPostProcessingColorCorrectionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingColorCorrectionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiPostProcessingColorCorrectionData = z.object({
  body: zSchemaPostProcessingColorCorrectionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPostProcessingColorCorrectionResponse =
  zSchemaQueueStatus

export const zGetFalAiPostProcessingColorCorrectionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingColorCorrectionRequestsByRequestIdResponse =
  zSchemaPostProcessingColorCorrectionOutput

export const zGetFalAiPostProcessingChromaticAberrationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiPostProcessingChromaticAberrationRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPostProcessingChromaticAberrationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingChromaticAberrationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiPostProcessingChromaticAberrationData = z.object({
  body: zSchemaPostProcessingChromaticAberrationInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPostProcessingChromaticAberrationResponse =
  zSchemaQueueStatus

export const zGetFalAiPostProcessingChromaticAberrationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingChromaticAberrationRequestsByRequestIdResponse =
  zSchemaPostProcessingChromaticAberrationOutput

export const zGetFalAiPostProcessingBlurRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiPostProcessingBlurRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPostProcessingBlurRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingBlurRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiPostProcessingBlurData = z.object({
  body: zSchemaPostProcessingBlurInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPostProcessingBlurResponse = zSchemaQueueStatus

export const zGetFalAiPostProcessingBlurRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingBlurRequestsByRequestIdResponse =
  zSchemaPostProcessingBlurOutput

export const zGetFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageEditingYoutubeThumbnailsData = z.object({
  body: zSchemaImageEditingYoutubeThumbnailsInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingYoutubeThumbnailsResponse =
  zSchemaQueueStatus

export const zGetFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingYoutubeThumbnailsRequestsByRequestIdResponse =
  zSchemaImageEditingYoutubeThumbnailsOutput

export const zGetFalAiTopazUpscaleImageRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiTopazUpscaleImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiTopazUpscaleImageRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiTopazUpscaleImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiTopazUpscaleImageData = z.object({
  body: zSchemaTopazUpscaleImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiTopazUpscaleImageResponse = zSchemaQueueStatus

export const zGetFalAiTopazUpscaleImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiTopazUpscaleImageRequestsByRequestIdResponse =
  zSchemaTopazUpscaleImageOutput

export const zGetFalAiImageEditingBroccoliHaircutRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingBroccoliHaircutRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingBroccoliHaircutRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingBroccoliHaircutRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageEditingBroccoliHaircutData = z.object({
  body: zSchemaImageEditingBroccoliHaircutInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingBroccoliHaircutResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingBroccoliHaircutRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingBroccoliHaircutRequestsByRequestIdResponse =
  zSchemaImageEditingBroccoliHaircutOutput

export const zGetFalAiImageEditingWojakStyleRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingWojakStyleRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingWojakStyleRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingWojakStyleRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageEditingWojakStyleData = z.object({
  body: zSchemaImageEditingWojakStyleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingWojakStyleResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingWojakStyleRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingWojakStyleRequestsByRequestIdResponse =
  zSchemaImageEditingWojakStyleOutput

export const zGetFalAiImageEditingPlushieStyleRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingPlushieStyleRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingPlushieStyleRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingPlushieStyleRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageEditingPlushieStyleData = z.object({
  body: zSchemaImageEditingPlushieStyleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingPlushieStyleResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingPlushieStyleRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingPlushieStyleRequestsByRequestIdResponse =
  zSchemaImageEditingPlushieStyleOutput

export const zGetFalAiFluxKontextLoraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxKontextLoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxKontextLoraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKontextLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxKontextLoraData = z.object({
  body: zSchemaFluxKontextLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxKontextLoraResponse = zSchemaQueueStatus

export const zGetFalAiFluxKontextLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxKontextLoraRequestsByRequestIdResponse =
  zSchemaFluxKontextLoraOutput

export const zGetFalAiFashnTryonV16RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFashnTryonV16RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFashnTryonV16RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFashnTryonV16RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFashnTryonV16Data = z.object({
  body: zSchemaFashnTryonV16Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFashnTryonV16Response = zSchemaQueueStatus

export const zGetFalAiFashnTryonV16RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFashnTryonV16RequestsByRequestIdResponse =
  zSchemaFashnTryonV16Output

export const zGetFalAiChainOfZoomRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiChainOfZoomRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiChainOfZoomRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiChainOfZoomRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiChainOfZoomData = z.object({
  body: zSchemaChainOfZoomInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiChainOfZoomResponse = zSchemaQueueStatus

export const zGetFalAiChainOfZoomRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiChainOfZoomRequestsByRequestIdResponse =
  zSchemaChainOfZoomOutput

export const zGetFalAiPasdRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiPasdRequestsByRequestIdStatusResponse = zSchemaQueueStatus

export const zPutFalAiPasdRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiPasdRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiPasdData = z.object({
  body: zSchemaPasdInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPasdResponse = zSchemaQueueStatus

export const zGetFalAiPasdRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiPasdRequestsByRequestIdResponse = zSchemaPasdOutput

export const zGetFalAiObjectRemovalBboxRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiObjectRemovalBboxRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiObjectRemovalBboxRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiObjectRemovalBboxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiObjectRemovalBboxData = z.object({
  body: zSchemaObjectRemovalBboxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiObjectRemovalBboxResponse = zSchemaQueueStatus

export const zGetFalAiObjectRemovalBboxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiObjectRemovalBboxRequestsByRequestIdResponse =
  zSchemaObjectRemovalBboxOutput

export const zGetFalAiObjectRemovalMaskRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiObjectRemovalMaskRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiObjectRemovalMaskRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiObjectRemovalMaskRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiObjectRemovalMaskData = z.object({
  body: zSchemaObjectRemovalMaskInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiObjectRemovalMaskResponse = zSchemaQueueStatus

export const zGetFalAiObjectRemovalMaskRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiObjectRemovalMaskRequestsByRequestIdResponse =
  zSchemaObjectRemovalMaskOutput

export const zGetFalAiObjectRemovalRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiObjectRemovalRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiObjectRemovalRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiObjectRemovalRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiObjectRemovalData = z.object({
  body: zSchemaObjectRemovalInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiObjectRemovalResponse = zSchemaQueueStatus

export const zGetFalAiObjectRemovalRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiObjectRemovalRequestsByRequestIdResponse =
  zSchemaObjectRemovalOutput

export const zGetFalAiRecraftVectorizeRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiRecraftVectorizeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiRecraftVectorizeRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiRecraftVectorizeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiRecraftVectorizeData = z.object({
  body: zSchemaRecraftVectorizeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiRecraftVectorizeResponse = zSchemaQueueStatus

export const zGetFalAiRecraftVectorizeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiRecraftVectorizeRequestsByRequestIdResponse =
  zSchemaRecraftVectorizeOutput

export const zGetFalAiFfmpegApiExtractFrameRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFfmpegApiExtractFrameRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFfmpegApiExtractFrameRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFfmpegApiExtractFrameRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFfmpegApiExtractFrameData = z.object({
  body: zSchemaFfmpegApiExtractFrameInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFfmpegApiExtractFrameResponse = zSchemaQueueStatus

export const zGetFalAiFfmpegApiExtractFrameRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFfmpegApiExtractFrameRequestsByRequestIdResponse =
  zSchemaFfmpegApiExtractFrameOutput

export const zGetFalAiLumaPhotonFlashModifyRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiLumaPhotonFlashModifyRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLumaPhotonFlashModifyRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiLumaPhotonFlashModifyRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLumaPhotonFlashModifyData = z.object({
  body: zSchemaLumaPhotonFlashModifyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLumaPhotonFlashModifyResponse = zSchemaQueueStatus

export const zGetFalAiLumaPhotonFlashModifyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLumaPhotonFlashModifyRequestsByRequestIdResponse =
  zSchemaLumaPhotonFlashModifyOutput

export const zGetFalAiLumaPhotonModifyRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiLumaPhotonModifyRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLumaPhotonModifyRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiLumaPhotonModifyRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLumaPhotonModifyData = z.object({
  body: zSchemaLumaPhotonModifyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLumaPhotonModifyResponse = zSchemaQueueStatus

export const zGetFalAiLumaPhotonModifyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLumaPhotonModifyRequestsByRequestIdResponse =
  zSchemaLumaPhotonModifyOutput

export const zGetFalAiImageEditingReframeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingReframeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingReframeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingReframeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImageEditingReframeData = z.object({
  body: zSchemaImageEditingReframeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingReframeResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingReframeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingReframeRequestsByRequestIdResponse =
  zSchemaImageEditingReframeOutput

export const zGetFalAiImageEditingBabyVersionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingBabyVersionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingBabyVersionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingBabyVersionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageEditingBabyVersionData = z.object({
  body: zSchemaImageEditingBabyVersionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingBabyVersionResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingBabyVersionRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingBabyVersionRequestsByRequestIdResponse =
  zSchemaImageEditingBabyVersionOutput

export const zGetFalAiLumaPhotonFlashReframeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiLumaPhotonFlashReframeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLumaPhotonFlashReframeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiLumaPhotonFlashReframeRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiLumaPhotonFlashReframeData = z.object({
  body: zSchemaLumaPhotonFlashReframeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLumaPhotonFlashReframeResponse = zSchemaQueueStatus

export const zGetFalAiLumaPhotonFlashReframeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLumaPhotonFlashReframeRequestsByRequestIdResponse =
  zSchemaLumaPhotonFlashReframeOutput

export const zGetFalAiLumaPhotonReframeRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiLumaPhotonReframeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLumaPhotonReframeRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiLumaPhotonReframeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLumaPhotonReframeData = z.object({
  body: zSchemaLumaPhotonReframeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLumaPhotonReframeResponse = zSchemaQueueStatus

export const zGetFalAiLumaPhotonReframeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLumaPhotonReframeRequestsByRequestIdResponse =
  zSchemaLumaPhotonReframeOutput

export const zGetFalAiFlux1SchnellReduxRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiFlux1SchnellReduxRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux1SchnellReduxRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1SchnellReduxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux1SchnellReduxData = z.object({
  body: zSchemaFlux1SchnellReduxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux1SchnellReduxResponse = zSchemaQueueStatus

export const zGetFalAiFlux1SchnellReduxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux1SchnellReduxRequestsByRequestIdResponse =
  zSchemaFlux1SchnellReduxOutput

export const zGetFalAiFlux1DevReduxRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux1DevReduxRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux1DevReduxRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1DevReduxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux1DevReduxData = z.object({
  body: zSchemaFlux1DevReduxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux1DevReduxResponse = zSchemaQueueStatus

export const zGetFalAiFlux1DevReduxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux1DevReduxRequestsByRequestIdResponse =
  zSchemaFlux1DevReduxOutput

export const zGetFalAiFlux1DevImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux1DevImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux1DevImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1DevImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux1DevImageToImageData = z.object({
  body: zSchemaFlux1DevImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux1DevImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiFlux1DevImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux1DevImageToImageRequestsByRequestIdResponse =
  zSchemaFlux1DevImageToImageOutput

export const zGetFalAiImageEditingTextRemovalRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingTextRemovalRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingTextRemovalRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingTextRemovalRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageEditingTextRemovalData = z.object({
  body: zSchemaImageEditingTextRemovalInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingTextRemovalResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingTextRemovalRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingTextRemovalRequestsByRequestIdResponse =
  zSchemaImageEditingTextRemovalOutput

export const zGetFalAiImageEditingPhotoRestorationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingPhotoRestorationRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingPhotoRestorationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingPhotoRestorationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageEditingPhotoRestorationData = z.object({
  body: zSchemaImageEditingPhotoRestorationInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingPhotoRestorationResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingPhotoRestorationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingPhotoRestorationRequestsByRequestIdResponse =
  zSchemaImageEditingPhotoRestorationOutput

export const zGetFalAiImageEditingWeatherEffectRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingWeatherEffectRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingWeatherEffectRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingWeatherEffectRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageEditingWeatherEffectData = z.object({
  body: zSchemaImageEditingWeatherEffectInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingWeatherEffectResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingWeatherEffectRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingWeatherEffectRequestsByRequestIdResponse =
  zSchemaImageEditingWeatherEffectOutput

export const zGetFalAiImageEditingTimeOfDayRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingTimeOfDayRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingTimeOfDayRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingTimeOfDayRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImageEditingTimeOfDayData = z.object({
  body: zSchemaImageEditingTimeOfDayInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingTimeOfDayResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingTimeOfDayRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingTimeOfDayRequestsByRequestIdResponse =
  zSchemaImageEditingTimeOfDayOutput

export const zGetFalAiImageEditingStyleTransferRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingStyleTransferRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingStyleTransferRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingStyleTransferRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageEditingStyleTransferData = z.object({
  body: zSchemaImageEditingStyleTransferInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingStyleTransferResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingStyleTransferRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingStyleTransferRequestsByRequestIdResponse =
  zSchemaImageEditingStyleTransferOutput

export const zGetFalAiImageEditingSceneCompositionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingSceneCompositionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingSceneCompositionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingSceneCompositionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageEditingSceneCompositionData = z.object({
  body: zSchemaImageEditingSceneCompositionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingSceneCompositionResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingSceneCompositionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingSceneCompositionRequestsByRequestIdResponse =
  zSchemaImageEditingSceneCompositionOutput

export const zGetFalAiImageEditingProfessionalPhotoRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingProfessionalPhotoRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingProfessionalPhotoRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingProfessionalPhotoRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageEditingProfessionalPhotoData = z.object({
  body: zSchemaImageEditingProfessionalPhotoInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingProfessionalPhotoResponse =
  zSchemaQueueStatus

export const zGetFalAiImageEditingProfessionalPhotoRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingProfessionalPhotoRequestsByRequestIdResponse =
  zSchemaImageEditingProfessionalPhotoOutput

export const zGetFalAiImageEditingObjectRemovalRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingObjectRemovalRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingObjectRemovalRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingObjectRemovalRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageEditingObjectRemovalData = z.object({
  body: zSchemaImageEditingObjectRemovalInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingObjectRemovalResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingObjectRemovalRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingObjectRemovalRequestsByRequestIdResponse =
  zSchemaImageEditingObjectRemovalOutput

export const zGetFalAiImageEditingHairChangeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingHairChangeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingHairChangeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingHairChangeRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageEditingHairChangeData = z.object({
  body: zSchemaImageEditingHairChangeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingHairChangeResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingHairChangeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingHairChangeRequestsByRequestIdResponse =
  zSchemaImageEditingHairChangeOutput

export const zGetFalAiImageEditingFaceEnhancementRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingFaceEnhancementRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingFaceEnhancementRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingFaceEnhancementRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageEditingFaceEnhancementData = z.object({
  body: zSchemaImageEditingFaceEnhancementInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingFaceEnhancementResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingFaceEnhancementRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingFaceEnhancementRequestsByRequestIdResponse =
  zSchemaImageEditingFaceEnhancementOutput

export const zGetFalAiImageEditingExpressionChangeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingExpressionChangeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingExpressionChangeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingExpressionChangeRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageEditingExpressionChangeData = z.object({
  body: zSchemaImageEditingExpressionChangeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingExpressionChangeResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingExpressionChangeRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingExpressionChangeRequestsByRequestIdResponse =
  zSchemaImageEditingExpressionChangeOutput

export const zGetFalAiImageEditingColorCorrectionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingColorCorrectionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingColorCorrectionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingColorCorrectionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageEditingColorCorrectionData = z.object({
  body: zSchemaImageEditingColorCorrectionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingColorCorrectionResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingColorCorrectionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingColorCorrectionRequestsByRequestIdResponse =
  zSchemaImageEditingColorCorrectionOutput

export const zGetFalAiImageEditingCartoonifyRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingCartoonifyRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingCartoonifyRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingCartoonifyRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageEditingCartoonifyData = z.object({
  body: zSchemaImageEditingCartoonifyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingCartoonifyResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingCartoonifyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingCartoonifyRequestsByRequestIdResponse =
  zSchemaImageEditingCartoonifyOutput

export const zGetFalAiImageEditingBackgroundChangeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingBackgroundChangeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingBackgroundChangeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingBackgroundChangeRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageEditingBackgroundChangeData = z.object({
  body: zSchemaImageEditingBackgroundChangeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingBackgroundChangeResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingBackgroundChangeRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingBackgroundChangeRequestsByRequestIdResponse =
  zSchemaImageEditingBackgroundChangeOutput

export const zGetFalAiImageEditingAgeProgressionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageEditingAgeProgressionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageEditingAgeProgressionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageEditingAgeProgressionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageEditingAgeProgressionData = z.object({
  body: zSchemaImageEditingAgeProgressionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageEditingAgeProgressionResponse = zSchemaQueueStatus

export const zGetFalAiImageEditingAgeProgressionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImageEditingAgeProgressionRequestsByRequestIdResponse =
  zSchemaImageEditingAgeProgressionOutput

export const zGetFalAiFluxProKontextMaxMultiRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxProKontextMaxMultiRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxProKontextMaxMultiRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProKontextMaxMultiRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFluxProKontextMaxMultiData = z.object({
  body: zSchemaFluxProKontextMaxMultiInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxProKontextMaxMultiResponse = zSchemaQueueStatus

export const zGetFalAiFluxProKontextMaxMultiRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxProKontextMaxMultiRequestsByRequestIdResponse =
  zSchemaFluxProKontextMaxMultiOutput

export const zGetFalAiFluxProKontextMultiRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxProKontextMultiRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxProKontextMultiRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProKontextMultiRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxProKontextMultiData = z.object({
  body: zSchemaFluxProKontextMultiInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxProKontextMultiResponse = zSchemaQueueStatus

export const zGetFalAiFluxProKontextMultiRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxProKontextMultiRequestsByRequestIdResponse =
  zSchemaFluxProKontextMultiOutput

export const zGetFalAiFluxProKontextMaxRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiFluxProKontextMaxRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxProKontextMaxRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProKontextMaxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxProKontextMaxData = z.object({
  body: zSchemaFluxProKontextMaxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxProKontextMaxResponse = zSchemaQueueStatus

export const zGetFalAiFluxProKontextMaxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxProKontextMaxRequestsByRequestIdResponse =
  zSchemaFluxProKontextMaxOutput

export const zGetFalAiFluxKontextDevRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxKontextDevRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxKontextDevRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKontextDevRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxKontextDevData = z.object({
  body: zSchemaFluxKontextDevInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxKontextDevResponse = zSchemaQueueStatus

export const zGetFalAiFluxKontextDevRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxKontextDevRequestsByRequestIdResponse =
  zSchemaFluxKontextDevOutput

export const zGetFalAiBagelEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiBagelEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBagelEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiBagelEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiBagelEditData = z.object({
  body: zSchemaBagelEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBagelEditResponse = zSchemaQueueStatus

export const zGetFalAiBagelEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiBagelEditRequestsByRequestIdResponse =
  zSchemaBagelEditOutput

export const zGetSmoretalkAiRembgEnhanceRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetSmoretalkAiRembgEnhanceRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutSmoretalkAiRembgEnhanceRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutSmoretalkAiRembgEnhanceRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostSmoretalkAiRembgEnhanceData = z.object({
  body: zSchemaRembgEnhanceInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostSmoretalkAiRembgEnhanceResponse = zSchemaQueueStatus

export const zGetSmoretalkAiRembgEnhanceRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetSmoretalkAiRembgEnhanceRequestsByRequestIdResponse =
  zSchemaRembgEnhanceOutput

export const zGetFalAiRecraftUpscaleCreativeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiRecraftUpscaleCreativeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiRecraftUpscaleCreativeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiRecraftUpscaleCreativeRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiRecraftUpscaleCreativeData = z.object({
  body: zSchemaRecraftUpscaleCreativeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiRecraftUpscaleCreativeResponse = zSchemaQueueStatus

export const zGetFalAiRecraftUpscaleCreativeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiRecraftUpscaleCreativeRequestsByRequestIdResponse =
  zSchemaRecraftUpscaleCreativeOutput

export const zGetFalAiRecraftUpscaleCrispRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiRecraftUpscaleCrispRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiRecraftUpscaleCrispRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiRecraftUpscaleCrispRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiRecraftUpscaleCrispData = z.object({
  body: zSchemaRecraftUpscaleCrispInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiRecraftUpscaleCrispResponse = zSchemaQueueStatus

export const zGetFalAiRecraftUpscaleCrispRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiRecraftUpscaleCrispRequestsByRequestIdResponse =
  zSchemaRecraftUpscaleCrispOutput

export const zGetFalAiRecraftV3ImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiRecraftV3ImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiRecraftV3ImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiRecraftV3ImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiRecraftV3ImageToImageData = z.object({
  body: zSchemaRecraftV3ImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiRecraftV3ImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiRecraftV3ImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiRecraftV3ImageToImageRequestsByRequestIdResponse =
  zSchemaRecraftV3ImageToImageOutput

export const zGetFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiMinimaxImage01SubjectReferenceData = z.object({
  body: zSchemaMinimaxImage01SubjectReferenceInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiMinimaxImage01SubjectReferenceResponse =
  zSchemaQueueStatus

export const zGetFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiMinimaxImage01SubjectReferenceRequestsByRequestIdResponse =
  zSchemaMinimaxImage01SubjectReferenceOutput

export const zGetFalAiHidreamI1FullImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiHidreamI1FullImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHidreamI1FullImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiHidreamI1FullImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiHidreamI1FullImageToImageData = z.object({
  body: zSchemaHidreamI1FullImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHidreamI1FullImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiHidreamI1FullImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiHidreamI1FullImageToImageRequestsByRequestIdResponse =
  zSchemaHidreamI1FullImageToImageOutput

export const zGetFalAiIdeogramV3ReframeRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiIdeogramV3ReframeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIdeogramV3ReframeRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV3ReframeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIdeogramV3ReframeData = z.object({
  body: zSchemaIdeogramV3ReframeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIdeogramV3ReframeResponse = zSchemaQueueStatus

export const zGetFalAiIdeogramV3ReframeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV3ReframeRequestsByRequestIdResponse =
  zSchemaIdeogramV3ReframeOutput

export const zGetFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiIdeogramV3ReplaceBackgroundData = z.object({
  body: zSchemaIdeogramV3ReplaceBackgroundInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIdeogramV3ReplaceBackgroundResponse = zSchemaQueueStatus

export const zGetFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV3ReplaceBackgroundRequestsByRequestIdResponse =
  zSchemaIdeogramV3ReplaceBackgroundOutput

export const zGetFalAiIdeogramV3RemixRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiIdeogramV3RemixRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIdeogramV3RemixRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV3RemixRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIdeogramV3RemixData = z.object({
  body: zSchemaIdeogramV3RemixInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIdeogramV3RemixResponse = zSchemaQueueStatus

export const zGetFalAiIdeogramV3RemixRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV3RemixRequestsByRequestIdResponse =
  zSchemaIdeogramV3RemixOutput

export const zGetFalAiIdeogramV3EditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiIdeogramV3EditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIdeogramV3EditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV3EditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIdeogramV3EditData = z.object({
  body: zSchemaIdeogramV3EditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIdeogramV3EditResponse = zSchemaQueueStatus

export const zGetFalAiIdeogramV3EditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV3EditRequestsByRequestIdResponse =
  zSchemaIdeogramV3EditOutput

export const zGetFalAiStep1xEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiStep1xEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiStep1xEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiStep1xEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiStep1xEditData = z.object({
  body: zSchemaStep1xEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiStep1xEditResponse = zSchemaQueueStatus

export const zGetFalAiStep1xEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiStep1xEditRequestsByRequestIdResponse =
  zSchemaStep1xEditOutput

export const zGetFalAiImage2SvgRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiImage2SvgRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImage2SvgRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiImage2SvgRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImage2SvgData = z.object({
  body: zSchemaImage2SvgInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImage2SvgResponse = zSchemaQueueStatus

export const zGetFalAiImage2SvgRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImage2SvgRequestsByRequestIdResponse =
  zSchemaImage2SvgOutput

export const zGetFalAiUnoRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiUnoRequestsByRequestIdStatusResponse = zSchemaQueueStatus

export const zPutFalAiUnoRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiUnoRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiUnoData = z.object({
  body: zSchemaUnoInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiUnoResponse = zSchemaQueueStatus

export const zGetFalAiUnoRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiUnoRequestsByRequestIdResponse = zSchemaUnoOutput

export const zGetFalAiGptImage1EditImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiGptImage1EditImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiGptImage1EditImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiGptImage1EditImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiGptImage1EditImageData = z.object({
  body: zSchemaGptImage1EditImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiGptImage1EditImageResponse = zSchemaQueueStatus

export const zGetFalAiGptImage1EditImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiGptImage1EditImageRequestsByRequestIdResponse =
  zSchemaGptImage1EditImageOutput

export const zGetRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostRundiffusionFalJuggernautFluxLoraInpaintingData = z.object({
  body: zSchemaJuggernautFluxLoraInpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostRundiffusionFalJuggernautFluxLoraInpaintingResponse =
  zSchemaQueueStatus

export const zGetRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetRundiffusionFalJuggernautFluxLoraInpaintingRequestsByRequestIdResponse =
  zSchemaJuggernautFluxLoraInpaintingOutput

export const zGetFalAiFashnTryonV15RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFashnTryonV15RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFashnTryonV15RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFashnTryonV15RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFashnTryonV15Data = z.object({
  body: zSchemaFashnTryonV15Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFashnTryonV15Response = zSchemaQueueStatus

export const zGetFalAiFashnTryonV15RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFashnTryonV15RequestsByRequestIdResponse =
  zSchemaFashnTryonV15Output

export const zGetFalAiPlushifyRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiPlushifyRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPlushifyRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiPlushifyRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiPlushifyData = z.object({
  body: zSchemaPlushifyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPlushifyResponse = zSchemaQueueStatus

export const zGetFalAiPlushifyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiPlushifyRequestsByRequestIdResponse =
  zSchemaPlushifyOutput

export const zGetFalAiInstantCharacterRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiInstantCharacterRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiInstantCharacterRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiInstantCharacterRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiInstantCharacterData = z.object({
  body: zSchemaInstantCharacterInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiInstantCharacterResponse = zSchemaQueueStatus

export const zGetFalAiInstantCharacterRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiInstantCharacterRequestsByRequestIdResponse =
  zSchemaInstantCharacterOutput

export const zGetFalAiCartoonifyRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiCartoonifyRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiCartoonifyRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiCartoonifyRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiCartoonifyData = z.object({
  body: zSchemaCartoonifyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiCartoonifyResponse = zSchemaQueueStatus

export const zGetFalAiCartoonifyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiCartoonifyRequestsByRequestIdResponse =
  zSchemaCartoonifyOutput

export const zGetFalAiFinegrainEraserMaskRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFinegrainEraserMaskRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFinegrainEraserMaskRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFinegrainEraserMaskRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFinegrainEraserMaskData = z.object({
  body: zSchemaFinegrainEraserMaskInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFinegrainEraserMaskResponse = zSchemaQueueStatus

export const zGetFalAiFinegrainEraserMaskRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFinegrainEraserMaskRequestsByRequestIdResponse =
  zSchemaFinegrainEraserMaskOutput

export const zGetFalAiFinegrainEraserBboxRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFinegrainEraserBboxRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFinegrainEraserBboxRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFinegrainEraserBboxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFinegrainEraserBboxData = z.object({
  body: zSchemaFinegrainEraserBboxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFinegrainEraserBboxResponse = zSchemaQueueStatus

export const zGetFalAiFinegrainEraserBboxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFinegrainEraserBboxRequestsByRequestIdResponse =
  zSchemaFinegrainEraserBboxOutput

export const zGetFalAiFinegrainEraserRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFinegrainEraserRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFinegrainEraserRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFinegrainEraserRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFinegrainEraserData = z.object({
  body: zSchemaFinegrainEraserInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFinegrainEraserResponse = zSchemaQueueStatus

export const zGetFalAiFinegrainEraserRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFinegrainEraserRequestsByRequestIdResponse =
  zSchemaFinegrainEraserOutput

export const zGetFalAiStarVectorRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiStarVectorRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiStarVectorRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiStarVectorRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiStarVectorData = z.object({
  body: zSchemaStarVectorInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiStarVectorResponse = zSchemaQueueStatus

export const zGetFalAiStarVectorRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiStarVectorRequestsByRequestIdResponse =
  zSchemaStarVectorOutput

export const zGetFalAiGhiblifyRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiGhiblifyRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiGhiblifyRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiGhiblifyRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiGhiblifyData = z.object({
  body: zSchemaGhiblifyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiGhiblifyResponse = zSchemaQueueStatus

export const zGetFalAiGhiblifyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiGhiblifyRequestsByRequestIdResponse =
  zSchemaGhiblifyOutput

export const zGetFalAiTheraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiTheraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiTheraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiTheraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiTheraData = z.object({
  body: zSchemaTheraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiTheraResponse = zSchemaQueueStatus

export const zGetFalAiTheraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiTheraRequestsByRequestIdResponse = zSchemaTheraOutput

export const zGetFalAiMixDehazeNetRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiMixDehazeNetRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiMixDehazeNetRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiMixDehazeNetRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiMixDehazeNetData = z.object({
  body: zSchemaMixDehazeNetInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiMixDehazeNetResponse = zSchemaQueueStatus

export const zGetFalAiMixDehazeNetRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiMixDehazeNetRequestsByRequestIdResponse =
  zSchemaMixDehazeNetOutput

export const zGetFalAiGeminiFlashEditMultiRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiGeminiFlashEditMultiRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiGeminiFlashEditMultiRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiGeminiFlashEditMultiRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiGeminiFlashEditMultiData = z.object({
  body: zSchemaGeminiFlashEditMultiInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiGeminiFlashEditMultiResponse = zSchemaQueueStatus

export const zGetFalAiGeminiFlashEditMultiRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiGeminiFlashEditMultiRequestsByRequestIdResponse =
  zSchemaGeminiFlashEditMultiOutput

export const zGetFalAiGeminiFlashEditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiGeminiFlashEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiGeminiFlashEditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiGeminiFlashEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiGeminiFlashEditData = z.object({
  body: zSchemaGeminiFlashEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiGeminiFlashEditResponse = zSchemaQueueStatus

export const zGetFalAiGeminiFlashEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiGeminiFlashEditRequestsByRequestIdResponse =
  zSchemaGeminiFlashEditOutput

export const zGetFalAiInvisibleWatermarkRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiInvisibleWatermarkRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiInvisibleWatermarkRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiInvisibleWatermarkRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiInvisibleWatermarkData = z.object({
  body: zSchemaInvisibleWatermarkInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiInvisibleWatermarkResponse = zSchemaQueueStatus

export const zGetFalAiInvisibleWatermarkRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiInvisibleWatermarkRequestsByRequestIdResponse =
  zSchemaInvisibleWatermarkOutput

export const zGetRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostRundiffusionFalJuggernautFluxProImageToImageData = z.object({
  body: zSchemaJuggernautFluxProImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostRundiffusionFalJuggernautFluxProImageToImageResponse =
  zSchemaQueueStatus

export const zGetRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetRundiffusionFalJuggernautFluxProImageToImageRequestsByRequestIdResponse =
  zSchemaJuggernautFluxProImageToImageOutput

export const zGetRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostRundiffusionFalJuggernautFluxBaseImageToImageData = z.object({
  body: zSchemaJuggernautFluxBaseImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostRundiffusionFalJuggernautFluxBaseImageToImageResponse =
  zSchemaQueueStatus

export const zGetRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetRundiffusionFalJuggernautFluxBaseImageToImageRequestsByRequestIdResponse =
  zSchemaJuggernautFluxBaseImageToImageOutput

export const zGetFalAiDocresDewarpRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiDocresDewarpRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiDocresDewarpRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiDocresDewarpRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiDocresDewarpData = z.object({
  body: zSchemaDocresDewarpInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiDocresDewarpResponse = zSchemaQueueStatus

export const zGetFalAiDocresDewarpRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiDocresDewarpRequestsByRequestIdResponse =
  zSchemaDocresDewarpOutput

export const zGetFalAiDocresRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiDocresRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiDocresRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiDocresRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiDocresData = z.object({
  body: zSchemaDocresInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiDocresResponse = zSchemaQueueStatus

export const zGetFalAiDocresRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiDocresRequestsByRequestIdResponse = zSchemaDocresOutput

export const zGetFalAiSwin2SrRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiSwin2SrRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSwin2SrRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiSwin2SrRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSwin2SrData = z.object({
  body: zSchemaSwin2SrInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSwin2SrResponse = zSchemaQueueStatus

export const zGetFalAiSwin2SrRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSwin2SrRequestsByRequestIdResponse = zSchemaSwin2SrOutput

export const zGetFalAiIdeogramV2aRemixRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2aRemixRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIdeogramV2aRemixRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2aRemixRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIdeogramV2aRemixData = z.object({
  body: zSchemaIdeogramV2aRemixInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2aRemixResponse = zSchemaQueueStatus

export const zGetFalAiIdeogramV2aRemixRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2aRemixRequestsByRequestIdResponse =
  zSchemaIdeogramV2aRemixOutput

export const zGetFalAiIdeogramV2aTurboRemixRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2aTurboRemixRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIdeogramV2aTurboRemixRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2aTurboRemixRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIdeogramV2aTurboRemixData = z.object({
  body: zSchemaIdeogramV2aTurboRemixInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2aTurboRemixResponse = zSchemaQueueStatus

export const zGetFalAiIdeogramV2aTurboRemixRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2aTurboRemixRequestsByRequestIdResponse =
  zSchemaIdeogramV2aTurboRemixOutput

export const zGetFalAiEvfSamRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiEvfSamRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiEvfSamRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiEvfSamRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiEvfSamData = z.object({
  body: zSchemaEvfSamInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiEvfSamResponse = zSchemaQueueStatus

export const zGetFalAiEvfSamRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiEvfSamRequestsByRequestIdResponse = zSchemaEvfSamOutput

export const zGetFalAiDdcolorRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiDdcolorRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiDdcolorRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiDdcolorRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiDdcolorData = z.object({
  body: zSchemaDdcolorInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiDdcolorResponse = zSchemaQueueStatus

export const zGetFalAiDdcolorRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiDdcolorRequestsByRequestIdResponse = zSchemaDdcolorOutput

export const zGetFalAiSam2AutoSegmentRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiSam2AutoSegmentRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSam2AutoSegmentRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiSam2AutoSegmentRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSam2AutoSegmentData = z.object({
  body: zSchemaSam2AutoSegmentInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSam2AutoSegmentResponse = zSchemaQueueStatus

export const zGetFalAiSam2AutoSegmentRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSam2AutoSegmentRequestsByRequestIdResponse =
  zSchemaSam2AutoSegmentOutput

export const zGetFalAiDrctSuperResolutionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiDrctSuperResolutionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiDrctSuperResolutionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiDrctSuperResolutionRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiDrctSuperResolutionData = z.object({
  body: zSchemaDrctSuperResolutionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiDrctSuperResolutionResponse = zSchemaQueueStatus

export const zGetFalAiDrctSuperResolutionRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiDrctSuperResolutionRequestsByRequestIdResponse =
  zSchemaDrctSuperResolutionOutput

export const zGetFalAiNafnetDeblurRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiNafnetDeblurRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiNafnetDeblurRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiNafnetDeblurRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiNafnetDeblurData = z.object({
  body: zSchemaNafnetDeblurInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiNafnetDeblurResponse = zSchemaQueueStatus

export const zGetFalAiNafnetDeblurRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiNafnetDeblurRequestsByRequestIdResponse =
  zSchemaNafnetDeblurOutput

export const zGetFalAiNafnetDenoiseRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiNafnetDenoiseRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiNafnetDenoiseRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiNafnetDenoiseRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiNafnetDenoiseData = z.object({
  body: zSchemaNafnetDenoiseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiNafnetDenoiseResponse = zSchemaQueueStatus

export const zGetFalAiNafnetDenoiseRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiNafnetDenoiseRequestsByRequestIdResponse =
  zSchemaNafnetDenoiseOutput

export const zGetFalAiPostProcessingRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiPostProcessingRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPostProcessingRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiPostProcessingRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiPostProcessingData = z.object({
  body: zSchemaPostProcessingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPostProcessingResponse = zSchemaQueueStatus

export const zGetFalAiPostProcessingRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiPostProcessingRequestsByRequestIdResponse =
  zSchemaPostProcessingOutput

export const zGetFalAiFloweditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFloweditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFloweditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFloweditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFloweditData = z.object({
  body: zSchemaFloweditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFloweditResponse = zSchemaQueueStatus

export const zGetFalAiFloweditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFloweditRequestsByRequestIdResponse =
  zSchemaFloweditOutput

export const zGetFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFluxControlLoraDepthImageToImageData = z.object({
  body: zSchemaFluxControlLoraDepthImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxControlLoraDepthImageToImageResponse =
  zSchemaQueueStatus

export const zGetFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFluxControlLoraDepthImageToImageRequestsByRequestIdResponse =
  zSchemaFluxControlLoraDepthImageToImageOutput

export const zGetFalAiBenV2ImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiBenV2ImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBenV2ImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiBenV2ImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiBenV2ImageData = z.object({
  body: zSchemaBenV2ImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBenV2ImageResponse = zSchemaQueueStatus

export const zGetFalAiBenV2ImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiBenV2ImageRequestsByRequestIdResponse =
  zSchemaBenV2ImageOutput

export const zGetFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFluxControlLoraCannyImageToImageData = z.object({
  body: zSchemaFluxControlLoraCannyImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxControlLoraCannyImageToImageResponse =
  zSchemaQueueStatus

export const zGetFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFluxControlLoraCannyImageToImageRequestsByRequestIdResponse =
  zSchemaFluxControlLoraCannyImageToImageOutput

export const zGetFalAiIdeogramUpscaleRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiIdeogramUpscaleRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIdeogramUpscaleRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramUpscaleRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIdeogramUpscaleData = z.object({
  body: zSchemaIdeogramUpscaleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIdeogramUpscaleResponse = zSchemaQueueStatus

export const zGetFalAiIdeogramUpscaleRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramUpscaleRequestsByRequestIdResponse =
  zSchemaIdeogramUpscaleOutput

export const zGetFalAiCodeformerRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiCodeformerRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiCodeformerRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiCodeformerRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiCodeformerData = z.object({
  body: zSchemaCodeformerInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiCodeformerResponse = zSchemaQueueStatus

export const zGetFalAiCodeformerRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiCodeformerRequestsByRequestIdResponse =
  zSchemaCodeformerOutput

export const zGetFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiKlingV15KolorsVirtualTryOnData = z.object({
  body: zSchemaKlingV15KolorsVirtualTryOnInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKlingV15KolorsVirtualTryOnResponse = zSchemaQueueStatus

export const zGetFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiKlingV15KolorsVirtualTryOnRequestsByRequestIdResponse =
  zSchemaKlingV15KolorsVirtualTryOnOutput

export const zGetFalAiFluxLoraCannyRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxLoraCannyRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxLoraCannyRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxLoraCannyRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxLoraCannyData = z.object({
  body: zSchemaFluxLoraCannyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxLoraCannyResponse = zSchemaQueueStatus

export const zGetFalAiFluxLoraCannyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxLoraCannyRequestsByRequestIdResponse =
  zSchemaFluxLoraCannyOutput

export const zGetFalAiFluxProV1FillFinetunedRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxProV1FillFinetunedRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxProV1FillFinetunedRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProV1FillFinetunedRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFluxProV1FillFinetunedData = z.object({
  body: zSchemaFluxProV1FillFinetunedInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxProV1FillFinetunedResponse = zSchemaQueueStatus

export const zGetFalAiFluxProV1FillFinetunedRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxProV1FillFinetunedRequestsByRequestIdResponse =
  zSchemaFluxProV1FillFinetunedOutput

export const zGetFalAiMoondreamNextDetectionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiMoondreamNextDetectionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiMoondreamNextDetectionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiMoondreamNextDetectionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiMoondreamNextDetectionData = z.object({
  body: zSchemaMoondreamNextDetectionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiMoondreamNextDetectionResponse = zSchemaQueueStatus

export const zGetFalAiMoondreamNextDetectionRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiMoondreamNextDetectionRequestsByRequestIdResponse =
  zSchemaMoondreamNextDetectionOutput

export const zGetFalAiBriaExpandRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiBriaExpandRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBriaExpandRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaExpandRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiBriaExpandData = z.object({
  body: zSchemaBriaExpandInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBriaExpandResponse = zSchemaQueueStatus

export const zGetFalAiBriaExpandRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiBriaExpandRequestsByRequestIdResponse =
  zSchemaBriaExpandOutput

export const zGetFalAiBriaGenfillRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiBriaGenfillRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBriaGenfillRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaGenfillRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiBriaGenfillData = z.object({
  body: zSchemaBriaGenfillInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBriaGenfillResponse = zSchemaQueueStatus

export const zGetFalAiBriaGenfillRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiBriaGenfillRequestsByRequestIdResponse =
  zSchemaBriaGenfillOutput

export const zGetFalAiFluxLoraFillRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxLoraFillRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxLoraFillRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxLoraFillRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxLoraFillData = z.object({
  body: zSchemaFluxLoraFillInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxLoraFillResponse = zSchemaQueueStatus

export const zGetFalAiFluxLoraFillRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxLoraFillRequestsByRequestIdResponse =
  zSchemaFluxLoraFillOutput

export const zGetFalAiBriaBackgroundReplaceRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiBriaBackgroundReplaceRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBriaBackgroundReplaceRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaBackgroundReplaceRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiBriaBackgroundReplaceData = z.object({
  body: zSchemaBriaBackgroundReplaceInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBriaBackgroundReplaceResponse = zSchemaQueueStatus

export const zGetFalAiBriaBackgroundReplaceRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiBriaBackgroundReplaceRequestsByRequestIdResponse =
  zSchemaBriaBackgroundReplaceOutput

export const zGetFalAiBriaEraserRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiBriaEraserRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBriaEraserRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaEraserRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiBriaEraserData = z.object({
  body: zSchemaBriaEraserInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBriaEraserResponse = zSchemaQueueStatus

export const zGetFalAiBriaEraserRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiBriaEraserRequestsByRequestIdResponse =
  zSchemaBriaEraserOutput

export const zGetFalAiBriaProductShotRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiBriaProductShotRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBriaProductShotRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaProductShotRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiBriaProductShotData = z.object({
  body: zSchemaBriaProductShotInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBriaProductShotResponse = zSchemaQueueStatus

export const zGetFalAiBriaProductShotRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiBriaProductShotRequestsByRequestIdResponse =
  zSchemaBriaProductShotOutput

export const zGetFalAiBriaBackgroundRemoveRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiBriaBackgroundRemoveRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBriaBackgroundRemoveRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaBackgroundRemoveRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiBriaBackgroundRemoveData = z.object({
  body: zSchemaBriaBackgroundRemoveInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBriaBackgroundRemoveResponse = zSchemaQueueStatus

export const zGetFalAiBriaBackgroundRemoveRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiBriaBackgroundRemoveRequestsByRequestIdResponse =
  zSchemaBriaBackgroundRemoveOutput

export const zGetFalAiCatVtonRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiCatVtonRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiCatVtonRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiCatVtonRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiCatVtonData = z.object({
  body: zSchemaCatVtonInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiCatVtonResponse = zSchemaQueueStatus

export const zGetFalAiCatVtonRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiCatVtonRequestsByRequestIdResponse = zSchemaCatVtonOutput

export const zGetFalAiLeffaPoseTransferRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiLeffaPoseTransferRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLeffaPoseTransferRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiLeffaPoseTransferRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLeffaPoseTransferData = z.object({
  body: zSchemaLeffaPoseTransferInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLeffaPoseTransferResponse = zSchemaQueueStatus

export const zGetFalAiLeffaPoseTransferRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLeffaPoseTransferRequestsByRequestIdResponse =
  zSchemaLeffaPoseTransferOutput

export const zGetFalAiLeffaVirtualTryonRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiLeffaVirtualTryonRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLeffaVirtualTryonRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiLeffaVirtualTryonRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLeffaVirtualTryonData = z.object({
  body: zSchemaLeffaVirtualTryonInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLeffaVirtualTryonResponse = zSchemaQueueStatus

export const zGetFalAiLeffaVirtualTryonRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLeffaVirtualTryonRequestsByRequestIdResponse =
  zSchemaLeffaVirtualTryonOutput

export const zGetFalAiIdeogramV2EditRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2EditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIdeogramV2EditRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2EditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIdeogramV2EditData = z.object({
  body: zSchemaIdeogramV2EditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2EditResponse = zSchemaQueueStatus

export const zGetFalAiIdeogramV2EditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2EditRequestsByRequestIdResponse =
  zSchemaIdeogramV2EditOutput

export const zGetFalAiIdeogramV2TurboEditRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2TurboEditRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIdeogramV2TurboEditRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2TurboEditRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIdeogramV2TurboEditData = z.object({
  body: zSchemaIdeogramV2TurboEditInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2TurboEditResponse = zSchemaQueueStatus

export const zGetFalAiIdeogramV2TurboEditRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2TurboEditRequestsByRequestIdResponse =
  zSchemaIdeogramV2TurboEditOutput

export const zGetFalAiIdeogramV2TurboRemixRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2TurboRemixRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIdeogramV2TurboRemixRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2TurboRemixRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIdeogramV2TurboRemixData = z.object({
  body: zSchemaIdeogramV2TurboRemixInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2TurboRemixResponse = zSchemaQueueStatus

export const zGetFalAiIdeogramV2TurboRemixRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2TurboRemixRequestsByRequestIdResponse =
  zSchemaIdeogramV2TurboRemixOutput

export const zGetFalAiIdeogramV2RemixRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2RemixRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIdeogramV2RemixRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2RemixRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIdeogramV2RemixData = z.object({
  body: zSchemaIdeogramV2RemixInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2RemixResponse = zSchemaQueueStatus

export const zGetFalAiIdeogramV2RemixRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2RemixRequestsByRequestIdResponse =
  zSchemaIdeogramV2RemixOutput

export const zGetFalAiFluxSchnellReduxRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxSchnellReduxRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxSchnellReduxRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxSchnellReduxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxSchnellReduxData = z.object({
  body: zSchemaFluxSchnellReduxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxSchnellReduxResponse = zSchemaQueueStatus

export const zGetFalAiFluxSchnellReduxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxSchnellReduxRequestsByRequestIdResponse =
  zSchemaFluxSchnellReduxOutput

export const zGetFalAiFluxProV11ReduxRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxProV11ReduxRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxProV11ReduxRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProV11ReduxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxProV11ReduxData = z.object({
  body: zSchemaFluxProV11ReduxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxProV11ReduxResponse = zSchemaQueueStatus

export const zGetFalAiFluxProV11ReduxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxProV11ReduxRequestsByRequestIdResponse =
  zSchemaFluxProV11ReduxOutput

export const zGetFalAiFluxDevReduxRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxDevReduxRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxDevReduxRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxDevReduxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxDevReduxData = z.object({
  body: zSchemaFluxDevReduxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxDevReduxResponse = zSchemaQueueStatus

export const zGetFalAiFluxDevReduxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxDevReduxRequestsByRequestIdResponse =
  zSchemaFluxDevReduxOutput

export const zGetFalAiFluxProV11UltraReduxRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxProV11UltraReduxRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxProV11UltraReduxRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProV11UltraReduxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxProV11UltraReduxData = z.object({
  body: zSchemaFluxProV11UltraReduxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxProV11UltraReduxResponse = zSchemaQueueStatus

export const zGetFalAiFluxProV11UltraReduxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxProV11UltraReduxRequestsByRequestIdResponse =
  zSchemaFluxProV11UltraReduxOutput

export const zGetFalAiFluxLoraDepthRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxLoraDepthRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxLoraDepthRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxLoraDepthRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxLoraDepthData = z.object({
  body: zSchemaFluxLoraDepthInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxLoraDepthResponse = zSchemaQueueStatus

export const zGetFalAiFluxLoraDepthRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxLoraDepthRequestsByRequestIdResponse =
  zSchemaFluxLoraDepthOutput

export const zGetFalAiFluxProV1FillRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxProV1FillRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxProV1FillRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProV1FillRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxProV1FillData = z.object({
  body: zSchemaFluxProV1FillInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxProV1FillResponse = zSchemaQueueStatus

export const zGetFalAiFluxProV1FillRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxProV1FillRequestsByRequestIdResponse =
  zSchemaFluxProV1FillOutput

export const zGetFalAiKolorsImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiKolorsImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKolorsImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiKolorsImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKolorsImageToImageData = z.object({
  body: zSchemaKolorsImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKolorsImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiKolorsImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKolorsImageToImageRequestsByRequestIdResponse =
  zSchemaKolorsImageToImageOutput

export const zGetFalAiIclightV2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiIclightV2RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIclightV2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiIclightV2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIclightV2Data = z.object({
  body: zSchemaIclightV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIclightV2Response = zSchemaQueueStatus

export const zGetFalAiIclightV2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIclightV2RequestsByRequestIdResponse =
  zSchemaIclightV2Output

export const zGetFalAiFluxDifferentialDiffusionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxDifferentialDiffusionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxDifferentialDiffusionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxDifferentialDiffusionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFluxDifferentialDiffusionData = z.object({
  body: zSchemaFluxDifferentialDiffusionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxDifferentialDiffusionResponse = zSchemaQueueStatus

export const zGetFalAiFluxDifferentialDiffusionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFluxDifferentialDiffusionRequestsByRequestIdResponse =
  zSchemaFluxDifferentialDiffusionOutput

export const zGetFalAiFluxPulidRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxPulidRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxPulidRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxPulidRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxPulidData = z.object({
  body: zSchemaFluxPulidInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxPulidResponse = zSchemaQueueStatus

export const zGetFalAiFluxPulidRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxPulidRequestsByRequestIdResponse =
  zSchemaFluxPulidOutput

export const zGetFalAiBirefnetV2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiBirefnetV2RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBirefnetV2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiBirefnetV2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiBirefnetV2Data = z.object({
  body: zSchemaBirefnetV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBirefnetV2Response = zSchemaQueueStatus

export const zGetFalAiBirefnetV2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiBirefnetV2RequestsByRequestIdResponse =
  zSchemaBirefnetV2Output

export const zGetFalAiLivePortraitImageRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiLivePortraitImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLivePortraitImageRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiLivePortraitImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLivePortraitImageData = z.object({
  body: zSchemaLivePortraitImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLivePortraitImageResponse = zSchemaQueueStatus

export const zGetFalAiLivePortraitImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLivePortraitImageRequestsByRequestIdResponse =
  zSchemaLivePortraitImageOutput

export const zGetFalAiFluxGeneralRfInversionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxGeneralRfInversionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxGeneralRfInversionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxGeneralRfInversionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFluxGeneralRfInversionData = z.object({
  body: zSchemaFluxGeneralRfInversionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxGeneralRfInversionResponse = zSchemaQueueStatus

export const zGetFalAiFluxGeneralRfInversionRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxGeneralRfInversionRequestsByRequestIdResponse =
  zSchemaFluxGeneralRfInversionOutput

export const zGetFalAiImagePreprocessorsHedRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsHedRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImagePreprocessorsHedRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsHedRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImagePreprocessorsHedData = z.object({
  body: zSchemaImagePreprocessorsHedInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsHedResponse = zSchemaQueueStatus

export const zGetFalAiImagePreprocessorsHedRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsHedRequestsByRequestIdResponse =
  zSchemaImagePreprocessorsHedOutput

export const zGetFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImagePreprocessorsDepthAnythingV2Data = z.object({
  body: zSchemaImagePreprocessorsDepthAnythingV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsDepthAnythingV2Response =
  zSchemaQueueStatus

export const zGetFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsDepthAnythingV2RequestsByRequestIdResponse =
  zSchemaImagePreprocessorsDepthAnythingV2Output

export const zGetFalAiImagePreprocessorsScribbleRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsScribbleRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImagePreprocessorsScribbleRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsScribbleRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImagePreprocessorsScribbleData = z.object({
  body: zSchemaImagePreprocessorsScribbleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsScribbleResponse = zSchemaQueueStatus

export const zGetFalAiImagePreprocessorsScribbleRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsScribbleRequestsByRequestIdResponse =
  zSchemaImagePreprocessorsScribbleOutput

export const zGetFalAiImagePreprocessorsMlsdRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsMlsdRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImagePreprocessorsMlsdRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsMlsdRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImagePreprocessorsMlsdData = z.object({
  body: zSchemaImagePreprocessorsMlsdInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsMlsdResponse = zSchemaQueueStatus

export const zGetFalAiImagePreprocessorsMlsdRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsMlsdRequestsByRequestIdResponse =
  zSchemaImagePreprocessorsMlsdOutput

export const zGetFalAiImagePreprocessorsSamRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsSamRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImagePreprocessorsSamRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsSamRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImagePreprocessorsSamData = z.object({
  body: zSchemaImagePreprocessorsSamInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsSamResponse = zSchemaQueueStatus

export const zGetFalAiImagePreprocessorsSamRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsSamRequestsByRequestIdResponse =
  zSchemaImagePreprocessorsSamOutput

export const zGetFalAiImagePreprocessorsMidasRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsMidasRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImagePreprocessorsMidasRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsMidasRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImagePreprocessorsMidasData = z.object({
  body: zSchemaImagePreprocessorsMidasInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsMidasResponse = zSchemaQueueStatus

export const zGetFalAiImagePreprocessorsMidasRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsMidasRequestsByRequestIdResponse =
  zSchemaImagePreprocessorsMidasOutput

export const zGetFalAiImagePreprocessorsTeedRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsTeedRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImagePreprocessorsTeedRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsTeedRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImagePreprocessorsTeedData = z.object({
  body: zSchemaImagePreprocessorsTeedInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsTeedResponse = zSchemaQueueStatus

export const zGetFalAiImagePreprocessorsTeedRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsTeedRequestsByRequestIdResponse =
  zSchemaImagePreprocessorsTeedOutput

export const zGetFalAiImagePreprocessorsLineartRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsLineartRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImagePreprocessorsLineartRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsLineartRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImagePreprocessorsLineartData = z.object({
  body: zSchemaImagePreprocessorsLineartInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsLineartResponse = zSchemaQueueStatus

export const zGetFalAiImagePreprocessorsLineartRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsLineartRequestsByRequestIdResponse =
  zSchemaImagePreprocessorsLineartOutput

export const zGetFalAiImagePreprocessorsZoeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsZoeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImagePreprocessorsZoeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsZoeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImagePreprocessorsZoeData = z.object({
  body: zSchemaImagePreprocessorsZoeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsZoeResponse = zSchemaQueueStatus

export const zGetFalAiImagePreprocessorsZoeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsZoeRequestsByRequestIdResponse =
  zSchemaImagePreprocessorsZoeOutput

export const zGetFalAiImagePreprocessorsPidiRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImagePreprocessorsPidiRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImagePreprocessorsPidiRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImagePreprocessorsPidiRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImagePreprocessorsPidiData = z.object({
  body: zSchemaImagePreprocessorsPidiInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImagePreprocessorsPidiResponse = zSchemaQueueStatus

export const zGetFalAiImagePreprocessorsPidiRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImagePreprocessorsPidiRequestsByRequestIdResponse =
  zSchemaImagePreprocessorsPidiOutput

export const zGetFalAiSam2ImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiSam2ImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSam2ImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiSam2ImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSam2ImageData = z.object({
  body: zSchemaSam2ImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSam2ImageResponse = zSchemaQueueStatus

export const zGetFalAiSam2ImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSam2ImageRequestsByRequestIdResponse =
  zSchemaSam2ImageOutput

export const zGetFalAiFluxGeneralImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxGeneralImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxGeneralImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxGeneralImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFluxGeneralImageToImageData = z.object({
  body: zSchemaFluxGeneralImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxGeneralImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiFluxGeneralImageToImageRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * Result of the request.
 */
export const zGetFalAiFluxGeneralImageToImageRequestsByRequestIdResponse =
  zSchemaFluxGeneralImageToImageOutput

export const zGetFalAiFluxGeneralInpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxGeneralInpaintingRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxGeneralInpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxGeneralInpaintingRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxGeneralInpaintingData = z.object({
  body: zSchemaFluxGeneralInpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxGeneralInpaintingResponse = zSchemaQueueStatus

export const zGetFalAiFluxGeneralInpaintingRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxGeneralInpaintingRequestsByRequestIdResponse =
  zSchemaFluxGeneralInpaintingOutput

export const zGetFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFluxGeneralDifferentialDiffusionData = z.object({
  body: zSchemaFluxGeneralDifferentialDiffusionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxGeneralDifferentialDiffusionResponse =
  zSchemaQueueStatus

export const zGetFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFluxGeneralDifferentialDiffusionRequestsByRequestIdResponse =
  zSchemaFluxGeneralDifferentialDiffusionOutput

export const zGetFalAiFluxLoraImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxLoraImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxLoraImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxLoraImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxLoraImageToImageData = z.object({
  body: zSchemaFluxLoraImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxLoraImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiFluxLoraImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxLoraImageToImageRequestsByRequestIdResponse =
  zSchemaFluxLoraImageToImageOutput

export const zGetFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiSdxlControlnetUnionInpaintingData = z.object({
  body: zSchemaSdxlControlnetUnionInpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSdxlControlnetUnionInpaintingResponse =
  zSchemaQueueStatus

export const zGetFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiSdxlControlnetUnionInpaintingRequestsByRequestIdResponse =
  zSchemaSdxlControlnetUnionInpaintingOutput

export const zGetFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiSdxlControlnetUnionImageToImageData = z.object({
  body: zSchemaSdxlControlnetUnionImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSdxlControlnetUnionImageToImageResponse =
  zSchemaQueueStatus

export const zGetFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiSdxlControlnetUnionImageToImageRequestsByRequestIdResponse =
  zSchemaSdxlControlnetUnionImageToImageOutput

export const zGetFalAiEra3dRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiEra3dRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiEra3dRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiEra3dRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiEra3dData = z.object({
  body: zSchemaEra3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiEra3dResponse = zSchemaQueueStatus

export const zGetFalAiEra3dRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiEra3dRequestsByRequestIdResponse = zSchemaEra3dOutput

export const zGetFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlorence2LargeDenseRegionCaptionData = z.object({
  body: zSchemaFlorence2LargeDenseRegionCaptionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlorence2LargeDenseRegionCaptionResponse =
  zSchemaQueueStatus

export const zGetFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlorence2LargeDenseRegionCaptionRequestsByRequestIdResponse =
  zSchemaFlorence2LargeDenseRegionCaptionOutput

export const zGetFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlorence2LargeReferringExpressionSegmentationData =
  z.object({
    body: zSchemaFlorence2LargeReferringExpressionSegmentationInput,
    path: z.optional(z.never()),
    query: z.optional(z.never()),
  })

/**
 * The request status.
 */
export const zPostFalAiFlorence2LargeReferringExpressionSegmentationResponse =
  zSchemaQueueStatus

export const zGetFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlorence2LargeReferringExpressionSegmentationRequestsByRequestIdResponse =
  zSchemaFlorence2LargeReferringExpressionSegmentationOutput

export const zGetFalAiFlorence2LargeObjectDetectionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlorence2LargeObjectDetectionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlorence2LargeObjectDetectionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlorence2LargeObjectDetectionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlorence2LargeObjectDetectionData = z.object({
  body: zSchemaFlorence2LargeObjectDetectionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlorence2LargeObjectDetectionResponse =
  zSchemaQueueStatus

export const zGetFalAiFlorence2LargeObjectDetectionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlorence2LargeObjectDetectionRequestsByRequestIdResponse =
  zSchemaFlorence2LargeObjectDetectionOutput

export const zGetFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlorence2LargeOpenVocabularyDetectionData = z.object({
  body: zSchemaFlorence2LargeOpenVocabularyDetectionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlorence2LargeOpenVocabularyDetectionResponse =
  zSchemaQueueStatus

export const zGetFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlorence2LargeOpenVocabularyDetectionRequestsByRequestIdResponse =
  zSchemaFlorence2LargeOpenVocabularyDetectionOutput

export const zGetFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlorence2LargeCaptionToPhraseGroundingData = z.object({
  body: zSchemaFlorence2LargeCaptionToPhraseGroundingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlorence2LargeCaptionToPhraseGroundingResponse =
  zSchemaQueueStatus

export const zGetFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlorence2LargeCaptionToPhraseGroundingRequestsByRequestIdResponse =
  zSchemaFlorence2LargeCaptionToPhraseGroundingOutput

export const zGetFalAiFlorence2LargeRegionProposalRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlorence2LargeRegionProposalRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlorence2LargeRegionProposalRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlorence2LargeRegionProposalRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlorence2LargeRegionProposalData = z.object({
  body: zSchemaFlorence2LargeRegionProposalInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlorence2LargeRegionProposalResponse = zSchemaQueueStatus

export const zGetFalAiFlorence2LargeRegionProposalRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlorence2LargeRegionProposalRequestsByRequestIdResponse =
  zSchemaFlorence2LargeRegionProposalOutput

export const zGetFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlorence2LargeOcrWithRegionData = z.object({
  body: zSchemaFlorence2LargeOcrWithRegionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlorence2LargeOcrWithRegionResponse = zSchemaQueueStatus

export const zGetFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlorence2LargeOcrWithRegionRequestsByRequestIdResponse =
  zSchemaFlorence2LargeOcrWithRegionOutput

export const zGetFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlorence2LargeRegionToSegmentationData = z.object({
  body: zSchemaFlorence2LargeRegionToSegmentationInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlorence2LargeRegionToSegmentationResponse =
  zSchemaQueueStatus

export const zGetFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlorence2LargeRegionToSegmentationRequestsByRequestIdResponse =
  zSchemaFlorence2LargeRegionToSegmentationOutput

export const zGetFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiStableDiffusionV3MediumImageToImageData = z.object({
  body: zSchemaStableDiffusionV3MediumImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiStableDiffusionV3MediumImageToImageResponse =
  zSchemaQueueStatus

export const zGetFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiStableDiffusionV3MediumImageToImageRequestsByRequestIdResponse =
  zSchemaStableDiffusionV3MediumImageToImageOutput

export const zGetFalAiDwposeRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiDwposeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiDwposeRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiDwposeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiDwposeData = z.object({
  body: zSchemaDwposeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiDwposeResponse = zSchemaQueueStatus

export const zGetFalAiDwposeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiDwposeRequestsByRequestIdResponse = zSchemaDwposeOutput

export const zGetFalAiSd15DepthControlnetRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiSd15DepthControlnetRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSd15DepthControlnetRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiSd15DepthControlnetRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSd15DepthControlnetData = z.object({
  body: zSchemaSd15DepthControlnetInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSd15DepthControlnetResponse = zSchemaQueueStatus

export const zGetFalAiSd15DepthControlnetRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSd15DepthControlnetRequestsByRequestIdResponse =
  zSchemaSd15DepthControlnetOutput

export const zGetFalAiCcsrRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiCcsrRequestsByRequestIdStatusResponse = zSchemaQueueStatus

export const zPutFalAiCcsrRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiCcsrRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiCcsrData = z.object({
  body: zSchemaCcsrInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiCcsrResponse = zSchemaQueueStatus

export const zGetFalAiCcsrRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiCcsrRequestsByRequestIdResponse = zSchemaCcsrOutput

export const zGetFalAiOmniZeroRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiOmniZeroRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiOmniZeroRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiOmniZeroRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiOmniZeroData = z.object({
  body: zSchemaOmniZeroInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiOmniZeroResponse = zSchemaQueueStatus

export const zGetFalAiOmniZeroRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiOmniZeroRequestsByRequestIdResponse =
  zSchemaOmniZeroOutput

export const zGetFalAiIpAdapterFaceIdRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiIpAdapterFaceIdRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIpAdapterFaceIdRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiIpAdapterFaceIdRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIpAdapterFaceIdData = z.object({
  body: zSchemaIpAdapterFaceIdInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIpAdapterFaceIdResponse = zSchemaQueueStatus

export const zGetFalAiIpAdapterFaceIdRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIpAdapterFaceIdRequestsByRequestIdResponse =
  zSchemaIpAdapterFaceIdOutput

export const zGetFalAiLoraInpaintRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiLoraInpaintRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLoraInpaintRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiLoraInpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLoraInpaintData = z.object({
  body: zSchemaLoraInpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLoraInpaintResponse = zSchemaQueueStatus

export const zGetFalAiLoraInpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLoraInpaintRequestsByRequestIdResponse =
  zSchemaLoraInpaintOutput

export const zGetFalAiLoraImageToImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiLoraImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLoraImageToImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiLoraImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLoraImageToImageData = z.object({
  body: zSchemaLoraImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLoraImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiLoraImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLoraImageToImageRequestsByRequestIdResponse =
  zSchemaLoraImageToImageOutput

export const zGetFalAiFastSdxlImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFastSdxlImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFastSdxlImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFastSdxlImageToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFastSdxlImageToImageData = z.object({
  body: zSchemaFastSdxlImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFastSdxlImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiFastSdxlImageToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFastSdxlImageToImageRequestsByRequestIdResponse =
  zSchemaFastSdxlImageToImageOutput

export const zGetFalAiFastSdxlInpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFastSdxlInpaintingRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFastSdxlInpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFastSdxlInpaintingRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFastSdxlInpaintingData = z.object({
  body: zSchemaFastSdxlInpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFastSdxlInpaintingResponse = zSchemaQueueStatus

export const zGetFalAiFastSdxlInpaintingRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFastSdxlInpaintingRequestsByRequestIdResponse =
  zSchemaFastSdxlInpaintingOutput

export const zGetFalAiFaceToStickerRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFaceToStickerRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFaceToStickerRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFaceToStickerRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFaceToStickerData = z.object({
  body: zSchemaFaceToStickerInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFaceToStickerResponse = zSchemaQueueStatus

export const zGetFalAiFaceToStickerRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFaceToStickerRequestsByRequestIdResponse =
  zSchemaFaceToStickerOutput

export const zGetFalAiPhotomakerRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiPhotomakerRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPhotomakerRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiPhotomakerRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiPhotomakerData = z.object({
  body: zSchemaPhotomakerInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPhotomakerResponse = zSchemaQueueStatus

export const zGetFalAiPhotomakerRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiPhotomakerRequestsByRequestIdResponse =
  zSchemaPhotomakerOutput

export const zGetFalAiCreativeUpscalerRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiCreativeUpscalerRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiCreativeUpscalerRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiCreativeUpscalerRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiCreativeUpscalerData = z.object({
  body: zSchemaCreativeUpscalerInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiCreativeUpscalerResponse = zSchemaQueueStatus

export const zGetFalAiCreativeUpscalerRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiCreativeUpscalerRequestsByRequestIdResponse =
  zSchemaCreativeUpscalerOutput

export const zGetFalAiBirefnetRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiBirefnetRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBirefnetRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiBirefnetRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiBirefnetData = z.object({
  body: zSchemaBirefnetInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBirefnetResponse = zSchemaQueueStatus

export const zGetFalAiBirefnetRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiBirefnetRequestsByRequestIdResponse =
  zSchemaBirefnetOutput

export const zGetFalAiPlaygroundV25ImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiPlaygroundV25ImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPlaygroundV25ImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiPlaygroundV25ImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiPlaygroundV25ImageToImageData = z.object({
  body: zSchemaPlaygroundV25ImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPlaygroundV25ImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiPlaygroundV25ImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiPlaygroundV25ImageToImageRequestsByRequestIdResponse =
  zSchemaPlaygroundV25ImageToImageOutput

export const zGetFalAiFastLightningSdxlImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFastLightningSdxlImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFastLightningSdxlImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFastLightningSdxlImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFastLightningSdxlImageToImageData = z.object({
  body: zSchemaFastLightningSdxlImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFastLightningSdxlImageToImageResponse =
  zSchemaQueueStatus

export const zGetFalAiFastLightningSdxlImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFastLightningSdxlImageToImageRequestsByRequestIdResponse =
  zSchemaFastLightningSdxlImageToImageOutput

export const zGetFalAiFastLightningSdxlInpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFastLightningSdxlInpaintingRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFastLightningSdxlInpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFastLightningSdxlInpaintingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFastLightningSdxlInpaintingData = z.object({
  body: zSchemaFastLightningSdxlInpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFastLightningSdxlInpaintingResponse = zSchemaQueueStatus

export const zGetFalAiFastLightningSdxlInpaintingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFastLightningSdxlInpaintingRequestsByRequestIdResponse =
  zSchemaFastLightningSdxlInpaintingOutput

export const zGetFalAiPlaygroundV25InpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiPlaygroundV25InpaintingRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPlaygroundV25InpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiPlaygroundV25InpaintingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiPlaygroundV25InpaintingData = z.object({
  body: zSchemaPlaygroundV25InpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPlaygroundV25InpaintingResponse = zSchemaQueueStatus

export const zGetFalAiPlaygroundV25InpaintingRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * Result of the request.
 */
export const zGetFalAiPlaygroundV25InpaintingRequestsByRequestIdResponse =
  zSchemaPlaygroundV25InpaintingOutput

export const zGetFalAiFastLcmDiffusionInpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFastLcmDiffusionInpaintingRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFastLcmDiffusionInpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFastLcmDiffusionInpaintingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFastLcmDiffusionInpaintingData = z.object({
  body: zSchemaFastLcmDiffusionInpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFastLcmDiffusionInpaintingResponse = zSchemaQueueStatus

export const zGetFalAiFastLcmDiffusionInpaintingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFastLcmDiffusionInpaintingRequestsByRequestIdResponse =
  zSchemaFastLcmDiffusionInpaintingOutput

export const zGetFalAiFastLcmDiffusionImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFastLcmDiffusionImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFastLcmDiffusionImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFastLcmDiffusionImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFastLcmDiffusionImageToImageData = z.object({
  body: zSchemaFastLcmDiffusionImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFastLcmDiffusionImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiFastLcmDiffusionImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFastLcmDiffusionImageToImageRequestsByRequestIdResponse =
  zSchemaFastLcmDiffusionImageToImageOutput

export const zGetFalAiRetoucherRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiRetoucherRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiRetoucherRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiRetoucherRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiRetoucherData = z.object({
  body: zSchemaRetoucherInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiRetoucherResponse = zSchemaQueueStatus

export const zGetFalAiRetoucherRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiRetoucherRequestsByRequestIdResponse =
  zSchemaRetoucherOutput

export const zGetFalAiImageutilsDepthRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiImageutilsDepthRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageutilsDepthRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiImageutilsDepthRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImageutilsDepthData = z.object({
  body: zSchemaImageutilsDepthInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageutilsDepthResponse = zSchemaQueueStatus

export const zGetFalAiImageutilsDepthRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImageutilsDepthRequestsByRequestIdResponse =
  zSchemaImageutilsDepthOutput

export const zGetFalAiImageutilsMarigoldDepthRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImageutilsMarigoldDepthRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageutilsMarigoldDepthRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImageutilsMarigoldDepthRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiImageutilsMarigoldDepthData = z.object({
  body: zSchemaImageutilsMarigoldDepthInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageutilsMarigoldDepthResponse = zSchemaQueueStatus

export const zGetFalAiImageutilsMarigoldDepthRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * Result of the request.
 */
export const zGetFalAiImageutilsMarigoldDepthRequestsByRequestIdResponse =
  zSchemaImageutilsMarigoldDepthOutput

export const zGetFalAiPulidRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiPulidRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPulidRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiPulidRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiPulidData = z.object({
  body: zSchemaPulidInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPulidResponse = zSchemaQueueStatus

export const zGetFalAiPulidRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiPulidRequestsByRequestIdResponse = zSchemaPulidOutput

export const zGetFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFastSdxlControlnetCannyImageToImageData = z.object({
  body: zSchemaFastSdxlControlnetCannyImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFastSdxlControlnetCannyImageToImageResponse =
  zSchemaQueueStatus

export const zGetFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFastSdxlControlnetCannyImageToImageRequestsByRequestIdResponse =
  zSchemaFastSdxlControlnetCannyImageToImageOutput

export const zGetFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFastSdxlControlnetCannyInpaintingData = z.object({
  body: zSchemaFastSdxlControlnetCannyInpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFastSdxlControlnetCannyInpaintingResponse =
  zSchemaQueueStatus

export const zGetFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFastSdxlControlnetCannyInpaintingRequestsByRequestIdResponse =
  zSchemaFastSdxlControlnetCannyInpaintingOutput

export const zGetFalAiLcmSd15I2iRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiLcmSd15I2iRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLcmSd15I2iRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiLcmSd15I2iRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLcmSd15I2iData = z.object({
  body: zSchemaLcmSd15I2iInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLcmSd15I2iResponse = zSchemaQueueStatus

export const zGetFalAiLcmSd15I2iRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLcmSd15I2iRequestsByRequestIdResponse =
  zSchemaLcmSd15I2iOutput

export const zGetFalAiInpaintRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiInpaintRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiInpaintRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiInpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiInpaintData = z.object({
  body: zSchemaInpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiInpaintResponse = zSchemaQueueStatus

export const zGetFalAiInpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiInpaintRequestsByRequestIdResponse = zSchemaInpaintOutput

export const zGetFalAiEsrganRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiEsrganRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiEsrganRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiEsrganRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiEsrganData = z.object({
  body: zSchemaEsrganInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiEsrganResponse = zSchemaQueueStatus

export const zGetFalAiEsrganRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiEsrganRequestsByRequestIdResponse = zSchemaEsrganOutput

export const zGetFalAiImageutilsRembgRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiImageutilsRembgRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImageutilsRembgRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiImageutilsRembgRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImageutilsRembgData = z.object({
  body: zSchemaImageutilsRembgInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImageutilsRembgResponse = zSchemaQueueStatus

export const zGetFalAiImageutilsRembgRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImageutilsRembgRequestsByRequestIdResponse =
  zSchemaImageutilsRembgOutput
