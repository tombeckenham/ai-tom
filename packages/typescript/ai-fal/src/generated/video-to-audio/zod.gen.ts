// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod'

export const zFile = z.object({
  url: z.url(),
  content_type: z.optional(z.string()),
  file_name: z.optional(z.string()),
  file_size: z.optional(z.int()),
})

export const zQueueStatus = z.object({
  status: z.enum(['IN_PROGRESS', 'COMPLETED', 'FAILED']),
  response_url: z.optional(z.url()),
})

/**
 * SAMAudioVisualInput
 *
 * Input for visual-prompted audio separation.
 */
export const zSamAudioVisualSeparateInput = z
  .object({
    prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'Text prompt to assist with separation. Use natural language to describe the target sound.',
        }),
      )
      .default(''),
    video_url: z.string().register(z.globalRegistry, {
      description: 'URL of the video file to process (MP4, MOV, etc.)',
    }),
    acceleration: z.optional(
      z.enum(['fast', 'balanced', 'quality']).register(z.globalRegistry, {
        description: 'The acceleration level to use.',
      }),
    ),
    mask_video_url: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'URL of the mask video (binary mask indicating target object). Black=target, White=background.',
      }),
    ),
    output_format: z.optional(
      z.enum(['wav', 'mp3']).register(z.globalRegistry, {
        description: 'Output audio format.',
      }),
    ),
    reranking_candidates: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description:
            'Number of candidates to generate and rank. Higher improves quality but increases latency and cost.',
        }),
      )
      .default(1),
  })
  .register(z.globalRegistry, {
    description: 'Input for visual-prompted audio separation.',
  })

/**
 * File
 */
export const zFalAiSamAudioVisualSeparateFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * SAMAudioVisualSeparateOutput
 *
 * Output for visual-prompted audio separation.
 */
export const zSamAudioVisualSeparateOutput = z
  .object({
    target: zFalAiSamAudioVisualSeparateFile,
    duration: z.number().register(z.globalRegistry, {
      description: 'Duration of the output audio in seconds.',
    }),
    sample_rate: z
      .optional(
        z.int().register(z.globalRegistry, {
          description: 'Sample rate of the output audio in Hz.',
        }),
      )
      .default(48000),
    residual: zFalAiSamAudioVisualSeparateFile,
  })
  .register(z.globalRegistry, {
    description: 'Output for visual-prompted audio separation.',
  })

/**
 * Input
 */
export const zSfxV15VideoToAudioInput = z.object({
  num_samples: z.optional(z.union([z.int().gte(2).lte(8), z.unknown()])),
  duration: z.optional(z.union([z.number().gte(1).lte(10), z.unknown()])),
  start_offset: z.optional(z.union([z.number().gte(0), z.unknown()])),
  video_url: z.url().min(1).max(2083).register(z.globalRegistry, {
    description:
      'A video url that can accessed from the API to process and add sound effects',
  }),
  seed: z.optional(z.union([z.int().gte(1), z.unknown()])),
  text_prompt: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * Audio
 */
export const zAudioOutput = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * VideoToAudioInput
 */
export const zKlingVideoVideoToAudioInput = z.object({
  video_url: z.string().register(z.globalRegistry, {
    description:
      'The video URL to extract audio from. Only .mp4/.mov formats are supported. File size does not exceed 100MB. Video duration between 3.0s and 20.0s.',
  }),
  asmr_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Enable ASMR mode. This mode enhances detailed sound effects and is suitable for highly immersive content scenarios.',
      }),
    )
    .default(false),
  background_music_prompt: z
    .optional(
      z.string().max(200).register(z.globalRegistry, {
        description: 'Background music prompt. Cannot exceed 200 characters.',
      }),
    )
    .default('intense car race'),
  sound_effect_prompt: z
    .optional(
      z.string().max(200).register(z.globalRegistry, {
        description: 'Sound effect prompt. Cannot exceed 200 characters.',
      }),
    )
    .default('Car tires screech as they accelerate in a drag race'),
})

/**
 * File
 */
export const zFalAiKlingVideoVideoToAudioFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * VideoToAudioOutput
 */
export const zKlingVideoVideoToAudioOutput = z.object({
  video: zFalAiKlingVideoVideoToAudioFile,
  audio: zFalAiKlingVideoVideoToAudioFile,
})

/**
 * Input
 */
export const zSfxV1VideoToAudioInput = z.object({
  num_samples: z.optional(z.union([z.int().gte(2).lte(8), z.unknown()])),
  video_url: z.url().min(1).max(2083).register(z.globalRegistry, {
    description:
      'A video url that can accessed from the API to process and add sound effects',
  }),
  duration: z.optional(z.union([z.number().gte(1).lte(10), z.unknown()])),
  seed: z.optional(z.union([z.int().gte(1), z.unknown()])),
  text_prompt: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * Audio
 */
export const zAudio = z.object({
  file_size: z.optional(z.union([z.int(), z.unknown()])),
  file_name: z.optional(z.union([z.string(), z.unknown()])),
  content_type: z.optional(z.union([z.string(), z.unknown()])),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
})

/**
 * AudioOutput
 */
export const zSfxV1VideoToAudioOutput = z.object({
  audio: z.array(zAudio).register(z.globalRegistry, {
    description: 'The generated sound effects audio',
  }),
})
