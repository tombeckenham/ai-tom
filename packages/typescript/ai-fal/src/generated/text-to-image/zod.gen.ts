// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod'

/**
 * TimestepsInput
 */
export const zSchemaTimestepsInput = z.object({
  method: z.optional(
    z.enum(['default', 'array']).register(z.globalRegistry, {
      description:
        "\n            The method to use for the timesteps. If set to 'array', the timesteps will be set based\n            on the provided timesteps schedule in the `array` field.\n            Defaults to 'default' which means the scheduler will use the `num_inference_steps` parameter.\n        ",
    }),
  ),
  array: z
    .optional(
      z.array(z.int()).register(z.globalRegistry, {
        description:
          "\n           Timesteps schedule to be used if 'custom' method is selected.\n        ",
      }),
    )
    .default([]),
})

/**
 * SigmasInput
 */
export const zSchemaSigmasInput = z.object({
  method: z.optional(
    z.enum(['default', 'array']).register(z.globalRegistry, {
      description:
        "\n            The method to use for the sigmas. If set to 'custom', the sigmas will be set based\n            on the provided sigmas schedule in the `array` field.\n            Defaults to 'default' which means the scheduler will use the sigmas of the scheduler.\n        ",
    }),
  ),
  array: z
    .optional(
      z.array(z.number()).register(z.globalRegistry, {
        description:
          "\n           Sigmas schedule to be used if 'custom' method is selected.\n        ",
      }),
    )
    .default([]),
})

/**
 * File
 */
export const zSchemaFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * Image
 *
 * Represents an image file.
 */
export const zSchemaImage = z
  .object({
    file_size: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The size of the file in bytes.',
      }),
    ),
    height: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The height of the image in pixels.',
      }),
    ),
    url: z.string().register(z.globalRegistry, {
      description: 'The URL where the file can be downloaded from.',
    }),
    width: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The width of the image in pixels.',
      }),
    ),
    file_name: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The name of the file. It will be auto-generated if not provided.',
      }),
    ),
    content_type: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The mime type of the file.',
      }),
    ),
    file_data: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'File data',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Represents an image file.',
  })

/**
 * OutputParameters
 */
export const zSchemaLoraOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  debug_latents: z.optional(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  debug_per_pass_latents: z.optional(zSchemaFile),
})

/**
 * ControlNet
 */
export const zSchemaControlNet = z.object({
  conditioning_scale: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description:
          '\n            The scale of the control net weight. This is used to scale the control net weight\n            before merging it with the base model.\n        ',
      }),
    )
    .default(1),
  path: z.string().register(z.globalRegistry, {
    description: 'URL or the path to the control net weights.',
  }),
  ip_adapter_index: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The index of the IP adapter to be applied to the controlnet. This is only needed for InstantID ControlNets.\n        ',
    }),
  ),
  end_percentage: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The percentage of the image to end applying the controlnet in terms of the total timesteps.\n        ',
      }),
    )
    .default(1),
  config_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'optional URL to the controlnet config.json file.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be used as the control net.',
  }),
  variant: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The optional variant if a Hugging Face repo key is used.',
    }),
  ),
  mask_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The mask to use for the controlnet. When using a mask, the control image size and the mask size must be the same and divisible by 32.\n        ',
    }),
  ),
  start_percentage: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The percentage of the image to start applying the controlnet in terms of the total timesteps.\n        ',
      }),
    )
    .default(0),
})

/**
 * LoraWeight
 */
export const zSchemaLoraWeight = z.object({
  path: z.string().register(z.globalRegistry, {
    description: 'URL or the path to the LoRA weights.',
  }),
  scale: z
    .optional(
      z.number().gte(0).lte(4).register(z.globalRegistry, {
        description:
          '\n            The scale of the LoRA weight. This is used to scale the LoRA weight\n            before merging it with the base model.\n        ',
      }),
    )
    .default(1),
})

/**
 * IPAdapter
 */
export const zSchemaIpAdapter = z.object({
  unconditional_noising_factor: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'The factor to apply to the unconditional noising of the IP adapter.',
      }),
    )
    .default(0),
  ip_adapter_image_url: z.union([z.string(), z.array(z.string())]),
  path: z.string().register(z.globalRegistry, {
    description: 'URL or the path to the IP adapter weights.',
  }),
  image_projection_shortcut: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            The value to set the image projection shortcut to. For FaceID plus V1 models,\n            this should be set to False. For FaceID plus V2 models, this should be set to True.\n            Default is True.\n        ',
      }),
    )
    .default(true),
  scale_json: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description:
        '\n            The scale of the IP adapter weight. This is used to scale the IP adapter weight\n            before merging it with the base model.\n        ',
    }),
  ),
  ip_adapter_mask_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The mask to use for the IP adapter. When using a mask, the ip-adapter image size and the mask size must be the same\n        ',
    }),
  ),
  model_subfolder: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Subfolder in the model directory where the IP adapter weights are stored.',
    }),
  ),
  scale: z
    .optional(
      z.number().gte(0).register(z.globalRegistry, {
        description:
          '\n            The scale of the IP adapter weight. This is used to scale the IP adapter weight\n            before merging it with the base model.\n        ',
      }),
    )
    .default(1),
  insight_face_model_path: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL or the path to the InsightFace model weights.',
    }),
  ),
  weight_name: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Name of the weight file.',
    }),
  ),
})

/**
 * Embedding
 */
export const zSchemaEmbedding = z.object({
  tokens: z
    .optional(
      z.array(z.string()).register(z.globalRegistry, {
        description:
          '\n            The tokens to map the embedding weights to. Use these tokens in your prompts.\n        ',
      }),
    )
    .default(['<s0>', '<s1>']),
  path: z.string().register(z.globalRegistry, {
    description: 'URL or the path to the embedding weights.',
  }),
})

/**
 * ImageSize
 */
export const zSchemaImageSize = z.object({
  height: z
    .optional(
      z.int().lte(14142).register(z.globalRegistry, {
        description: 'The height of the generated image.',
      }),
    )
    .default(512),
  width: z
    .optional(
      z.int().lte(14142).register(z.globalRegistry, {
        description: 'The width of the generated image.',
      }),
    )
    .default(512),
})

/**
 * TextToImageInput
 */
export const zSchemaLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  tile_height: z
    .optional(
      z.int().gte(128).lte(4096).register(z.globalRegistry, {
        description:
          'The size of the tiles to be used for the image generation.',
      }),
    )
    .default(4096),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description:
          '\n            The embeddings to use for the image generation. Only a single embedding is supported at the moment.\n            The embeddings will be used to map the tokens in the prompt to the embedding weights.\n        ',
      }),
    )
    .default([]),
  ic_light_model_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The URL of the IC Light model to use for the image generation.\n        ',
    }),
  ),
  image_encoder_weight_name: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            The weight name of the image encoder model to use for the image generation.\n        ',
      }),
    )
    .default('pytorch_model.bin'),
  ip_adapter: z
    .optional(
      z.array(zSchemaIpAdapter).register(z.globalRegistry, {
        description:
          '\n            The IP adapter to use for the image generation.\n        ',
      }),
    )
    .default([]),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  scheduler: z.optional(
    z
      .enum([
        'DPM++ 2M',
        'DPM++ 2M Karras',
        'DPM++ 2M SDE',
        'DPM++ 2M SDE Karras',
        'Euler',
        'Euler A',
        'Euler (trailing timesteps)',
        'LCM',
        'LCM (trailing timesteps)',
        'DDIM',
        'TCD',
      ])
      .register(z.globalRegistry, {
        description:
          'Scheduler / sampler to use for the image denoising process.',
      }),
  ),
  sigmas: z.optional(zSchemaSigmasInput),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(7.5),
  tile_stride_width: z
    .optional(
      z.int().gte(64).lte(2048).register(z.globalRegistry, {
        description:
          'The stride of the tiles to be used for the image generation.',
      }),
    )
    .default(2048),
  debug_per_pass_latents: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the latents will be saved for debugging per pass.',
      }),
    )
    .default(false),
  timesteps: z.optional(zSchemaTimestepsInput),
  image_encoder_subfolder: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The subfolder of the image encoder model to use for the image generation.\n        ',
    }),
  ),
  prompt_weighting: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the prompt weighting syntax will be used.\n            Additionally, this will lift the 77 token limit by averaging embeddings.\n        ',
      }),
    )
    .default(false),
  variant: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        "The variant of the model to use for huggingface models, e.g. 'fp16'.",
    }),
  ),
  model_name: z.string().register(z.globalRegistry, {
    description:
      'URL or HuggingFace ID of the base model to generate the image.',
  }),
  controlnet_guess_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the controlnet will be applied to only the conditional predictions.\n        ',
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  ic_light_model_background_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The URL of the IC Light model background image to use for the image generation.\n            Make sure to use a background compatible with the model.\n        ',
    }),
  ),
  rescale_betas_snr_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            Whether to set the rescale_betas_snr_zero option or not for the sampler\n        ',
      }),
    )
    .default(false),
  tile_width: z
    .optional(
      z.int().gte(128).lte(4096).register(z.globalRegistry, {
        description:
          'The size of the tiles to be used for the image generation.',
      }),
    )
    .default(4096),
  prediction_type: z.optional(
    z.enum(['v_prediction', 'epsilon']).register(z.globalRegistry, {
      description:
        '\n            The type of prediction to use for the image generation.\n            The `epsilon` is the default.\n        ',
    }),
  ),
  eta: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The eta value to be used for the image generation.',
      }),
    )
    .default(0),
  image_encoder_path: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The path to the image encoder model to use for the image generation.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  image_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description:
          '\n            Number of images to generate in one request. Note that the higher the batch size,\n            the longer it will take to generate the images.\n        ',
      }),
    )
    .default(1),
  debug_latents: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the latents will be saved for debugging.',
      }),
    )
    .default(false),
  ic_light_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The URL of the IC Light model image to use for the image generation.\n        ',
    }),
  ),
  unet_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'URL or HuggingFace ID of the custom U-Net model to use for the image generation.',
    }),
  ),
  clip_skip: z
    .optional(
      z.int().gte(0).lte(2).register(z.globalRegistry, {
        description:
          '\n            Skips part of the image generation process, leading to slightly different results.\n            This means the image renders faster, too.\n        ',
      }),
    )
    .default(0),
  tile_stride_height: z
    .optional(
      z.int().gte(64).lte(2048).register(z.globalRegistry, {
        description:
          'The stride of the tiles to be used for the image generation.',
      }),
    )
    .default(2048),
  controlnets: z
    .optional(
      z.array(zSchemaControlNet).register(z.globalRegistry, {
        description:
          '\n            The control nets to use for the image generation. You can use any number of control nets\n            and they will be applied to the image at the specified timesteps.\n        ',
      }),
    )
    .default([]),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(150).register(z.globalRegistry, {
        description:
          '\n            Increasing the amount of steps tells Stable Diffusion that it should take more steps\n            to generate your final result which can increase the amount of detail in your image.\n        ',
      }),
    )
    .default(30),
})

/**
 * FooocusOutput
 */
export const zSchemaFooocusOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image file info.',
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'The time taken for the generation process.',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
})

/**
 * FooocusLegacyInput
 */
export const zSchemaFooocusInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The prompt to use for generating the image. Be as descriptive as possible for best results.',
      }),
    )
    .default(''),
  performance: z.optional(
    z
      .enum(['Speed', 'Quality', 'Extreme Speed', 'Lightning'])
      .register(z.globalRegistry, {
        description: '\n            You can choose Speed or Quality\n        ',
      }),
  ),
  styles: z
    .optional(
      z
        .array(
          z.enum([
            'Fooocus V2',
            'Fooocus Enhance',
            'Fooocus Sharp',
            'Fooocus Semi Realistic',
            'Fooocus Masterpiece',
            'Fooocus Photograph',
            'Fooocus Negative',
            'Fooocus Cinematic',
            'SAI 3D Model',
            'SAI Analog Film',
            'SAI Anime',
            'SAI Cinematic',
            'SAI Comic Book',
            'SAI Craft Clay',
            'SAI Digital Art',
            'SAI Enhance',
            'SAI Fantasy Art',
            'SAI Isometric',
            'SAI Line Art',
            'SAI Lowpoly',
            'SAI Neonpunk',
            'SAI Origami',
            'SAI Photographic',
            'SAI Pixel Art',
            'SAI Texture',
            'MRE Cinematic Dynamic',
            'MRE Spontaneous Picture',
            'MRE Artistic Vision',
            'MRE Dark Dream',
            'MRE Gloomy Art',
            'MRE Bad Dream',
            'MRE Underground',
            'MRE Surreal Painting',
            'MRE Dynamic Illustration',
            'MRE Undead Art',
            'MRE Elemental Art',
            'MRE Space Art',
            'MRE Ancient Illustration',
            'MRE Brave Art',
            'MRE Heroic Fantasy',
            'MRE Dark Cyberpunk',
            'MRE Lyrical Geometry',
            'MRE Sumi E Symbolic',
            'MRE Sumi E Detailed',
            'MRE Manga',
            'MRE Anime',
            'MRE Comic',
            'Ads Advertising',
            'Ads Automotive',
            'Ads Corporate',
            'Ads Fashion Editorial',
            'Ads Food Photography',
            'Ads Gourmet Food Photography',
            'Ads Luxury',
            'Ads Real Estate',
            'Ads Retail',
            'Artstyle Abstract',
            'Artstyle Abstract Expressionism',
            'Artstyle Art Deco',
            'Artstyle Art Nouveau',
            'Artstyle Constructivist',
            'Artstyle Cubist',
            'Artstyle Expressionist',
            'Artstyle Graffiti',
            'Artstyle Hyperrealism',
            'Artstyle Impressionist',
            'Artstyle Pointillism',
            'Artstyle Pop Art',
            'Artstyle Psychedelic',
            'Artstyle Renaissance',
            'Artstyle Steampunk',
            'Artstyle Surrealist',
            'Artstyle Typography',
            'Artstyle Watercolor',
            'Futuristic Biomechanical',
            'Futuristic Biomechanical Cyberpunk',
            'Futuristic Cybernetic',
            'Futuristic Cybernetic Robot',
            'Futuristic Cyberpunk Cityscape',
            'Futuristic Futuristic',
            'Futuristic Retro Cyberpunk',
            'Futuristic Retro Futurism',
            'Futuristic Sci Fi',
            'Futuristic Vaporwave',
            'Game Bubble Bobble',
            'Game Cyberpunk Game',
            'Game Fighting Game',
            'Game Gta',
            'Game Mario',
            'Game Minecraft',
            'Game Pokemon',
            'Game Retro Arcade',
            'Game Retro Game',
            'Game Rpg Fantasy Game',
            'Game Strategy Game',
            'Game Streetfighter',
            'Game Zelda',
            'Misc Architectural',
            'Misc Disco',
            'Misc Dreamscape',
            'Misc Dystopian',
            'Misc Fairy Tale',
            'Misc Gothic',
            'Misc Grunge',
            'Misc Horror',
            'Misc Kawaii',
            'Misc Lovecraftian',
            'Misc Macabre',
            'Misc Manga',
            'Misc Metropolis',
            'Misc Minimalist',
            'Misc Monochrome',
            'Misc Nautical',
            'Misc Space',
            'Misc Stained Glass',
            'Misc Techwear Fashion',
            'Misc Tribal',
            'Misc Zentangle',
            'Papercraft Collage',
            'Papercraft Flat Papercut',
            'Papercraft Kirigami',
            'Papercraft Paper Mache',
            'Papercraft Paper Quilling',
            'Papercraft Papercut Collage',
            'Papercraft Papercut Shadow Box',
            'Papercraft Stacked Papercut',
            'Papercraft Thick Layered Papercut',
            'Photo Alien',
            'Photo Film Noir',
            'Photo Glamour',
            'Photo Hdr',
            'Photo Iphone Photographic',
            'Photo Long Exposure',
            'Photo Neon Noir',
            'Photo Silhouette',
            'Photo Tilt Shift',
            'Cinematic Diva',
            'Abstract Expressionism',
            'Academia',
            'Action Figure',
            'Adorable 3D Character',
            'Adorable Kawaii',
            'Art Deco',
            'Art Nouveau',
            'Astral Aura',
            'Avant Garde',
            'Baroque',
            'Bauhaus Style Poster',
            'Blueprint Schematic Drawing',
            'Caricature',
            'Cel Shaded Art',
            'Character Design Sheet',
            'Classicism Art',
            'Color Field Painting',
            'Colored Pencil Art',
            'Conceptual Art',
            'Constructivism',
            'Cubism',
            'Dadaism',
            'Dark Fantasy',
            'Dark Moody Atmosphere',
            'Dmt Art Style',
            'Doodle Art',
            'Double Exposure',
            'Dripping Paint Splatter Art',
            'Expressionism',
            'Faded Polaroid Photo',
            'Fauvism',
            'Flat 2d Art',
            'Fortnite Art Style',
            'Futurism',
            'Glitchcore',
            'Glo Fi',
            'Googie Art Style',
            'Graffiti Art',
            'Harlem Renaissance Art',
            'High Fashion',
            'Idyllic',
            'Impressionism',
            'Infographic Drawing',
            'Ink Dripping Drawing',
            'Japanese Ink Drawing',
            'Knolling Photography',
            'Light Cheery Atmosphere',
            'Logo Design',
            'Luxurious Elegance',
            'Macro Photography',
            'Mandola Art',
            'Marker Drawing',
            'Medievalism',
            'Minimalism',
            'Neo Baroque',
            'Neo Byzantine',
            'Neo Futurism',
            'Neo Impressionism',
            'Neo Rococo',
            'Neoclassicism',
            'Op Art',
            'Ornate And Intricate',
            'Pencil Sketch Drawing',
            'Pop Art 2',
            'Rococo',
            'Silhouette Art',
            'Simple Vector Art',
            'Sketchup',
            'Steampunk 2',
            'Surrealism',
            'Suprematism',
            'Terragen',
            'Tranquil Relaxing Atmosphere',
            'Sticker Designs',
            'Vibrant Rim Light',
            'Volumetric Lighting',
            'Watercolor 2',
            'Whimsical And Playful',
            'Mk Chromolithography',
            'Mk Cross Processing Print',
            'Mk Dufaycolor Photograph',
            'Mk Herbarium',
            'Mk Punk Collage',
            'Mk Mosaic',
            'Mk Van Gogh',
            'Mk Coloring Book',
            'Mk Singer Sargent',
            'Mk Pollock',
            'Mk Basquiat',
            'Mk Andy Warhol',
            'Mk Halftone Print',
            'Mk Gond Painting',
            'Mk Albumen Print',
            'Mk Aquatint Print',
            'Mk Anthotype Print',
            'Mk Inuit Carving',
            'Mk Bromoil Print',
            'Mk Calotype Print',
            'Mk Color Sketchnote',
            'Mk Cibulak Porcelain',
            'Mk Alcohol Ink Art',
            'Mk One Line Art',
            'Mk Blacklight Paint',
            'Mk Carnival Glass',
            'Mk Cyanotype Print',
            'Mk Cross Stitching',
            'Mk Encaustic Paint',
            'Mk Embroidery',
            'Mk Gyotaku',
            'Mk Luminogram',
            'Mk Lite Brite Art',
            'Mk Mokume Gane',
            'Pebble Art',
            'Mk Palekh',
            'Mk Suminagashi',
            'Mk Scrimshaw',
            'Mk Shibori',
            'Mk Vitreous Enamel',
            'Mk Ukiyo E',
            'Mk Vintage Airline Poster',
            'Mk Vintage Travel Poster',
            'Mk Bauhaus Style',
            'Mk Afrofuturism',
            'Mk Atompunk',
            'Mk Constructivism',
            'Mk Chicano Art',
            'Mk De Stijl',
            'Mk Dayak Art',
            'Mk Fayum Portrait',
            'Mk Illuminated Manuscript',
            'Mk Kalighat Painting',
            'Mk Madhubani Painting',
            'Mk Pictorialism',
            'Mk Pichwai Painting',
            'Mk Patachitra Painting',
            'Mk Samoan Art Inspired',
            'Mk Tlingit Art',
            'Mk Adnate Style',
            'Mk Ron English Style',
            'Mk Shepard Fairey Style',
          ]),
        )
        .register(z.globalRegistry, {
          description: '\n            The style to use.\n        ',
        }),
    )
    .default(['Fooocus Enhance', 'Fooocus V2', 'Fooocus Sharp']),
  control_type: z.optional(
    z
      .enum(['ImagePrompt', 'PyraCanny', 'CPDS', 'FaceSwap'])
      .register(z.globalRegistry, {
        description: 'The type of image control',
      }),
  ),
  mask_image_url: z.optional(z.union([z.string(), z.null()])),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use up to 5 LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([
      {
        path: 'https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0/resolve/main/sd_xl_offset_example-lora_1.0.safetensors',
        scale: 0.1,
      },
    ]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to false, the safety checker will be disabled.',
      }),
    )
    .default(true),
  sharpness: z
    .optional(
      z.number().gte(0).lte(30).register(z.globalRegistry, {
        description:
          '\n            The sharpness of the generated image. Use it to control how sharp the generated\n            image should be. Higher value means image and texture are sharper.\n        ',
      }),
    )
    .default(2),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(30).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  inpaint_image_url: z.optional(z.union([z.string(), z.null()])),
  mixing_image_prompt_and_inpaint: z.optional(z.boolean()).default(false),
  aspect_ratio: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            The size of the generated image. You can choose between some presets or\n            custom height and width that **must be multiples of 8**.\n        ',
      }),
    )
    .default('1024x1024'),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          '\n            Number of images to generate in one request\n        ',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  refiner_model: z.optional(
    z
      .enum(['None', 'realisticVisionV60B1_v51VAE.safetensors'])
      .register(z.globalRegistry, {
        description: 'Refiner (SDXL or SD 1.5)',
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  control_image_url: z.optional(z.union([z.string(), z.null()])),
  seed: z.optional(z.union([z.int(), z.null()])),
  refiner_switch: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            Use 0.4 for SD1.5 realistic models; 0.667 for SD1.5 anime models\n            0.8 for XL-refiners; or any value for switching two SDXL models.\n        ',
      }),
    )
    .default(0.8),
  control_image_weight: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description:
          '\n            The strength of the control image. Use it to control how much the generated image\n            should look like the control image.\n        ',
      }),
    )
    .default(1),
  control_image_stop_at: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The stop at value of the control image. Use it to control how much the generated image\n            should look like the control image.\n        ',
      }),
    )
    .default(1),
})

/**
 * DiffusionEdgeOutput
 */
export const zSchemaDiffusionEdgeOutput = z.object({
  image: zSchemaImage,
})

/**
 * DiffusionEdgeInput
 */
export const zSchemaDiffusionEdgeInput = z.object({
  image_url: z.string().register(z.globalRegistry, {
    description: 'The text prompt you would like to convert to speech.',
  }),
})

/**
 * LCMOutput
 */
export const zSchemaLcmOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  timings: z.record(z.string(), z.number()),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  num_inference_steps: z
    .optional(
      z.int().register(z.globalRegistry, {
        description:
          '\n            Number of inference steps used to generate the image. It will be the same value of the one passed in the\n            input or the default one in case none was passed.\n        ',
      }),
    )
    .default(4),
  nsfw_content_detected: z.array(z.boolean()).register(z.globalRegistry, {
    description:
      '\n            A list of booleans indicating whether the generated image contains any\n            potentially unsafe content. If the safety check is disabled, this field\n            will all will be false.\n        ',
  }),
})

/**
 * LCMInput
 */
export const zSchemaLcmInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  controlnet_inpaint: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the inpainting pipeline will use controlnet inpainting.\n            Only effective for inpainting pipelines.\n        ',
      }),
    )
    .default(false),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  enable_safety_checks: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the resulting image will be checked whether it includes any\n            potentially unsafe content. If it does, it will be replaced with a black\n            image.\n        ',
      }),
    )
    .default(true),
  model: z.optional(
    z.enum(['sdxl', 'sdv1-5']).register(z.globalRegistry, {
      description: 'The model to use for generating the image.',
    }),
  ),
  lora_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The url of the lora server to use for image generation.\n        ',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(8).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(1),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  inpaint_mask_only: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the inpainting pipeline will only inpaint the provided mask\n            area. Only effective for inpainting pipelines.\n        ',
      }),
    )
    .default(false),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description:
          '\n            The number of images to generate. The function will return a list of images\n            with the same prompt and negative prompt but different seeds.\n        ',
      }),
    )
    .default(1),
  lora_scale: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          '\n            The scale of the lora server to use for image generation.\n        ',
      }),
    )
    .default(1),
  image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n        The base image to use for guiding the image generation on image-to-image\n        generations. If the either width or height of the image is larger than 1024\n        pixels, the image will be resized to 1024 pixels while keeping the aspect ratio.\n        ',
    }),
  ),
  strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n        The strength of the image that is passed as `image_url`. The strength\n        determines how much the generated image will be similar to the image passed as\n        `image_url`. The higher the strength the more model gets "creative" and\n        generates an image that\'s different from the initial image. A strength of 1.0\n        means that the initial image is more or less ignored and the model will try to\n        generate an image that\'s as close as possible to the prompt.\n        ',
      }),
    )
    .default(0.8),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  mask_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n        The mask to use for guiding the image generation on image\n        inpainting. The model will focus on the mask area and try to fill it with\n        the most relevant content.\n\n        The mask must be a black and white image where the white area is the area\n        that needs to be filled and the black area is the area that should be\n        ignored.\n\n        The mask must have the same dimensions as the image passed as `image_url`.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(12).register(z.globalRegistry, {
        description:
          '\n            The number of inference steps to use for generating the image. The more steps\n            the better the image will be but it will also take longer to generate.\n        ',
      }),
    )
    .default(4),
})

/**
 * FooocusOutput
 */
export const zSchemaFooocusInpaintOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image file info.',
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'The time taken for the generation process.',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
})

/**
 * ImagePrompt
 */
export const zSchemaImagePrompt = z.object({
  weight: z.optional(z.number().gte(0).lte(2)).default(1),
  stop_at: z.optional(z.number().gte(0).lte(1)).default(0.5),
  type: z.optional(z.enum(['ImagePrompt', 'PyraCanny', 'CPDS', 'FaceSwap'])),
  image_url: z.optional(z.string()),
})

/**
 * FooocusInpaintInput
 */
export const zSchemaFooocusInpaintInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The prompt to use for generating the image. Be as descriptive as possible for best results.',
      }),
    )
    .default(''),
  performance: z.optional(
    z
      .enum(['Speed', 'Quality', 'Extreme Speed', 'Lightning'])
      .register(z.globalRegistry, {
        description: '\n            You can choose Speed or Quality\n        ',
      }),
  ),
  styles: z
    .optional(
      z
        .array(
          z.enum([
            'Fooocus V2',
            'Fooocus Enhance',
            'Fooocus Sharp',
            'Fooocus Semi Realistic',
            'Fooocus Masterpiece',
            'Fooocus Photograph',
            'Fooocus Negative',
            'Fooocus Cinematic',
            'SAI 3D Model',
            'SAI Analog Film',
            'SAI Anime',
            'SAI Cinematic',
            'SAI Comic Book',
            'SAI Craft Clay',
            'SAI Digital Art',
            'SAI Enhance',
            'SAI Fantasy Art',
            'SAI Isometric',
            'SAI Line Art',
            'SAI Lowpoly',
            'SAI Neonpunk',
            'SAI Origami',
            'SAI Photographic',
            'SAI Pixel Art',
            'SAI Texture',
            'MRE Cinematic Dynamic',
            'MRE Spontaneous Picture',
            'MRE Artistic Vision',
            'MRE Dark Dream',
            'MRE Gloomy Art',
            'MRE Bad Dream',
            'MRE Underground',
            'MRE Surreal Painting',
            'MRE Dynamic Illustration',
            'MRE Undead Art',
            'MRE Elemental Art',
            'MRE Space Art',
            'MRE Ancient Illustration',
            'MRE Brave Art',
            'MRE Heroic Fantasy',
            'MRE Dark Cyberpunk',
            'MRE Lyrical Geometry',
            'MRE Sumi E Symbolic',
            'MRE Sumi E Detailed',
            'MRE Manga',
            'MRE Anime',
            'MRE Comic',
            'Ads Advertising',
            'Ads Automotive',
            'Ads Corporate',
            'Ads Fashion Editorial',
            'Ads Food Photography',
            'Ads Gourmet Food Photography',
            'Ads Luxury',
            'Ads Real Estate',
            'Ads Retail',
            'Artstyle Abstract',
            'Artstyle Abstract Expressionism',
            'Artstyle Art Deco',
            'Artstyle Art Nouveau',
            'Artstyle Constructivist',
            'Artstyle Cubist',
            'Artstyle Expressionist',
            'Artstyle Graffiti',
            'Artstyle Hyperrealism',
            'Artstyle Impressionist',
            'Artstyle Pointillism',
            'Artstyle Pop Art',
            'Artstyle Psychedelic',
            'Artstyle Renaissance',
            'Artstyle Steampunk',
            'Artstyle Surrealist',
            'Artstyle Typography',
            'Artstyle Watercolor',
            'Futuristic Biomechanical',
            'Futuristic Biomechanical Cyberpunk',
            'Futuristic Cybernetic',
            'Futuristic Cybernetic Robot',
            'Futuristic Cyberpunk Cityscape',
            'Futuristic Futuristic',
            'Futuristic Retro Cyberpunk',
            'Futuristic Retro Futurism',
            'Futuristic Sci Fi',
            'Futuristic Vaporwave',
            'Game Bubble Bobble',
            'Game Cyberpunk Game',
            'Game Fighting Game',
            'Game Gta',
            'Game Mario',
            'Game Minecraft',
            'Game Pokemon',
            'Game Retro Arcade',
            'Game Retro Game',
            'Game Rpg Fantasy Game',
            'Game Strategy Game',
            'Game Streetfighter',
            'Game Zelda',
            'Misc Architectural',
            'Misc Disco',
            'Misc Dreamscape',
            'Misc Dystopian',
            'Misc Fairy Tale',
            'Misc Gothic',
            'Misc Grunge',
            'Misc Horror',
            'Misc Kawaii',
            'Misc Lovecraftian',
            'Misc Macabre',
            'Misc Manga',
            'Misc Metropolis',
            'Misc Minimalist',
            'Misc Monochrome',
            'Misc Nautical',
            'Misc Space',
            'Misc Stained Glass',
            'Misc Techwear Fashion',
            'Misc Tribal',
            'Misc Zentangle',
            'Papercraft Collage',
            'Papercraft Flat Papercut',
            'Papercraft Kirigami',
            'Papercraft Paper Mache',
            'Papercraft Paper Quilling',
            'Papercraft Papercut Collage',
            'Papercraft Papercut Shadow Box',
            'Papercraft Stacked Papercut',
            'Papercraft Thick Layered Papercut',
            'Photo Alien',
            'Photo Film Noir',
            'Photo Glamour',
            'Photo Hdr',
            'Photo Iphone Photographic',
            'Photo Long Exposure',
            'Photo Neon Noir',
            'Photo Silhouette',
            'Photo Tilt Shift',
            'Cinematic Diva',
            'Abstract Expressionism',
            'Academia',
            'Action Figure',
            'Adorable 3D Character',
            'Adorable Kawaii',
            'Art Deco',
            'Art Nouveau',
            'Astral Aura',
            'Avant Garde',
            'Baroque',
            'Bauhaus Style Poster',
            'Blueprint Schematic Drawing',
            'Caricature',
            'Cel Shaded Art',
            'Character Design Sheet',
            'Classicism Art',
            'Color Field Painting',
            'Colored Pencil Art',
            'Conceptual Art',
            'Constructivism',
            'Cubism',
            'Dadaism',
            'Dark Fantasy',
            'Dark Moody Atmosphere',
            'Dmt Art Style',
            'Doodle Art',
            'Double Exposure',
            'Dripping Paint Splatter Art',
            'Expressionism',
            'Faded Polaroid Photo',
            'Fauvism',
            'Flat 2d Art',
            'Fortnite Art Style',
            'Futurism',
            'Glitchcore',
            'Glo Fi',
            'Googie Art Style',
            'Graffiti Art',
            'Harlem Renaissance Art',
            'High Fashion',
            'Idyllic',
            'Impressionism',
            'Infographic Drawing',
            'Ink Dripping Drawing',
            'Japanese Ink Drawing',
            'Knolling Photography',
            'Light Cheery Atmosphere',
            'Logo Design',
            'Luxurious Elegance',
            'Macro Photography',
            'Mandola Art',
            'Marker Drawing',
            'Medievalism',
            'Minimalism',
            'Neo Baroque',
            'Neo Byzantine',
            'Neo Futurism',
            'Neo Impressionism',
            'Neo Rococo',
            'Neoclassicism',
            'Op Art',
            'Ornate And Intricate',
            'Pencil Sketch Drawing',
            'Pop Art 2',
            'Rococo',
            'Silhouette Art',
            'Simple Vector Art',
            'Sketchup',
            'Steampunk 2',
            'Surrealism',
            'Suprematism',
            'Terragen',
            'Tranquil Relaxing Atmosphere',
            'Sticker Designs',
            'Vibrant Rim Light',
            'Volumetric Lighting',
            'Watercolor 2',
            'Whimsical And Playful',
            'Mk Chromolithography',
            'Mk Cross Processing Print',
            'Mk Dufaycolor Photograph',
            'Mk Herbarium',
            'Mk Punk Collage',
            'Mk Mosaic',
            'Mk Van Gogh',
            'Mk Coloring Book',
            'Mk Singer Sargent',
            'Mk Pollock',
            'Mk Basquiat',
            'Mk Andy Warhol',
            'Mk Halftone Print',
            'Mk Gond Painting',
            'Mk Albumen Print',
            'Mk Aquatint Print',
            'Mk Anthotype Print',
            'Mk Inuit Carving',
            'Mk Bromoil Print',
            'Mk Calotype Print',
            'Mk Color Sketchnote',
            'Mk Cibulak Porcelain',
            'Mk Alcohol Ink Art',
            'Mk One Line Art',
            'Mk Blacklight Paint',
            'Mk Carnival Glass',
            'Mk Cyanotype Print',
            'Mk Cross Stitching',
            'Mk Encaustic Paint',
            'Mk Embroidery',
            'Mk Gyotaku',
            'Mk Luminogram',
            'Mk Lite Brite Art',
            'Mk Mokume Gane',
            'Pebble Art',
            'Mk Palekh',
            'Mk Suminagashi',
            'Mk Scrimshaw',
            'Mk Shibori',
            'Mk Vitreous Enamel',
            'Mk Ukiyo E',
            'Mk Vintage Airline Poster',
            'Mk Vintage Travel Poster',
            'Mk Bauhaus Style',
            'Mk Afrofuturism',
            'Mk Atompunk',
            'Mk Constructivism',
            'Mk Chicano Art',
            'Mk De Stijl',
            'Mk Dayak Art',
            'Mk Fayum Portrait',
            'Mk Illuminated Manuscript',
            'Mk Kalighat Painting',
            'Mk Madhubani Painting',
            'Mk Pictorialism',
            'Mk Pichwai Painting',
            'Mk Patachitra Painting',
            'Mk Samoan Art Inspired',
            'Mk Tlingit Art',
            'Mk Adnate Style',
            'Mk Ron English Style',
            'Mk Shepard Fairey Style',
          ]),
        )
        .register(z.globalRegistry, {
          description: '\n            The style to use.\n        ',
        }),
    )
    .default(['Fooocus Enhance', 'Fooocus V2', 'Fooocus Sharp']),
  image_prompt_3: z.optional(zSchemaImagePrompt),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use up to 5 LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([
      {
        path: 'https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0/resolve/main/sd_xl_offset_example-lora_1.0.safetensors',
        scale: 0.1,
      },
    ]),
  image_prompt_4: z.optional(zSchemaImagePrompt),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(30).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4),
  sharpness: z
    .optional(
      z.number().gte(0).lte(30).register(z.globalRegistry, {
        description:
          '\n            The sharpness of the generated image. Use it to control how sharp the generated\n            image should be. Higher value means image and texture are sharper.\n        ',
      }),
    )
    .default(2),
  mixing_image_prompt_and_inpaint: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Mixing Image Prompt and Inpaint',
      }),
    )
    .default(false),
  outpaint_selections: z
    .optional(
      z
        .array(z.enum(['Left', 'Right', 'Top', 'Bottom']))
        .register(z.globalRegistry, {
          description: 'The directions to outpaint.',
        }),
    )
    .default([]),
  inpaint_image_url: z.string().register(z.globalRegistry, {
    description: 'The image to use as a reference for inpainting.',
  }),
  refiner_model: z.optional(
    z
      .enum(['None', 'realisticVisionV60B1_v51VAE.safetensors'])
      .register(z.globalRegistry, {
        description: 'Refiner (SDXL or SD 1.5)',
      }),
  ),
  output_format: z.optional(
    z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_prompt_2: z.optional(zSchemaImagePrompt),
  inpaint_respective_field: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The area to inpaint. Value 0 is same as "Only Masked" in A1111. Value 1 is\n            same as "Whole Image" in A1111. Only used in inpaint, not used in outpaint.\n            (Outpaint always use 1.0)\n        ',
      }),
    )
    .default(0.618),
  inpaint_mode: z.optional(
    z
      .enum([
        'Inpaint or Outpaint (default)',
        'Improve Detail (face, hand, eyes, etc.)',
        'Modify Content (add objects, change background, etc.)',
      ])
      .register(z.globalRegistry, {
        description: 'The mode to use for inpainting.',
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.null()])),
  refiner_switch: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            Use 0.4 for SD1.5 realistic models; 0.667 for SD1.5 anime models\n            0.8 for XL-refiners; or any value for switching two SDXL models.\n        ',
      }),
    )
    .default(0.8),
  inpaint_disable_initial_latent: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the initial preprocessing will be disabled.',
      }),
    )
    .default(false),
  mask_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The image to use as a mask for the generated image.',
    }),
  ),
  invert_mask: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the mask will be inverted.',
      }),
    )
    .default(false),
  image_prompt_1: z.optional(zSchemaImagePrompt),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to false, the safety checker will be disabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          '\n            Number of images to generate in one request\n        ',
      }),
    )
    .default(1),
  aspect_ratio: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            The size of the generated image. You can choose between some presets or\n            custom height and width that **must be multiples of 8**.\n        ',
      }),
    )
    .default('1024x1024'),
  inpaint_additional_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Describe what you want to inpaint.',
      }),
    )
    .default(''),
  inpaint_strength: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          '\n            Same as the denoising strength in A1111 inpaint. Only used in inpaint, not\n            used in outpaint. (Outpaint always use 1.0)\n        ',
      }),
    )
    .default(1),
  override_inpaint_options: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "\n            If set to true, the advanced inpaint options ('inpaint_disable_initial_latent',\n            'inpaint_engine', 'inpaint_strength', 'inpaint_respective_field',\n            'inpaint_erode_or_dilate') will be overridden.\n            Otherwise, the default values will be used.\n        ",
      }),
    )
    .default(false),
  inpaint_engine: z.optional(
    z.enum(['None', 'v1', 'v2.5', 'v2.6']).register(z.globalRegistry, {
      description: 'Version of Fooocus inpaint model',
    }),
  ),
  inpaint_erode_or_dilate: z
    .optional(
      z.number().gte(-64).lte(64).register(z.globalRegistry, {
        description:
          '\n            Positive value will make white area in the mask larger, negative value will\n            make white area smaller. (default is 0, always process before any mask\n            invert)\n        ',
      }),
    )
    .default(0),
})

/**
 * FooocusOutput
 */
export const zSchemaFooocusImagePromptOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image file info.',
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'The time taken for the generation process.',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
})

/**
 * FooocusImagePromptInput
 */
export const zSchemaFooocusImagePromptInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The prompt to use for generating the image. Be as descriptive as possible for best results.',
      }),
    )
    .default(''),
  uov_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The image to upscale or vary.',
    }),
  ),
  performance: z.optional(
    z
      .enum(['Speed', 'Quality', 'Extreme Speed', 'Lightning'])
      .register(z.globalRegistry, {
        description: '\n            You can choose Speed or Quality\n        ',
      }),
  ),
  image_prompt_3: z.optional(zSchemaImagePrompt),
  styles: z
    .optional(
      z
        .array(
          z.enum([
            'Fooocus V2',
            'Fooocus Enhance',
            'Fooocus Sharp',
            'Fooocus Semi Realistic',
            'Fooocus Masterpiece',
            'Fooocus Photograph',
            'Fooocus Negative',
            'Fooocus Cinematic',
            'SAI 3D Model',
            'SAI Analog Film',
            'SAI Anime',
            'SAI Cinematic',
            'SAI Comic Book',
            'SAI Craft Clay',
            'SAI Digital Art',
            'SAI Enhance',
            'SAI Fantasy Art',
            'SAI Isometric',
            'SAI Line Art',
            'SAI Lowpoly',
            'SAI Neonpunk',
            'SAI Origami',
            'SAI Photographic',
            'SAI Pixel Art',
            'SAI Texture',
            'MRE Cinematic Dynamic',
            'MRE Spontaneous Picture',
            'MRE Artistic Vision',
            'MRE Dark Dream',
            'MRE Gloomy Art',
            'MRE Bad Dream',
            'MRE Underground',
            'MRE Surreal Painting',
            'MRE Dynamic Illustration',
            'MRE Undead Art',
            'MRE Elemental Art',
            'MRE Space Art',
            'MRE Ancient Illustration',
            'MRE Brave Art',
            'MRE Heroic Fantasy',
            'MRE Dark Cyberpunk',
            'MRE Lyrical Geometry',
            'MRE Sumi E Symbolic',
            'MRE Sumi E Detailed',
            'MRE Manga',
            'MRE Anime',
            'MRE Comic',
            'Ads Advertising',
            'Ads Automotive',
            'Ads Corporate',
            'Ads Fashion Editorial',
            'Ads Food Photography',
            'Ads Gourmet Food Photography',
            'Ads Luxury',
            'Ads Real Estate',
            'Ads Retail',
            'Artstyle Abstract',
            'Artstyle Abstract Expressionism',
            'Artstyle Art Deco',
            'Artstyle Art Nouveau',
            'Artstyle Constructivist',
            'Artstyle Cubist',
            'Artstyle Expressionist',
            'Artstyle Graffiti',
            'Artstyle Hyperrealism',
            'Artstyle Impressionist',
            'Artstyle Pointillism',
            'Artstyle Pop Art',
            'Artstyle Psychedelic',
            'Artstyle Renaissance',
            'Artstyle Steampunk',
            'Artstyle Surrealist',
            'Artstyle Typography',
            'Artstyle Watercolor',
            'Futuristic Biomechanical',
            'Futuristic Biomechanical Cyberpunk',
            'Futuristic Cybernetic',
            'Futuristic Cybernetic Robot',
            'Futuristic Cyberpunk Cityscape',
            'Futuristic Futuristic',
            'Futuristic Retro Cyberpunk',
            'Futuristic Retro Futurism',
            'Futuristic Sci Fi',
            'Futuristic Vaporwave',
            'Game Bubble Bobble',
            'Game Cyberpunk Game',
            'Game Fighting Game',
            'Game Gta',
            'Game Mario',
            'Game Minecraft',
            'Game Pokemon',
            'Game Retro Arcade',
            'Game Retro Game',
            'Game Rpg Fantasy Game',
            'Game Strategy Game',
            'Game Streetfighter',
            'Game Zelda',
            'Misc Architectural',
            'Misc Disco',
            'Misc Dreamscape',
            'Misc Dystopian',
            'Misc Fairy Tale',
            'Misc Gothic',
            'Misc Grunge',
            'Misc Horror',
            'Misc Kawaii',
            'Misc Lovecraftian',
            'Misc Macabre',
            'Misc Manga',
            'Misc Metropolis',
            'Misc Minimalist',
            'Misc Monochrome',
            'Misc Nautical',
            'Misc Space',
            'Misc Stained Glass',
            'Misc Techwear Fashion',
            'Misc Tribal',
            'Misc Zentangle',
            'Papercraft Collage',
            'Papercraft Flat Papercut',
            'Papercraft Kirigami',
            'Papercraft Paper Mache',
            'Papercraft Paper Quilling',
            'Papercraft Papercut Collage',
            'Papercraft Papercut Shadow Box',
            'Papercraft Stacked Papercut',
            'Papercraft Thick Layered Papercut',
            'Photo Alien',
            'Photo Film Noir',
            'Photo Glamour',
            'Photo Hdr',
            'Photo Iphone Photographic',
            'Photo Long Exposure',
            'Photo Neon Noir',
            'Photo Silhouette',
            'Photo Tilt Shift',
            'Cinematic Diva',
            'Abstract Expressionism',
            'Academia',
            'Action Figure',
            'Adorable 3D Character',
            'Adorable Kawaii',
            'Art Deco',
            'Art Nouveau',
            'Astral Aura',
            'Avant Garde',
            'Baroque',
            'Bauhaus Style Poster',
            'Blueprint Schematic Drawing',
            'Caricature',
            'Cel Shaded Art',
            'Character Design Sheet',
            'Classicism Art',
            'Color Field Painting',
            'Colored Pencil Art',
            'Conceptual Art',
            'Constructivism',
            'Cubism',
            'Dadaism',
            'Dark Fantasy',
            'Dark Moody Atmosphere',
            'Dmt Art Style',
            'Doodle Art',
            'Double Exposure',
            'Dripping Paint Splatter Art',
            'Expressionism',
            'Faded Polaroid Photo',
            'Fauvism',
            'Flat 2d Art',
            'Fortnite Art Style',
            'Futurism',
            'Glitchcore',
            'Glo Fi',
            'Googie Art Style',
            'Graffiti Art',
            'Harlem Renaissance Art',
            'High Fashion',
            'Idyllic',
            'Impressionism',
            'Infographic Drawing',
            'Ink Dripping Drawing',
            'Japanese Ink Drawing',
            'Knolling Photography',
            'Light Cheery Atmosphere',
            'Logo Design',
            'Luxurious Elegance',
            'Macro Photography',
            'Mandola Art',
            'Marker Drawing',
            'Medievalism',
            'Minimalism',
            'Neo Baroque',
            'Neo Byzantine',
            'Neo Futurism',
            'Neo Impressionism',
            'Neo Rococo',
            'Neoclassicism',
            'Op Art',
            'Ornate And Intricate',
            'Pencil Sketch Drawing',
            'Pop Art 2',
            'Rococo',
            'Silhouette Art',
            'Simple Vector Art',
            'Sketchup',
            'Steampunk 2',
            'Surrealism',
            'Suprematism',
            'Terragen',
            'Tranquil Relaxing Atmosphere',
            'Sticker Designs',
            'Vibrant Rim Light',
            'Volumetric Lighting',
            'Watercolor 2',
            'Whimsical And Playful',
            'Mk Chromolithography',
            'Mk Cross Processing Print',
            'Mk Dufaycolor Photograph',
            'Mk Herbarium',
            'Mk Punk Collage',
            'Mk Mosaic',
            'Mk Van Gogh',
            'Mk Coloring Book',
            'Mk Singer Sargent',
            'Mk Pollock',
            'Mk Basquiat',
            'Mk Andy Warhol',
            'Mk Halftone Print',
            'Mk Gond Painting',
            'Mk Albumen Print',
            'Mk Aquatint Print',
            'Mk Anthotype Print',
            'Mk Inuit Carving',
            'Mk Bromoil Print',
            'Mk Calotype Print',
            'Mk Color Sketchnote',
            'Mk Cibulak Porcelain',
            'Mk Alcohol Ink Art',
            'Mk One Line Art',
            'Mk Blacklight Paint',
            'Mk Carnival Glass',
            'Mk Cyanotype Print',
            'Mk Cross Stitching',
            'Mk Encaustic Paint',
            'Mk Embroidery',
            'Mk Gyotaku',
            'Mk Luminogram',
            'Mk Lite Brite Art',
            'Mk Mokume Gane',
            'Pebble Art',
            'Mk Palekh',
            'Mk Suminagashi',
            'Mk Scrimshaw',
            'Mk Shibori',
            'Mk Vitreous Enamel',
            'Mk Ukiyo E',
            'Mk Vintage Airline Poster',
            'Mk Vintage Travel Poster',
            'Mk Bauhaus Style',
            'Mk Afrofuturism',
            'Mk Atompunk',
            'Mk Constructivism',
            'Mk Chicano Art',
            'Mk De Stijl',
            'Mk Dayak Art',
            'Mk Fayum Portrait',
            'Mk Illuminated Manuscript',
            'Mk Kalighat Painting',
            'Mk Madhubani Painting',
            'Mk Pictorialism',
            'Mk Pichwai Painting',
            'Mk Patachitra Painting',
            'Mk Samoan Art Inspired',
            'Mk Tlingit Art',
            'Mk Adnate Style',
            'Mk Ron English Style',
            'Mk Shepard Fairey Style',
          ]),
        )
        .register(z.globalRegistry, {
          description: '\n            The style to use.\n        ',
        }),
    )
    .default(['Fooocus Enhance', 'Fooocus V2', 'Fooocus Sharp']),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use up to 5 LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([
      {
        path: 'https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0/resolve/main/sd_xl_offset_example-lora_1.0.safetensors',
        scale: 0.1,
      },
    ]),
  image_prompt_4: z.optional(zSchemaImagePrompt),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(30).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4),
  sharpness: z
    .optional(
      z.number().gte(0).lte(30).register(z.globalRegistry, {
        description:
          '\n            The sharpness of the generated image. Use it to control how sharp the generated\n            image should be. Higher value means image and texture are sharper.\n        ',
      }),
    )
    .default(2),
  mixing_image_prompt_and_inpaint: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Mixing Image Prompt and Inpaint',
      }),
    )
    .default(false),
  outpaint_selections: z
    .optional(
      z
        .array(z.enum(['Left', 'Right', 'Top', 'Bottom']))
        .register(z.globalRegistry, {
          description: 'The directions to outpaint.',
        }),
    )
    .default([]),
  inpaint_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The image to use as a reference for inpainting.',
    }),
  ),
  output_format: z.optional(
    z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  refiner_model: z.optional(
    z
      .enum(['None', 'realisticVisionV60B1_v51VAE.safetensors'])
      .register(z.globalRegistry, {
        description: 'Refiner (SDXL or SD 1.5)',
      }),
  ),
  image_prompt_2: z.optional(zSchemaImagePrompt),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  inpaint_mode: z.optional(
    z
      .enum([
        'Inpaint or Outpaint (default)',
        'Improve Detail (face, hand, eyes, etc.)',
        'Modify Content (add objects, change background, etc.)',
      ])
      .register(z.globalRegistry, {
        description: 'The mode to use for inpainting.',
      }),
  ),
  uov_method: z.optional(
    z
      .enum([
        'Disabled',
        'Vary (Subtle)',
        'Vary (Strong)',
        'Upscale (1.5x)',
        'Upscale (2x)',
        'Upscale (Fast 2x)',
      ])
      .register(z.globalRegistry, {
        description: 'The method to use for upscaling or varying.',
      }),
  ),
  seed: z.optional(z.union([z.int(), z.null()])),
  refiner_switch: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            Use 0.4 for SD1.5 realistic models; 0.667 for SD1.5 anime models\n            0.8 for XL-refiners; or any value for switching two SDXL models.\n        ',
      }),
    )
    .default(0.8),
  mixing_image_prompt_and_vary_upscale: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Mixing Image Prompt and Vary/Upscale',
      }),
    )
    .default(false),
  mask_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The image to use as a mask for the generated image.',
    }),
  ),
  image_prompt_1: zSchemaImagePrompt,
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to false, the safety checker will be disabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          '\n            Number of images to generate in one request\n        ',
      }),
    )
    .default(1),
  aspect_ratio: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            The size of the generated image. You can choose between some presets or\n            custom height and width that **must be multiples of 8**.\n        ',
      }),
    )
    .default('1024x1024'),
  inpaint_additional_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Describe what you want to inpaint.',
      }),
    )
    .default(''),
})

/**
 * IllusionDiffusionOutput
 */
export const zSchemaIllusionDiffusionOutput = z.object({
  image: zSchemaImage,
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * IllusionDiffusionInput
 */
export const zSchemaIllusionDiffusionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  controlnet_conditioning_scale: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'The scale of the ControlNet.',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description: 'Input image url.',
  }),
  scheduler: z.optional(
    z.enum(['DPM++ Karras SDE', 'Euler']).register(z.globalRegistry, {
      description:
        'Scheduler / sampler to use for the image denoising process.',
    }),
  ),
  control_guidance_start: z.optional(z.number().gte(0).lte(1)).default(0),
  guidance_scale: z
    .optional(
      z.number().lte(50).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(7.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
    }),
  ),
  control_guidance_end: z.optional(z.number().gte(0).lte(1)).default(1),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  num_inference_steps: z
    .optional(
      z.int().gte(0).lte(80).register(z.globalRegistry, {
        description:
          '\n            Increasing the amount of steps tells Stable Diffusion that it should take more steps\n            to generate your final result which can increase the amount of detail in your image.\n        ',
      }),
    )
    .default(40),
})

/**
 * Output
 */
export const zSchemaFastFooocusSdxlOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageFooocusInput
 */
export const zSchemaFastFooocusSdxlInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  enable_refiner: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, a smaller model will try to refine the output after it was processed.',
      }),
    )
    .default(true),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description: 'The list of embeddings to use.',
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(true),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The rescale factor for the CFG.',
      }),
    )
    .default(0),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(2),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(24).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaFastLcmDiffusionOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageLCMInput
 */
export const zSchemaFastLcmDiffusionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The rescale factor for the CFG.',
      }),
    )
    .default(0),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(1.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  model_name: z.optional(
    z
      .enum([
        'stabilityai/stable-diffusion-xl-base-1.0',
        'runwayml/stable-diffusion-v1-5',
      ])
      .register(z.globalRegistry, {
        description: 'The name of the model to use.',
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(true),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(32).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(6),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaFastSdxlControlnetCannyOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageControlNetInput
 */
export const zSchemaFastSdxlControlnetCannyInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
      z.null(),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description: 'The list of LoRA weights to use.',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(7.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  controlnet_conditioning_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The scale of the controlnet conditioning.',
      }),
    )
    .default(0.5),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  control_image_url: z.string().register(z.globalRegistry, {
    description: 'The URL of the control image.',
  }),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(25),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  enable_deep_cache: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, DeepCache will be enabled. TBD\n        ',
      }),
    )
    .default(false),
})

/**
 * Output
 */
export const zSchemaFastFooocusSdxlImageToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * ImageToImageFooocusInput
 */
export const zSchemaFastFooocusSdxlImageToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  enable_refiner: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, a smaller model will try to refine the output after it was processed.',
      }),
    )
    .default(true),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
      z.null(),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description: 'The list of embeddings to use.',
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(true),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The rescale factor for the CFG.',
      }),
    )
    .default(0),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(2),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use.Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The URL of the image to use as a starting point for the generation.',
  }),
  strength: z
    .optional(
      z.number().gte(0.05).lte(1).register(z.globalRegistry, {
        description:
          'determines how much the generated image resembles the initial image',
      }),
    )
    .default(0.95),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(24).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaFastLightningSdxlOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageLightningInput
 */
export const zSchemaFastLightningSdxlInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description: 'The list of embeddings to use.',
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The rescale factor for the CFG.',
      }),
    )
    .default(0),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z.optional(
    z.enum(['1', '2', '4', '8']).register(z.globalRegistry, {
      description: 'The number of inference steps to perform.',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
})

/**
 * Output
 */
export const zSchemaLayerDiffusionOutput = z.object({
  image: zSchemaImage,
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used to generate the image.',
  }),
})

/**
 * Input
 */
export const zSchemaLayerDiffusionInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The prompt to use for generating the image. Be as descriptive as possible for best results.',
      }),
    )
    .default(''),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'The guidance scale for the model.',
      }),
    )
    .default(8),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(40).register(z.globalRegistry, {
        description: 'The number of inference steps for the model.',
      }),
    )
    .default(20),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The prompt to use for generating the negative image. Be as descriptive as possible for best results.',
      }),
    )
    .default('text, watermark'),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to false, the safety checker will be disabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaStableDiffusionV15Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageSD15Input
 */
export const zSchemaStableDiffusionV15Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description: 'The list of embeddings to use.',
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description: 'The list of LoRA weights to use.',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(7.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(25),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaDreamshaperOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * DreamshaperTextToImageInput
 */
export const zSchemaDreamshaperInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description: 'The list of embeddings to use.',
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description: 'The list of LoRA weights to use.',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The negative prompt to use. Use it to address details that you don't want in the image.",
      }),
    )
    .default(
      '(worst quality, low quality, normal quality, lowres, low details, oversaturated, undersaturated, overexposed, underexposed, grayscale, bw, bad photo, bad photography, bad art:1.4), (watermark, signature, text font, username, error, logo, words, letters, digits, autograph, trademark, name:1.2), (blur, blurry, grainy), morbid, ugly, asymmetrical, mutated malformed, mutilated, poorly lit, bad shadow, draft, cropped, out of frame, cut off, censored, jpeg artifacts, out of focus, glitch, duplicate, (airbrushed, cartoon, anime, semi-realistic, cgi, render, blender, digital art, manga, amateur:1.3), (3D ,3D Game, 3D Game Scene, 3D Character:1.1), (bad hands, bad anatomy, bad body, bad face, bad teeth, bad arms, bad legs, deformities:1.3)',
    ),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  model_name: z.optional(
    z
      .enum([
        'Lykon/dreamshaper-xl-1-0',
        'Lykon/dreamshaper-xl-v2-turbo',
        'Lykon/dreamshaper-8',
      ])
      .register(z.globalRegistry, {
        description: 'The Dreamshaper model to use.',
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(70).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(35),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaRealisticVisionOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * RealisticVisionTextToImageInput
 */
export const zSchemaRealisticVisionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description: 'The list of embeddings to use.',
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description: 'The list of LoRA weights to use.',
      }),
    )
    .default([]),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The rescale factor for the CFG.',
      }),
    )
    .default(0),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The negative prompt to use. Use it to address details that you don't want in the image.",
      }),
    )
    .default(
      '(worst quality, low quality, normal quality, lowres, low details, oversaturated, undersaturated, overexposed, underexposed, grayscale, bw, bad photo, bad photography, bad art:1.4), (watermark, signature, text font, username, error, logo, words, letters, digits, autograph, trademark, name:1.2), (blur, blurry, grainy), morbid, ugly, asymmetrical, mutated malformed, mutilated, poorly lit, bad shadow, draft, cropped, out of frame, cut off, censored, jpeg artifacts, out of focus, glitch, duplicate, (airbrushed, cartoon, anime, semi-realistic, cgi, render, blender, digital art, manga, amateur:1.3), (3D ,3D Game, 3D Game Scene, 3D Character:1.1), (bad hands, bad anatomy, bad body, bad face, bad teeth, bad arms, bad legs, deformities:1.3)',
    ),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  model_name: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The Realistic Vision model to use.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(70).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(35),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaPlaygroundV25Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImagePlaygroundv25Input
 */
export const zSchemaPlaygroundV25Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description: 'The list of embeddings to use.',
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  guidance_rescale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The rescale factor for the CFG.',
      }),
    )
    .default(0),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(25),
})

/**
 * Output
 */
export const zSchemaLightningModelsOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * LightningModelsTextToImageInput
 */
export const zSchemaLightningModelsInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description: 'The list of embeddings to use.',
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description: 'The list of LoRA weights to use.',
      }),
    )
    .default([]),
  scheduler: z.optional(
    z
      .enum([
        'DPM++ 2M',
        'DPM++ 2M Karras',
        'DPM++ 2M SDE',
        'DPM++ 2M SDE Karras',
        'DPM++ SDE',
        'DPM++ SDE Karras',
        'KDPM 2A',
        'Euler',
        'Euler (trailing timesteps)',
        'Euler A',
        'LCM',
        'EDMDPMSolverMultistepScheduler',
        'TCDScheduler',
      ])
      .register(z.globalRegistry, {
        description:
          'Scheduler / sampler to use for the image denoising process.',
      }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(2),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "The negative prompt to use. Use it to address details that you don't want in the image.",
      }),
    )
    .default(
      '(worst quality, low quality, normal quality, lowres, low details, oversaturated, undersaturated, overexposed, underexposed, grayscale, bw, bad photo, bad photography, bad art:1.4), (watermark, signature, text font, username, error, logo, words, letters, digits, autograph, trademark, name:1.2), (blur, blurry, grainy), morbid, ugly, asymmetrical, mutated malformed, mutilated, poorly lit, bad shadow, draft, cropped, out of frame, cut off, censored, jpeg artifacts, out of focus, glitch, duplicate, (airbrushed, cartoon, anime, semi-realistic, cgi, render, blender, digital art, manga, amateur:1.3), (3D ,3D Game, 3D Game Scene, 3D Character:1.1), (bad hands, bad anatomy, bad body, bad face, bad teeth, bad arms, bad legs, deformities:1.3)',
    ),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  model_name: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The Lightning model to use.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(12).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * T2IOutput
 */
export const zSchemaLumaPhotonOutput = z.object({
  images: z.array(zSchemaFile).register(z.globalRegistry, {
    description: 'The generated image',
  }),
})

/**
 * TextToImageRequest
 */
export const zSchemaLumaPhotonInput = z.object({
  prompt: z.string().min(3).max(5000),
  aspect_ratio: z.optional(
    z
      .enum(['16:9', '9:16', '1:1', '4:3', '3:4', '21:9', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated video',
      }),
  ),
})

/**
 * Output
 */
export const zSchemaStableCascadeSoteDiffusionOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * SoteDiffusionInput
 */
export const zSchemaStableCascadeSoteDiffusionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  second_stage_guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(2),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the image will be returned as base64 encoded string.\n        ',
      }),
    )
    .default(false),
  first_stage_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: 'Number of steps to run the first stage for.',
      }),
    )
    .default(25),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Cascade\n            will output the same image every time.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to false, the safety checker will be disabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  second_stage_steps: z
    .optional(
      z.int().gte(4).lte(24).register(z.globalRegistry, {
        description: 'Number of steps to run the second stage for.',
      }),
    )
    .default(10),
})

/**
 * Output
 */
export const zSchemaFastSdxlOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * TextToImageInput
 */
export const zSchemaFastSdxlInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description: 'The list of embeddings to use.',
      }),
    )
    .default([]),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description: 'The list of LoRA weights to use.',
      }),
    )
    .default([]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(7.5),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(25),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaStableCascadeOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * StableCascadeInput
 */
export const zSchemaStableCascadeInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  second_stage_guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(0),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the image will be returned as base64 encoded string.\n        ',
      }),
    )
    .default(false),
  first_stage_steps: z
    .optional(
      z.int().gte(4).lte(40).register(z.globalRegistry, {
        description: 'Number of steps to run the first stage for.',
      }),
    )
    .default(20),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Cascade\n            will output the same image every time.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to false, the safety checker will be disabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  second_stage_steps: z
    .optional(
      z.int().gte(4).lte(24).register(z.globalRegistry, {
        description: 'Number of steps to run the second stage for.',
      }),
    )
    .default(10),
})

/**
 * Output
 */
export const zSchemaKolorsOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * KolorsInput
 */
export const zSchemaKolorsInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      '\n            The prompt to use for generating the image. Be as descriptive as possible\n            for best results.\n        ',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and\n            uploaded before returning the response. This will increase the latency of\n            the function but it allows you to get the image directly in the response\n            without going through the CDN.\n        ',
      }),
    )
    .default(false),
  scheduler: z.optional(
    z
      .enum([
        'EulerDiscreteScheduler',
        'EulerAncestralDiscreteScheduler',
        'DPMSolverMultistepScheduler',
        'DPMSolverMultistepScheduler_SDE_karras',
        'UniPCMultistepScheduler',
        'DEISMultistepScheduler',
      ])
      .register(z.globalRegistry, {
        description: 'The scheduler to use for the model.',
      }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show\n            you.\n        ',
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(150).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(50),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Seed',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small\n            details (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable safety checker.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaSdxlControlnetUnionOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageControlNetUnionInput
 */
export const zSchemaSdxlControlnetUnionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  depth_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to preprocess the depth image.',
      }),
    )
    .default(true),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
      z.null(),
    ]),
  ),
  normal_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL of the control image.',
    }),
  ),
  embeddings: z
    .optional(
      z.array(zSchemaEmbedding).register(z.globalRegistry, {
        description: 'The list of embeddings to use.',
      }),
    )
    .default([]),
  teed_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL of the control image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description: 'The list of LoRA weights to use.',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(7.5),
  canny_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL of the control image.',
    }),
  ),
  segmentation_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to preprocess the segmentation image.',
      }),
    )
    .default(true),
  format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  request_id: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            An id bound to a request, can be used with response to identify the request\n            itself.\n        ',
      }),
    )
    .default(''),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  segmentation_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL of the control image.',
    }),
  ),
  openpose_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL of the control image.',
    }),
  ),
  canny_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to preprocess the canny image.',
      }),
    )
    .default(true),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded with additional prompts.',
      }),
    )
    .default(false),
  depth_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The URL of the control image.',
    }),
  ),
  normal_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to preprocess the normal image.',
      }),
    )
    .default(true),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  teed_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to preprocess the teed image.',
      }),
    )
    .default(true),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  controlnet_conditioning_scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The scale of the controlnet conditioning.',
      }),
    )
    .default(0.5),
  safety_checker_version: z.optional(
    z.enum(['v1', 'v2']).register(z.globalRegistry, {
      description:
        'The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.',
    }),
  ),
  openpose_preprocess: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to preprocess the openpose image.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(70).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(35),
})

/**
 * PixArtSigmaOutput
 */
export const zSchemaPixartSigmaOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description:
      'The timings of the different steps of the generation process.',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * PixArtSigmaInput
 */
export const zSchemaPixartSigmaInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      'The prompt to use for generating the image. Be as descriptive as possible for best results.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  style: z.optional(
    z
      .enum([
        '(No style)',
        'Cinematic',
        'Photographic',
        'Anime',
        'Manga',
        'Digital Art',
        'Pixel art',
        'Fantasy art',
        'Neonpunk',
        '3D Model',
      ])
      .register(z.globalRegistry, {
        description: 'The style to apply to the image.',
      }),
  ),
  scheduler: z.optional(
    z.enum(['DPM-SOLVER', 'SA-SOLVER']).register(z.globalRegistry, {
      description: 'The scheduler to use for the model.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(5).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(35),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
})

/**
 * Output
 */
export const zSchemaFluxSubjectOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * FluxSubjectInput
 */
export const zSchemaFluxSubjectInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image of the subject',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaSanaOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaSanaInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  style_name: z.optional(
    z
      .enum([
        '(No style)',
        'Cinematic',
        'Photographic',
        'Anime',
        'Manga',
        'Digital Art',
        'Pixel art',
        'Fantasy art',
        'Neonpunk',
        '3D Model',
      ])
      .register(z.globalRegistry, {
        description: 'The style to generate the image in.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(18),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * FooocusOutput
 */
export const zSchemaFooocusUpscaleOrVaryOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image file info.',
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'The time taken for the generation process.',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
})

/**
 * FooocusUpscaleOrVaryInput
 */
export const zSchemaFooocusUpscaleOrVaryInput = z.object({
  styles: z
    .optional(
      z
        .array(
          z.enum([
            'Fooocus V2',
            'Fooocus Enhance',
            'Fooocus Sharp',
            'Fooocus Semi Realistic',
            'Fooocus Masterpiece',
            'Fooocus Photograph',
            'Fooocus Negative',
            'Fooocus Cinematic',
            'SAI 3D Model',
            'SAI Analog Film',
            'SAI Anime',
            'SAI Cinematic',
            'SAI Comic Book',
            'SAI Craft Clay',
            'SAI Digital Art',
            'SAI Enhance',
            'SAI Fantasy Art',
            'SAI Isometric',
            'SAI Line Art',
            'SAI Lowpoly',
            'SAI Neonpunk',
            'SAI Origami',
            'SAI Photographic',
            'SAI Pixel Art',
            'SAI Texture',
            'MRE Cinematic Dynamic',
            'MRE Spontaneous Picture',
            'MRE Artistic Vision',
            'MRE Dark Dream',
            'MRE Gloomy Art',
            'MRE Bad Dream',
            'MRE Underground',
            'MRE Surreal Painting',
            'MRE Dynamic Illustration',
            'MRE Undead Art',
            'MRE Elemental Art',
            'MRE Space Art',
            'MRE Ancient Illustration',
            'MRE Brave Art',
            'MRE Heroic Fantasy',
            'MRE Dark Cyberpunk',
            'MRE Lyrical Geometry',
            'MRE Sumi E Symbolic',
            'MRE Sumi E Detailed',
            'MRE Manga',
            'MRE Anime',
            'MRE Comic',
            'Ads Advertising',
            'Ads Automotive',
            'Ads Corporate',
            'Ads Fashion Editorial',
            'Ads Food Photography',
            'Ads Gourmet Food Photography',
            'Ads Luxury',
            'Ads Real Estate',
            'Ads Retail',
            'Artstyle Abstract',
            'Artstyle Abstract Expressionism',
            'Artstyle Art Deco',
            'Artstyle Art Nouveau',
            'Artstyle Constructivist',
            'Artstyle Cubist',
            'Artstyle Expressionist',
            'Artstyle Graffiti',
            'Artstyle Hyperrealism',
            'Artstyle Impressionist',
            'Artstyle Pointillism',
            'Artstyle Pop Art',
            'Artstyle Psychedelic',
            'Artstyle Renaissance',
            'Artstyle Steampunk',
            'Artstyle Surrealist',
            'Artstyle Typography',
            'Artstyle Watercolor',
            'Futuristic Biomechanical',
            'Futuristic Biomechanical Cyberpunk',
            'Futuristic Cybernetic',
            'Futuristic Cybernetic Robot',
            'Futuristic Cyberpunk Cityscape',
            'Futuristic Futuristic',
            'Futuristic Retro Cyberpunk',
            'Futuristic Retro Futurism',
            'Futuristic Sci Fi',
            'Futuristic Vaporwave',
            'Game Bubble Bobble',
            'Game Cyberpunk Game',
            'Game Fighting Game',
            'Game Gta',
            'Game Mario',
            'Game Minecraft',
            'Game Pokemon',
            'Game Retro Arcade',
            'Game Retro Game',
            'Game Rpg Fantasy Game',
            'Game Strategy Game',
            'Game Streetfighter',
            'Game Zelda',
            'Misc Architectural',
            'Misc Disco',
            'Misc Dreamscape',
            'Misc Dystopian',
            'Misc Fairy Tale',
            'Misc Gothic',
            'Misc Grunge',
            'Misc Horror',
            'Misc Kawaii',
            'Misc Lovecraftian',
            'Misc Macabre',
            'Misc Manga',
            'Misc Metropolis',
            'Misc Minimalist',
            'Misc Monochrome',
            'Misc Nautical',
            'Misc Space',
            'Misc Stained Glass',
            'Misc Techwear Fashion',
            'Misc Tribal',
            'Misc Zentangle',
            'Papercraft Collage',
            'Papercraft Flat Papercut',
            'Papercraft Kirigami',
            'Papercraft Paper Mache',
            'Papercraft Paper Quilling',
            'Papercraft Papercut Collage',
            'Papercraft Papercut Shadow Box',
            'Papercraft Stacked Papercut',
            'Papercraft Thick Layered Papercut',
            'Photo Alien',
            'Photo Film Noir',
            'Photo Glamour',
            'Photo Hdr',
            'Photo Iphone Photographic',
            'Photo Long Exposure',
            'Photo Neon Noir',
            'Photo Silhouette',
            'Photo Tilt Shift',
            'Cinematic Diva',
            'Abstract Expressionism',
            'Academia',
            'Action Figure',
            'Adorable 3D Character',
            'Adorable Kawaii',
            'Art Deco',
            'Art Nouveau',
            'Astral Aura',
            'Avant Garde',
            'Baroque',
            'Bauhaus Style Poster',
            'Blueprint Schematic Drawing',
            'Caricature',
            'Cel Shaded Art',
            'Character Design Sheet',
            'Classicism Art',
            'Color Field Painting',
            'Colored Pencil Art',
            'Conceptual Art',
            'Constructivism',
            'Cubism',
            'Dadaism',
            'Dark Fantasy',
            'Dark Moody Atmosphere',
            'Dmt Art Style',
            'Doodle Art',
            'Double Exposure',
            'Dripping Paint Splatter Art',
            'Expressionism',
            'Faded Polaroid Photo',
            'Fauvism',
            'Flat 2d Art',
            'Fortnite Art Style',
            'Futurism',
            'Glitchcore',
            'Glo Fi',
            'Googie Art Style',
            'Graffiti Art',
            'Harlem Renaissance Art',
            'High Fashion',
            'Idyllic',
            'Impressionism',
            'Infographic Drawing',
            'Ink Dripping Drawing',
            'Japanese Ink Drawing',
            'Knolling Photography',
            'Light Cheery Atmosphere',
            'Logo Design',
            'Luxurious Elegance',
            'Macro Photography',
            'Mandola Art',
            'Marker Drawing',
            'Medievalism',
            'Minimalism',
            'Neo Baroque',
            'Neo Byzantine',
            'Neo Futurism',
            'Neo Impressionism',
            'Neo Rococo',
            'Neoclassicism',
            'Op Art',
            'Ornate And Intricate',
            'Pencil Sketch Drawing',
            'Pop Art 2',
            'Rococo',
            'Silhouette Art',
            'Simple Vector Art',
            'Sketchup',
            'Steampunk 2',
            'Surrealism',
            'Suprematism',
            'Terragen',
            'Tranquil Relaxing Atmosphere',
            'Sticker Designs',
            'Vibrant Rim Light',
            'Volumetric Lighting',
            'Watercolor 2',
            'Whimsical And Playful',
            'Mk Chromolithography',
            'Mk Cross Processing Print',
            'Mk Dufaycolor Photograph',
            'Mk Herbarium',
            'Mk Punk Collage',
            'Mk Mosaic',
            'Mk Van Gogh',
            'Mk Coloring Book',
            'Mk Singer Sargent',
            'Mk Pollock',
            'Mk Basquiat',
            'Mk Andy Warhol',
            'Mk Halftone Print',
            'Mk Gond Painting',
            'Mk Albumen Print',
            'Mk Aquatint Print',
            'Mk Anthotype Print',
            'Mk Inuit Carving',
            'Mk Bromoil Print',
            'Mk Calotype Print',
            'Mk Color Sketchnote',
            'Mk Cibulak Porcelain',
            'Mk Alcohol Ink Art',
            'Mk One Line Art',
            'Mk Blacklight Paint',
            'Mk Carnival Glass',
            'Mk Cyanotype Print',
            'Mk Cross Stitching',
            'Mk Encaustic Paint',
            'Mk Embroidery',
            'Mk Gyotaku',
            'Mk Luminogram',
            'Mk Lite Brite Art',
            'Mk Mokume Gane',
            'Pebble Art',
            'Mk Palekh',
            'Mk Suminagashi',
            'Mk Scrimshaw',
            'Mk Shibori',
            'Mk Vitreous Enamel',
            'Mk Ukiyo E',
            'Mk Vintage Airline Poster',
            'Mk Vintage Travel Poster',
            'Mk Bauhaus Style',
            'Mk Afrofuturism',
            'Mk Atompunk',
            'Mk Constructivism',
            'Mk Chicano Art',
            'Mk De Stijl',
            'Mk Dayak Art',
            'Mk Fayum Portrait',
            'Mk Illuminated Manuscript',
            'Mk Kalighat Painting',
            'Mk Madhubani Painting',
            'Mk Pictorialism',
            'Mk Pichwai Painting',
            'Mk Patachitra Painting',
            'Mk Samoan Art Inspired',
            'Mk Tlingit Art',
            'Mk Adnate Style',
            'Mk Ron English Style',
            'Mk Shepard Fairey Style',
          ]),
        )
        .register(z.globalRegistry, {
          description: '\n            The style to use.\n        ',
        }),
    )
    .default(['Fooocus Enhance', 'Fooocus V2', 'Fooocus Sharp']),
  uov_image_url: z.string().register(z.globalRegistry, {
    description: 'The image to upscale or vary.',
  }),
  performance: z.optional(
    z
      .enum(['Speed', 'Quality', 'Extreme Speed', 'Lightning'])
      .register(z.globalRegistry, {
        description: '\n            You can choose Speed or Quality\n        ',
      }),
  ),
  mixing_image_prompt_and_vary_upscale: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Mixing Image Prompt and Vary/Upscale',
      }),
    )
    .default(false),
  image_prompt_3: z.optional(zSchemaImagePrompt),
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The prompt to use for generating the image. Be as descriptive as possible for best results.',
      }),
    )
    .default(''),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use up to 5 LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([
      {
        path: 'https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0/resolve/main/sd_xl_offset_example-lora_1.0.safetensors',
        scale: 0.1,
      },
    ]),
  image_prompt_4: z.optional(zSchemaImagePrompt),
  image_prompt_1: z.optional(zSchemaImagePrompt),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to false, the safety checker will be disabled.',
      }),
    )
    .default(true),
  sharpness: z
    .optional(
      z.number().gte(0).lte(30).register(z.globalRegistry, {
        description:
          '\n            The sharpness of the generated image. Use it to control how sharp the generated\n            image should be. Higher value means image and texture are sharper.\n        ',
      }),
    )
    .default(2),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(30).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  aspect_ratio: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            The size of the generated image. You can choose between some presets or\n            custom height and width that **must be multiples of 8**.\n        ',
      }),
    )
    .default('1024x1024'),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          '\n            Number of images to generate in one request\n        ',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  refiner_model: z.optional(
    z
      .enum(['None', 'realisticVisionV60B1_v51VAE.safetensors'])
      .register(z.globalRegistry, {
        description: 'Refiner (SDXL or SD 1.5)',
      }),
  ),
  image_prompt_2: z.optional(zSchemaImagePrompt),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  uov_method: z.optional(
    z
      .enum([
        'Disabled',
        'Vary (Subtle)',
        'Vary (Strong)',
        'Upscale (1.5x)',
        'Upscale (2x)',
        'Upscale (Fast 2x)',
      ])
      .register(z.globalRegistry, {
        description: 'The method to use for upscaling or varying.',
      }),
  ),
  seed: z.optional(z.union([z.int(), z.null()])),
  refiner_switch: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            Use 0.4 for SD1.5 realistic models; 0.667 for SD1.5 anime models\n            0.8 for XL-refiners; or any value for switching two SDXL models.\n        ',
      }),
    )
    .default(0.8),
})

/**
 * SD3Output
 */
export const zSchemaStableDiffusionV3MediumOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  num_images: z.int().register(z.globalRegistry, {
    description: 'The number of images generated.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaStableDiffusionV3MediumInput = z.object({
  prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, prompt will be upsampled with more details.',
      }),
    )
    .default(false),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of Stable Diffusion\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to generate an image from.',
      }),
    )
    .default(''),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaFluxLoraInpaintingOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * InpaintInput
 */
export const zSchemaFluxLoraInpaintingInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'The number of images to generate. This is always set to 1 for streaming output.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of image to use for inpainting. or img2img',
  }),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  strength: z
    .optional(
      z.number().gte(0.01).lte(1).register(z.globalRegistry, {
        description:
          'The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.',
      }),
    )
    .default(0.85),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  mask_url: z.string().register(z.globalRegistry, {
    description: '\n            The mask to area to Inpaint in.\n        ',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaStableDiffusionV35MediumOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaStableDiffusionV35MediumInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(40),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaFluxSchnellOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * SchnellTextToImageInput
 */
export const zSchemaFluxSchnellInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(12).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(4),
})

/**
 * Output
 */
export const zSchemaOmnigenV1Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaOmnigenV1Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  img_guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The Image Guidance scale is a measure of how close you want\n            the model to stick to your input image when looking for a related image to show you.\n        ',
      }),
    )
    .default(1.6),
  input_image_urls: z
    .optional(
      z.array(z.string()).register(z.globalRegistry, {
        description:
          'URL of images to use while generating the image, Use <img><|image_1|></img> for the first image and so on.',
      }),
    )
    .default([]),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(50),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaAuraFlowOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The expanded prompt',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used to generate the images',
  }),
})

/**
 * Input
 */
export const zSchemaAuraFlowInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate images from',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(2).register(z.globalRegistry, {
        description: 'The number of images to generate',
      }),
    )
    .default(1),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to perform prompt expansion (recommended)',
      }),
    )
    .default(true),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Classifier free guidance scale',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to take',
      }),
    )
    .default(50),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed to use for generating images',
    }),
  ),
})

/**
 * T2IOutput
 */
export const zSchemaLumaPhotonFlashOutput = z.object({
  images: z.array(zSchemaFile).register(z.globalRegistry, {
    description: 'The generated image',
  }),
})

/**
 * TextToImageRequest
 */
export const zSchemaLumaPhotonFlashInput = z.object({
  prompt: z.string().min(3).max(5000),
  aspect_ratio: z.optional(
    z
      .enum(['16:9', '9:16', '1:1', '4:3', '3:4', '21:9', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated video',
      }),
  ),
})

/**
 * Output
 */
export const zSchemaIdeogramV2TurboOutput = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for the random number generator',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaIdeogramV2TurboInput = z.object({
  prompt: z.string(),
  aspect_ratio: z.optional(
    z
      .enum([
        '10:16',
        '16:10',
        '9:16',
        '16:9',
        '4:3',
        '3:4',
        '1:1',
        '1:3',
        '3:1',
        '3:2',
        '2:3',
      ])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image',
      }),
  ),
  style: z.optional(
    z
      .enum(['auto', 'general', 'realistic', 'design', 'render_3D', 'anime'])
      .register(z.globalRegistry, {
        description: 'The style of the generated image',
      }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to expand the prompt with MagicPrompt functionality.',
      }),
    )
    .default(true),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'A negative prompt to avoid in the generated image',
      }),
    )
    .default(''),
})

/**
 * Recraft20BTextToImageOutput
 */
export const zSchemaRecraft20bOutput = z.object({
  images: z.array(zSchemaFile),
})

/**
 * RGBColor
 */
export const zSchemaRgbColor = z.object({
  r: z
    .optional(
      z.int().gte(0).lte(255).register(z.globalRegistry, {
        description: 'Red color value',
      }),
    )
    .default(0),
  b: z
    .optional(
      z.int().gte(0).lte(255).register(z.globalRegistry, {
        description: 'Blue color value',
      }),
    )
    .default(0),
  g: z
    .optional(
      z.int().gte(0).lte(255).register(z.globalRegistry, {
        description: 'Green color value',
      }),
    )
    .default(0),
})

/**
 * Recraft20BTextToImageInput
 */
export const zSchemaRecraft20bInput = z.object({
  prompt: z.string().min(1).max(1000),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
  colors: z
    .optional(
      z.array(zSchemaRgbColor).register(z.globalRegistry, {
        description: 'An array of preferable colors',
      }),
    )
    .default([]),
  style: z.optional(
    z
      .enum([
        'any',
        'realistic_image',
        'digital_illustration',
        'vector_illustration',
        'realistic_image/b_and_w',
        'realistic_image/enterprise',
        'realistic_image/hard_flash',
        'realistic_image/hdr',
        'realistic_image/motion_blur',
        'realistic_image/natural_light',
        'realistic_image/studio_portrait',
        'digital_illustration/2d_art_poster',
        'digital_illustration/2d_art_poster_2',
        'digital_illustration/3d',
        'digital_illustration/80s',
        'digital_illustration/engraving_color',
        'digital_illustration/glow',
        'digital_illustration/grain',
        'digital_illustration/hand_drawn',
        'digital_illustration/hand_drawn_outline',
        'digital_illustration/handmade_3d',
        'digital_illustration/infantile_sketch',
        'digital_illustration/kawaii',
        'digital_illustration/pixel_art',
        'digital_illustration/psychedelic',
        'digital_illustration/seamless',
        'digital_illustration/voxel',
        'digital_illustration/watercolor',
        'vector_illustration/cartoon',
        'vector_illustration/doodle_line_art',
        'vector_illustration/engraving',
        'vector_illustration/flat_2',
        'vector_illustration/kawaii',
        'vector_illustration/line_art',
        'vector_illustration/line_circuit',
        'vector_illustration/linocut',
        'vector_illustration/seamless',
      ])
      .register(z.globalRegistry, {
        description:
          'The style of the generated images. Vector images cost 2X as much.',
      }),
  ),
  style_id: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The ID of the custom style reference (optional)',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaBriaTextToImageHdOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
})

/**
 * GuidanceInput
 */
export const zSchemaGuidanceInput = z.object({
  scale: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'Impact of the guidance.',
      }),
    )
    .default(1),
  method: z.optional(
    z
      .enum([
        'controlnet_canny',
        'controlnet_depth',
        'controlnet_recoloring',
        'controlnet_color_grid',
      ])
      .register(z.globalRegistry, {
        description:
          'Which guidance type you would like to include in the generation. Up to 4 guidance methods can be combined during a single inference. This parameter is optional.',
      }),
  ),
  image_url: z.string().register(z.globalRegistry, {
    description:
      'The image that should be used as guidance, in base64 format, with the method defined in guidance_method_1. Accepted formats are jpeg, jpg, png, webp. Maximum file size 12MB. If more then one guidance method is used, all guidance images must be of the same aspect ratio, and this will be the aspect ratio of the generated results. If guidance_method_1 is selected, an image must be provided.',
  }),
})

/**
 * TextToImageRequest
 */
export const zSchemaBriaTextToImageHdInput = z.object({
  prompt: z.string().min(1).register(z.globalRegistry, {
    description: 'The prompt you would like to use to generate images.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'How many images you would like to generate. When using any Guidance Method, Value is set to 1.',
      }),
    )
    .default(4),
  prompt_enhancement: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'When set to true, enhances the provided prompt by generating additional, more descriptive variations, resulting in more diverse and creative output images.',
      }),
    )
    .default(false),
  guidance: z
    .optional(
      z.array(zSchemaGuidanceInput).register(z.globalRegistry, {
        description:
          'Guidance images to use for the generation. Up to 4 guidance methods can be combined during a single inference.',
      }),
    )
    .default([]),
  aspect_ratio: z.optional(
    z
      .enum(['1:1', '2:3', '3:2', '3:4', '4:3', '4:5', '5:4', '9:16', '16:9'])
      .register(z.globalRegistry, {
        description:
          'The aspect ratio of the image. When a guidance method is being used, the aspect ratio is defined by the guidance image and this parameter is ignored.',
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(5),
  medium: z.optional(
    z.enum(['photography', 'art']).register(z.globalRegistry, {
      description:
        'Which medium should be included in your generated images. This parameter is optional.',
    }),
  ),
  seed: z.optional(
    z.int().gte(0).lte(2147483647).register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The negative prompt you would like to use to generate images.',
      }),
    )
    .default(''),
  num_inference_steps: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description:
          'The number of iterations the model goes through to refine the generated image. This parameter is optional.',
      }),
    )
    .default(30),
})

/**
 * Output
 */
export const zSchemaBriaTextToImageFastOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
})

/**
 * FastTextToImageRequest
 */
export const zSchemaBriaTextToImageFastInput = z.object({
  prompt: z.string().min(1).register(z.globalRegistry, {
    description: 'The prompt you would like to use to generate images.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'How many images you would like to generate. When using any Guidance Method, Value is set to 1.',
      }),
    )
    .default(4),
  prompt_enhancement: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'When set to true, enhances the provided prompt by generating additional, more descriptive variations, resulting in more diverse and creative output images.',
      }),
    )
    .default(false),
  guidance: z
    .optional(
      z.array(zSchemaGuidanceInput).register(z.globalRegistry, {
        description:
          'Guidance images to use for the generation. Up to 4 guidance methods can be combined during a single inference.',
      }),
    )
    .default([]),
  aspect_ratio: z.optional(
    z
      .enum(['1:1', '2:3', '3:2', '3:4', '4:3', '4:5', '5:4', '9:16', '16:9'])
      .register(z.globalRegistry, {
        description:
          'The aspect ratio of the image. When a guidance method is being used, the aspect ratio is defined by the guidance image and this parameter is ignored.',
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(5),
  medium: z.optional(
    z.enum(['photography', 'art']).register(z.globalRegistry, {
      description:
        'Which medium should be included in your generated images. This parameter is optional.',
    }),
  ),
  seed: z.optional(
    z.int().gte(0).lte(2147483647).register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The negative prompt you would like to use to generate images.',
      }),
    )
    .default(''),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(10).register(z.globalRegistry, {
        description:
          'The number of iterations the model goes through to refine the generated image. This parameter is optional.',
      }),
    )
    .default(8),
})

/**
 * Output
 */
export const zSchemaBriaTextToImageBaseOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
})

/**
 * TextToImageRequest
 */
export const zSchemaBriaTextToImageBaseInput = z.object({
  prompt: z.string().min(1).register(z.globalRegistry, {
    description: 'The prompt you would like to use to generate images.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'How many images you would like to generate. When using any Guidance Method, Value is set to 1.',
      }),
    )
    .default(4),
  prompt_enhancement: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'When set to true, enhances the provided prompt by generating additional, more descriptive variations, resulting in more diverse and creative output images.',
      }),
    )
    .default(false),
  guidance: z
    .optional(
      z.array(zSchemaGuidanceInput).register(z.globalRegistry, {
        description:
          'Guidance images to use for the generation. Up to 4 guidance methods can be combined during a single inference.',
      }),
    )
    .default([]),
  aspect_ratio: z.optional(
    z
      .enum(['1:1', '2:3', '3:2', '3:4', '4:3', '4:5', '5:4', '9:16', '16:9'])
      .register(z.globalRegistry, {
        description:
          'The aspect ratio of the image. When a guidance method is being used, the aspect ratio is defined by the guidance image and this parameter is ignored.',
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(5),
  medium: z.optional(
    z.enum(['photography', 'art']).register(z.globalRegistry, {
      description:
        'Which medium should be included in your generated images. This parameter is optional.',
    }),
  ),
  seed: z.optional(
    z.int().gte(0).lte(2147483647).register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The negative prompt you would like to use to generate images.',
      }),
    )
    .default(''),
  num_inference_steps: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description:
          'The number of iterations the model goes through to refine the generated image. This parameter is optional.',
      }),
    )
    .default(30),
})

/**
 * SwittiOutput
 */
export const zSchemaSwitti512Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaSwitti512Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  sampling_top_k: z
    .optional(
      z.int().gte(10).lte(1000).register(z.globalRegistry, {
        description: 'The number of top-k tokens to sample from.',
      }),
    )
    .default(400),
  turn_off_cfg_start_si: z
    .optional(
      z.int().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Disable CFG starting scale',
      }),
    )
    .default(8),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(6),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  smooth_start_si: z
    .optional(
      z.int().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Smoothing starting scale',
      }),
    )
    .default(2),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  last_scale_temp: z
    .optional(
      z.number().gte(0.1).lte(10).register(z.globalRegistry, {
        description: 'Temperature after disabling CFG',
      }),
    )
    .default(0.1),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  more_diverse: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'More diverse sampling',
      }),
    )
    .default(false),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  more_smooth: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Smoothing with Gumbel softmax sampling',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  sampling_top_p: z
    .optional(
      z.number().gte(0.1).lte(1).register(z.globalRegistry, {
        description: 'The top-p probability to sample from.',
      }),
    )
    .default(0.95),
})

/**
 * SwittiOutput
 */
export const zSchemaSwittiOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaSwittiInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  sampling_top_k: z
    .optional(
      z.int().gte(10).lte(1000).register(z.globalRegistry, {
        description: 'The number of top-k tokens to sample from.',
      }),
    )
    .default(400),
  turn_off_cfg_start_si: z
    .optional(
      z.int().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Disable CFG starting scale',
      }),
    )
    .default(8),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(6),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  smooth_start_si: z
    .optional(
      z.int().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Smoothing starting scale',
      }),
    )
    .default(2),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  last_scale_temp: z
    .optional(
      z.number().gte(0.1).lte(10).register(z.globalRegistry, {
        description: 'Temperature after disabling CFG',
      }),
    )
    .default(0.1),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  more_diverse: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'More diverse sampling',
      }),
    )
    .default(false),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  more_smooth: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Smoothing with Gumbel softmax sampling',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  sampling_top_p: z
    .optional(
      z.number().gte(0.1).lte(1).register(z.globalRegistry, {
        description: 'The top-p probability to sample from.',
      }),
    )
    .default(0.95),
})

/**
 * Image
 */
export const zSchemaRegistryImageFastSdxlModelsImage = z.object({
  height: z.int(),
  content_type: z.optional(z.string()).default('image/jpeg'),
  url: z.string(),
  width: z.int(),
})

/**
 * Output
 */
export const zSchemaFluxProV11Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z
    .array(zSchemaRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: 'The generated image files info.',
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * FluxProPlusTextToImageInput
 */
export const zSchemaFluxProV11Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enhance the prompt for better results.',
      }),
    )
    .default(false),
})

/**
 * Output
 */
export const zSchemaFluxProV11UltraFinetunedOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z
    .array(zSchemaRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: 'The generated image files info.',
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * FluxProUltraTextToImageFinetunedInput
 */
export const zSchemaFluxProV11UltraFinetunedInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  finetune_id: z.string().register(z.globalRegistry, {
    description: 'References your specific model',
  }),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.',
    }),
  ),
  image_prompt_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The strength of the image prompt, between 0 and 1.',
      }),
    )
    .default(0.1),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enhance the prompt for better results.',
      }),
    )
    .default(false),
  raw: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Generate less processed, more natural-looking images.',
      }),
    )
    .default(false),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z.union([
      z.enum([
        '21:9',
        '16:9',
        '4:3',
        '3:2',
        '1:1',
        '2:3',
        '3:4',
        '9:16',
        '9:21',
      ]),
      z.string(),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The image URL to generate an image from.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  finetune_strength: z.number().gte(0).lte(2).register(z.globalRegistry, {
    description:
      "\n        Controls finetune influence.\n        Increase this value if your target concept isn't showing up strongly enough.\n        The optimal setting depends on your finetune and prompt\n        ",
  }),
})

/**
 * Output
 */
export const zSchemaJanusOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * JanusInput
 */
export const zSchemaJanusInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(16).register(z.globalRegistry, {
        description: 'Number of images to generate in parallel.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  cfg_weight: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          'Classifier Free Guidance scale - how closely to follow the prompt.',
      }),
    )
    .default(5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  temperature: z
    .optional(
      z.number().gte(0.1).lte(2).register(z.globalRegistry, {
        description:
          'Controls randomness in the generation. Higher values make output more random.',
      }),
    )
    .default(1),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducible generation.',
    }),
  ),
})

/**
 * ImageOutput
 */
export const zSchemaLuminaImageV2Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaLuminaImageV2Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  cfg_trunc_ratio: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          'The ratio of the timestep interval to apply normalization-based guidance scale.',
      }),
    )
    .default(1),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  system_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The system prompt to use.',
      }),
    )
    .default(
      'You are an assistant designed to generate superior images with the superior degree of image-text alignment based on textual prompts or user prompts.',
    ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(30),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  cfg_normalization: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to apply normalization-based guidance scale.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaImagen3FastOutput = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaImagen3FastInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt describing what you want to see',
  }),
  aspect_ratio: z.optional(
    z.enum(['1:1', '16:9', '9:16', '3:4', '4:3']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated image',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'Number of images to generate (1-4)',
      }),
    )
    .default(1),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducible generation',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'A description of what to discourage in the generated images',
      }),
    )
    .default(''),
})

/**
 * Output
 */
export const zSchemaImagen3Output = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaImagen3Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt describing what you want to see',
  }),
  aspect_ratio: z.optional(
    z.enum(['1:1', '16:9', '9:16', '3:4', '4:3']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated image',
    }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'Number of images to generate (1-4)',
      }),
    )
    .default(1),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducible generation',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'A description of what to discourage in the generated images',
      }),
    )
    .default(''),
})

/**
 * Output
 */
export const zSchemaFluxControlLoraDepthOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * DepthLoraInput
 */
export const zSchemaFluxControlLoraDepthInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  control_lora_strength: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description: 'The strength of the control lora.',
      }),
    )
    .default(1),
  preprocess_depth: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the input image will be preprocessed to extract depth information.\n            This is useful for generating depth maps from images.\n        ',
      }),
    )
    .default(true),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  control_lora_image_url: z.string().register(z.globalRegistry, {
    description:
      '\n            The image to use for control lora. This is used to control the style of the generated image.\n        ',
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaFluxControlLoraCannyOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaFluxControlLoraCannyInput = z.object({
  control_lora_strength: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description: 'The strength of the control lora.',
      }),
    )
    .default(1),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  control_lora_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        '\n            The image to use for control lora. This is used to control the style of the generated image.\n        ',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaIdeogramV2aOutput = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for the random number generator',
  }),
})

/**
 * BaseTextToImageInput
 */
export const zSchemaIdeogramV2aInput = z.object({
  prompt: z.string(),
  aspect_ratio: z.optional(
    z
      .enum([
        '10:16',
        '16:10',
        '9:16',
        '16:9',
        '4:3',
        '3:4',
        '1:1',
        '1:3',
        '3:1',
        '3:2',
        '2:3',
      ])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image',
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  style: z.optional(
    z
      .enum(['auto', 'general', 'realistic', 'design', 'render_3D', 'anime'])
      .register(z.globalRegistry, {
        description: 'The style of the generated image',
      }),
  ),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to expand the prompt with MagicPrompt functionality.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaIdeogramV2aTurboOutput = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for the random number generator',
  }),
})

/**
 * BaseTextToImageInput
 */
export const zSchemaIdeogramV2aTurboInput = z.object({
  prompt: z.string(),
  aspect_ratio: z.optional(
    z
      .enum([
        '10:16',
        '16:10',
        '9:16',
        '16:9',
        '4:3',
        '3:4',
        '1:1',
        '1:3',
        '3:1',
        '3:2',
        '2:3',
      ])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image',
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  style: z.optional(
    z
      .enum(['auto', 'general', 'realistic', 'design', 'render_3D', 'anime'])
      .register(z.globalRegistry, {
        description: 'The style of the generated image',
      }),
  ),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to expand the prompt with MagicPrompt functionality.',
      }),
    )
    .default(true),
})

/**
 * ImageOutput
 */
export const zSchemaCogview4Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaCogview4Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(50),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaJuggernautFluxBaseOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * DevTextToImageInput
 */
export const zSchemaJuggernautFluxBaseInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaRundiffusionPhotoFluxOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * PhotoLoraT2IInput
 */
export const zSchemaRundiffusionPhotoFluxInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  photo_lora_scale: z
    .optional(
      z.number().register(z.globalRegistry, {
        description: 'LoRA Scale of the photo lora model',
      }),
    )
    .default(0.75),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaJuggernautFluxLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaJuggernautFluxLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaJuggernautFluxProOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * DevTextToImageInput
 */
export const zSchemaJuggernautFluxProInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaJuggernautFluxLightningOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * SchnellTextToImageInput
 */
export const zSchemaJuggernautFluxLightningInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(12).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(4),
})

/**
 * Output
 */
export const zSchemaSanaSprintOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * SprintInput
 */
export const zSchemaSanaSprintInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  style_name: z.optional(
    z
      .enum([
        '(No style)',
        'Cinematic',
        'Photographic',
        'Anime',
        'Manga',
        'Digital Art',
        'Pixel art',
        'Fantasy art',
        'Neonpunk',
        '3D Model',
      ])
      .register(z.globalRegistry, {
        description: 'The style to generate the image in.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(20).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(2),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaSanaV1548bOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaSanaV1548bInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  style_name: z.optional(
    z
      .enum([
        '(No style)',
        'Cinematic',
        'Photographic',
        'Anime',
        'Manga',
        'Digital Art',
        'Pixel art',
        'Fantasy art',
        'Neonpunk',
        '3D Model',
      ])
      .register(z.globalRegistry, {
        description: 'The style to generate the image in.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(18),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaSanaV1516bOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaSanaV1516bInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  style_name: z.optional(
    z
      .enum([
        '(No style)',
        'Cinematic',
        'Photographic',
        'Anime',
        'Manga',
        'Digital Art',
        'Pixel art',
        'Fantasy art',
        'Neonpunk',
        '3D Model',
      ])
      .register(z.globalRegistry, {
        description: 'The style to generate the image in.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(18),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * ImageFile
 */
export const zSchemaImageFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  height: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The height of the image',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  width: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The width of the image',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ImageResponse
 */
export const zSchemaGptImage1TextToImageOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
})

/**
 * TextToImageRequest
 */
export const zSchemaGptImage1TextToImageInput = z.object({
  prompt: z.string().min(2).register(z.globalRegistry, {
    description: 'The prompt for image generation',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'Number of images to generate',
      }),
    )
    .default(1),
  image_size: z.optional(
    z
      .enum(['auto', '1024x1024', '1536x1024', '1024x1536'])
      .register(z.globalRegistry, {
        description: 'Aspect ratio for the generated image',
      }),
  ),
  background: z.optional(
    z.enum(['auto', 'transparent', 'opaque']).register(z.globalRegistry, {
      description: 'Background for the generated image',
    }),
  ),
  quality: z.optional(
    z.enum(['auto', 'low', 'medium', 'high']).register(z.globalRegistry, {
      description: 'Quality for the generated image',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'Output format for the images',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
})

/**
 * Output
 */
export const zSchemaFLiteTextureOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInputTexture
 */
export const zSchemaFLiteTextureInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative Prompt for generation.',
      }),
    )
    .default(''),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaFLiteStandardOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInputStandard
 */
export const zSchemaFLiteStandardInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative Prompt for generation.',
      }),
    )
    .default(''),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * ColorPaletteMember
 */
export const zSchemaColorPaletteMember = z.object({
  color_weight: z.optional(z.union([z.number().gte(0.05).lte(1), z.unknown()])),
  rgb: zSchemaRgbColor,
})

/**
 * ColorPalette
 */
export const zSchemaColorPalette = z.object({
  members: z.optional(
    z.union([z.array(zSchemaColorPaletteMember), z.unknown()]),
  ),
  name: z.optional(
    z.union([
      z.enum([
        'EMBER',
        'FRESH',
        'JUNGLE',
        'MAGIC',
        'MELON',
        'MOSAIC',
        'PASTEL',
        'ULTRAMARINE',
      ]),
      z.unknown(),
    ]),
  ),
})

/**
 * OutputV3
 */
export const zSchemaIdeogramV3Output = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for the random number generator',
  }),
})

/**
 * BaseTextToImageInputV3
 */
export const zSchemaIdeogramV3Input = z.object({
  prompt: z.string(),
  num_images: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'Number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
      z.unknown(),
    ]),
  ),
  style: z.optional(
    z.union([z.enum(['AUTO', 'GENERAL', 'REALISTIC', 'DESIGN']), z.unknown()]),
  ),
  style_preset: z.optional(
    z.union([
      z.enum([
        '80S_ILLUSTRATION',
        '90S_NOSTALGIA',
        'ABSTRACT_ORGANIC',
        'ANALOG_NOSTALGIA',
        'ART_BRUT',
        'ART_DECO',
        'ART_POSTER',
        'AURA',
        'AVANT_GARDE',
        'BAUHAUS',
        'BLUEPRINT',
        'BLURRY_MOTION',
        'BRIGHT_ART',
        'C4D_CARTOON',
        'CHILDRENS_BOOK',
        'COLLAGE',
        'COLORING_BOOK_I',
        'COLORING_BOOK_II',
        'CUBISM',
        'DARK_AURA',
        'DOODLE',
        'DOUBLE_EXPOSURE',
        'DRAMATIC_CINEMA',
        'EDITORIAL',
        'EMOTIONAL_MINIMAL',
        'ETHEREAL_PARTY',
        'EXPIRED_FILM',
        'FLAT_ART',
        'FLAT_VECTOR',
        'FOREST_REVERIE',
        'GEO_MINIMALIST',
        'GLASS_PRISM',
        'GOLDEN_HOUR',
        'GRAFFITI_I',
        'GRAFFITI_II',
        'HALFTONE_PRINT',
        'HIGH_CONTRAST',
        'HIPPIE_ERA',
        'ICONIC',
        'JAPANDI_FUSION',
        'JAZZY',
        'LONG_EXPOSURE',
        'MAGAZINE_EDITORIAL',
        'MINIMAL_ILLUSTRATION',
        'MIXED_MEDIA',
        'MONOCHROME',
        'NIGHTLIFE',
        'OIL_PAINTING',
        'OLD_CARTOONS',
        'PAINT_GESTURE',
        'POP_ART',
        'RETRO_ETCHING',
        'RIVIERA_POP',
        'SPOTLIGHT_80S',
        'STYLIZED_RED',
        'SURREAL_COLLAGE',
        'TRAVEL_POSTER',
        'VINTAGE_GEO',
        'VINTAGE_POSTER',
        'WATERCOLOR',
        'WEIRD',
        'WOODBLOCK_PRINT',
      ]),
      z.unknown(),
    ]),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Determine if MagicPrompt should be used in generating the request or not.',
      }),
    )
    .default(true),
  rendering_speed: z.optional(
    z.enum(['TURBO', 'BALANCED', 'QUALITY']).register(z.globalRegistry, {
      description: 'The rendering speed to use.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  color_palette: z.optional(z.union([zSchemaColorPalette, z.unknown()])),
  style_codes: z.optional(z.union([z.array(z.string()), z.unknown()])),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  image_urls: z.optional(z.union([z.array(z.string()), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Description of what to exclude from an image. Descriptions in the prompt take precedence to descriptions in the negative prompt.',
      }),
    )
    .default(''),
})

/**
 * ImageOutput
 */
export const zSchemaPonyV7Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * Input
 */
export const zSchemaPonyV7Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate images from',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(2).register(z.globalRegistry, {
        description: 'The number of images to generate',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  noise_source: z.optional(
    z.enum(['gpu', 'cpu']).register(z.globalRegistry, {
      description:
        "\n            The source of the noise to use for generating images.\n            If set to 'gpu', the noise will be generated on the GPU.\n            If set to 'cpu', the noise will be generated on the CPU.\n        ",
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Classifier free guidance scale',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to take',
      }),
    )
    .default(40),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed to use for generating images',
    }),
  ),
})

/**
 * MiniMaxTextToImageOutput
 */
export const zSchemaMinimaxImage01Output = z.object({
  images: z.array(zSchemaFile).register(z.globalRegistry, {
    description: 'Generated images',
  }),
})

/**
 * MiniMaxTextToImageRequest
 */
export const zSchemaMinimaxImage01Input = z.object({
  prompt_optimizer: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable automatic prompt optimization',
      }),
    )
    .default(false),
  aspect_ratio: z.optional(
    z
      .enum(['1:1', '16:9', '4:3', '3:2', '2:3', '3:4', '9:16', '21:9'])
      .register(z.globalRegistry, {
        description: 'Aspect ratio of the generated image',
      }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(9).register(z.globalRegistry, {
        description: 'Number of images to generate (1-9)',
      }),
    )
    .default(1),
  prompt: z.string().min(1).max(1500).register(z.globalRegistry, {
    description: 'Text prompt for image generation (max 1500 characters)',
  }),
})

/**
 * Output
 */
export const zSchemaFluxLoraStreamOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaFluxLoraStreamInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'The number of images to generate. This is always set to 1 for streaming output.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * DreamOOutput
 */
export const zSchemaDreamoOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used to generate the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The URLs of the generated images.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * DreamOInput
 */
export const zSchemaDreamoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  first_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of first reference image to use for generation.',
    }),
  ),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  second_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of second reference image to use for generation.',
    }),
  ),
  second_reference_task: z.optional(
    z.enum(['ip', 'id', 'style']).register(z.globalRegistry, {
      description: 'Task for second reference image (ip/id/style).',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  first_reference_task: z.optional(
    z.enum(['ip', 'id', 'style']).register(z.globalRegistry, {
      description: 'Task for first reference image (ip/id/style).',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The prompt to generate an image from.',
      }),
    )
    .default(''),
  ref_resolution: z
    .optional(
      z.int().gte(512).lte(1024).register(z.globalRegistry, {
        description: 'Resolution for reference images.',
      }),
    )
    .default(512),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            If set to true, the function will wait for the image to be generated and uploaded\n            before returning the response. This will increase the latency of the function but\n            it allows you to get the image directly in the response without going through the CDN.\n        ',
      }),
    )
    .default(false),
  true_cfg: z
    .optional(
      z.number().gte(1).lte(5).register(z.globalRegistry, {
        description: 'The weight of the CFG loss.',
      }),
    )
    .default(1),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(12),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * Imagen4TextToImageUltraOutput
 */
export const zSchemaImagen4PreviewUltraOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  description: z.string().register(z.globalRegistry, {
    description: 'The description of the generated images.',
  }),
})

/**
 * Imagen4TextToImageUltraInput
 */
export const zSchemaImagen4PreviewUltraInput = z.object({
  prompt: z.string().min(3).max(5000).register(z.globalRegistry, {
    description: 'The text prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z.enum(['1:1', '16:9', '9:16', '4:3', '3:4']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated image.',
    }),
  ),
  resolution: z.optional(
    z.enum(['1K', '2K']).register(z.globalRegistry, {
      description: 'The resolution of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
})

/**
 * ImageOutput
 */
export const zSchemaBagelOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * ImageGenInput
 */
export const zSchemaBagelInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed to use for the generation.',
    }),
  ),
  use_thought: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to use thought tokens for generation. If set to true, the model will "think" to potentially improve generation quality. Increases generation time and increases the cost by 20%.',
      }),
    )
    .default(false),
})

/**
 * Output
 */
export const zSchemaFluxProKontextTextToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z
    .array(zSchemaRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: 'The generated image files info.',
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * FluxProTextToImageInputWithAR
 */
export const zSchemaFluxProKontextTextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enhance the prompt for better results.',
      }),
    )
    .default(false),
})

/**
 * Output
 */
export const zSchemaFluxProKontextMaxTextToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z
    .array(zSchemaRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: 'The generated image files info.',
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * FluxProTextToImageInputWithAR
 */
export const zSchemaFluxProKontextMaxTextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enhance the prompt for better results.',
      }),
    )
    .default(false),
})

/**
 * Output
 */
export const zSchemaFlux1DevOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseFlux1Input
 */
export const zSchemaFlux1DevInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ',
      }),
    )
    .default(3.5),
})

/**
 * Output
 */
export const zSchemaFlux1SchnellOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * SchnellFlux1TextToImageInput
 */
export const zSchemaFlux1SchnellInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(12).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(4),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ',
      }),
    )
    .default(3.5),
})

/**
 * SeedDreamOutput
 */
export const zSchemaBytedanceSeedreamV3TextToImageOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Generated images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation',
  }),
})

/**
 * SeedDreamInput
 */
export const zSchemaBytedanceSeedreamV3TextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt used to generate the image',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'Number of images to generate',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Controls how closely the output image aligns with the input prompt. Higher values mean stronger prompt correlation.',
      }),
    )
    .default(2.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed to control the stochasticity of image generation.',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaOmnigenV2Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaOmnigenV2Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description:
      "The prompt to generate or edit an image. Use specific language like 'Add the bird from image 1 to the desk in image 2' for better results.",
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  scheduler: z.optional(
    z.enum(['euler', 'dpmsolver']).register(z.globalRegistry, {
      description: 'The scheduler to use for the diffusion process.',
    }),
  ),
  cfg_range_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'CFG range end value.',
      }),
    )
    .default(1),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Negative prompt to guide what should not be in the image.',
      }),
    )
    .default(
      '(((deformed))), blurry, over saturation, bad anatomy, disfigured, poorly drawn face, mutation, mutated, (extra_limb), (ugly), (poorly drawn hands), fused fingers, messy drawing, broken legs censor, censored, censor_bar',
    ),
  text_guidance_scale: z
    .optional(
      z.number().gte(1).lte(8).register(z.globalRegistry, {
        description:
          '\n            The Text Guidance scale controls how closely the model follows the text prompt.\n            Higher values make the model stick more closely to the prompt.\n        ',
      }),
    )
    .default(5),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_guidance_scale: z
    .optional(
      z.number().gte(1).lte(3).register(z.globalRegistry, {
        description:
          '\n            The Image Guidance scale controls how closely the model follows the input images.\n            For image editing: 1.3-2.0, for in-context generation: 2.0-3.0\n        ',
      }),
    )
    .default(2),
  input_image_urls: z
    .optional(
      z.array(z.string()).register(z.globalRegistry, {
        description:
          'URLs of input images to use for image editing or multi-image generation. Support up to 3 images.',
      }),
    )
    .default([]),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  cfg_range_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'CFG range start value.',
      }),
    )
    .default(0),
  num_inference_steps: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(50),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * KontextT2IOutput
 */
export const zSchemaFluxKontextLoraTextToImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseKontextInput
 */
export const zSchemaFluxKontextLoraTextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the image with',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(2.5),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(30),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * SkyRaccoonResponse
 */
export const zSchemaSkyRaccoonOutput = z.object({
  image: zSchemaFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
})

/**
 * SkyRaccoonRequest
 */
export const zSchemaSkyRaccoonInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide video generation.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  turbo_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If true, the video will be generated faster with no noticeable degradation in the visual quality.',
      }),
    )
    .default(false),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable prompt expansion.',
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If None, a random seed is chosen.',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for video generation.',
      }),
    )
    .default(
      'bright colors, overexposed, static, blurred details, subtitles, style, artwork, painting, picture, still, overall gray, worst quality, low quality, JPEG compression residue, ugly, incomplete, extra fingers, poorly drawn hands, poorly drawn faces, deformed, disfigured, malformed limbs, fused fingers, still picture, cluttered background, three legs, many people in the background, walking backwards',
    ),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(40).register(z.globalRegistry, {
        description:
          'Number of inference steps for sampling. Higher values give better quality but take longer.',
      }),
    )
    .default(30),
})

/**
 * KreaOutput
 */
export const zSchemaFlux1KreaOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseKreaFlux1Input
 */
export const zSchemaFlux1KreaInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ',
      }),
    )
    .default(4.5),
})

/**
 * KreaOutput
 */
export const zSchemaFluxKreaOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseKreaInput
 */
export const zSchemaFluxKreaInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ',
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
})

/**
 * Output
 */
export const zSchemaFluxKreaLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * TextToImageInput
 */
export const zSchemaFluxKreaLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'The number of images to generate. This is always set to 1 for streaming output.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaFluxKreaLoraStreamOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * TextToImageInput
 */
export const zSchemaFluxKreaLoraStreamInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'The number of images to generate. This is always set to 1 for streaming output.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * QwenImageOutput
 */
export const zSchemaQwenImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * BaseQwenImageInput
 */
export const zSchemaQwenImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate the image with',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        "Acceleration level for image generation. Options: 'none', 'regular', 'high'. Higher acceleration increases speed. 'regular' balances speed and quality. 'high' is recommended for images without text.",
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(250).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(30),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use up to 3 LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  use_turbo: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Enable turbo mode for faster generation with high quality. When enabled, uses optimized settings (10 steps, CFG=1.2).',
      }),
    )
    .default(false),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt for the generation',
      }),
    )
    .default(' '),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(2.5),
})

/**
 * WanT2IResponse
 */
export const zSchemaWanV22A14bTextToImageOutput = z.object({
  image: zSchemaFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
})

/**
 * WanT2IRequest
 */
export const zSchemaWanV22A14bTextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide image generation.',
  }),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher values give better adherence to the prompt but may decrease quality.',
      }),
    )
    .default(3.5),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular']).register(z.globalRegistry, {
      description:
        "Acceleration level to use. The more acceleration, the faster the generation, but with lower quality. The recommended value is 'regular'.",
    }),
  ),
  shift: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: 'Shift value for the image. Must be between 1.0 and 10.0.',
      }),
    )
    .default(2),
  enable_output_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, output video will be checked for safety after generation.',
      }),
    )
    .default(false),
  guidance_scale_2: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Guidance scale for the second stage of the model. This is used to control the adherence to the prompt in the second stage of the model.',
      }),
    )
    .default(4),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, input data will be checked for safety before processing.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(40).register(z.globalRegistry, {
        description:
          'Number of inference steps for sampling. Higher values give better quality but take longer.',
      }),
    )
    .default(27),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If None, a random seed is chosen.',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for video generation.',
      }),
    )
    .default(''),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.',
      }),
    )
    .default(false),
})

/**
 * WanSmallT2IResponse
 */
export const zSchemaWanV225bTextToImageOutput = z.object({
  image: zSchemaFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
})

/**
 * WanSmallT2IRequest
 */
export const zSchemaWanV225bTextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide image generation.',
  }),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.',
      }),
    )
    .default(false),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for video generation.',
      }),
    )
    .default(''),
  shift: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: 'Shift value for the image. Must be between 1.0 and 10.0.',
      }),
    )
    .default(2),
  enable_output_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, output video will be checked for safety after generation.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, input data will be checked for safety before processing.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description:
          'Number of inference steps for sampling. Higher values give better quality but take longer.',
      }),
    )
    .default(40),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If None, a random seed is chosen.',
    }),
  ),
  image_format: z.optional(
    z.enum(['png', 'jpeg']).register(z.globalRegistry, {
      description: 'The format of the output image.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher values give better adherence to the prompt but may decrease quality.',
      }),
    )
    .default(3.5),
})

/**
 * LoRAWeight
 */
export const zSchemaLoRaWeight = z.object({
  path: z.string().register(z.globalRegistry, {
    description: 'URL or the path to the LoRA weights.',
  }),
  scale: z
    .optional(
      z.number().gte(0).lte(4).register(z.globalRegistry, {
        description:
          '\n            The scale of the LoRA weight. This is used to scale the LoRA weight\n            before merging it with the base model.\n        ',
      }),
    )
    .default(1),
  transformer: z.optional(
    z.enum(['high', 'low', 'both']).register(z.globalRegistry, {
      description:
        "Specifies the transformer to load the lora weight into. 'high' loads into the high-noise transformer, 'low' loads it into the low-noise transformer, while 'both' loads the LoRA into both transformers.",
    }),
  ),
  weight_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Name of the LoRA weight. Used only if `path` is a Hugging Face repository, and required only if you have more than 1 safetensors file in the repo.',
    }),
  ),
})

/**
 * WanT2IResponse
 */
export const zSchemaWanV22A14bTextToImageLoraOutput = z.object({
  image: zSchemaFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
})

/**
 * WanLoRAT2IRequest
 */
export const zSchemaWanV22A14bTextToImageLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to guide image generation.',
  }),
  shift: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: 'Shift value for the image. Must be between 1.0 and 10.0.',
      }),
    )
    .default(2),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular']).register(z.globalRegistry, {
      description:
        "Acceleration level to use. The more acceleration, the faster the generation, but with lower quality. The recommended value is 'regular'.",
    }),
  ),
  reverse_video: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If true, the video will be reversed.',
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoRaWeight).register(z.globalRegistry, {
        description: 'LoRA weights to be used in the inference.',
      }),
    )
    .default([]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, input data will be checked for safety before processing.',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher values give better adherence to the prompt but may decrease quality.',
      }),
    )
    .default(3.5),
  image_format: z.optional(
    z.enum(['png', 'jpeg']).register(z.globalRegistry, {
      description: 'The format of the output image.',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for video generation.',
      }),
    )
    .default(''),
  enable_output_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, output video will be checked for safety after generation.',
      }),
    )
    .default(false),
  guidance_scale_2: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Guidance scale for the second stage of the model. This is used to control the adherence to the prompt in the second stage of the model.',
      }),
    )
    .default(4),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(40).register(z.globalRegistry, {
        description:
          'Number of inference steps for sampling. Higher values give better quality but take longer.',
      }),
    )
    .default(27),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. If None, a random seed is chosen.',
    }),
  ),
})

/**
 * DreaminaOutput
 */
export const zSchemaBytedanceDreaminaV31TextToImageOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Generated images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation',
  }),
})

/**
 * DreaminaInput
 */
export const zSchemaBytedanceDreaminaV31TextToImageInput = z.object({
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'Number of images to generate',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt used to generate the image',
  }),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed to control the stochasticity of image generation.',
    }),
  ),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to use an LLM to enhance the prompt',
      }),
    )
    .default(false),
})

/**
 * NanoBananaTextToImageOutput
 */
export const zSchemaNanoBananaOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  description: z.string().register(z.globalRegistry, {
    description: 'The description of the generated images.',
  }),
})

/**
 * NanoBananaTextToImageInput
 */
export const zSchemaNanoBananaInput = z.object({
  prompt: z.string().min(3).max(50000).register(z.globalRegistry, {
    description: 'The text prompt to generate an image from.',
  }),
  aspect_ratio: z.optional(
    z
      .enum([
        '21:9',
        '16:9',
        '3:2',
        '4:3',
        '5:4',
        '1:1',
        '4:5',
        '3:4',
        '2:3',
        '9:16',
      ])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  limit_generations: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.',
      }),
    )
    .default(false),
})

/**
 * NanoBananaTextToImageOutput
 */
export const zSchemaGemini25FlashImageOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  description: z.string().register(z.globalRegistry, {
    description: 'The description of the generated images.',
  }),
})

/**
 * NanoBananaTextToImageInput
 */
export const zSchemaGemini25FlashImageInput = z.object({
  prompt: z.string().min(3).max(50000).register(z.globalRegistry, {
    description: 'The text prompt to generate an image from.',
  }),
  aspect_ratio: z.optional(
    z
      .enum([
        '21:9',
        '16:9',
        '3:2',
        '4:3',
        '5:4',
        '1:1',
        '4:5',
        '3:4',
        '2:3',
        '9:16',
      ])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  limit_generations: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.',
      }),
    )
    .default(false),
})

/**
 * SeedDream4T2IOutput
 */
export const zSchemaBytedanceSeedreamV4TextToImageOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Generated images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation',
  }),
})

/**
 * SeedDream4T2IInput
 */
export const zSchemaBytedanceSeedreamV4TextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt used to generate the image',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(6).register(z.globalRegistry, {
        description:
          'Number of separate model generations to be run with the prompt.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
        'auto',
        'auto_2K',
        'auto_4K',
      ]),
    ]),
  ),
  enhance_prompt_mode: z.optional(
    z.enum(['standard', 'fast']).register(z.globalRegistry, {
      description:
        'The mode to use for enhancing prompt enhancement. Standard mode provides higher quality results but takes longer to generate. Fast mode provides average quality results but takes less time to generate.',
    }),
  ),
  max_images: z
    .optional(
      z.int().gte(1).lte(6).register(z.globalRegistry, {
        description:
          'If set to a number greater than one, enables multi-image generation. The model will potentially return up to `max_images` images every generation, and in total, `num_images` generations will be carried out. In total, the number of images generated will be between `num_images` and `max_images*num_images`.',
      }),
    )
    .default(1),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed to control the stochasticity of image generation.',
    }),
  ),
})

/**
 * HunyuanTextToImageOutput
 */
export const zSchemaHunyuanImageV21TextToImageOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'A list of the generated images.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The base seed used for the generation process.',
  }),
})

/**
 * HunyuanTextToImageInput
 */
export const zSchemaHunyuanImageV21TextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  use_reprompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Enable prompt enhancement for potentially better results.',
      }),
    )
    .default(true),
  use_refiner: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable the refiner model for improved image quality.',
      }),
    )
    .default(false),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          'Controls how much the model adheres to the prompt. Higher values mean stricter adherence.',
      }),
    )
    .default(3.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducible results. If None, a random seed is used.',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The negative prompt to guide the image generation away from certain concepts.',
      }),
    )
    .default(''),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of denoising steps.',
      }),
    )
    .default(28),
})

/**
 * SRPOOutput
 */
export const zSchemaFlux1SrpoOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseSRPOFlux1Input
 */
export const zSchemaFlux1SrpoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ',
      }),
    )
    .default(4.5),
})

/**
 * SRPOOutput
 */
export const zSchemaFluxSrpoOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseSRPOInput
 */
export const zSchemaFluxSrpoInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ',
      }),
    )
    .default(4.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
})

/**
 * TextToImageOutput
 *
 * Output for text-to-image generation
 */
export const zSchemaWan25PreviewTextToImageOutput = z
  .object({
    images: z.array(zSchemaImageFile).register(z.globalRegistry, {
      description: 'The generated images',
    }),
    seeds: z.array(z.int()).register(z.globalRegistry, {
      description: 'The seeds used for each generated image',
    }),
    actual_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The actual prompt used if prompt rewriting was enabled',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Output for text-to-image generation',
  })

/**
 * TextToImageInput
 *
 * Input for text-to-image generation
 */
export const zSchemaWan25PreviewTextToImageInput = z
  .object({
    prompt: z.string().min(1).register(z.globalRegistry, {
      description:
        'The prompt for image generation. Supports Chinese and English, max 2000 characters.',
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate. Values from 1 to 4.',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
      ]),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'If set to true, the safety checker will be enabled.',
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          'Random seed for reproducibility. If None, a random seed is chosen.',
      }),
    ),
    enable_prompt_expansion: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable prompt rewriting using LLM. Improves results for short prompts but increases processing time.',
        }),
      )
      .default(true),
    negative_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'Negative prompt to describe content to avoid. Max 500 characters.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Input for text-to-image generation',
  })

/**
 * HunyuanTextToImageV3Output
 */
export const zSchemaHunyuanImageV3TextToImageOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'A list of the generated images.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The base seed used for the generation process.',
  }),
})

/**
 * HunyuanTextToImageInputV3
 */
export const zSchemaHunyuanImageV3TextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt for image-to-image.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.',
      }),
    )
    .default(false),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          'Controls how much the model adheres to the prompt. Higher values mean stricter adherence.',
      }),
    )
    .default(7.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducible results. If None, a random seed is used.',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'The negative prompt to guide the image generation away from certain concepts.',
      }),
    )
    .default(''),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of denoising steps.',
      }),
    )
    .default(28),
})

/**
 * ReveCreateOutput
 *
 * Output for Reve text-to-image generation
 */
export const zSchemaReveTextToImageOutput = z
  .object({
    images: z.array(zSchemaImage).register(z.globalRegistry, {
      description: 'The generated images',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Output for Reve text-to-image generation',
  })

/**
 * ReveCreateInput
 *
 * Input for Reve text-to-image generation
 */
export const zSchemaReveTextToImageInput = z
  .object({
    prompt: z.string().min(1).max(2560).register(z.globalRegistry, {
      description: 'The text description of the desired image.',
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    aspect_ratio: z.optional(
      z
        .enum(['16:9', '9:16', '3:2', '2:3', '4:3', '3:4', '1:1'])
        .register(z.globalRegistry, {
          description: 'The desired aspect ratio of the generated image.',
        }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
        }),
      )
      .default(false),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'Output format for the generated image.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Input for Reve text-to-image generation',
  })

/**
 * ImageResponseMini
 */
export const zSchemaGptImage1MiniOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
})

/**
 * TextToImageRequestMini
 */
export const zSchemaGptImage1MiniInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt for image generation',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'Number of images to generate',
      }),
    )
    .default(1),
  image_size: z.optional(
    z
      .enum(['auto', '1024x1024', '1536x1024', '1024x1536'])
      .register(z.globalRegistry, {
        description: 'Aspect ratio for the generated image',
      }),
  ),
  background: z.optional(
    z.enum(['auto', 'transparent', 'opaque']).register(z.globalRegistry, {
      description: 'Background for the generated image',
    }),
  ),
  quality: z.optional(
    z.enum(['auto', 'low', 'medium', 'high']).register(z.globalRegistry, {
      description: 'Quality for the generated image',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'Output format for the images',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
})

/**
 * PiQwenOutput
 */
export const zSchemaPiflowOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The URLs of the generated images.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation.',
  }),
})

/**
 * PiQwenInput
 */
export const zSchemaPiflowInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducible generation. If set to None, a random seed will be used.',
    }),
  ),
})

/**
 * GaiaOutputModel
 */
export const zSchemaFiboGenerateOutput = z.object({
  images: z
    .optional(
      z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: 'Generated images.',
      }),
    )
    .default([]),
  image: zSchemaImage,
  structured_prompt: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: 'Current prompt.',
    }),
})

/**
 * Lighting
 */
export const zSchemaLighting = z.object({
  shadows: z.optional(z.union([z.string(), z.unknown()])),
  conditions: z.optional(z.union([z.string(), z.unknown()])),
  direction: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * PhotographicCharacteristics
 */
export const zSchemaPhotographicCharacteristics = z.object({
  focus: z.optional(z.union([z.string(), z.unknown()])),
  lens_focal_length: z.optional(z.union([z.string(), z.unknown()])),
  camera_angle: z.optional(z.union([z.string(), z.unknown()])),
  depth_of_field: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * PromptObject
 */
export const zSchemaPromptObject = z.object({
  clothing: z.optional(z.union([z.string(), z.unknown()])),
  description: z.optional(z.union([z.string(), z.unknown()])),
  skin_tone_and_texture: z.optional(z.union([z.string(), z.unknown()])),
  appearance_details: z.optional(z.union([z.string(), z.unknown()])),
  number_of_objects: z.optional(z.union([z.int(), z.unknown()])),
  expression: z.optional(z.union([z.string(), z.unknown()])),
  pose: z.optional(z.union([z.string(), z.unknown()])),
  shape_and_color: z.optional(z.union([z.string(), z.unknown()])),
  relationship: z.string().register(z.globalRegistry, {
    description:
      'The relationship of the object to other objects in the image.',
  }),
  texture: z.optional(z.union([z.string(), z.unknown()])),
  gender: z.optional(z.union([z.string(), z.unknown()])),
  relative_size: z.optional(z.union([z.string(), z.unknown()])),
  location: z.optional(z.union([z.string(), z.unknown()])),
  orientation: z.optional(z.union([z.string(), z.unknown()])),
  action: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * Aesthetics
 */
export const zSchemaAesthetics = z.object({
  composition: z.optional(z.union([z.string(), z.unknown()])),
  mood_atmosphere: z.optional(z.union([z.string(), z.unknown()])),
  color_scheme: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * StructuredPrompt
 */
export const zSchemaStructuredPrompt = z.object({
  background_setting: z.optional(z.union([z.string(), z.unknown()])),
  artistic_style: z.optional(z.union([z.string(), z.unknown()])),
  aesthetics: z.optional(z.union([zSchemaAesthetics, z.unknown()])),
  text_render: z.optional(z.union([z.array(z.unknown()), z.unknown()])),
  objects: z.optional(z.union([z.array(zSchemaPromptObject), z.unknown()])),
  style_medium: z.optional(z.union([z.string(), z.unknown()])),
  photographic_characteristics: z.optional(
    z.union([zSchemaPhotographicCharacteristics, z.unknown()]),
  ),
  context: z.optional(z.union([z.string(), z.unknown()])),
  lighting: z.optional(z.union([zSchemaLighting, z.unknown()])),
  short_description: z.optional(z.union([z.string(), z.unknown()])),
})

/**
 * GaiaInputModel
 */
export const zSchemaFiboGenerateInput = z.object({
  prompt: z.optional(z.union([z.string(), z.unknown()])),
  steps_num: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps.',
      }),
    )
    .default(50),
  aspect_ratio: z.optional(
    z
      .enum(['1:1', '2:3', '3:2', '3:4', '4:3', '4:5', '5:4', '9:16', '16:9'])
      .register(z.globalRegistry, {
        description:
          'Aspect ratio. Options: 1:1, 2:3, 3:2, 3:4, 4:3, 4:5, 5:4, 9:16, 16:9',
      }),
  ),
  image_url: z.optional(z.union([z.string(), z.unknown()])),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If true, returns the image directly in the response (increases latency).',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.int().gte(3).lte(5).register(z.globalRegistry, {
        description: 'Guidance scale for text.',
      }),
    )
    .default(5),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Random seed for reproducibility.',
      }),
    )
    .default(5555),
  structured_prompt: z.optional(
    z.union([zSchemaStructuredPrompt, z.unknown()]),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for image generation.',
      }),
    )
    .default(''),
})

/**
 * Emu35Output
 */
export const zSchemaEmu35ImageTextToImageOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The edited image.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed for the inference.',
  }),
})

/**
 * Emu35ImageInput
 */
export const zSchemaEmu35ImageTextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to create the image.',
  }),
  resolution: z.optional(
    z.enum(['480p', '720p']).register(z.globalRegistry, {
      description: 'The resolution of the output image.',
    }),
  ),
  aspect_ratio: z.optional(
    z
      .enum(['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the output image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the output image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to return the image in sync mode.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable the safety checker.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed for the inference.',
    }),
  ),
})

/**
 * Image
 *
 * Represents an image file.
 */
export const zSchemaImageOutput = z
  .object({
    file_size: z.optional(z.union([z.int(), z.unknown()])),
    height: z.optional(z.union([z.int(), z.unknown()])),
    file_name: z.optional(z.union([z.string(), z.unknown()])),
    content_type: z.optional(z.union([z.string(), z.unknown()])),
    url: z.string().register(z.globalRegistry, {
      description: 'The URL where the file can be downloaded from.',
    }),
    width: z.optional(z.union([z.int(), z.unknown()])),
  })
  .register(z.globalRegistry, {
    description: 'Represents an image file.',
  })

/**
 * ImagineArt_1_5_Output
 */
export const zSchemaImagineart15PreviewTextToImageOutput = z.object({
  images: z.array(zSchemaImageOutput).register(z.globalRegistry, {
    description: 'Generated image',
  }),
})

/**
 * ImagineArt_1_5_Input
 */
export const zSchemaImagineart15PreviewTextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text prompt describing the desired image',
  }),
  aspect_ratio: z.optional(
    z
      .enum(['1:1', '16:9', '9:16', '4:3', '3:4', '3:1', '1:3', '3:2', '2:3'])
      .register(z.globalRegistry, {
        description:
          'Image aspect ratio: 1:1, 3:1, 1:3, 16:9, 9:16, 4:3, 3:4, 3:2, 2:3',
      }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Seed for the image generation',
    }),
  ),
})

/**
 * NanoBananaTextToImageOutput
 */
export const zSchemaNanoBananaProOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  description: z.string().register(z.globalRegistry, {
    description: 'The description of the generated images.',
  }),
})

/**
 * NanoBananaTextToImageInput
 */
export const zSchemaNanoBananaProInput = z.object({
  prompt: z.string().min(3).max(50000).register(z.globalRegistry, {
    description: 'The text prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  enable_web_search: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Enable web search for the image generation task. This will allow the model to use the latest information from the web to generate the image.',
      }),
    )
    .default(false),
  aspect_ratio: z.optional(
    z
      .enum([
        '21:9',
        '16:9',
        '3:2',
        '4:3',
        '5:4',
        '1:1',
        '4:5',
        '3:4',
        '2:3',
        '9:16',
      ])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  resolution: z.optional(
    z.enum(['1K', '2K', '4K']).register(z.globalRegistry, {
      description: 'The resolution of the image to generate.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed for the random number generator.',
    }),
  ),
  limit_generations: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.',
      }),
    )
    .default(false),
})

/**
 * NanoBananaTextToImageOutput
 */
export const zSchemaGemini3ProImagePreviewOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  description: z.string().register(z.globalRegistry, {
    description: 'The description of the generated images.',
  }),
})

/**
 * NanoBananaTextToImageInput
 */
export const zSchemaGemini3ProImagePreviewInput = z.object({
  prompt: z.string().min(3).max(50000).register(z.globalRegistry, {
    description: 'The text prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  enable_web_search: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Enable web search for the image generation task. This will allow the model to use the latest information from the web to generate the image.',
      }),
    )
    .default(false),
  resolution: z.optional(
    z.enum(['1K', '2K', '4K']).register(z.globalRegistry, {
      description: 'The resolution of the image to generate.',
    }),
  ),
  aspect_ratio: z.optional(
    z
      .enum([
        '21:9',
        '16:9',
        '3:2',
        '4:3',
        '5:4',
        '1:1',
        '4:5',
        '3:4',
        '2:3',
        '9:16',
      ])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image.',
      }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed for the random number generator.',
    }),
  ),
  limit_generations: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.',
      }),
    )
    .default(false),
})

/**
 * Flux2FlexOutput
 */
export const zSchemaFlux2FlexOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for the generation.',
  }),
})

/**
 * Flux2FlexTextToImageInput
 */
export const zSchemaFlux2FlexInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.',
    }),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "Whether to expand the prompt using the model's own knowledge.",
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(2).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable the safety checker.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed to use for the generation.',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1.5).lte(10).register(z.globalRegistry, {
        description: 'The guidance scale to use for the generation.',
      }),
    )
    .default(3.5),
})

/**
 * BallpointPenSketchOutput
 */
export const zSchemaFlux2LoraGalleryBallpointPenSketchOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated ballpoint pen sketch style images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * BallpointPenSketchInput
 *
 * Input model for Ballpoint Pen Sketch endpoint - Generate ballpoint pen sketch style images
 */
export const zSchemaFlux2LoraGalleryBallpointPenSketchInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description:
        "The prompt to generate a ballpoint pen sketch style image. Use 'b4llp01nt' trigger word for best results.",
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: 'The strength of the ballpoint pen sketch effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Ballpoint Pen Sketch endpoint - Generate ballpoint pen sketch style images',
  })

/**
 * DigitalComicArtOutput
 */
export const zSchemaFlux2LoraGalleryDigitalComicArtOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated digital comic art style images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * DigitalComicArtInput
 *
 * Input model for Digital Comic Art endpoint - Generate digital comic art style images
 */
export const zSchemaFlux2LoraGalleryDigitalComicArtInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description:
        "The prompt to generate a digital comic art style image. Use 'd1g1t4l' trigger word for best results.",
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: 'The strength of the digital comic art effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Digital Comic Art endpoint - Generate digital comic art style images',
  })

/**
 * HdrStyleOutput
 */
export const zSchemaFlux2LoraGalleryHdrStyleOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated HDR style images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * HdrStyleInput
 *
 * Input model for HDR Style endpoint - Generate HDR style images with vibrant colors
 */
export const zSchemaFlux2LoraGalleryHdrStyleInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description:
        "The prompt to generate an HDR style image. The trigger word 'Hyp3rRe4list1c' will be automatically prepended.",
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: 'The strength of the HDR style effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for HDR Style endpoint - Generate HDR style images with vibrant colors',
  })

/**
 * RealismOutput
 */
export const zSchemaFlux2LoraGalleryRealismOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated realistic style images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * RealismInput
 *
 * Input model for Realism endpoint - Generate realistic style images
 */
export const zSchemaFlux2LoraGalleryRealismInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description:
        'The prompt to generate a realistic image with natural lighting and authentic details.',
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: 'The strength of the realism effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Realism endpoint - Generate realistic style images',
  })

/**
 * SatelliteViewStyleOutput
 */
export const zSchemaFlux2LoraGallerySatelliteViewStyleOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated satellite view style images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * SatelliteViewStyleInput
 *
 * Input model for Satellite View Style endpoint - Generate satellite/aerial view style images
 */
export const zSchemaFlux2LoraGallerySatelliteViewStyleInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description:
        'The prompt to generate a satellite/aerial view style image.',
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: 'The strength of the satellite view style effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Satellite View Style endpoint - Generate satellite/aerial view style images',
  })

/**
 * SepiaVintageOutput
 */
export const zSchemaFlux2LoraGallerySepiaVintageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generation',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated sepia vintage photography style images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for generation',
  }),
})

/**
 * SepiaVintageInput
 *
 * Input model for Sepia Vintage Photography endpoint - Generate vintage sepia style images
 */
export const zSchemaFlux2LoraGallerySepiaVintageInput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description:
        'The prompt to generate a sepia vintage photography style image.',
    }),
    num_images: z
      .optional(
        z.int().gte(1).lte(4).register(z.globalRegistry, {
          description: 'Number of images to generate',
        }),
      )
      .default(1),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
      ]),
    ),
    acceleration: z.optional(
      z.enum(['none', 'regular']).register(z.globalRegistry, {
        description:
          "Acceleration level for image generation. 'regular' balances speed and quality.",
      }),
    ),
    lora_scale: z
      .optional(
        z.number().gte(0).lte(2).register(z.globalRegistry, {
          description: 'The strength of the sepia vintage photography effect.',
        }),
      )
      .default(1),
    output_format: z.optional(
      z.enum(['png', 'jpeg', 'webp']).register(z.globalRegistry, {
        description: 'The format of the output image',
      }),
    ),
    sync_mode: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            "If `True`, the media will be returned as a data URI and won't be saved in history.",
        }),
      )
      .default(false),
    guidance_scale: z
      .optional(
        z.number().gte(0).lte(20).register(z.globalRegistry, {
          description:
            'The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.',
        }),
      )
      .default(2.5),
    seed: z.optional(z.union([z.int(), z.unknown()])),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the safety checker for the generated image.',
        }),
      )
      .default(true),
    num_inference_steps: z
      .optional(
        z.int().gte(1).lte(50).register(z.globalRegistry, {
          description: 'The number of inference steps to perform.',
        }),
      )
      .default(40),
  })
  .register(z.globalRegistry, {
    description:
      'Input model for Sepia Vintage Photography endpoint - Generate vintage sepia style images',
  })

/**
 * ZImageTurboOutput
 */
export const zSchemaZImageTurboOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      'Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'The timings of the generation process.',
  }),
})

/**
 * ZImageTurboTextToImageInput
 */
export const zSchemaZImageTurboInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * OvisImageOutput
 */
export const zSchemaOvisImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * TextToImageInput
 */
export const zSchemaOvisImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: 'The guidance scale to use for the image generation.',
      }),
    )
    .default(5),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to generate an image from.',
      }),
    )
    .default(''),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
})

/**
 * ZImageTurboOutput
 */
export const zSchemaZImageTurboLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      'Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'The timings of the generation process.',
  }),
})

/**
 * LoRAInput
 *
 * LoRA weight configuration.
 */
export const zSchemaLoRaInput = z
  .object({
    path: z.string().register(z.globalRegistry, {
      description: 'URL, HuggingFace repo ID (owner/repo) to lora weights.',
    }),
    scale: z
      .optional(
        z.number().gte(0).lte(4).register(z.globalRegistry, {
          description: 'Scale factor for LoRA application (0.0 to 4.0).',
        }),
      )
      .default(1),
  })
  .register(z.globalRegistry, {
    description: 'LoRA weight configuration.',
  })

/**
 * ZImageTurboTextToImageLoRAInput
 */
export const zSchemaZImageTurboLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoRaInput).register(z.globalRegistry, {
        description: 'List of LoRA weights to apply (maximum 3).',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(8).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(8),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * TextToImageOutput
 */
export const zSchemaViduQ2TextToImageOutput = z.object({
  image: zSchemaImage,
})

/**
 * TextToImageRequest
 */
export const zSchemaViduQ2TextToImageInput = z.object({
  prompt: z.string().max(1500).register(z.globalRegistry, {
    description: 'Text prompt for video generation, max 1500 characters',
  }),
  aspect_ratio: z.optional(
    z.enum(['16:9', '9:16', '1:1']).register(z.globalRegistry, {
      description: 'The aspect ratio of the output video',
    }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for generation',
    }),
  ),
})

/**
 * SeedDream45T2IOutput
 */
export const zSchemaBytedanceSeedreamV45TextToImageOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Generated images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation',
  }),
})

/**
 * SeedDream45T2IInput
 */
export const zSchemaBytedanceSeedreamV45TextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The text prompt used to generate the image',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(6).register(z.globalRegistry, {
        description:
          'Number of separate model generations to be run with the prompt.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
        'auto_2K',
        'auto_4K',
      ]),
    ]),
  ),
  max_images: z
    .optional(
      z.int().gte(1).lte(6).register(z.globalRegistry, {
        description:
          'If set to a number greater than one, enables multi-image generation. The model will potentially return up to `max_images` images every generation, and in total, `num_images` generations will be carried out. In total, the number of images generated will be between `num_images` and `max_images*num_images`.',
      }),
    )
    .default(1),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed to control the stochasticity of image generation.',
    }),
  ),
})

/**
 * TextToImageOutput
 */
export const zSchemaLongcatImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaLongcatImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: 'The guidance scale to use for the image generation.',
      }),
    )
    .default(4.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * Flux2MaxOutput
 */
export const zSchemaFlux2MaxOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for the generation.',
  }),
})

/**
 * Flux2MaxTextToImageInput
 */
export const zSchemaFlux2MaxInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable the safety checker.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed to use for the generation.',
    }),
  ),
})

/**
 * Flux2TurboT2IOutput
 */
export const zSchemaFlux2TurboOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * Flux2TurboTextToImageInput
 */
export const zSchemaFlux2TurboInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(2.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded for better results.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * GaiaOutputModel
 */
export const zSchemaFiboLiteGenerateOutput = z.object({
  images: z
    .optional(
      z.array(z.record(z.string(), z.unknown())).register(z.globalRegistry, {
        description: 'Generated images.',
      }),
    )
    .default([]),
  image: zSchemaImage,
  structured_prompt: z
    .record(z.string(), z.unknown())
    .register(z.globalRegistry, {
      description: 'Current prompt.',
    }),
})

/**
 * GaiaLiteInputModel
 */
export const zSchemaFiboLiteGenerateInput = z.object({
  prompt: z.optional(z.union([z.string(), z.unknown()])),
  steps_num: z
    .optional(
      z.int().gte(4).lte(30).register(z.globalRegistry, {
        description: 'Number of inference steps for Fibo Lite.',
      }),
    )
    .default(8),
  aspect_ratio: z.optional(
    z
      .enum(['1:1', '2:3', '3:2', '3:4', '4:3', '4:5', '5:4', '9:16', '16:9'])
      .register(z.globalRegistry, {
        description:
          'Aspect ratio. Options: 1:1, 2:3, 3:2, 3:4, 4:3, 4:5, 5:4, 9:16, 16:9',
      }),
  ),
  image_url: z.optional(z.union([z.string(), z.unknown()])),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If true, returns the image directly in the response (increases latency).',
      }),
    )
    .default(false),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Random seed for reproducibility.',
      }),
    )
    .default(5555),
  structured_prompt: z.optional(
    z.union([zSchemaStructuredPrompt, z.unknown()]),
  ),
})

/**
 * ImageResponse
 */
export const zSchemaGptImage15Output = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
})

/**
 * TextToImageRequest
 */
export const zSchemaGptImage15Input = z.object({
  prompt: z.string().min(2).register(z.globalRegistry, {
    description: 'The prompt for image generation',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'Number of images to generate',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.enum(['1024x1024', '1536x1024', '1024x1536']).register(z.globalRegistry, {
      description: 'Aspect ratio for the generated image',
    }),
  ),
  background: z.optional(
    z.enum(['auto', 'transparent', 'opaque']).register(z.globalRegistry, {
      description: 'Background for the generated image',
    }),
  ),
  quality: z.optional(
    z.enum(['low', 'medium', 'high']).register(z.globalRegistry, {
      description: 'Quality for the generated image',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'Output format for the images',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
})

/**
 * Flux2FlashT2IOutput
 */
export const zSchemaFlux2FlashOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * Flux2FlashTextToImageInput
 */
export const zSchemaFlux2FlashInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(2.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded for better results.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * TextToImageWanOutput
 *
 * Output for Wan 2.6 text-to-image (can include generated text in mixed mode)
 */
export const zSchemaV26TextToImageOutput = z
  .object({
    images: z.array(zSchemaFile).register(z.globalRegistry, {
      description: 'Generated images in PNG format',
    }),
    seed: z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
    generated_text: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'Generated text content (in mixed text-and-image mode). May be None if only images were generated.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description:
      'Output for Wan 2.6 text-to-image (can include generated text in mixed mode)',
  })

/**
 * TextToImageWanInput
 *
 * Input for Wan 2.6 text-to-image or mixed text-and-image generation (enable_interleave=true)
 */
export const zSchemaV26TextToImageInput = z
  .object({
    prompt: z.string().min(1).register(z.globalRegistry, {
      description:
        'Text prompt describing the desired image. Supports Chinese and English. Max 2000 characters.',
    }),
    image_size: z.optional(
      z.union([
        zSchemaImageSize,
        z.enum([
          'square_hd',
          'square',
          'portrait_4_3',
          'portrait_16_9',
          'landscape_4_3',
          'landscape_16_9',
        ]),
      ]),
    ),
    max_images: z
      .optional(
        z.int().gte(1).lte(5).register(z.globalRegistry, {
          description:
            'Maximum number of images to generate (1-5). Actual count may be less depending on model inference.',
        }),
      )
      .default(1),
    image_url: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'Optional reference image (0 or 1). When provided, can be used for style guidance. Resolution: 384-5000px each dimension. Max size: 10MB. Formats: JPEG, JPG, PNG (no alpha), BMP, WEBP.',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Enable content moderation for input and output.',
        }),
      )
      .default(true),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'Random seed for reproducibility (0-2147483647).',
      }),
    ),
    negative_prompt: z
      .optional(
        z.string().register(z.globalRegistry, {
          description:
            'Content to avoid in the generated image. Max 500 characters.',
        }),
      )
      .default(''),
  })
  .register(z.globalRegistry, {
    description:
      'Input for Wan 2.6 text-to-image or mixed text-and-image generation (enable_interleave=true)',
  })

/**
 * QwenImage2512Output
 */
export const zSchemaQwenImage2512Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaQwenImage2512Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'The guidance scale to use for the image generation.',
      }),
    )
    .default(4),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to generate an image from.',
      }),
    )
    .default(''),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
})

/**
 * QwenImage2512Output
 */
export const zSchemaQwenImage2512LoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * LoraInput
 */
export const zSchemaQwenImage2512LoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use up to 3 LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'The guidance scale to use for the image generation.',
      }),
    )
    .default(4),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to generate an image from.',
      }),
    )
    .default(''),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
})

/**
 * GlmImageOutput
 */
export const zSchemaGlmImageOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'List of URLs to the generated images.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * GlmImageInput
 */
export const zSchemaGlmImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text prompt for image generation.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'Number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
        'portrait_3_2',
        'landscape_3_2',
        'portrait_hd',
        'landscape_hd',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'Output image format.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If True, the image will be returned as a base64 data URI instead of a URL.',
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher values make the model follow the prompt more closely.',
      }),
    )
    .default(1.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Random seed for reproducibility. The same seed with the same prompt will produce the same image.',
    }),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If True, the prompt will be enhanced using an LLM for more detailed and higher quality results.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(10).lte(100).register(z.globalRegistry, {
        description:
          'Number of diffusion denoising steps. More steps generally produce higher quality images.',
      }),
    )
    .default(30),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Enable NSFW safety checking on the generated images.',
      }),
    )
    .default(true),
})

/**
 * ImagineArt_1_5_Output
 */
export const zSchemaImagineart15ProPreviewTextToImageOutput = z.object({
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Generated image',
  }),
})

/**
 * ImagineArt_1_5_Input
 */
export const zSchemaImagineart15ProPreviewTextToImageInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text prompt describing the desired image',
  }),
  aspect_ratio: z.optional(
    z
      .enum(['1:1', '16:9', '9:16', '4:3', '3:4', '3:1', '1:3', '3:2', '2:3'])
      .register(z.globalRegistry, {
        description:
          'Image aspect ratio: 1:1, 3:1, 1:3, 16:9, 9:16, 4:3, 3:4, 3:2, 2:3',
      }),
  ),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Seed for the image generation',
    }),
  ),
})

/**
 * Klein4BDistilledT2IOutput
 */
export const zSchemaFlux2Klein4bOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * KleinDistilledInput
 */
export const zSchemaFlux2Klein4bInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If `True`, the media will be returned as a data URI. Output is not stored when this is True.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(8).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(4),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
})

/**
 * Klein9BDistilledT2IOutput
 */
export const zSchemaFlux2Klein9bOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * Klein9BDistilledInput
 */
export const zSchemaFlux2Klein9bInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If `True`, the media will be returned as a data URI. Output is not stored when this is True.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(8).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(4),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
})

/**
 * Klein4BT2IOutput
 */
export const zSchemaFlux2Klein4bBaseOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * Klein4BBaseInput
 */
export const zSchemaFlux2Klein4bBaseInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use for image generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If `True`, the media will be returned as a data URI. Output is not stored when this is True.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Negative prompt for classifier-free guidance. Describes what to avoid in the image.',
      }),
    )
    .default(''),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for classifier-free guidance.',
      }),
    )
    .default(5),
})

/**
 * Klein9BT2IOutput
 */
export const zSchemaFlux2Klein9bBaseOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * Klein9BBaseInput
 */
export const zSchemaFlux2Klein9bBaseInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use for image generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If `True`, the media will be returned as a data URI. Output is not stored when this is True.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Negative prompt for classifier-free guidance. Describes what to avoid in the image.',
      }),
    )
    .default(''),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for classifier-free guidance.',
      }),
    )
    .default(5),
})

/**
 * KleinT2IOutput
 */
export const zSchemaFlux2Klein4bBaseLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * LoRAInput
 */
export const zSchemaFalAiFlux2KleinLoRaInput = z.object({
  path: z.string().register(z.globalRegistry, {
    description:
      'URL, HuggingFace repo ID (owner/repo), or local path to LoRA weights.',
  }),
  scale: z
    .optional(
      z.number().gte(0).lte(4).register(z.globalRegistry, {
        description: 'Scale factor for LoRA application (0.0 to 4.0).',
      }),
    )
    .default(1),
})

/**
 * KleinBaseLoRAInput
 */
export const zSchemaFlux2Klein4bBaseLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use for image generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaFalAiFlux2KleinLoRaInput).register(z.globalRegistry, {
        description: 'List of LoRA weights to apply (maximum 3).',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If `True`, the media will be returned as a data URI. Output is not stored when this is True.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Negative prompt for classifier-free guidance. Describes what to avoid in the image.',
      }),
    )
    .default(''),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for classifier-free guidance.',
      }),
    )
    .default(5),
})

/**
 * KleinT2IOutput
 */
export const zSchemaFlux2Klein9bBaseLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * KleinBaseLoRAInput
 */
export const zSchemaFlux2Klein9bBaseLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use for image generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaFalAiFlux2KleinLoRaInput).register(z.globalRegistry, {
        description: 'List of LoRA weights to apply (maximum 3).',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If `True`, the media will be returned as a data URI. Output is not stored when this is True.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'Negative prompt for classifier-free guidance. Describes what to avoid in the image.',
      }),
    )
    .default(''),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for classifier-free guidance.',
      }),
    )
    .default(5),
})

/**
 * ZImageBaseOutput
 */
export const zSchemaZImageBaseOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      'Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'The timings of the generation process.',
  }),
})

/**
 * ZImageBaseTextToImageInput
 */
export const zSchemaZImageBaseInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: 'The guidance scale to use for the image generation.',
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to use for the image generation.',
      }),
    )
    .default(''),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * ZImageBaseOutput
 */
export const zSchemaZImageBaseLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      'Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'The timings of the generation process.',
  }),
})

/**
 * ZImageBaseTextToImageLoRAInput
 */
export const zSchemaZImageBaseLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoRaInput).register(z.globalRegistry, {
        description: 'List of LoRA weights to apply (maximum 3).',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description: 'The guidance scale to use for the image generation.',
      }),
    )
    .default(4),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'The negative prompt to use for the image generation.',
      }),
    )
    .default(''),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Output
 */
export const zSchemaFluxLoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaFluxLoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description:
          'The number of images to generate. This is always set to 1 for streaming output.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(35).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * ControlNetUnionInput
 */
export const zSchemaControlNetUnionInput = z.object({
  conditioning_scale: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description:
          '\n            The scale of the control net weight. This is used to scale the control net weight\n            before merging it with the base model.\n        ',
      }),
    )
    .default(1),
  mask_threshold: z
    .optional(
      z.number().gte(0.01).lte(0.99).register(z.globalRegistry, {
        description: 'Threshold for mask.',
      }),
    )
    .default(0.5),
  end_percentage: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The percentage of the image to end applying the controlnet in terms of the total timesteps.\n        ',
      }),
    )
    .default(1),
  mask_image_url: z.optional(z.union([z.string(), z.null()])),
  control_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be used as the control image.',
  }),
  control_mode: z
    .enum(['canny', 'tile', 'depth', 'blur', 'pose', 'gray', 'low-quality'])
    .register(z.globalRegistry, {
      description:
        'Control Mode for Flux Controlnet Union. Supported values are:\n        - canny: Uses the edges for guided generation.\n        - tile: Uses the tiles for guided generation.\n        - depth: Utilizes a grayscale depth map for guided generation.\n        - blur: Adds a blur to the image.\n        - pose: Uses the pose of the image for guided generation.\n        - gray: Converts the image to grayscale.\n        - low-quality: Converts the image to a low-quality image.',
    }),
  start_percentage: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The percentage of the image to start applying the controlnet in terms of the total timesteps.\n        ',
      }),
    )
    .default(0),
})

/**
 * ControlNetUnion
 */
export const zSchemaControlNetUnion = z.object({
  controls: z.array(zSchemaControlNetUnionInput).register(z.globalRegistry, {
    description: 'The control images and modes to use for the control net.',
  }),
  path: z.string().register(z.globalRegistry, {
    description: 'URL or the path to the control net weights.',
  }),
  variant: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The optional variant if a Hugging Face repo key is used.',
    }),
  ),
  config_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'optional URL to the controlnet config.json file.',
    }),
  ),
})

/**
 * ImageFillInput
 */
export const zSchemaImageFillInput = z.object({
  fill_image_url: z.optional(z.union([z.string(), z.array(z.string())])),
})

/**
 * EasyControlWeight
 */
export const zSchemaEasyControlWeight = z.object({
  scale: z
    .optional(
      z.number().gte(0).lte(2).register(z.globalRegistry, {
        description: 'Scale for the control method.',
      }),
    )
    .default(1),
  image_control_type: z
    .enum(['subject', 'spatial'])
    .register(z.globalRegistry, {
      description:
        'Control type of the image. Must be one of `spatial` or `subject`.',
    }),
  control_method_url: z.string().register(z.globalRegistry, {
    description:
      'URL to safetensor weights of control method to be applied. Can also be one of `canny`, `depth`, `hedsketch`, `inpainting`, `pose`, `seg`, `subject`, `ghibli` ',
  }),
  image_url: z.string().register(z.globalRegistry, {
    description: 'URL of an image to use as a control',
  }),
})

/**
 * ControlLoraWeight
 */
export const zSchemaControlLoraWeight = z.object({
  path: z.string().register(z.globalRegistry, {
    description: 'URL or the path to the LoRA weights.',
  }),
  scale: z.optional(
    z.union([z.record(z.string(), z.unknown()), z.number().gte(-4).lte(4)]),
  ),
  control_image_url: z.string().register(z.globalRegistry, {
    description: 'URL of the image to be used as the control image.',
  }),
  preprocess: z.optional(
    z.enum(['canny', 'depth', 'None']).register(z.globalRegistry, {
      description: 'Type of preprocessing to apply to the input image.',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaFluxGeneralOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaFluxGeneralInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  nag_end: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          '\n            The proportion of steps to apply NAG. After the specified proportion\n            of steps has been iterated, the remaining steps will use original\n            attention processors in FLUX.\n        ',
      }),
    )
    .default(0.25),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  control_loras: z
    .optional(
      z.array(zSchemaControlLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation which use a control image. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  scheduler: z.optional(
    z.enum(['euler', 'dpmpp_2m']).register(z.globalRegistry, {
      description: 'Scheduler for the denoising process.',
    }),
  ),
  easycontrols: z
    .optional(
      z.array(zSchemaEasyControlWeight).register(z.globalRegistry, {
        description:
          '\n        EasyControl Inputs to use for image generation.\n        ',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  real_cfg_scale: z
    .optional(
      z.number().gte(0).lte(5).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  use_cfg_zero: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            Uses CFG-zero init sampling as in https://arxiv.org/abs/2503.18886.\n        ',
      }),
    )
    .default(false),
  fill_image: z.optional(zSchemaImageFillInput),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  sigma_schedule: z.optional(
    z.enum(['sgm_uniform']).register(z.globalRegistry, {
      description: 'Sigmas schedule for the denoising process.',
    }),
  ),
  reference_end: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The percentage of the total timesteps when the reference guidance is to be ended.\n        ',
      }),
    )
    .default(1),
  reference_strength: z
    .optional(
      z.number().gte(-3).lte(3).register(z.globalRegistry, {
        description:
          'Strength of reference_only generation. Only used if a reference image is provided.',
      }),
    )
    .default(0.65),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  nag_scale: z
    .optional(
      z.number().lte(10).register(z.globalRegistry, {
        description:
          '\n            The scale for NAG. Higher values will result in a image that is more distant\n            to the negative prompt.\n        ',
      }),
    )
    .default(3),
  reference_image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'URL of Image for Reference-Only',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  controlnet_unions: z
    .optional(
      z.array(zSchemaControlNetUnion).register(z.globalRegistry, {
        description:
          '\n            The controlnet unions to use for the image generation. Only one controlnet is supported at the moment.\n        ',
      }),
    )
    .default([]),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          '\n            Negative prompt to steer the image generation away from unwanted features.\n            By default, we will be using NAG for processing the negative prompt.\n        ',
      }),
    )
    .default(''),
  nag_tau: z
    .optional(
      z.number().register(z.globalRegistry, {
        description:
          '\n            The tau for NAG. Controls the normalization of the hidden state.\n            Higher values will result in a less aggressive normalization,\n            but may also lead to unexpected changes with respect to the original image.\n            Not recommended to change this value.\n        ',
      }),
    )
    .default(2.5),
  num_images: z
    .optional(
      z.int().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'The number of images to generate. This is always set to 1 for streaming output.',
      }),
    )
    .default(1),
  use_beta_schedule: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Specifies whether beta sigmas ought to be used.',
      }),
    )
    .default(false),
  ip_adapters: z
    .optional(
      z.array(zSchemaIpAdapter).register(z.globalRegistry, {
        description:
          '\n        IP-Adapter to use for image generation.\n        ',
      }),
    )
    .default([]),
  base_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: 'Base shift for the scheduled timesteps',
      }),
    )
    .default(0.5),
  nag_alpha: z
    .optional(
      z.number().lte(1).register(z.globalRegistry, {
        description:
          '\n            The alpha value for NAG. This value is used as a final weighting\n            factor for steering the normalized guidance (positive and negative prompts)\n            in the direction of the positive prompt. Higher values will result in less\n            steering on the normalized guidance where lower values will result in\n            considering the positive prompt guidance more.\n        ',
      }),
    )
    .default(0.25),
  use_real_cfg: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          '\n            Uses classical CFG as in SD1.5, SDXL, etc. Increases generation times and price when set to be true.\n            If using XLabs IP-Adapter v1, this will be turned on!.\n        ',
      }),
    )
    .default(false),
  max_shift: z
    .optional(
      z.number().gte(0.01).lte(5).register(z.globalRegistry, {
        description: 'Max shift for the scheduled timesteps',
      }),
    )
    .default(1.15),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  controlnets: z
    .optional(
      z.array(zSchemaControlNet).register(z.globalRegistry, {
        description:
          '\n            The controlnets to use for the image generation. Only one controlnet is supported at the moment.\n        ',
      }),
    )
    .default([]),
  reference_start: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description:
          '\n            The percentage of the total timesteps when the reference guidance is to bestarted.\n        ',
      }),
    )
    .default(0),
})

/**
 * Output
 */
export const zSchemaStableDiffusionV35LargeOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * TextToImageInput
 */
export const zSchemaStableDiffusionV35LargeInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  controlnet: z.optional(zSchemaControlNet),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  ip_adapter: z.optional(zSchemaIpAdapter),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          '\n            The LoRAs to use for the image generation. You can use any number of LoRAs\n            and they will be merged together to generate the final image.\n        ',
      }),
    )
    .default([]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(3.5),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaIdeogramV2Output = z.object({
  images: z.array(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for the random number generator',
  }),
})

/**
 * TextToImageInput
 */
export const zSchemaIdeogramV2Input = z.object({
  prompt: z.string(),
  aspect_ratio: z.optional(
    z
      .enum([
        '10:16',
        '16:10',
        '9:16',
        '16:9',
        '4:3',
        '3:4',
        '1:1',
        '1:3',
        '3:1',
        '3:2',
        '2:3',
      ])
      .register(z.globalRegistry, {
        description: 'The aspect ratio of the generated image',
      }),
  ),
  style: z.optional(
    z
      .enum(['auto', 'general', 'realistic', 'design', 'render_3D', 'anime'])
      .register(z.globalRegistry, {
        description: 'The style of the generated image',
      }),
  ),
  expand_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to expand the prompt with MagicPrompt functionality.',
      }),
    )
    .default(true),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'A negative prompt to avoid in the generated image',
      }),
    )
    .default(''),
})

/**
 * Output
 */
export const zSchemaFluxDevOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * BaseInput
 */
export const zSchemaFluxDevInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description:
        'The speed of the generation. The higher the speed, the faster the generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(20).register(z.globalRegistry, {
        description:
          '\n        The CFG (Classifier Free Guidance) scale is a measure of how close you want\n        the model to stick to your prompt when looking for a related image to show you.\n    ',
      }),
    )
    .default(3.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
})

/**
 * Output
 */
export const zSchemaHidreamI1FastOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * FastInput
 */
export const zSchemaHidreamI1FastInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(16),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
})

/**
 * Output
 */
export const zSchemaHidreamI1DevOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'The generated image files info.',
  }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * DevInput
 */
export const zSchemaHidreamI1DevInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
})

export const zSchemaHidreamI1FullOutput = z.unknown()

/**
 * TextToImageInput
 */
export const zSchemaHidreamI1FullInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  loras: z
    .optional(
      z.array(zSchemaLoraWeight).register(z.globalRegistry, {
        description:
          'A list of LoRAs to apply to the model. Each LoRA specifies its path, scale, and optional weight name.',
      }),
    )
    .default([]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          '\n            The CFG (Classifier Free Guidance) scale is a measure of how close you want\n            the model to stick to your prompt when looking for a related image to show you.\n        ',
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(50),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "\n            The negative prompt to use. Use it to address details that you don't want\n            in the image. This could be colors, objects, scenery and even the small details\n            (e.g. moustache, blurry, low resolution).\n        ",
      }),
    )
    .default(''),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Imagen4TextToImageFastOutput
 */
export const zSchemaImagen4PreviewFastOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  description: z.string().register(z.globalRegistry, {
    description: 'The description of the generated images.',
  }),
})

/**
 * Imagen4TextToImageFastInput
 */
export const zSchemaImagen4PreviewFastInput = z.object({
  prompt: z.string().min(3).max(5000).register(z.globalRegistry, {
    description: 'The text prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z.enum(['1:1', '16:9', '9:16', '4:3', '3:4']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
})

/**
 * OutputModel
 */
export const zSchemaTextToImage32Output = z.object({
  image: zSchemaImage,
})

/**
 * InputModel
 */
export const zSchemaTextToImage32Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Prompt for image generation.',
  }),
  aspect_ratio: z.optional(
    z
      .enum(['1:1', '2:3', '3:2', '3:4', '4:3', '4:5', '5:4', '9:16', '16:9'])
      .register(z.globalRegistry, {
        description:
          'Aspect ratio. Options: 1:1, 2:3, 3:2, 3:4, 4:3, 4:5, 5:4, 9:16, 16:9',
      }),
  ),
  prompt_enhancer: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to improve the prompt.',
      }),
    )
    .default(true),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If true, returns the image directly in the response (increases latency).',
      }),
    )
    .default(false),
  truncate_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to truncate the prompt.',
      }),
    )
    .default(true),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description: 'Guidance scale for text.',
      }),
    )
    .default(5),
  num_inference_steps: z
    .optional(
      z.int().gte(20).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps.',
      }),
    )
    .default(30),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Random seed for reproducibility.',
      }),
    )
    .default(5555),
  negative_prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description: 'Negative prompt for image generation.',
      }),
    )
    .default(
      'Logo,Watermark,Ugly,Morbid,Extra fingers,Poorly drawn hands,Mutation,Blurry,Extra limbs,Gross proportions,Missing arms,Mutated hands,Long neck,Duplicate,Mutilated,Mutilated hands,Poorly drawn face,Deformed,Bad anatomy,Cloned face,Malformed limbs,Missing legs,Too many fingers',
    ),
})

/**
 * Flux2ProOutput
 */
export const zSchemaFlux2ProOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description: 'The seed used for the generation.',
  }),
})

/**
 * Flux2ProTextToImageInput
 */
export const zSchemaFlux2ProInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable the safety checker.',
      }),
    )
    .default(true),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed to use for the generation.',
    }),
  ),
})

/**
 * Flux2T2IOutput
 */
export const zSchemaFlux2Output = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * Flux2TextToImageInput
 */
export const zSchemaFlux2Input = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use for the image generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(2.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded for better results.',
      }),
    )
    .default(false),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * Flux2T2ILoRAOutput
 */
export const zSchemaFlux2LoraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  timings: z.record(z.string(), z.number()),
})

/**
 * Flux2TextToImageLoRAInput
 */
export const zSchemaFlux2LoraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  acceleration: z.optional(
    z.enum(['none', 'regular', 'high']).register(z.globalRegistry, {
      description: 'The acceleration level to use for the image generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  loras: z
    .optional(
      z.array(zSchemaLoRaInput).register(z.globalRegistry, {
        description:
          'List of LoRA weights to apply (maximum 3). Each LoRA can be a URL, HuggingFace repo ID, or local path.',
      }),
    )
    .default([]),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description:
          'Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.',
      }),
    )
    .default(2.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The seed to use for the generation. If not provided, a random seed will be used.',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(4).lte(50).register(z.globalRegistry, {
        description: 'The number of inference steps to perform.',
      }),
    )
    .default(28),
  enable_prompt_expansion: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set to true, the prompt will be expanded for better results.',
      }),
    )
    .default(false),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
})

/**
 * TextToImageOutput
 */
export const zSchemaRecraftV3TextToImageOutput = z.object({
  images: z.array(zSchemaFile),
})

/**
 * TextToImageInput
 */
export const zSchemaRecraftV3TextToImageInput = z.object({
  prompt: z.string().min(1).max(1000),
  image_size: z.optional(
    z.union([
      zSchemaImageSize,
      z.enum([
        'square_hd',
        'square',
        'portrait_4_3',
        'portrait_16_9',
        'landscape_4_3',
        'landscape_16_9',
      ]),
    ]),
  ),
  style: z.optional(
    z
      .enum([
        'any',
        'realistic_image',
        'digital_illustration',
        'vector_illustration',
        'realistic_image/b_and_w',
        'realistic_image/hard_flash',
        'realistic_image/hdr',
        'realistic_image/natural_light',
        'realistic_image/studio_portrait',
        'realistic_image/enterprise',
        'realistic_image/motion_blur',
        'realistic_image/evening_light',
        'realistic_image/faded_nostalgia',
        'realistic_image/forest_life',
        'realistic_image/mystic_naturalism',
        'realistic_image/natural_tones',
        'realistic_image/organic_calm',
        'realistic_image/real_life_glow',
        'realistic_image/retro_realism',
        'realistic_image/retro_snapshot',
        'realistic_image/urban_drama',
        'realistic_image/village_realism',
        'realistic_image/warm_folk',
        'digital_illustration/pixel_art',
        'digital_illustration/hand_drawn',
        'digital_illustration/grain',
        'digital_illustration/infantile_sketch',
        'digital_illustration/2d_art_poster',
        'digital_illustration/handmade_3d',
        'digital_illustration/hand_drawn_outline',
        'digital_illustration/engraving_color',
        'digital_illustration/2d_art_poster_2',
        'digital_illustration/antiquarian',
        'digital_illustration/bold_fantasy',
        'digital_illustration/child_book',
        'digital_illustration/child_books',
        'digital_illustration/cover',
        'digital_illustration/crosshatch',
        'digital_illustration/digital_engraving',
        'digital_illustration/expressionism',
        'digital_illustration/freehand_details',
        'digital_illustration/grain_20',
        'digital_illustration/graphic_intensity',
        'digital_illustration/hard_comics',
        'digital_illustration/long_shadow',
        'digital_illustration/modern_folk',
        'digital_illustration/multicolor',
        'digital_illustration/neon_calm',
        'digital_illustration/noir',
        'digital_illustration/nostalgic_pastel',
        'digital_illustration/outline_details',
        'digital_illustration/pastel_gradient',
        'digital_illustration/pastel_sketch',
        'digital_illustration/pop_art',
        'digital_illustration/pop_renaissance',
        'digital_illustration/street_art',
        'digital_illustration/tablet_sketch',
        'digital_illustration/urban_glow',
        'digital_illustration/urban_sketching',
        'digital_illustration/vanilla_dreams',
        'digital_illustration/young_adult_book',
        'digital_illustration/young_adult_book_2',
        'vector_illustration/bold_stroke',
        'vector_illustration/chemistry',
        'vector_illustration/colored_stencil',
        'vector_illustration/contour_pop_art',
        'vector_illustration/cosmics',
        'vector_illustration/cutout',
        'vector_illustration/depressive',
        'vector_illustration/editorial',
        'vector_illustration/emotional_flat',
        'vector_illustration/infographical',
        'vector_illustration/marker_outline',
        'vector_illustration/mosaic',
        'vector_illustration/naivector',
        'vector_illustration/roundish_flat',
        'vector_illustration/segmented_colors',
        'vector_illustration/sharp_contrast',
        'vector_illustration/thin',
        'vector_illustration/vector_photo',
        'vector_illustration/vivid_shapes',
        'vector_illustration/engraving',
        'vector_illustration/line_art',
        'vector_illustration/line_circuit',
        'vector_illustration/linocut',
      ])
      .register(z.globalRegistry, {
        description:
          'The style of the generated images. Vector images cost 2X as much.',
      }),
  ),
  colors: z
    .optional(
      z.array(zSchemaRgbColor).register(z.globalRegistry, {
        description: 'An array of preferable colors',
      }),
    )
    .default([]),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(false),
  style_id: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The ID of the custom style reference (optional)',
    }),
  ),
})

/**
 * Output
 */
export const zSchemaFluxProV11UltraOutput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt used for generating the image.',
  }),
  images: z
    .array(zSchemaRegistryImageFastSdxlModelsImage)
    .register(z.globalRegistry, {
      description: 'The generated image files info.',
    }),
  timings: z.record(z.string(), z.number()),
  has_nsfw_concepts: z.array(z.boolean()).register(z.globalRegistry, {
    description: 'Whether the generated images contain NSFW concepts.',
  }),
  seed: z.int().register(z.globalRegistry, {
    description:
      '\n            Seed of the generated Image. It will be the same value of the one passed in the\n            input or the randomly generated that was used in case none was passed.\n        ',
  }),
})

/**
 * FluxProUltraTextToImageInput
 */
export const zSchemaFluxProV11UltraInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'The prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z.union([
      z.enum([
        '21:9',
        '16:9',
        '4:3',
        '3:2',
        '1:1',
        '2:3',
        '3:4',
        '9:16',
        '9:21',
      ]),
      z.string(),
    ]),
  ),
  enhance_prompt: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enhance the prompt for better results.',
      }),
    )
    .default(false),
  output_format: z.optional(
    z.enum(['jpeg', 'png']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
  image_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The image URL to generate an image from.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  safety_tolerance: z.optional(
    z.enum(['1', '2', '3', '4', '5', '6']).register(z.globalRegistry, {
      description:
        'The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.',
    }),
  ),
  image_prompt_strength: z
    .optional(
      z.number().gte(0).lte(1).register(z.globalRegistry, {
        description: 'The strength of the image prompt, between 0 and 1.',
      }),
    )
    .default(0.1),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  enable_safety_checker: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'If set to true, the safety checker will be enabled.',
      }),
    )
    .default(true),
  raw: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Generate less processed, more natural-looking images.',
      }),
    )
    .default(false),
})

/**
 * Imagen4TextToImageOutput
 */
export const zSchemaImagen4PreviewOutput = z.object({
  images: z.array(zSchemaImageFile).register(z.globalRegistry, {
    description: 'The generated images.',
  }),
  description: z.string().register(z.globalRegistry, {
    description: 'The description of the generated images.',
  }),
})

/**
 * Imagen4TextToImageInput
 */
export const zSchemaImagen4PreviewInput = z.object({
  prompt: z.string().min(3).max(5000).register(z.globalRegistry, {
    description: 'The text prompt to generate an image from.',
  }),
  num_images: z
    .optional(
      z.int().gte(1).lte(4).register(z.globalRegistry, {
        description: 'The number of images to generate.',
      }),
    )
    .default(1),
  aspect_ratio: z.optional(
    z.enum(['1:1', '16:9', '9:16', '4:3', '3:4']).register(z.globalRegistry, {
      description: 'The aspect ratio of the generated image.',
    }),
  ),
  resolution: z.optional(
    z.enum(['1K', '2K']).register(z.globalRegistry, {
      description: 'The resolution of the generated image.',
    }),
  ),
  sync_mode: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          "If `True`, the media will be returned as a data URI and the output data won't be available in the request history.",
      }),
    )
    .default(false),
  output_format: z.optional(
    z.enum(['jpeg', 'png', 'webp']).register(z.globalRegistry, {
      description: 'The format of the generated image.',
    }),
  ),
})

export const zSchemaQueueStatus = z.object({
  status: z.enum(['IN_QUEUE', 'IN_PROGRESS', 'COMPLETED']),
  request_id: z.string().register(z.globalRegistry, {
    description: 'The request id.',
  }),
  response_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The response url.',
    }),
  ),
  status_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The status url.',
    }),
  ),
  cancel_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The cancel url.',
    }),
  ),
  logs: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The logs.',
    }),
  ),
  metrics: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The metrics.',
    }),
  ),
  queue_position: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The queue position.',
    }),
  ),
})

export const zGetFalAiImagen4PreviewRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiImagen4PreviewRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImagen4PreviewRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiImagen4PreviewRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImagen4PreviewData = z.object({
  body: zSchemaImagen4PreviewInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImagen4PreviewResponse = zSchemaQueueStatus

export const zGetFalAiImagen4PreviewRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImagen4PreviewRequestsByRequestIdResponse =
  zSchemaImagen4PreviewOutput

export const zGetFalAiFluxProV11UltraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxProV11UltraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxProV11UltraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProV11UltraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxProV11UltraData = z.object({
  body: zSchemaFluxProV11UltraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxProV11UltraResponse = zSchemaQueueStatus

export const zGetFalAiFluxProV11UltraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxProV11UltraRequestsByRequestIdResponse =
  zSchemaFluxProV11UltraOutput

export const zGetFalAiRecraftV3TextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiRecraftV3TextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiRecraftV3TextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiRecraftV3TextToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiRecraftV3TextToImageData = z.object({
  body: zSchemaRecraftV3TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiRecraftV3TextToImageResponse = zSchemaQueueStatus

export const zGetFalAiRecraftV3TextToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiRecraftV3TextToImageRequestsByRequestIdResponse =
  zSchemaRecraftV3TextToImageOutput

export const zGetFalAiFlux2LoraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2LoraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2LoraData = z.object({
  body: zSchemaFlux2LoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraResponse = zSchemaQueueStatus

export const zGetFalAiFlux2LoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraRequestsByRequestIdResponse =
  zSchemaFlux2LoraOutput

export const zGetFalAiFlux2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2Data = z.object({
  body: zSchemaFlux2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2Response = zSchemaQueueStatus

export const zGetFalAiFlux2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2RequestsByRequestIdResponse = zSchemaFlux2Output

export const zGetFalAiFlux2ProRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2ProRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2ProRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2ProRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2ProData = z.object({
  body: zSchemaFlux2ProInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2ProResponse = zSchemaQueueStatus

export const zGetFalAiFlux2ProRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2ProRequestsByRequestIdResponse =
  zSchemaFlux2ProOutput

export const zGetBriaTextToImage32RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetBriaTextToImage32RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaTextToImage32RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutBriaTextToImage32RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostBriaTextToImage32Data = z.object({
  body: zSchemaTextToImage32Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaTextToImage32Response = zSchemaQueueStatus

export const zGetBriaTextToImage32RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetBriaTextToImage32RequestsByRequestIdResponse =
  zSchemaTextToImage32Output

export const zGetFalAiImagen4PreviewFastRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImagen4PreviewFastRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImagen4PreviewFastRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImagen4PreviewFastRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImagen4PreviewFastData = z.object({
  body: zSchemaImagen4PreviewFastInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImagen4PreviewFastResponse = zSchemaQueueStatus

export const zGetFalAiImagen4PreviewFastRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImagen4PreviewFastRequestsByRequestIdResponse =
  zSchemaImagen4PreviewFastOutput

export const zGetFalAiHidreamI1FullRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiHidreamI1FullRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHidreamI1FullRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiHidreamI1FullRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHidreamI1FullData = z.object({
  body: zSchemaHidreamI1FullInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHidreamI1FullResponse = zSchemaQueueStatus

export const zGetFalAiHidreamI1FullRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHidreamI1FullRequestsByRequestIdResponse =
  zSchemaHidreamI1FullOutput

export const zGetFalAiHidreamI1DevRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiHidreamI1DevRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHidreamI1DevRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiHidreamI1DevRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHidreamI1DevData = z.object({
  body: zSchemaHidreamI1DevInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHidreamI1DevResponse = zSchemaQueueStatus

export const zGetFalAiHidreamI1DevRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHidreamI1DevRequestsByRequestIdResponse =
  zSchemaHidreamI1DevOutput

export const zGetFalAiHidreamI1FastRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiHidreamI1FastRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHidreamI1FastRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiHidreamI1FastRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHidreamI1FastData = z.object({
  body: zSchemaHidreamI1FastInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHidreamI1FastResponse = zSchemaQueueStatus

export const zGetFalAiHidreamI1FastRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHidreamI1FastRequestsByRequestIdResponse =
  zSchemaHidreamI1FastOutput

export const zGetFalAiFluxDevRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxDevRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxDevRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxDevRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxDevData = z.object({
  body: zSchemaFluxDevInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxDevResponse = zSchemaQueueStatus

export const zGetFalAiFluxDevRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxDevRequestsByRequestIdResponse = zSchemaFluxDevOutput

export const zGetFalAiIdeogramV2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIdeogramV2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIdeogramV2Data = z.object({
  body: zSchemaIdeogramV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2Response = zSchemaQueueStatus

export const zGetFalAiIdeogramV2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2RequestsByRequestIdResponse =
  zSchemaIdeogramV2Output

export const zGetFalAiStableDiffusionV35LargeRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiStableDiffusionV35LargeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiStableDiffusionV35LargeRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiStableDiffusionV35LargeRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiStableDiffusionV35LargeData = z.object({
  body: zSchemaStableDiffusionV35LargeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiStableDiffusionV35LargeResponse = zSchemaQueueStatus

export const zGetFalAiStableDiffusionV35LargeRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * Result of the request.
 */
export const zGetFalAiStableDiffusionV35LargeRequestsByRequestIdResponse =
  zSchemaStableDiffusionV35LargeOutput

export const zGetFalAiFluxGeneralRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxGeneralRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxGeneralRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxGeneralRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxGeneralData = z.object({
  body: zSchemaFluxGeneralInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxGeneralResponse = zSchemaQueueStatus

export const zGetFalAiFluxGeneralRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxGeneralRequestsByRequestIdResponse =
  zSchemaFluxGeneralOutput

export const zGetFalAiFluxLoraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxLoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxLoraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxLoraData = z.object({
  body: zSchemaFluxLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxLoraResponse = zSchemaQueueStatus

export const zGetFalAiFluxLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxLoraRequestsByRequestIdResponse =
  zSchemaFluxLoraOutput

export const zGetFalAiZImageBaseLoraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiZImageBaseLoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiZImageBaseLoraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageBaseLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiZImageBaseLoraData = z.object({
  body: zSchemaZImageBaseLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiZImageBaseLoraResponse = zSchemaQueueStatus

export const zGetFalAiZImageBaseLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiZImageBaseLoraRequestsByRequestIdResponse =
  zSchemaZImageBaseLoraOutput

export const zGetFalAiZImageBaseRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiZImageBaseRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiZImageBaseRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageBaseRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiZImageBaseData = z.object({
  body: zSchemaZImageBaseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiZImageBaseResponse = zSchemaQueueStatus

export const zGetFalAiZImageBaseRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiZImageBaseRequestsByRequestIdResponse =
  zSchemaZImageBaseOutput

export const zGetFalAiFlux2Klein9bBaseLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein9bBaseLoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2Klein9bBaseLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein9bBaseLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2Klein9bBaseLoraData = z.object({
  body: zSchemaFlux2Klein9bBaseLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein9bBaseLoraResponse = zSchemaQueueStatus

export const zGetFalAiFlux2Klein9bBaseLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein9bBaseLoraRequestsByRequestIdResponse =
  zSchemaFlux2Klein9bBaseLoraOutput

export const zGetFalAiFlux2Klein4bBaseLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein4bBaseLoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2Klein4bBaseLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein4bBaseLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2Klein4bBaseLoraData = z.object({
  body: zSchemaFlux2Klein4bBaseLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein4bBaseLoraResponse = zSchemaQueueStatus

export const zGetFalAiFlux2Klein4bBaseLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein4bBaseLoraRequestsByRequestIdResponse =
  zSchemaFlux2Klein4bBaseLoraOutput

export const zGetFalAiFlux2Klein9bBaseRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein9bBaseRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2Klein9bBaseRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein9bBaseRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2Klein9bBaseData = z.object({
  body: zSchemaFlux2Klein9bBaseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein9bBaseResponse = zSchemaQueueStatus

export const zGetFalAiFlux2Klein9bBaseRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein9bBaseRequestsByRequestIdResponse =
  zSchemaFlux2Klein9bBaseOutput

export const zGetFalAiFlux2Klein4bBaseRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein4bBaseRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2Klein4bBaseRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein4bBaseRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2Klein4bBaseData = z.object({
  body: zSchemaFlux2Klein4bBaseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein4bBaseResponse = zSchemaQueueStatus

export const zGetFalAiFlux2Klein4bBaseRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein4bBaseRequestsByRequestIdResponse =
  zSchemaFlux2Klein4bBaseOutput

export const zGetFalAiFlux2Klein9bRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein9bRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2Klein9bRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein9bRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2Klein9bData = z.object({
  body: zSchemaFlux2Klein9bInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein9bResponse = zSchemaQueueStatus

export const zGetFalAiFlux2Klein9bRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein9bRequestsByRequestIdResponse =
  zSchemaFlux2Klein9bOutput

export const zGetFalAiFlux2Klein4bRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2Klein4bRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2Klein4bRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2Klein4bRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2Klein4bData = z.object({
  body: zSchemaFlux2Klein4bInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2Klein4bResponse = zSchemaQueueStatus

export const zGetFalAiFlux2Klein4bRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2Klein4bRequestsByRequestIdResponse =
  zSchemaFlux2Klein4bOutput

export const zGetImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostImagineartImagineart15ProPreviewTextToImageData = z.object({
  body: zSchemaImagineart15ProPreviewTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostImagineartImagineart15ProPreviewTextToImageResponse =
  zSchemaQueueStatus

export const zGetImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdResponse =
  zSchemaImagineart15ProPreviewTextToImageOutput

export const zGetFalAiGlmImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiGlmImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiGlmImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiGlmImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiGlmImageData = z.object({
  body: zSchemaGlmImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiGlmImageResponse = zSchemaQueueStatus

export const zGetFalAiGlmImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiGlmImageRequestsByRequestIdResponse =
  zSchemaGlmImageOutput

export const zGetFalAiQwenImage2512LoraRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiQwenImage2512LoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImage2512LoraRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImage2512LoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiQwenImage2512LoraData = z.object({
  body: zSchemaQwenImage2512LoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImage2512LoraResponse = zSchemaQueueStatus

export const zGetFalAiQwenImage2512LoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiQwenImage2512LoraRequestsByRequestIdResponse =
  zSchemaQwenImage2512LoraOutput

export const zGetFalAiQwenImage2512RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiQwenImage2512RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImage2512RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImage2512RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiQwenImage2512Data = z.object({
  body: zSchemaQwenImage2512Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImage2512Response = zSchemaQueueStatus

export const zGetFalAiQwenImage2512RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiQwenImage2512RequestsByRequestIdResponse =
  zSchemaQwenImage2512Output

export const zGetWanV26TextToImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetWanV26TextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutWanV26TextToImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutWanV26TextToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostWanV26TextToImageData = z.object({
  body: zSchemaV26TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostWanV26TextToImageResponse = zSchemaQueueStatus

export const zGetWanV26TextToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetWanV26TextToImageRequestsByRequestIdResponse =
  zSchemaV26TextToImageOutput

export const zGetFalAiFlux2FlashRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2FlashRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2FlashRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2FlashRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2FlashData = z.object({
  body: zSchemaFlux2FlashInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2FlashResponse = zSchemaQueueStatus

export const zGetFalAiFlux2FlashRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2FlashRequestsByRequestIdResponse =
  zSchemaFlux2FlashOutput

export const zGetFalAiGptImage15RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiGptImage15RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiGptImage15RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiGptImage15RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiGptImage15Data = z.object({
  body: zSchemaGptImage15Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiGptImage15Response = zSchemaQueueStatus

export const zGetFalAiGptImage15RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiGptImage15RequestsByRequestIdResponse =
  zSchemaGptImage15Output

export const zGetBriaFiboLiteGenerateRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetBriaFiboLiteGenerateRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaFiboLiteGenerateRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutBriaFiboLiteGenerateRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostBriaFiboLiteGenerateData = z.object({
  body: zSchemaFiboLiteGenerateInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaFiboLiteGenerateResponse = zSchemaQueueStatus

export const zGetBriaFiboLiteGenerateRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetBriaFiboLiteGenerateRequestsByRequestIdResponse =
  zSchemaFiboLiteGenerateOutput

export const zGetFalAiFlux2TurboRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2TurboRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2TurboRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2TurboRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2TurboData = z.object({
  body: zSchemaFlux2TurboInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2TurboResponse = zSchemaQueueStatus

export const zGetFalAiFlux2TurboRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2TurboRequestsByRequestIdResponse =
  zSchemaFlux2TurboOutput

export const zGetFalAiFlux2MaxRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2MaxRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2MaxRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2MaxRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2MaxData = z.object({
  body: zSchemaFlux2MaxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2MaxResponse = zSchemaQueueStatus

export const zGetFalAiFlux2MaxRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2MaxRequestsByRequestIdResponse =
  zSchemaFlux2MaxOutput

export const zGetFalAiLongcatImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiLongcatImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLongcatImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiLongcatImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLongcatImageData = z.object({
  body: zSchemaLongcatImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLongcatImageResponse = zSchemaQueueStatus

export const zGetFalAiLongcatImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLongcatImageRequestsByRequestIdResponse =
  zSchemaLongcatImageOutput

export const zGetFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiBytedanceSeedreamV45TextToImageData = z.object({
  body: zSchemaBytedanceSeedreamV45TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBytedanceSeedreamV45TextToImageResponse =
  zSchemaQueueStatus

export const zGetFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdResponse =
  zSchemaBytedanceSeedreamV45TextToImageOutput

export const zGetFalAiViduQ2TextToImageRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiViduQ2TextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiViduQ2TextToImageRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiViduQ2TextToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiViduQ2TextToImageData = z.object({
  body: zSchemaViduQ2TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiViduQ2TextToImageResponse = zSchemaQueueStatus

export const zGetFalAiViduQ2TextToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiViduQ2TextToImageRequestsByRequestIdResponse =
  zSchemaViduQ2TextToImageOutput

export const zGetFalAiZImageTurboLoraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiZImageTurboLoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiZImageTurboLoraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageTurboLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiZImageTurboLoraData = z.object({
  body: zSchemaZImageTurboLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiZImageTurboLoraResponse = zSchemaQueueStatus

export const zGetFalAiZImageTurboLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiZImageTurboLoraRequestsByRequestIdResponse =
  zSchemaZImageTurboLoraOutput

export const zGetFalAiOvisImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiOvisImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiOvisImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiOvisImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiOvisImageData = z.object({
  body: zSchemaOvisImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiOvisImageResponse = zSchemaQueueStatus

export const zGetFalAiOvisImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiOvisImageRequestsByRequestIdResponse =
  zSchemaOvisImageOutput

export const zGetFalAiZImageTurboRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiZImageTurboRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiZImageTurboRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiZImageTurboRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiZImageTurboData = z.object({
  body: zSchemaZImageTurboInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiZImageTurboResponse = zSchemaQueueStatus

export const zGetFalAiZImageTurboRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiZImageTurboRequestsByRequestIdResponse =
  zSchemaZImageTurboOutput

export const zGetFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlux2LoraGallerySepiaVintageData = z.object({
  body: zSchemaFlux2LoraGallerySepiaVintageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGallerySepiaVintageResponse = zSchemaQueueStatus

export const zGetFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdResponse =
  zSchemaFlux2LoraGallerySepiaVintageOutput

export const zGetFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlux2LoraGallerySatelliteViewStyleData = z.object({
  body: zSchemaFlux2LoraGallerySatelliteViewStyleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGallerySatelliteViewStyleResponse =
  zSchemaQueueStatus

export const zGetFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdResponse =
  zSchemaFlux2LoraGallerySatelliteViewStyleOutput

export const zGetFalAiFlux2LoraGalleryRealismRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGalleryRealismRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2LoraGalleryRealismRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGalleryRealismRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlux2LoraGalleryRealismData = z.object({
  body: zSchemaFlux2LoraGalleryRealismInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGalleryRealismResponse = zSchemaQueueStatus

export const zGetFalAiFlux2LoraGalleryRealismRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGalleryRealismRequestsByRequestIdResponse =
  zSchemaFlux2LoraGalleryRealismOutput

export const zGetFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlux2LoraGalleryHdrStyleData = z.object({
  body: zSchemaFlux2LoraGalleryHdrStyleInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGalleryHdrStyleResponse = zSchemaQueueStatus

export const zGetFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdResponse =
  zSchemaFlux2LoraGalleryHdrStyleOutput

export const zGetFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlux2LoraGalleryDigitalComicArtData = z.object({
  body: zSchemaFlux2LoraGalleryDigitalComicArtInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGalleryDigitalComicArtResponse =
  zSchemaQueueStatus

export const zGetFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdResponse =
  zSchemaFlux2LoraGalleryDigitalComicArtOutput

export const zGetFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFlux2LoraGalleryBallpointPenSketchData = z.object({
  body: zSchemaFlux2LoraGalleryBallpointPenSketchInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2LoraGalleryBallpointPenSketchResponse =
  zSchemaQueueStatus

export const zGetFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdResponse =
  zSchemaFlux2LoraGalleryBallpointPenSketchOutput

export const zGetFalAiFlux2FlexRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux2FlexRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux2FlexRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux2FlexRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux2FlexData = z.object({
  body: zSchemaFlux2FlexInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux2FlexResponse = zSchemaQueueStatus

export const zGetFalAiFlux2FlexRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux2FlexRequestsByRequestIdResponse =
  zSchemaFlux2FlexOutput

export const zGetFalAiGemini3ProImagePreviewRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiGemini3ProImagePreviewRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiGemini3ProImagePreviewRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiGemini3ProImagePreviewRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiGemini3ProImagePreviewData = z.object({
  body: zSchemaGemini3ProImagePreviewInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiGemini3ProImagePreviewResponse = zSchemaQueueStatus

export const zGetFalAiGemini3ProImagePreviewRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiGemini3ProImagePreviewRequestsByRequestIdResponse =
  zSchemaGemini3ProImagePreviewOutput

export const zGetFalAiNanoBananaProRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiNanoBananaProRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiNanoBananaProRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiNanoBananaProRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiNanoBananaProData = z.object({
  body: zSchemaNanoBananaProInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiNanoBananaProResponse = zSchemaQueueStatus

export const zGetFalAiNanoBananaProRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiNanoBananaProRequestsByRequestIdResponse =
  zSchemaNanoBananaProOutput

export const zGetImagineartImagineart15PreviewTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetImagineartImagineart15PreviewTextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutImagineartImagineart15PreviewTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutImagineartImagineart15PreviewTextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostImagineartImagineart15PreviewTextToImageData = z.object({
  body: zSchemaImagineart15PreviewTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostImagineartImagineart15PreviewTextToImageResponse =
  zSchemaQueueStatus

export const zGetImagineartImagineart15PreviewTextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetImagineartImagineart15PreviewTextToImageRequestsByRequestIdResponse =
  zSchemaImagineart15PreviewTextToImageOutput

export const zGetFalAiEmu35ImageTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiEmu35ImageTextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiEmu35ImageTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiEmu35ImageTextToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiEmu35ImageTextToImageData = z.object({
  body: zSchemaEmu35ImageTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiEmu35ImageTextToImageResponse = zSchemaQueueStatus

export const zGetFalAiEmu35ImageTextToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiEmu35ImageTextToImageRequestsByRequestIdResponse =
  zSchemaEmu35ImageTextToImageOutput

export const zGetBriaFiboGenerateRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetBriaFiboGenerateRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutBriaFiboGenerateRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutBriaFiboGenerateRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostBriaFiboGenerateData = z.object({
  body: zSchemaFiboGenerateInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostBriaFiboGenerateResponse = zSchemaQueueStatus

export const zGetBriaFiboGenerateRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetBriaFiboGenerateRequestsByRequestIdResponse =
  zSchemaFiboGenerateOutput

export const zGetFalAiPiflowRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiPiflowRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPiflowRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiPiflowRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiPiflowData = z.object({
  body: zSchemaPiflowInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPiflowResponse = zSchemaQueueStatus

export const zGetFalAiPiflowRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiPiflowRequestsByRequestIdResponse = zSchemaPiflowOutput

export const zGetFalAiGptImage1MiniRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiGptImage1MiniRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiGptImage1MiniRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiGptImage1MiniRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiGptImage1MiniData = z.object({
  body: zSchemaGptImage1MiniInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiGptImage1MiniResponse = zSchemaQueueStatus

export const zGetFalAiGptImage1MiniRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiGptImage1MiniRequestsByRequestIdResponse =
  zSchemaGptImage1MiniOutput

export const zGetFalAiReveTextToImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiReveTextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiReveTextToImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiReveTextToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiReveTextToImageData = z.object({
  body: zSchemaReveTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiReveTextToImageResponse = zSchemaQueueStatus

export const zGetFalAiReveTextToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiReveTextToImageRequestsByRequestIdResponse =
  zSchemaReveTextToImageOutput

export const zGetFalAiHunyuanImageV3TextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiHunyuanImageV3TextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuanImageV3TextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuanImageV3TextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiHunyuanImageV3TextToImageData = z.object({
  body: zSchemaHunyuanImageV3TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuanImageV3TextToImageResponse = zSchemaQueueStatus

export const zGetFalAiHunyuanImageV3TextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiHunyuanImageV3TextToImageRequestsByRequestIdResponse =
  zSchemaHunyuanImageV3TextToImageOutput

export const zGetFalAiWan25PreviewTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiWan25PreviewTextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiWan25PreviewTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiWan25PreviewTextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiWan25PreviewTextToImageData = z.object({
  body: zSchemaWan25PreviewTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiWan25PreviewTextToImageResponse = zSchemaQueueStatus

export const zGetFalAiWan25PreviewTextToImageRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * Result of the request.
 */
export const zGetFalAiWan25PreviewTextToImageRequestsByRequestIdResponse =
  zSchemaWan25PreviewTextToImageOutput

export const zGetFalAiFluxSrpoRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxSrpoRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxSrpoRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxSrpoRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxSrpoData = z.object({
  body: zSchemaFluxSrpoInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxSrpoResponse = zSchemaQueueStatus

export const zGetFalAiFluxSrpoRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxSrpoRequestsByRequestIdResponse =
  zSchemaFluxSrpoOutput

export const zGetFalAiFlux1SrpoRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux1SrpoRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux1SrpoRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1SrpoRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux1SrpoData = z.object({
  body: zSchemaFlux1SrpoInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux1SrpoResponse = zSchemaQueueStatus

export const zGetFalAiFlux1SrpoRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux1SrpoRequestsByRequestIdResponse =
  zSchemaFlux1SrpoOutput

export const zGetFalAiHunyuanImageV21TextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiHunyuanImageV21TextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuanImageV21TextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuanImageV21TextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiHunyuanImageV21TextToImageData = z.object({
  body: zSchemaHunyuanImageV21TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuanImageV21TextToImageResponse = zSchemaQueueStatus

export const zGetFalAiHunyuanImageV21TextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiHunyuanImageV21TextToImageRequestsByRequestIdResponse =
  zSchemaHunyuanImageV21TextToImageOutput

export const zGetFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiBytedanceSeedreamV4TextToImageData = z.object({
  body: zSchemaBytedanceSeedreamV4TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBytedanceSeedreamV4TextToImageResponse =
  zSchemaQueueStatus

export const zGetFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdResponse =
  zSchemaBytedanceSeedreamV4TextToImageOutput

export const zGetFalAiGemini25FlashImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiGemini25FlashImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiGemini25FlashImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiGemini25FlashImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiGemini25FlashImageData = z.object({
  body: zSchemaGemini25FlashImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiGemini25FlashImageResponse = zSchemaQueueStatus

export const zGetFalAiGemini25FlashImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiGemini25FlashImageRequestsByRequestIdResponse =
  zSchemaGemini25FlashImageOutput

export const zGetFalAiNanoBananaRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiNanoBananaRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiNanoBananaRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiNanoBananaRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiNanoBananaData = z.object({
  body: zSchemaNanoBananaInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiNanoBananaResponse = zSchemaQueueStatus

export const zGetFalAiNanoBananaRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiNanoBananaRequestsByRequestIdResponse =
  zSchemaNanoBananaOutput

export const zGetFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiBytedanceDreaminaV31TextToImageData = z.object({
  body: zSchemaBytedanceDreaminaV31TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBytedanceDreaminaV31TextToImageResponse =
  zSchemaQueueStatus

export const zGetFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdResponse =
  zSchemaBytedanceDreaminaV31TextToImageOutput

export const zGetFalAiWanV22A14bTextToImageLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiWanV22A14bTextToImageLoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiWanV22A14bTextToImageLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiWanV22A14bTextToImageLoraRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiWanV22A14bTextToImageLoraData = z.object({
  body: zSchemaWanV22A14bTextToImageLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiWanV22A14bTextToImageLoraResponse = zSchemaQueueStatus

export const zGetFalAiWanV22A14bTextToImageLoraRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiWanV22A14bTextToImageLoraRequestsByRequestIdResponse =
  zSchemaWanV22A14bTextToImageLoraOutput

export const zGetFalAiWanV225bTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiWanV225bTextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiWanV225bTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiWanV225bTextToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiWanV225bTextToImageData = z.object({
  body: zSchemaWanV225bTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiWanV225bTextToImageResponse = zSchemaQueueStatus

export const zGetFalAiWanV225bTextToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiWanV225bTextToImageRequestsByRequestIdResponse =
  zSchemaWanV225bTextToImageOutput

export const zGetFalAiWanV22A14bTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiWanV22A14bTextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiWanV22A14bTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiWanV22A14bTextToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiWanV22A14bTextToImageData = z.object({
  body: zSchemaWanV22A14bTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiWanV22A14bTextToImageResponse = zSchemaQueueStatus

export const zGetFalAiWanV22A14bTextToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiWanV22A14bTextToImageRequestsByRequestIdResponse =
  zSchemaWanV22A14bTextToImageOutput

export const zGetFalAiQwenImageRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiQwenImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiQwenImageRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiQwenImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiQwenImageData = z.object({
  body: zSchemaQwenImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiQwenImageResponse = zSchemaQueueStatus

export const zGetFalAiQwenImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiQwenImageRequestsByRequestIdResponse =
  zSchemaQwenImageOutput

export const zGetFalAiFluxKreaLoraStreamRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxKreaLoraStreamRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxKreaLoraStreamRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKreaLoraStreamRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxKreaLoraStreamData = z.object({
  body: zSchemaFluxKreaLoraStreamInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxKreaLoraStreamResponse = zSchemaQueueStatus

export const zGetFalAiFluxKreaLoraStreamRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxKreaLoraStreamRequestsByRequestIdResponse =
  zSchemaFluxKreaLoraStreamOutput

export const zGetFalAiFluxKreaLoraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxKreaLoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxKreaLoraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKreaLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxKreaLoraData = z.object({
  body: zSchemaFluxKreaLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxKreaLoraResponse = zSchemaQueueStatus

export const zGetFalAiFluxKreaLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxKreaLoraRequestsByRequestIdResponse =
  zSchemaFluxKreaLoraOutput

export const zGetFalAiFluxKreaRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxKreaRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxKreaRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKreaRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxKreaData = z.object({
  body: zSchemaFluxKreaInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxKreaResponse = zSchemaQueueStatus

export const zGetFalAiFluxKreaRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxKreaRequestsByRequestIdResponse =
  zSchemaFluxKreaOutput

export const zGetFalAiFlux1KreaRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux1KreaRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux1KreaRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1KreaRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux1KreaData = z.object({
  body: zSchemaFlux1KreaInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux1KreaResponse = zSchemaQueueStatus

export const zGetFalAiFlux1KreaRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux1KreaRequestsByRequestIdResponse =
  zSchemaFlux1KreaOutput

export const zGetFalAiSkyRaccoonRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiSkyRaccoonRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSkyRaccoonRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiSkyRaccoonRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSkyRaccoonData = z.object({
  body: zSchemaSkyRaccoonInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSkyRaccoonResponse = zSchemaQueueStatus

export const zGetFalAiSkyRaccoonRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSkyRaccoonRequestsByRequestIdResponse =
  zSchemaSkyRaccoonOutput

export const zGetFalAiFluxKontextLoraTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxKontextLoraTextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxKontextLoraTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxKontextLoraTextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFluxKontextLoraTextToImageData = z.object({
  body: zSchemaFluxKontextLoraTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxKontextLoraTextToImageResponse = zSchemaQueueStatus

export const zGetFalAiFluxKontextLoraTextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFluxKontextLoraTextToImageRequestsByRequestIdResponse =
  zSchemaFluxKontextLoraTextToImageOutput

export const zGetFalAiOmnigenV2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiOmnigenV2RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiOmnigenV2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiOmnigenV2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiOmnigenV2Data = z.object({
  body: zSchemaOmnigenV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiOmnigenV2Response = zSchemaQueueStatus

export const zGetFalAiOmnigenV2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiOmnigenV2RequestsByRequestIdResponse =
  zSchemaOmnigenV2Output

export const zGetFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiBytedanceSeedreamV3TextToImageData = z.object({
  body: zSchemaBytedanceSeedreamV3TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBytedanceSeedreamV3TextToImageResponse =
  zSchemaQueueStatus

export const zGetFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdResponse =
  zSchemaBytedanceSeedreamV3TextToImageOutput

export const zGetFalAiFlux1SchnellRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux1SchnellRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux1SchnellRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1SchnellRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux1SchnellData = z.object({
  body: zSchemaFlux1SchnellInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux1SchnellResponse = zSchemaQueueStatus

export const zGetFalAiFlux1SchnellRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux1SchnellRequestsByRequestIdResponse =
  zSchemaFlux1SchnellOutput

export const zGetFalAiFlux1DevRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFlux1DevRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFlux1DevRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFlux1DevRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFlux1DevData = z.object({
  body: zSchemaFlux1DevInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFlux1DevResponse = zSchemaQueueStatus

export const zGetFalAiFlux1DevRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFlux1DevRequestsByRequestIdResponse =
  zSchemaFlux1DevOutput

export const zGetFalAiFluxProKontextMaxTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxProKontextMaxTextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxProKontextMaxTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProKontextMaxTextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFluxProKontextMaxTextToImageData = z.object({
  body: zSchemaFluxProKontextMaxTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxProKontextMaxTextToImageResponse = zSchemaQueueStatus

export const zGetFalAiFluxProKontextMaxTextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFluxProKontextMaxTextToImageRequestsByRequestIdResponse =
  zSchemaFluxProKontextMaxTextToImageOutput

export const zGetFalAiFluxProKontextTextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxProKontextTextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxProKontextTextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProKontextTextToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFluxProKontextTextToImageData = z.object({
  body: zSchemaFluxProKontextTextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxProKontextTextToImageResponse = zSchemaQueueStatus

export const zGetFalAiFluxProKontextTextToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFluxProKontextTextToImageRequestsByRequestIdResponse =
  zSchemaFluxProKontextTextToImageOutput

export const zGetFalAiBagelRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiBagelRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBagelRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiBagelRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiBagelData = z.object({
  body: zSchemaBagelInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBagelResponse = zSchemaQueueStatus

export const zGetFalAiBagelRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiBagelRequestsByRequestIdResponse = zSchemaBagelOutput

export const zGetFalAiImagen4PreviewUltraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiImagen4PreviewUltraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImagen4PreviewUltraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiImagen4PreviewUltraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImagen4PreviewUltraData = z.object({
  body: zSchemaImagen4PreviewUltraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImagen4PreviewUltraResponse = zSchemaQueueStatus

export const zGetFalAiImagen4PreviewUltraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImagen4PreviewUltraRequestsByRequestIdResponse =
  zSchemaImagen4PreviewUltraOutput

export const zGetFalAiDreamoRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiDreamoRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiDreamoRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiDreamoRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiDreamoData = z.object({
  body: zSchemaDreamoInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiDreamoResponse = zSchemaQueueStatus

export const zGetFalAiDreamoRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiDreamoRequestsByRequestIdResponse = zSchemaDreamoOutput

export const zGetFalAiFluxLoraStreamRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxLoraStreamRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxLoraStreamRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxLoraStreamRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxLoraStreamData = z.object({
  body: zSchemaFluxLoraStreamInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxLoraStreamResponse = zSchemaQueueStatus

export const zGetFalAiFluxLoraStreamRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxLoraStreamRequestsByRequestIdResponse =
  zSchemaFluxLoraStreamOutput

export const zGetFalAiMinimaxImage01RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiMinimaxImage01RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiMinimaxImage01RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiMinimaxImage01RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiMinimaxImage01Data = z.object({
  body: zSchemaMinimaxImage01Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiMinimaxImage01Response = zSchemaQueueStatus

export const zGetFalAiMinimaxImage01RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiMinimaxImage01RequestsByRequestIdResponse =
  zSchemaMinimaxImage01Output

export const zGetFalAiPonyV7RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiPonyV7RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPonyV7RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiPonyV7RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiPonyV7Data = z.object({
  body: zSchemaPonyV7Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPonyV7Response = zSchemaQueueStatus

export const zGetFalAiPonyV7RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiPonyV7RequestsByRequestIdResponse = zSchemaPonyV7Output

export const zGetFalAiIdeogramV3RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiIdeogramV3RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIdeogramV3RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV3RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIdeogramV3Data = z.object({
  body: zSchemaIdeogramV3Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIdeogramV3Response = zSchemaQueueStatus

export const zGetFalAiIdeogramV3RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV3RequestsByRequestIdResponse =
  zSchemaIdeogramV3Output

export const zGetFalAiFLiteStandardRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFLiteStandardRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFLiteStandardRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFLiteStandardRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFLiteStandardData = z.object({
  body: zSchemaFLiteStandardInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFLiteStandardResponse = zSchemaQueueStatus

export const zGetFalAiFLiteStandardRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFLiteStandardRequestsByRequestIdResponse =
  zSchemaFLiteStandardOutput

export const zGetFalAiFLiteTextureRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFLiteTextureRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFLiteTextureRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFLiteTextureRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFLiteTextureData = z.object({
  body: zSchemaFLiteTextureInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFLiteTextureResponse = zSchemaQueueStatus

export const zGetFalAiFLiteTextureRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFLiteTextureRequestsByRequestIdResponse =
  zSchemaFLiteTextureOutput

export const zGetFalAiGptImage1TextToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiGptImage1TextToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiGptImage1TextToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiGptImage1TextToImageRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiGptImage1TextToImageData = z.object({
  body: zSchemaGptImage1TextToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiGptImage1TextToImageResponse = zSchemaQueueStatus

export const zGetFalAiGptImage1TextToImageRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiGptImage1TextToImageRequestsByRequestIdResponse =
  zSchemaGptImage1TextToImageOutput

export const zGetFalAiSanaV1516bRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiSanaV1516bRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSanaV1516bRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiSanaV1516bRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSanaV1516bData = z.object({
  body: zSchemaSanaV1516bInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSanaV1516bResponse = zSchemaQueueStatus

export const zGetFalAiSanaV1516bRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSanaV1516bRequestsByRequestIdResponse =
  zSchemaSanaV1516bOutput

export const zGetFalAiSanaV1548bRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiSanaV1548bRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSanaV1548bRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiSanaV1548bRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSanaV1548bData = z.object({
  body: zSchemaSanaV1548bInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSanaV1548bResponse = zSchemaQueueStatus

export const zGetFalAiSanaV1548bRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSanaV1548bRequestsByRequestIdResponse =
  zSchemaSanaV1548bOutput

export const zGetFalAiSanaSprintRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiSanaSprintRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSanaSprintRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiSanaSprintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSanaSprintData = z.object({
  body: zSchemaSanaSprintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSanaSprintResponse = zSchemaQueueStatus

export const zGetFalAiSanaSprintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSanaSprintRequestsByRequestIdResponse =
  zSchemaSanaSprintOutput

export const zGetRundiffusionFalJuggernautFluxLightningRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetRundiffusionFalJuggernautFluxLightningRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutRundiffusionFalJuggernautFluxLightningRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutRundiffusionFalJuggernautFluxLightningRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostRundiffusionFalJuggernautFluxLightningData = z.object({
  body: zSchemaJuggernautFluxLightningInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostRundiffusionFalJuggernautFluxLightningResponse =
  zSchemaQueueStatus

export const zGetRundiffusionFalJuggernautFluxLightningRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetRundiffusionFalJuggernautFluxLightningRequestsByRequestIdResponse =
  zSchemaJuggernautFluxLightningOutput

export const zGetRundiffusionFalJuggernautFluxProRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetRundiffusionFalJuggernautFluxProRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutRundiffusionFalJuggernautFluxProRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutRundiffusionFalJuggernautFluxProRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostRundiffusionFalJuggernautFluxProData = z.object({
  body: zSchemaJuggernautFluxProInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostRundiffusionFalJuggernautFluxProResponse = zSchemaQueueStatus

export const zGetRundiffusionFalJuggernautFluxProRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetRundiffusionFalJuggernautFluxProRequestsByRequestIdResponse =
  zSchemaJuggernautFluxProOutput

export const zGetRundiffusionFalJuggernautFluxLoraRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetRundiffusionFalJuggernautFluxLoraRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutRundiffusionFalJuggernautFluxLoraRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutRundiffusionFalJuggernautFluxLoraRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostRundiffusionFalJuggernautFluxLoraData = z.object({
  body: zSchemaJuggernautFluxLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostRundiffusionFalJuggernautFluxLoraResponse = zSchemaQueueStatus

export const zGetRundiffusionFalJuggernautFluxLoraRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetRundiffusionFalJuggernautFluxLoraRequestsByRequestIdResponse =
  zSchemaJuggernautFluxLoraOutput

export const zGetRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostRundiffusionFalRundiffusionPhotoFluxData = z.object({
  body: zSchemaRundiffusionPhotoFluxInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostRundiffusionFalRundiffusionPhotoFluxResponse =
  zSchemaQueueStatus

export const zGetRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdResponse =
  zSchemaRundiffusionPhotoFluxOutput

export const zGetRundiffusionFalJuggernautFluxBaseRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetRundiffusionFalJuggernautFluxBaseRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutRundiffusionFalJuggernautFluxBaseRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutRundiffusionFalJuggernautFluxBaseRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostRundiffusionFalJuggernautFluxBaseData = z.object({
  body: zSchemaJuggernautFluxBaseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostRundiffusionFalJuggernautFluxBaseResponse = zSchemaQueueStatus

export const zGetRundiffusionFalJuggernautFluxBaseRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetRundiffusionFalJuggernautFluxBaseRequestsByRequestIdResponse =
  zSchemaJuggernautFluxBaseOutput

export const zGetFalAiCogview4RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiCogview4RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiCogview4RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiCogview4RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiCogview4Data = z.object({
  body: zSchemaCogview4Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiCogview4Response = zSchemaQueueStatus

export const zGetFalAiCogview4RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiCogview4RequestsByRequestIdResponse =
  zSchemaCogview4Output

export const zGetFalAiIdeogramV2aTurboRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2aTurboRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIdeogramV2aTurboRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2aTurboRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIdeogramV2aTurboData = z.object({
  body: zSchemaIdeogramV2aTurboInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2aTurboResponse = zSchemaQueueStatus

export const zGetFalAiIdeogramV2aTurboRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2aTurboRequestsByRequestIdResponse =
  zSchemaIdeogramV2aTurboOutput

export const zGetFalAiIdeogramV2aRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2aRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIdeogramV2aRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2aRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIdeogramV2aData = z.object({
  body: zSchemaIdeogramV2aInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2aResponse = zSchemaQueueStatus

export const zGetFalAiIdeogramV2aRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2aRequestsByRequestIdResponse =
  zSchemaIdeogramV2aOutput

export const zGetFalAiFluxControlLoraCannyRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxControlLoraCannyRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxControlLoraCannyRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxControlLoraCannyRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxControlLoraCannyData = z.object({
  body: zSchemaFluxControlLoraCannyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxControlLoraCannyResponse = zSchemaQueueStatus

export const zGetFalAiFluxControlLoraCannyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxControlLoraCannyRequestsByRequestIdResponse =
  zSchemaFluxControlLoraCannyOutput

export const zGetFalAiFluxControlLoraDepthRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxControlLoraDepthRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxControlLoraDepthRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxControlLoraDepthRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxControlLoraDepthData = z.object({
  body: zSchemaFluxControlLoraDepthInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxControlLoraDepthResponse = zSchemaQueueStatus

export const zGetFalAiFluxControlLoraDepthRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxControlLoraDepthRequestsByRequestIdResponse =
  zSchemaFluxControlLoraDepthOutput

export const zGetFalAiImagen3RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiImagen3RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImagen3RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiImagen3RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImagen3Data = z.object({
  body: zSchemaImagen3Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImagen3Response = zSchemaQueueStatus

export const zGetFalAiImagen3RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImagen3RequestsByRequestIdResponse = zSchemaImagen3Output

export const zGetFalAiImagen3FastRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiImagen3FastRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiImagen3FastRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiImagen3FastRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiImagen3FastData = z.object({
  body: zSchemaImagen3FastInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiImagen3FastResponse = zSchemaQueueStatus

export const zGetFalAiImagen3FastRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiImagen3FastRequestsByRequestIdResponse =
  zSchemaImagen3FastOutput

export const zGetFalAiLuminaImageV2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiLuminaImageV2RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLuminaImageV2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiLuminaImageV2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLuminaImageV2Data = z.object({
  body: zSchemaLuminaImageV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLuminaImageV2Response = zSchemaQueueStatus

export const zGetFalAiLuminaImageV2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLuminaImageV2RequestsByRequestIdResponse =
  zSchemaLuminaImageV2Output

export const zGetFalAiJanusRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiJanusRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiJanusRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiJanusRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiJanusData = z.object({
  body: zSchemaJanusInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiJanusResponse = zSchemaQueueStatus

export const zGetFalAiJanusRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiJanusRequestsByRequestIdResponse = zSchemaJanusOutput

export const zGetFalAiFluxProV11UltraFinetunedRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxProV11UltraFinetunedRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxProV11UltraFinetunedRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProV11UltraFinetunedRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFluxProV11UltraFinetunedData = z.object({
  body: zSchemaFluxProV11UltraFinetunedInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxProV11UltraFinetunedResponse = zSchemaQueueStatus

export const zGetFalAiFluxProV11UltraFinetunedRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFluxProV11UltraFinetunedRequestsByRequestIdResponse =
  zSchemaFluxProV11UltraFinetunedOutput

export const zGetFalAiFluxProV11RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxProV11RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxProV11RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxProV11RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxProV11Data = z.object({
  body: zSchemaFluxProV11Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxProV11Response = zSchemaQueueStatus

export const zGetFalAiFluxProV11RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxProV11RequestsByRequestIdResponse =
  zSchemaFluxProV11Output

export const zGetFalAiSwittiRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiSwittiRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSwittiRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiSwittiRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSwittiData = z.object({
  body: zSchemaSwittiInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSwittiResponse = zSchemaQueueStatus

export const zGetFalAiSwittiRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSwittiRequestsByRequestIdResponse = zSchemaSwittiOutput

export const zGetFalAiSwitti512RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiSwitti512RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSwitti512RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiSwitti512RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSwitti512Data = z.object({
  body: zSchemaSwitti512Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSwitti512Response = zSchemaQueueStatus

export const zGetFalAiSwitti512RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSwitti512RequestsByRequestIdResponse =
  zSchemaSwitti512Output

export const zGetFalAiBriaTextToImageBaseRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiBriaTextToImageBaseRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBriaTextToImageBaseRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaTextToImageBaseRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiBriaTextToImageBaseData = z.object({
  body: zSchemaBriaTextToImageBaseInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBriaTextToImageBaseResponse = zSchemaQueueStatus

export const zGetFalAiBriaTextToImageBaseRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiBriaTextToImageBaseRequestsByRequestIdResponse =
  zSchemaBriaTextToImageBaseOutput

export const zGetFalAiBriaTextToImageFastRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiBriaTextToImageFastRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBriaTextToImageFastRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaTextToImageFastRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiBriaTextToImageFastData = z.object({
  body: zSchemaBriaTextToImageFastInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBriaTextToImageFastResponse = zSchemaQueueStatus

export const zGetFalAiBriaTextToImageFastRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiBriaTextToImageFastRequestsByRequestIdResponse =
  zSchemaBriaTextToImageFastOutput

export const zGetFalAiBriaTextToImageHdRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiBriaTextToImageHdRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBriaTextToImageHdRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiBriaTextToImageHdRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiBriaTextToImageHdData = z.object({
  body: zSchemaBriaTextToImageHdInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBriaTextToImageHdResponse = zSchemaQueueStatus

export const zGetFalAiBriaTextToImageHdRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiBriaTextToImageHdRequestsByRequestIdResponse =
  zSchemaBriaTextToImageHdOutput

export const zGetFalAiRecraft20bRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiRecraft20bRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiRecraft20bRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiRecraft20bRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiRecraft20bData = z.object({
  body: zSchemaRecraft20bInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiRecraft20bResponse = zSchemaQueueStatus

export const zGetFalAiRecraft20bRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiRecraft20bRequestsByRequestIdResponse =
  zSchemaRecraft20bOutput

export const zGetFalAiIdeogramV2TurboRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiIdeogramV2TurboRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIdeogramV2TurboRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiIdeogramV2TurboRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIdeogramV2TurboData = z.object({
  body: zSchemaIdeogramV2TurboInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIdeogramV2TurboResponse = zSchemaQueueStatus

export const zGetFalAiIdeogramV2TurboRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIdeogramV2TurboRequestsByRequestIdResponse =
  zSchemaIdeogramV2TurboOutput

export const zGetFalAiLumaPhotonFlashRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiLumaPhotonFlashRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLumaPhotonFlashRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiLumaPhotonFlashRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLumaPhotonFlashData = z.object({
  body: zSchemaLumaPhotonFlashInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLumaPhotonFlashResponse = zSchemaQueueStatus

export const zGetFalAiLumaPhotonFlashRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLumaPhotonFlashRequestsByRequestIdResponse =
  zSchemaLumaPhotonFlashOutput

export const zGetFalAiAuraFlowRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiAuraFlowRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiAuraFlowRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiAuraFlowRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiAuraFlowData = z.object({
  body: zSchemaAuraFlowInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiAuraFlowResponse = zSchemaQueueStatus

export const zGetFalAiAuraFlowRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiAuraFlowRequestsByRequestIdResponse =
  zSchemaAuraFlowOutput

export const zGetFalAiOmnigenV1RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiOmnigenV1RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiOmnigenV1RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiOmnigenV1RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiOmnigenV1Data = z.object({
  body: zSchemaOmnigenV1Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiOmnigenV1Response = zSchemaQueueStatus

export const zGetFalAiOmnigenV1RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiOmnigenV1RequestsByRequestIdResponse =
  zSchemaOmnigenV1Output

export const zGetFalAiFluxSchnellRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxSchnellRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxSchnellRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxSchnellRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxSchnellData = z.object({
  body: zSchemaFluxSchnellInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxSchnellResponse = zSchemaQueueStatus

export const zGetFalAiFluxSchnellRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxSchnellRequestsByRequestIdResponse =
  zSchemaFluxSchnellOutput

export const zGetFalAiStableDiffusionV35MediumRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiStableDiffusionV35MediumRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiStableDiffusionV35MediumRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiStableDiffusionV35MediumRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiStableDiffusionV35MediumData = z.object({
  body: zSchemaStableDiffusionV35MediumInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiStableDiffusionV35MediumResponse = zSchemaQueueStatus

export const zGetFalAiStableDiffusionV35MediumRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiStableDiffusionV35MediumRequestsByRequestIdResponse =
  zSchemaStableDiffusionV35MediumOutput

export const zGetFalAiFluxLoraInpaintingRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFluxLoraInpaintingRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxLoraInpaintingRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxLoraInpaintingRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxLoraInpaintingData = z.object({
  body: zSchemaFluxLoraInpaintingInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxLoraInpaintingResponse = zSchemaQueueStatus

export const zGetFalAiFluxLoraInpaintingRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxLoraInpaintingRequestsByRequestIdResponse =
  zSchemaFluxLoraInpaintingOutput

export const zGetFalAiStableDiffusionV3MediumRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiStableDiffusionV3MediumRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiStableDiffusionV3MediumRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiStableDiffusionV3MediumRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiStableDiffusionV3MediumData = z.object({
  body: zSchemaStableDiffusionV3MediumInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiStableDiffusionV3MediumResponse = zSchemaQueueStatus

export const zGetFalAiStableDiffusionV3MediumRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * Result of the request.
 */
export const zGetFalAiStableDiffusionV3MediumRequestsByRequestIdResponse =
  zSchemaStableDiffusionV3MediumOutput

export const zGetFalAiFooocusUpscaleOrVaryRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFooocusUpscaleOrVaryRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFooocusUpscaleOrVaryRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFooocusUpscaleOrVaryRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFooocusUpscaleOrVaryData = z.object({
  body: zSchemaFooocusUpscaleOrVaryInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFooocusUpscaleOrVaryResponse = zSchemaQueueStatus

export const zGetFalAiFooocusUpscaleOrVaryRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFooocusUpscaleOrVaryRequestsByRequestIdResponse =
  zSchemaFooocusUpscaleOrVaryOutput

export const zGetFalAiSanaRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiSanaRequestsByRequestIdStatusResponse = zSchemaQueueStatus

export const zPutFalAiSanaRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiSanaRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSanaData = z.object({
  body: zSchemaSanaInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSanaResponse = zSchemaQueueStatus

export const zGetFalAiSanaRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSanaRequestsByRequestIdResponse = zSchemaSanaOutput

export const zGetFalAiFluxSubjectRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFluxSubjectRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFluxSubjectRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFluxSubjectRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFluxSubjectData = z.object({
  body: zSchemaFluxSubjectInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFluxSubjectResponse = zSchemaQueueStatus

export const zGetFalAiFluxSubjectRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFluxSubjectRequestsByRequestIdResponse =
  zSchemaFluxSubjectOutput

export const zGetFalAiPixartSigmaRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiPixartSigmaRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPixartSigmaRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiPixartSigmaRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiPixartSigmaData = z.object({
  body: zSchemaPixartSigmaInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPixartSigmaResponse = zSchemaQueueStatus

export const zGetFalAiPixartSigmaRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiPixartSigmaRequestsByRequestIdResponse =
  zSchemaPixartSigmaOutput

export const zGetFalAiSdxlControlnetUnionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiSdxlControlnetUnionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSdxlControlnetUnionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiSdxlControlnetUnionRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSdxlControlnetUnionData = z.object({
  body: zSchemaSdxlControlnetUnionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSdxlControlnetUnionResponse = zSchemaQueueStatus

export const zGetFalAiSdxlControlnetUnionRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSdxlControlnetUnionRequestsByRequestIdResponse =
  zSchemaSdxlControlnetUnionOutput

export const zGetFalAiKolorsRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiKolorsRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiKolorsRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiKolorsRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiKolorsData = z.object({
  body: zSchemaKolorsInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiKolorsResponse = zSchemaQueueStatus

export const zGetFalAiKolorsRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiKolorsRequestsByRequestIdResponse = zSchemaKolorsOutput

export const zGetFalAiStableCascadeRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiStableCascadeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiStableCascadeRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiStableCascadeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiStableCascadeData = z.object({
  body: zSchemaStableCascadeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiStableCascadeResponse = zSchemaQueueStatus

export const zGetFalAiStableCascadeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiStableCascadeRequestsByRequestIdResponse =
  zSchemaStableCascadeOutput

export const zGetFalAiFastSdxlRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFastSdxlRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFastSdxlRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFastSdxlRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFastSdxlData = z.object({
  body: zSchemaFastSdxlInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFastSdxlResponse = zSchemaQueueStatus

export const zGetFalAiFastSdxlRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFastSdxlRequestsByRequestIdResponse =
  zSchemaFastSdxlOutput

export const zGetFalAiStableCascadeSoteDiffusionRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiStableCascadeSoteDiffusionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiStableCascadeSoteDiffusionRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiStableCascadeSoteDiffusionRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiStableCascadeSoteDiffusionData = z.object({
  body: zSchemaStableCascadeSoteDiffusionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiStableCascadeSoteDiffusionResponse = zSchemaQueueStatus

export const zGetFalAiStableCascadeSoteDiffusionRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiStableCascadeSoteDiffusionRequestsByRequestIdResponse =
  zSchemaStableCascadeSoteDiffusionOutput

export const zGetFalAiLumaPhotonRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiLumaPhotonRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLumaPhotonRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiLumaPhotonRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLumaPhotonData = z.object({
  body: zSchemaLumaPhotonInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLumaPhotonResponse = zSchemaQueueStatus

export const zGetFalAiLumaPhotonRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLumaPhotonRequestsByRequestIdResponse =
  zSchemaLumaPhotonOutput

export const zGetFalAiLightningModelsRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiLightningModelsRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLightningModelsRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiLightningModelsRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLightningModelsData = z.object({
  body: zSchemaLightningModelsInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLightningModelsResponse = zSchemaQueueStatus

export const zGetFalAiLightningModelsRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLightningModelsRequestsByRequestIdResponse =
  zSchemaLightningModelsOutput

export const zGetFalAiPlaygroundV25RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiPlaygroundV25RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPlaygroundV25RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiPlaygroundV25RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiPlaygroundV25Data = z.object({
  body: zSchemaPlaygroundV25Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPlaygroundV25Response = zSchemaQueueStatus

export const zGetFalAiPlaygroundV25RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiPlaygroundV25RequestsByRequestIdResponse =
  zSchemaPlaygroundV25Output

export const zGetFalAiRealisticVisionRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiRealisticVisionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiRealisticVisionRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiRealisticVisionRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiRealisticVisionData = z.object({
  body: zSchemaRealisticVisionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiRealisticVisionResponse = zSchemaQueueStatus

export const zGetFalAiRealisticVisionRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiRealisticVisionRequestsByRequestIdResponse =
  zSchemaRealisticVisionOutput

export const zGetFalAiDreamshaperRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiDreamshaperRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiDreamshaperRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiDreamshaperRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiDreamshaperData = z.object({
  body: zSchemaDreamshaperInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiDreamshaperResponse = zSchemaQueueStatus

export const zGetFalAiDreamshaperRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiDreamshaperRequestsByRequestIdResponse =
  zSchemaDreamshaperOutput

export const zGetFalAiStableDiffusionV15RequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiStableDiffusionV15RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiStableDiffusionV15RequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiStableDiffusionV15RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiStableDiffusionV15Data = z.object({
  body: zSchemaStableDiffusionV15Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiStableDiffusionV15Response = zSchemaQueueStatus

export const zGetFalAiStableDiffusionV15RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiStableDiffusionV15RequestsByRequestIdResponse =
  zSchemaStableDiffusionV15Output

export const zGetFalAiLayerDiffusionRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiLayerDiffusionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiLayerDiffusionRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiLayerDiffusionRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLayerDiffusionData = z.object({
  body: zSchemaLayerDiffusionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLayerDiffusionResponse = zSchemaQueueStatus

export const zGetFalAiLayerDiffusionRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLayerDiffusionRequestsByRequestIdResponse =
  zSchemaLayerDiffusionOutput

export const zGetFalAiFastLightningSdxlRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiFastLightningSdxlRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFastLightningSdxlRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiFastLightningSdxlRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFastLightningSdxlData = z.object({
  body: zSchemaFastLightningSdxlInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFastLightningSdxlResponse = zSchemaQueueStatus

export const zGetFalAiFastLightningSdxlRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFastLightningSdxlRequestsByRequestIdResponse =
  zSchemaFastLightningSdxlOutput

export const zGetFalAiFastFooocusSdxlImageToImageRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFastFooocusSdxlImageToImageRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFastFooocusSdxlImageToImageRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFastFooocusSdxlImageToImageRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFastFooocusSdxlImageToImageData = z.object({
  body: zSchemaFastFooocusSdxlImageToImageInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFastFooocusSdxlImageToImageResponse = zSchemaQueueStatus

export const zGetFalAiFastFooocusSdxlImageToImageRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiFastFooocusSdxlImageToImageRequestsByRequestIdResponse =
  zSchemaFastFooocusSdxlImageToImageOutput

export const zGetFalAiFastSdxlControlnetCannyRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFastSdxlControlnetCannyRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFastSdxlControlnetCannyRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFastSdxlControlnetCannyRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiFastSdxlControlnetCannyData = z.object({
  body: zSchemaFastSdxlControlnetCannyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFastSdxlControlnetCannyResponse = zSchemaQueueStatus

export const zGetFalAiFastSdxlControlnetCannyRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * Result of the request.
 */
export const zGetFalAiFastSdxlControlnetCannyRequestsByRequestIdResponse =
  zSchemaFastSdxlControlnetCannyOutput

export const zGetFalAiFastLcmDiffusionRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFastLcmDiffusionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFastLcmDiffusionRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFastLcmDiffusionRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFastLcmDiffusionData = z.object({
  body: zSchemaFastLcmDiffusionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFastLcmDiffusionResponse = zSchemaQueueStatus

export const zGetFalAiFastLcmDiffusionRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFastLcmDiffusionRequestsByRequestIdResponse =
  zSchemaFastLcmDiffusionOutput

export const zGetFalAiFastFooocusSdxlRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFastFooocusSdxlRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFastFooocusSdxlRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFastFooocusSdxlRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFastFooocusSdxlData = z.object({
  body: zSchemaFastFooocusSdxlInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFastFooocusSdxlResponse = zSchemaQueueStatus

export const zGetFalAiFastFooocusSdxlRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFastFooocusSdxlRequestsByRequestIdResponse =
  zSchemaFastFooocusSdxlOutput

export const zGetFalAiIllusionDiffusionRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiIllusionDiffusionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiIllusionDiffusionRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiIllusionDiffusionRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiIllusionDiffusionData = z.object({
  body: zSchemaIllusionDiffusionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiIllusionDiffusionResponse = zSchemaQueueStatus

export const zGetFalAiIllusionDiffusionRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiIllusionDiffusionRequestsByRequestIdResponse =
  zSchemaIllusionDiffusionOutput

export const zGetFalAiFooocusImagePromptRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiFooocusImagePromptRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFooocusImagePromptRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiFooocusImagePromptRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFooocusImagePromptData = z.object({
  body: zSchemaFooocusImagePromptInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFooocusImagePromptResponse = zSchemaQueueStatus

export const zGetFalAiFooocusImagePromptRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFooocusImagePromptRequestsByRequestIdResponse =
  zSchemaFooocusImagePromptOutput

export const zGetFalAiFooocusInpaintRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFooocusInpaintRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFooocusInpaintRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFooocusInpaintRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFooocusInpaintData = z.object({
  body: zSchemaFooocusInpaintInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFooocusInpaintResponse = zSchemaQueueStatus

export const zGetFalAiFooocusInpaintRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFooocusInpaintRequestsByRequestIdResponse =
  zSchemaFooocusInpaintOutput

export const zGetFalAiLcmRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiLcmRequestsByRequestIdStatusResponse = zSchemaQueueStatus

export const zPutFalAiLcmRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiLcmRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLcmData = z.object({
  body: zSchemaLcmInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLcmResponse = zSchemaQueueStatus

export const zGetFalAiLcmRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLcmRequestsByRequestIdResponse = zSchemaLcmOutput

export const zGetFalAiDiffusionEdgeRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiDiffusionEdgeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiDiffusionEdgeRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiDiffusionEdgeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiDiffusionEdgeData = z.object({
  body: zSchemaDiffusionEdgeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiDiffusionEdgeResponse = zSchemaQueueStatus

export const zGetFalAiDiffusionEdgeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiDiffusionEdgeRequestsByRequestIdResponse =
  zSchemaDiffusionEdgeOutput

export const zGetFalAiFooocusRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiFooocusRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiFooocusRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiFooocusRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiFooocusData = z.object({
  body: zSchemaFooocusInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiFooocusResponse = zSchemaQueueStatus

export const zGetFalAiFooocusRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiFooocusRequestsByRequestIdResponse = zSchemaFooocusOutput

export const zGetFalAiLoraRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiLoraRequestsByRequestIdStatusResponse = zSchemaQueueStatus

export const zPutFalAiLoraRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiLoraRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiLoraData = z.object({
  body: zSchemaLoraInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiLoraResponse = zSchemaQueueStatus

export const zGetFalAiLoraRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiLoraRequestsByRequestIdResponse = zSchemaLoraOutput
