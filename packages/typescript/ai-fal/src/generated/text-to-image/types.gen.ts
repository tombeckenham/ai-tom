// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
  baseUrl: 'https://queue.fal.run' | (string & {})
}

/**
 * TimestepsInput
 */
export type SchemaTimestepsInput = {
  /**
   * Method
   *
   *
   * The method to use for the timesteps. If set to 'array', the timesteps will be set based
   * on the provided timesteps schedule in the `array` field.
   * Defaults to 'default' which means the scheduler will use the `num_inference_steps` parameter.
   *
   */
  method?: 'default' | 'array'
  /**
   * Array
   *
   *
   * Timesteps schedule to be used if 'custom' method is selected.
   *
   */
  array?: Array<number>
}

/**
 * SigmasInput
 */
export type SchemaSigmasInput = {
  /**
   * Method
   *
   *
   * The method to use for the sigmas. If set to 'custom', the sigmas will be set based
   * on the provided sigmas schedule in the `array` field.
   * Defaults to 'default' which means the scheduler will use the sigmas of the scheduler.
   *
   */
  method?: 'default' | 'array'
  /**
   * Array
   *
   *
   * Sigmas schedule to be used if 'custom' method is selected.
   *
   */
  array?: Array<number>
}

/**
 * OutputParameters
 */
export type SchemaLoraOutput = {
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Debug Latents
   *
   * The latents saved for debugging.
   */
  debug_latents?: SchemaFile
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Debug Per Pass Latents
   *
   * The latents saved for debugging per pass.
   */
  debug_per_pass_latents?: SchemaFile
}

/**
 * File
 */
export type SchemaFile = {
  /**
   * File Size
   *
   * The size of the file in bytes.
   */
  file_size?: number
  /**
   * File Name
   *
   * The name of the file. It will be auto-generated if not provided.
   */
  file_name?: string
  /**
   * Content Type
   *
   * The mime type of the file.
   */
  content_type?: string
  /**
   * Url
   *
   * The URL where the file can be downloaded from.
   */
  url: string
  /**
   * File Data
   *
   * File data
   */
  file_data?: Blob | File
}

/**
 * Image
 *
 * Represents an image file.
 */
export type SchemaImage = {
  /**
   * File Size
   *
   * The size of the file in bytes.
   */
  file_size?: number
  /**
   * Height
   *
   * The height of the image in pixels.
   */
  height?: number
  /**
   * Url
   *
   * The URL where the file can be downloaded from.
   */
  url: string
  /**
   * Width
   *
   * The width of the image in pixels.
   */
  width?: number
  /**
   * File Name
   *
   * The name of the file. It will be auto-generated if not provided.
   */
  file_name?: string
  /**
   * Content Type
   *
   * The mime type of the file.
   */
  content_type?: string
  /**
   * File Data
   *
   * File data
   */
  file_data?: Blob | File
}

/**
 * TextToImageInput
 */
export type SchemaLoraInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   *
   *
   * The size of the generated image. You can choose between some presets or custom height and width
   * that **must be multiples of 8**.
   *
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Tile Height
   *
   * The size of the tiles to be used for the image generation.
   */
  tile_height?: number
  /**
   * Embeddings
   *
   *
   * The embeddings to use for the image generation. Only a single embedding is supported at the moment.
   * The embeddings will be used to map the tokens in the prompt to the embedding weights.
   *
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Ic Light Model Url
   *
   *
   * The URL of the IC Light model to use for the image generation.
   *
   */
  ic_light_model_url?: string
  /**
   * Image Encoder Weight Name
   *
   *
   * The weight name of the image encoder model to use for the image generation.
   *
   */
  image_encoder_weight_name?: string
  /**
   * Ip Adapter
   *
   *
   * The IP adapter to use for the image generation.
   *
   */
  ip_adapter?: Array<SchemaIpAdapter>
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Scheduler
   *
   * Scheduler / sampler to use for the image denoising process.
   */
  scheduler?:
    | 'DPM++ 2M'
    | 'DPM++ 2M Karras'
    | 'DPM++ 2M SDE'
    | 'DPM++ 2M SDE Karras'
    | 'Euler'
    | 'Euler A'
    | 'Euler (trailing timesteps)'
    | 'LCM'
    | 'LCM (trailing timesteps)'
    | 'DDIM'
    | 'TCD'
  /**
   * Sigmas
   *
   *
   * Optionally override the sigmas to use for the denoising process. Only works with schedulers which support the `sigmas` argument in their `set_sigmas` method.
   * Defaults to not overriding, in which case the scheduler automatically sets the sigmas based on the `num_inference_steps` parameter.
   * If set to a custom sigma schedule, the `num_inference_steps` parameter will be ignored. Cannot be set if `timesteps` is set.
   *
   */
  sigmas?: SchemaSigmasInput
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Tile Stride Width
   *
   * The stride of the tiles to be used for the image generation.
   */
  tile_stride_width?: number
  /**
   * Debug Per Pass Latents
   *
   * If set to true, the latents will be saved for debugging per pass.
   */
  debug_per_pass_latents?: boolean
  /**
   * Timesteps
   *
   *
   * Optionally override the timesteps to use for the denoising process. Only works with schedulers which support the `timesteps` argument in their `set_timesteps` method.
   * Defaults to not overriding, in which case the scheduler automatically sets the timesteps based on the `num_inference_steps` parameter.
   * If set to a custom timestep schedule, the `num_inference_steps` parameter will be ignored. Cannot be set if `sigmas` is set.
   *
   */
  timesteps?: SchemaTimestepsInput
  /**
   * Image Encoder Subfolder
   *
   *
   * The subfolder of the image encoder model to use for the image generation.
   *
   */
  image_encoder_subfolder?: string
  /**
   * Prompt Weighting
   *
   *
   * If set to true, the prompt weighting syntax will be used.
   * Additionally, this will lift the 77 token limit by averaging embeddings.
   *
   */
  prompt_weighting?: boolean
  /**
   * Variant
   *
   * The variant of the model to use for huggingface models, e.g. 'fp16'.
   */
  variant?: string
  /**
   * Model Name
   *
   * URL or HuggingFace ID of the base model to generate the image.
   */
  model_name: string
  /**
   * Controlnet Guess Mode
   *
   *
   * If set to true, the controlnet will be applied to only the conditional predictions.
   *
   */
  controlnet_guess_mode?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Ic Light Model Background Image Url
   *
   *
   * The URL of the IC Light model background image to use for the image generation.
   * Make sure to use a background compatible with the model.
   *
   */
  ic_light_model_background_image_url?: string
  /**
   * Rescale Betas Snr Zero
   *
   *
   * Whether to set the rescale_betas_snr_zero option or not for the sampler
   *
   */
  rescale_betas_snr_zero?: boolean
  /**
   * Tile Width
   *
   * The size of the tiles to be used for the image generation.
   */
  tile_width?: number
  /**
   * Prediction Type
   *
   *
   * The type of prediction to use for the image generation.
   * The `epsilon` is the default.
   *
   */
  prediction_type?: 'v_prediction' | 'epsilon'
  /**
   * Eta
   *
   * The eta value to be used for the image generation.
   */
  eta?: number
  /**
   * Image Encoder Path
   *
   *
   * The path to the image encoder model to use for the image generation.
   *
   */
  image_encoder_path?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use.Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Image Format
   *
   * The format of the generated image.
   */
  image_format?: 'jpeg' | 'png'
  /**
   * Number of images
   *
   *
   * Number of images to generate in one request. Note that the higher the batch size,
   * the longer it will take to generate the images.
   *
   */
  num_images?: number
  /**
   * Debug Latents
   *
   * If set to true, the latents will be saved for debugging.
   */
  debug_latents?: boolean
  /**
   * Ic Light Image Url
   *
   *
   * The URL of the IC Light model image to use for the image generation.
   *
   */
  ic_light_image_url?: string
  /**
   * Unet Name
   *
   * URL or HuggingFace ID of the custom U-Net model to use for the image generation.
   */
  unet_name?: string
  /**
   * Clip Skip
   *
   *
   * Skips part of the image generation process, leading to slightly different results.
   * This means the image renders faster, too.
   *
   */
  clip_skip?: number
  /**
   * Tile Stride Height
   *
   * The stride of the tiles to be used for the image generation.
   */
  tile_stride_height?: number
  /**
   * Controlnets
   *
   *
   * The control nets to use for the image generation. You can use any number of control nets
   * and they will be applied to the image at the specified timesteps.
   *
   */
  controlnets?: Array<SchemaControlNet>
  /**
   * Number of inference steps
   *
   *
   * Increasing the amount of steps tells Stable Diffusion that it should take more steps
   * to generate your final result which can increase the amount of detail in your image.
   *
   */
  num_inference_steps?: number
}

/**
 * ControlNet
 */
export type SchemaControlNet = {
  /**
   * Conditioning Scale
   *
   *
   * The scale of the control net weight. This is used to scale the control net weight
   * before merging it with the base model.
   *
   */
  conditioning_scale?: number
  /**
   * Path
   *
   * URL or the path to the control net weights.
   */
  path: string
  /**
   * Ip Adapter Index
   *
   *
   * The index of the IP adapter to be applied to the controlnet. This is only needed for InstantID ControlNets.
   *
   */
  ip_adapter_index?: number
  /**
   * End Percentage
   *
   *
   * The percentage of the image to end applying the controlnet in terms of the total timesteps.
   *
   */
  end_percentage?: number
  /**
   * Config Url
   *
   * optional URL to the controlnet config.json file.
   */
  config_url?: string
  /**
   * Image Url
   *
   * URL of the image to be used as the control net.
   */
  image_url: string
  /**
   * Variant
   *
   * The optional variant if a Hugging Face repo key is used.
   */
  variant?: string
  /**
   * Mask Url
   *
   *
   * The mask to use for the controlnet. When using a mask, the control image size and the mask size must be the same and divisible by 32.
   *
   */
  mask_url?: string
  /**
   * Start Percentage
   *
   *
   * The percentage of the image to start applying the controlnet in terms of the total timesteps.
   *
   */
  start_percentage?: number
}

/**
 * LoraWeight
 */
export type SchemaLoraWeight = {
  /**
   * Path
   *
   * URL or the path to the LoRA weights.
   */
  path: string
  /**
   * Scale
   *
   *
   * The scale of the LoRA weight. This is used to scale the LoRA weight
   * before merging it with the base model.
   *
   */
  scale?: number
}

/**
 * IPAdapter
 */
export type SchemaIpAdapter = {
  /**
   * Unconditional Noising Factor
   *
   * The factor to apply to the unconditional noising of the IP adapter.
   */
  unconditional_noising_factor?: number
  /**
   * Ip Adapter Image Url
   *
   * URL of the image to be used as the IP adapter.
   */
  ip_adapter_image_url: string | Array<string>
  /**
   * Path
   *
   * URL or the path to the IP adapter weights.
   */
  path: string
  /**
   * Image Projection Shortcut
   *
   *
   * The value to set the image projection shortcut to. For FaceID plus V1 models,
   * this should be set to False. For FaceID plus V2 models, this should be set to True.
   * Default is True.
   *
   */
  image_projection_shortcut?: boolean
  /**
   * Scale Json
   *
   *
   * The scale of the IP adapter weight. This is used to scale the IP adapter weight
   * before merging it with the base model.
   *
   */
  scale_json?: {
    [key: string]: unknown
  }
  /**
   * Ip Adapter Mask Url
   *
   *
   * The mask to use for the IP adapter. When using a mask, the ip-adapter image size and the mask size must be the same
   *
   */
  ip_adapter_mask_url?: string
  /**
   * Model Subfolder
   *
   * Subfolder in the model directory where the IP adapter weights are stored.
   */
  model_subfolder?: string
  /**
   * Scale
   *
   *
   * The scale of the IP adapter weight. This is used to scale the IP adapter weight
   * before merging it with the base model.
   *
   */
  scale?: number
  /**
   * Insight Face Model Path
   *
   * URL or the path to the InsightFace model weights.
   */
  insight_face_model_path?: string
  /**
   * Weight Name
   *
   * Name of the weight file.
   */
  weight_name?: string
}

/**
 * Embedding
 */
export type SchemaEmbedding = {
  /**
   * Tokens
   *
   *
   * The tokens to map the embedding weights to. Use these tokens in your prompts.
   *
   */
  tokens?: Array<string>
  /**
   * Path
   *
   * URL or the path to the embedding weights.
   */
  path: string
}

/**
 * ImageSize
 */
export type SchemaImageSize = {
  /**
   * Height
   *
   * The height of the generated image.
   */
  height?: number
  /**
   * Width
   *
   * The width of the generated image.
   */
  width?: number
}

/**
 * FooocusOutput
 */
export type SchemaFooocusOutput = {
  /**
   * Images
   *
   * The generated image file info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   *
   * The time taken for the generation process.
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
}

/**
 * FooocusLegacyInput
 */
export type SchemaFooocusInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt?: string
  /**
   * Performance
   *
   *
   * You can choose Speed or Quality
   *
   */
  performance?: 'Speed' | 'Quality' | 'Extreme Speed' | 'Lightning'
  /**
   * Styles
   *
   *
   * The style to use.
   *
   */
  styles?: Array<
    | 'Fooocus V2'
    | 'Fooocus Enhance'
    | 'Fooocus Sharp'
    | 'Fooocus Semi Realistic'
    | 'Fooocus Masterpiece'
    | 'Fooocus Photograph'
    | 'Fooocus Negative'
    | 'Fooocus Cinematic'
    | 'SAI 3D Model'
    | 'SAI Analog Film'
    | 'SAI Anime'
    | 'SAI Cinematic'
    | 'SAI Comic Book'
    | 'SAI Craft Clay'
    | 'SAI Digital Art'
    | 'SAI Enhance'
    | 'SAI Fantasy Art'
    | 'SAI Isometric'
    | 'SAI Line Art'
    | 'SAI Lowpoly'
    | 'SAI Neonpunk'
    | 'SAI Origami'
    | 'SAI Photographic'
    | 'SAI Pixel Art'
    | 'SAI Texture'
    | 'MRE Cinematic Dynamic'
    | 'MRE Spontaneous Picture'
    | 'MRE Artistic Vision'
    | 'MRE Dark Dream'
    | 'MRE Gloomy Art'
    | 'MRE Bad Dream'
    | 'MRE Underground'
    | 'MRE Surreal Painting'
    | 'MRE Dynamic Illustration'
    | 'MRE Undead Art'
    | 'MRE Elemental Art'
    | 'MRE Space Art'
    | 'MRE Ancient Illustration'
    | 'MRE Brave Art'
    | 'MRE Heroic Fantasy'
    | 'MRE Dark Cyberpunk'
    | 'MRE Lyrical Geometry'
    | 'MRE Sumi E Symbolic'
    | 'MRE Sumi E Detailed'
    | 'MRE Manga'
    | 'MRE Anime'
    | 'MRE Comic'
    | 'Ads Advertising'
    | 'Ads Automotive'
    | 'Ads Corporate'
    | 'Ads Fashion Editorial'
    | 'Ads Food Photography'
    | 'Ads Gourmet Food Photography'
    | 'Ads Luxury'
    | 'Ads Real Estate'
    | 'Ads Retail'
    | 'Artstyle Abstract'
    | 'Artstyle Abstract Expressionism'
    | 'Artstyle Art Deco'
    | 'Artstyle Art Nouveau'
    | 'Artstyle Constructivist'
    | 'Artstyle Cubist'
    | 'Artstyle Expressionist'
    | 'Artstyle Graffiti'
    | 'Artstyle Hyperrealism'
    | 'Artstyle Impressionist'
    | 'Artstyle Pointillism'
    | 'Artstyle Pop Art'
    | 'Artstyle Psychedelic'
    | 'Artstyle Renaissance'
    | 'Artstyle Steampunk'
    | 'Artstyle Surrealist'
    | 'Artstyle Typography'
    | 'Artstyle Watercolor'
    | 'Futuristic Biomechanical'
    | 'Futuristic Biomechanical Cyberpunk'
    | 'Futuristic Cybernetic'
    | 'Futuristic Cybernetic Robot'
    | 'Futuristic Cyberpunk Cityscape'
    | 'Futuristic Futuristic'
    | 'Futuristic Retro Cyberpunk'
    | 'Futuristic Retro Futurism'
    | 'Futuristic Sci Fi'
    | 'Futuristic Vaporwave'
    | 'Game Bubble Bobble'
    | 'Game Cyberpunk Game'
    | 'Game Fighting Game'
    | 'Game Gta'
    | 'Game Mario'
    | 'Game Minecraft'
    | 'Game Pokemon'
    | 'Game Retro Arcade'
    | 'Game Retro Game'
    | 'Game Rpg Fantasy Game'
    | 'Game Strategy Game'
    | 'Game Streetfighter'
    | 'Game Zelda'
    | 'Misc Architectural'
    | 'Misc Disco'
    | 'Misc Dreamscape'
    | 'Misc Dystopian'
    | 'Misc Fairy Tale'
    | 'Misc Gothic'
    | 'Misc Grunge'
    | 'Misc Horror'
    | 'Misc Kawaii'
    | 'Misc Lovecraftian'
    | 'Misc Macabre'
    | 'Misc Manga'
    | 'Misc Metropolis'
    | 'Misc Minimalist'
    | 'Misc Monochrome'
    | 'Misc Nautical'
    | 'Misc Space'
    | 'Misc Stained Glass'
    | 'Misc Techwear Fashion'
    | 'Misc Tribal'
    | 'Misc Zentangle'
    | 'Papercraft Collage'
    | 'Papercraft Flat Papercut'
    | 'Papercraft Kirigami'
    | 'Papercraft Paper Mache'
    | 'Papercraft Paper Quilling'
    | 'Papercraft Papercut Collage'
    | 'Papercraft Papercut Shadow Box'
    | 'Papercraft Stacked Papercut'
    | 'Papercraft Thick Layered Papercut'
    | 'Photo Alien'
    | 'Photo Film Noir'
    | 'Photo Glamour'
    | 'Photo Hdr'
    | 'Photo Iphone Photographic'
    | 'Photo Long Exposure'
    | 'Photo Neon Noir'
    | 'Photo Silhouette'
    | 'Photo Tilt Shift'
    | 'Cinematic Diva'
    | 'Abstract Expressionism'
    | 'Academia'
    | 'Action Figure'
    | 'Adorable 3D Character'
    | 'Adorable Kawaii'
    | 'Art Deco'
    | 'Art Nouveau'
    | 'Astral Aura'
    | 'Avant Garde'
    | 'Baroque'
    | 'Bauhaus Style Poster'
    | 'Blueprint Schematic Drawing'
    | 'Caricature'
    | 'Cel Shaded Art'
    | 'Character Design Sheet'
    | 'Classicism Art'
    | 'Color Field Painting'
    | 'Colored Pencil Art'
    | 'Conceptual Art'
    | 'Constructivism'
    | 'Cubism'
    | 'Dadaism'
    | 'Dark Fantasy'
    | 'Dark Moody Atmosphere'
    | 'Dmt Art Style'
    | 'Doodle Art'
    | 'Double Exposure'
    | 'Dripping Paint Splatter Art'
    | 'Expressionism'
    | 'Faded Polaroid Photo'
    | 'Fauvism'
    | 'Flat 2d Art'
    | 'Fortnite Art Style'
    | 'Futurism'
    | 'Glitchcore'
    | 'Glo Fi'
    | 'Googie Art Style'
    | 'Graffiti Art'
    | 'Harlem Renaissance Art'
    | 'High Fashion'
    | 'Idyllic'
    | 'Impressionism'
    | 'Infographic Drawing'
    | 'Ink Dripping Drawing'
    | 'Japanese Ink Drawing'
    | 'Knolling Photography'
    | 'Light Cheery Atmosphere'
    | 'Logo Design'
    | 'Luxurious Elegance'
    | 'Macro Photography'
    | 'Mandola Art'
    | 'Marker Drawing'
    | 'Medievalism'
    | 'Minimalism'
    | 'Neo Baroque'
    | 'Neo Byzantine'
    | 'Neo Futurism'
    | 'Neo Impressionism'
    | 'Neo Rococo'
    | 'Neoclassicism'
    | 'Op Art'
    | 'Ornate And Intricate'
    | 'Pencil Sketch Drawing'
    | 'Pop Art 2'
    | 'Rococo'
    | 'Silhouette Art'
    | 'Simple Vector Art'
    | 'Sketchup'
    | 'Steampunk 2'
    | 'Surrealism'
    | 'Suprematism'
    | 'Terragen'
    | 'Tranquil Relaxing Atmosphere'
    | 'Sticker Designs'
    | 'Vibrant Rim Light'
    | 'Volumetric Lighting'
    | 'Watercolor 2'
    | 'Whimsical And Playful'
    | 'Mk Chromolithography'
    | 'Mk Cross Processing Print'
    | 'Mk Dufaycolor Photograph'
    | 'Mk Herbarium'
    | 'Mk Punk Collage'
    | 'Mk Mosaic'
    | 'Mk Van Gogh'
    | 'Mk Coloring Book'
    | 'Mk Singer Sargent'
    | 'Mk Pollock'
    | 'Mk Basquiat'
    | 'Mk Andy Warhol'
    | 'Mk Halftone Print'
    | 'Mk Gond Painting'
    | 'Mk Albumen Print'
    | 'Mk Aquatint Print'
    | 'Mk Anthotype Print'
    | 'Mk Inuit Carving'
    | 'Mk Bromoil Print'
    | 'Mk Calotype Print'
    | 'Mk Color Sketchnote'
    | 'Mk Cibulak Porcelain'
    | 'Mk Alcohol Ink Art'
    | 'Mk One Line Art'
    | 'Mk Blacklight Paint'
    | 'Mk Carnival Glass'
    | 'Mk Cyanotype Print'
    | 'Mk Cross Stitching'
    | 'Mk Encaustic Paint'
    | 'Mk Embroidery'
    | 'Mk Gyotaku'
    | 'Mk Luminogram'
    | 'Mk Lite Brite Art'
    | 'Mk Mokume Gane'
    | 'Pebble Art'
    | 'Mk Palekh'
    | 'Mk Suminagashi'
    | 'Mk Scrimshaw'
    | 'Mk Shibori'
    | 'Mk Vitreous Enamel'
    | 'Mk Ukiyo E'
    | 'Mk Vintage Airline Poster'
    | 'Mk Vintage Travel Poster'
    | 'Mk Bauhaus Style'
    | 'Mk Afrofuturism'
    | 'Mk Atompunk'
    | 'Mk Constructivism'
    | 'Mk Chicano Art'
    | 'Mk De Stijl'
    | 'Mk Dayak Art'
    | 'Mk Fayum Portrait'
    | 'Mk Illuminated Manuscript'
    | 'Mk Kalighat Painting'
    | 'Mk Madhubani Painting'
    | 'Mk Pictorialism'
    | 'Mk Pichwai Painting'
    | 'Mk Patachitra Painting'
    | 'Mk Samoan Art Inspired'
    | 'Mk Tlingit Art'
    | 'Mk Adnate Style'
    | 'Mk Ron English Style'
    | 'Mk Shepard Fairey Style'
  >
  /**
   * Control Type
   *
   * The type of image control
   */
  control_type?: 'ImagePrompt' | 'PyraCanny' | 'CPDS' | 'FaceSwap'
  /**
   * Mask Image Url
   *
   * The image to use as a mask for the generated image.
   */
  mask_image_url?: string | null
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use up to 5 LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Enable Safety Checker
   *
   * If set to false, the safety checker will be disabled.
   */
  enable_safety_checker?: boolean
  /**
   * Sharpness
   *
   *
   * The sharpness of the generated image. Use it to control how sharp the generated
   * image should be. Higher value means image and texture are sharper.
   *
   */
  sharpness?: number
  /**
   * Guidance Scale
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Inpaint Image Url
   *
   * The image to use as a reference for inpainting.
   */
  inpaint_image_url?: string | null
  /**
   * Mixing Image Prompt And Inpaint
   */
  mixing_image_prompt_and_inpaint?: boolean
  /**
   * Aspect Ratio
   *
   *
   * The size of the generated image. You can choose between some presets or
   * custom height and width that **must be multiples of 8**.
   *
   */
  aspect_ratio?: string
  /**
   * Num Images
   *
   *
   * Number of images to generate in one request
   *
   */
  num_images?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Refiner Model
   *
   * Refiner (SDXL or SD 1.5)
   */
  refiner_model?: 'None' | 'realisticVisionV60B1_v51VAE.safetensors'
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Control Image Url
   *
   * The image to use as a reference for the generated image.
   */
  control_image_url?: string | null
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number | null
  /**
   * Refiner Switch At
   *
   *
   * Use 0.4 for SD1.5 realistic models; 0.667 for SD1.5 anime models
   * 0.8 for XL-refiners; or any value for switching two SDXL models.
   *
   */
  refiner_switch?: number
  /**
   * Control Image Weight
   *
   *
   * The strength of the control image. Use it to control how much the generated image
   * should look like the control image.
   *
   */
  control_image_weight?: number
  /**
   * Control Image Stop At
   *
   *
   * The stop at value of the control image. Use it to control how much the generated image
   * should look like the control image.
   *
   */
  control_image_stop_at?: number
}

/**
 * DiffusionEdgeOutput
 */
export type SchemaDiffusionEdgeOutput = {
  /**
   * Image
   *
   * The generated image file info.
   */
  image: SchemaImage
}

/**
 * DiffusionEdgeInput
 */
export type SchemaDiffusionEdgeInput = {
  /**
   * Image Url
   *
   * The text prompt you would like to convert to speech.
   */
  image_url: string
}

/**
 * LCMOutput
 */
export type SchemaLcmOutput = {
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Num Inference Steps
   *
   *
   * Number of inference steps used to generate the image. It will be the same value of the one passed in the
   * input or the default one in case none was passed.
   *
   */
  num_inference_steps?: number
  /**
   * Nsfw Content Detected
   *
   *
   * A list of booleans indicating whether the generated image contains any
   * potentially unsafe content. If the safety check is disabled, this field
   * will all will be false.
   *
   */
  nsfw_content_detected: Array<boolean>
}

/**
 * LCMInput
 */
export type SchemaLcmInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Controlnet Inpaint
   *
   *
   * If set to true, the inpainting pipeline will use controlnet inpainting.
   * Only effective for inpainting pipelines.
   *
   */
  controlnet_inpaint?: boolean
  /**
   * Image Size
   *
   *
   * The size of the generated image. You can choose between some presets or
   * custom height and width that **must be multiples of 8**.
   *
   * If not provided:
   * - For text-to-image generations, the default size is 512x512.
   * - For image-to-image generations, the default size is the same as the input image.
   * - For inpainting generations, the default size is the same as the input image.
   *
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Enable Safety Checks
   *
   *
   * If set to true, the resulting image will be checked whether it includes any
   * potentially unsafe content. If it does, it will be replaced with a black
   * image.
   *
   */
  enable_safety_checks?: boolean
  /**
   * Model
   *
   * The model to use for generating the image.
   */
  model?: 'sdxl' | 'sdv1-5'
  /**
   * Lora Url
   *
   *
   * The url of the lora server to use for image generation.
   *
   */
  lora_url?: string
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use.Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Inpaint Mask Only
   *
   *
   * If set to true, the inpainting pipeline will only inpaint the provided mask
   * area. Only effective for inpainting pipelines.
   *
   */
  inpaint_mask_only?: boolean
  /**
   * Num Images
   *
   *
   * The number of images to generate. The function will return a list of images
   * with the same prompt and negative prompt but different seeds.
   *
   */
  num_images?: number
  /**
   * Lora Scale
   *
   *
   * The scale of the lora server to use for image generation.
   *
   */
  lora_scale?: number
  /**
   * Image Url
   *
   *
   * The base image to use for guiding the image generation on image-to-image
   * generations. If the either width or height of the image is larger than 1024
   * pixels, the image will be resized to 1024 pixels while keeping the aspect ratio.
   *
   */
  image_url?: string
  /**
   * Strength
   *
   *
   * The strength of the image that is passed as `image_url`. The strength
   * determines how much the generated image will be similar to the image passed as
   * `image_url`. The higher the strength the more model gets "creative" and
   * generates an image that's different from the initial image. A strength of 1.0
   * means that the initial image is more or less ignored and the model will try to
   * generate an image that's as close as possible to the prompt.
   *
   */
  strength?: number
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Mask Url
   *
   *
   * The mask to use for guiding the image generation on image
   * inpainting. The model will focus on the mask area and try to fill it with
   * the most relevant content.
   *
   * The mask must be a black and white image where the white area is the area
   * that needs to be filled and the black area is the area that should be
   * ignored.
   *
   * The mask must have the same dimensions as the image passed as `image_url`.
   *
   */
  mask_url?: string
  /**
   * Num Inference Steps
   *
   *
   * The number of inference steps to use for generating the image. The more steps
   * the better the image will be but it will also take longer to generate.
   *
   */
  num_inference_steps?: number
}

/**
 * FooocusOutput
 */
export type SchemaFooocusInpaintOutput = {
  /**
   * Images
   *
   * The generated image file info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   *
   * The time taken for the generation process.
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
}

/**
 * FooocusInpaintInput
 */
export type SchemaFooocusInpaintInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt?: string
  /**
   * Performance
   *
   *
   * You can choose Speed or Quality
   *
   */
  performance?: 'Speed' | 'Quality' | 'Extreme Speed' | 'Lightning'
  /**
   * Styles
   *
   *
   * The style to use.
   *
   */
  styles?: Array<
    | 'Fooocus V2'
    | 'Fooocus Enhance'
    | 'Fooocus Sharp'
    | 'Fooocus Semi Realistic'
    | 'Fooocus Masterpiece'
    | 'Fooocus Photograph'
    | 'Fooocus Negative'
    | 'Fooocus Cinematic'
    | 'SAI 3D Model'
    | 'SAI Analog Film'
    | 'SAI Anime'
    | 'SAI Cinematic'
    | 'SAI Comic Book'
    | 'SAI Craft Clay'
    | 'SAI Digital Art'
    | 'SAI Enhance'
    | 'SAI Fantasy Art'
    | 'SAI Isometric'
    | 'SAI Line Art'
    | 'SAI Lowpoly'
    | 'SAI Neonpunk'
    | 'SAI Origami'
    | 'SAI Photographic'
    | 'SAI Pixel Art'
    | 'SAI Texture'
    | 'MRE Cinematic Dynamic'
    | 'MRE Spontaneous Picture'
    | 'MRE Artistic Vision'
    | 'MRE Dark Dream'
    | 'MRE Gloomy Art'
    | 'MRE Bad Dream'
    | 'MRE Underground'
    | 'MRE Surreal Painting'
    | 'MRE Dynamic Illustration'
    | 'MRE Undead Art'
    | 'MRE Elemental Art'
    | 'MRE Space Art'
    | 'MRE Ancient Illustration'
    | 'MRE Brave Art'
    | 'MRE Heroic Fantasy'
    | 'MRE Dark Cyberpunk'
    | 'MRE Lyrical Geometry'
    | 'MRE Sumi E Symbolic'
    | 'MRE Sumi E Detailed'
    | 'MRE Manga'
    | 'MRE Anime'
    | 'MRE Comic'
    | 'Ads Advertising'
    | 'Ads Automotive'
    | 'Ads Corporate'
    | 'Ads Fashion Editorial'
    | 'Ads Food Photography'
    | 'Ads Gourmet Food Photography'
    | 'Ads Luxury'
    | 'Ads Real Estate'
    | 'Ads Retail'
    | 'Artstyle Abstract'
    | 'Artstyle Abstract Expressionism'
    | 'Artstyle Art Deco'
    | 'Artstyle Art Nouveau'
    | 'Artstyle Constructivist'
    | 'Artstyle Cubist'
    | 'Artstyle Expressionist'
    | 'Artstyle Graffiti'
    | 'Artstyle Hyperrealism'
    | 'Artstyle Impressionist'
    | 'Artstyle Pointillism'
    | 'Artstyle Pop Art'
    | 'Artstyle Psychedelic'
    | 'Artstyle Renaissance'
    | 'Artstyle Steampunk'
    | 'Artstyle Surrealist'
    | 'Artstyle Typography'
    | 'Artstyle Watercolor'
    | 'Futuristic Biomechanical'
    | 'Futuristic Biomechanical Cyberpunk'
    | 'Futuristic Cybernetic'
    | 'Futuristic Cybernetic Robot'
    | 'Futuristic Cyberpunk Cityscape'
    | 'Futuristic Futuristic'
    | 'Futuristic Retro Cyberpunk'
    | 'Futuristic Retro Futurism'
    | 'Futuristic Sci Fi'
    | 'Futuristic Vaporwave'
    | 'Game Bubble Bobble'
    | 'Game Cyberpunk Game'
    | 'Game Fighting Game'
    | 'Game Gta'
    | 'Game Mario'
    | 'Game Minecraft'
    | 'Game Pokemon'
    | 'Game Retro Arcade'
    | 'Game Retro Game'
    | 'Game Rpg Fantasy Game'
    | 'Game Strategy Game'
    | 'Game Streetfighter'
    | 'Game Zelda'
    | 'Misc Architectural'
    | 'Misc Disco'
    | 'Misc Dreamscape'
    | 'Misc Dystopian'
    | 'Misc Fairy Tale'
    | 'Misc Gothic'
    | 'Misc Grunge'
    | 'Misc Horror'
    | 'Misc Kawaii'
    | 'Misc Lovecraftian'
    | 'Misc Macabre'
    | 'Misc Manga'
    | 'Misc Metropolis'
    | 'Misc Minimalist'
    | 'Misc Monochrome'
    | 'Misc Nautical'
    | 'Misc Space'
    | 'Misc Stained Glass'
    | 'Misc Techwear Fashion'
    | 'Misc Tribal'
    | 'Misc Zentangle'
    | 'Papercraft Collage'
    | 'Papercraft Flat Papercut'
    | 'Papercraft Kirigami'
    | 'Papercraft Paper Mache'
    | 'Papercraft Paper Quilling'
    | 'Papercraft Papercut Collage'
    | 'Papercraft Papercut Shadow Box'
    | 'Papercraft Stacked Papercut'
    | 'Papercraft Thick Layered Papercut'
    | 'Photo Alien'
    | 'Photo Film Noir'
    | 'Photo Glamour'
    | 'Photo Hdr'
    | 'Photo Iphone Photographic'
    | 'Photo Long Exposure'
    | 'Photo Neon Noir'
    | 'Photo Silhouette'
    | 'Photo Tilt Shift'
    | 'Cinematic Diva'
    | 'Abstract Expressionism'
    | 'Academia'
    | 'Action Figure'
    | 'Adorable 3D Character'
    | 'Adorable Kawaii'
    | 'Art Deco'
    | 'Art Nouveau'
    | 'Astral Aura'
    | 'Avant Garde'
    | 'Baroque'
    | 'Bauhaus Style Poster'
    | 'Blueprint Schematic Drawing'
    | 'Caricature'
    | 'Cel Shaded Art'
    | 'Character Design Sheet'
    | 'Classicism Art'
    | 'Color Field Painting'
    | 'Colored Pencil Art'
    | 'Conceptual Art'
    | 'Constructivism'
    | 'Cubism'
    | 'Dadaism'
    | 'Dark Fantasy'
    | 'Dark Moody Atmosphere'
    | 'Dmt Art Style'
    | 'Doodle Art'
    | 'Double Exposure'
    | 'Dripping Paint Splatter Art'
    | 'Expressionism'
    | 'Faded Polaroid Photo'
    | 'Fauvism'
    | 'Flat 2d Art'
    | 'Fortnite Art Style'
    | 'Futurism'
    | 'Glitchcore'
    | 'Glo Fi'
    | 'Googie Art Style'
    | 'Graffiti Art'
    | 'Harlem Renaissance Art'
    | 'High Fashion'
    | 'Idyllic'
    | 'Impressionism'
    | 'Infographic Drawing'
    | 'Ink Dripping Drawing'
    | 'Japanese Ink Drawing'
    | 'Knolling Photography'
    | 'Light Cheery Atmosphere'
    | 'Logo Design'
    | 'Luxurious Elegance'
    | 'Macro Photography'
    | 'Mandola Art'
    | 'Marker Drawing'
    | 'Medievalism'
    | 'Minimalism'
    | 'Neo Baroque'
    | 'Neo Byzantine'
    | 'Neo Futurism'
    | 'Neo Impressionism'
    | 'Neo Rococo'
    | 'Neoclassicism'
    | 'Op Art'
    | 'Ornate And Intricate'
    | 'Pencil Sketch Drawing'
    | 'Pop Art 2'
    | 'Rococo'
    | 'Silhouette Art'
    | 'Simple Vector Art'
    | 'Sketchup'
    | 'Steampunk 2'
    | 'Surrealism'
    | 'Suprematism'
    | 'Terragen'
    | 'Tranquil Relaxing Atmosphere'
    | 'Sticker Designs'
    | 'Vibrant Rim Light'
    | 'Volumetric Lighting'
    | 'Watercolor 2'
    | 'Whimsical And Playful'
    | 'Mk Chromolithography'
    | 'Mk Cross Processing Print'
    | 'Mk Dufaycolor Photograph'
    | 'Mk Herbarium'
    | 'Mk Punk Collage'
    | 'Mk Mosaic'
    | 'Mk Van Gogh'
    | 'Mk Coloring Book'
    | 'Mk Singer Sargent'
    | 'Mk Pollock'
    | 'Mk Basquiat'
    | 'Mk Andy Warhol'
    | 'Mk Halftone Print'
    | 'Mk Gond Painting'
    | 'Mk Albumen Print'
    | 'Mk Aquatint Print'
    | 'Mk Anthotype Print'
    | 'Mk Inuit Carving'
    | 'Mk Bromoil Print'
    | 'Mk Calotype Print'
    | 'Mk Color Sketchnote'
    | 'Mk Cibulak Porcelain'
    | 'Mk Alcohol Ink Art'
    | 'Mk One Line Art'
    | 'Mk Blacklight Paint'
    | 'Mk Carnival Glass'
    | 'Mk Cyanotype Print'
    | 'Mk Cross Stitching'
    | 'Mk Encaustic Paint'
    | 'Mk Embroidery'
    | 'Mk Gyotaku'
    | 'Mk Luminogram'
    | 'Mk Lite Brite Art'
    | 'Mk Mokume Gane'
    | 'Pebble Art'
    | 'Mk Palekh'
    | 'Mk Suminagashi'
    | 'Mk Scrimshaw'
    | 'Mk Shibori'
    | 'Mk Vitreous Enamel'
    | 'Mk Ukiyo E'
    | 'Mk Vintage Airline Poster'
    | 'Mk Vintage Travel Poster'
    | 'Mk Bauhaus Style'
    | 'Mk Afrofuturism'
    | 'Mk Atompunk'
    | 'Mk Constructivism'
    | 'Mk Chicano Art'
    | 'Mk De Stijl'
    | 'Mk Dayak Art'
    | 'Mk Fayum Portrait'
    | 'Mk Illuminated Manuscript'
    | 'Mk Kalighat Painting'
    | 'Mk Madhubani Painting'
    | 'Mk Pictorialism'
    | 'Mk Pichwai Painting'
    | 'Mk Patachitra Painting'
    | 'Mk Samoan Art Inspired'
    | 'Mk Tlingit Art'
    | 'Mk Adnate Style'
    | 'Mk Ron English Style'
    | 'Mk Shepard Fairey Style'
  >
  image_prompt_3?: SchemaImagePrompt
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use up to 5 LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  image_prompt_4?: SchemaImagePrompt
  /**
   * Guidance Scale
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Sharpness
   *
   *
   * The sharpness of the generated image. Use it to control how sharp the generated
   * image should be. Higher value means image and texture are sharper.
   *
   */
  sharpness?: number
  /**
   * Mixing Image Prompt and Inpaint
   *
   * Mixing Image Prompt and Inpaint
   */
  mixing_image_prompt_and_inpaint?: boolean
  /**
   * Outpaint Direction
   *
   * The directions to outpaint.
   */
  outpaint_selections?: Array<'Left' | 'Right' | 'Top' | 'Bottom'>
  /**
   * Inpaint Image Url
   *
   * The image to use as a reference for inpainting.
   */
  inpaint_image_url: string
  /**
   * Refiner Model
   *
   * Refiner (SDXL or SD 1.5)
   */
  refiner_model?: 'None' | 'realisticVisionV60B1_v51VAE.safetensors'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  image_prompt_2?: SchemaImagePrompt
  /**
   * Inpaint Respective Field
   *
   *
   * The area to inpaint. Value 0 is same as "Only Masked" in A1111. Value 1 is
   * same as "Whole Image" in A1111. Only used in inpaint, not used in outpaint.
   * (Outpaint always use 1.0)
   *
   */
  inpaint_respective_field?: number
  /**
   * Inpaint Mode
   *
   * The mode to use for inpainting.
   */
  inpaint_mode?:
    | 'Inpaint or Outpaint (default)'
    | 'Improve Detail (face, hand, eyes, etc.)'
    | 'Modify Content (add objects, change background, etc.)'
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number | null
  /**
   * Refiner Switch At
   *
   *
   * Use 0.4 for SD1.5 realistic models; 0.667 for SD1.5 anime models
   * 0.8 for XL-refiners; or any value for switching two SDXL models.
   *
   */
  refiner_switch?: number
  /**
   * Disable Initial Latent In Inpaint
   *
   * If set to true, the initial preprocessing will be disabled.
   */
  inpaint_disable_initial_latent?: boolean
  /**
   * Mask Image Url
   *
   * The image to use as a mask for the generated image.
   */
  mask_image_url?: string
  /**
   * Invert Mask
   *
   * If set to true, the mask will be inverted.
   */
  invert_mask?: boolean
  image_prompt_1?: SchemaImagePrompt
  /**
   * Enable Safety Checker
   *
   * If set to false, the safety checker will be disabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Num Images
   *
   *
   * Number of images to generate in one request
   *
   */
  num_images?: number
  /**
   * Aspect Ratio
   *
   *
   * The size of the generated image. You can choose between some presets or
   * custom height and width that **must be multiples of 8**.
   *
   */
  aspect_ratio?: string
  /**
   * Inpaint Additional Prompt
   *
   * Describe what you want to inpaint.
   */
  inpaint_additional_prompt?: string
  /**
   * Inpaint Denoising Strength
   *
   *
   * Same as the denoising strength in A1111 inpaint. Only used in inpaint, not
   * used in outpaint. (Outpaint always use 1.0)
   *
   */
  inpaint_strength?: number
  /**
   * Override Inpaint Options
   *
   *
   * If set to true, the advanced inpaint options ('inpaint_disable_initial_latent',
   * 'inpaint_engine', 'inpaint_strength', 'inpaint_respective_field',
   * 'inpaint_erode_or_dilate') will be overridden.
   * Otherwise, the default values will be used.
   *
   */
  override_inpaint_options?: boolean
  /**
   * Inpaint Engine
   *
   * Version of Fooocus inpaint model
   */
  inpaint_engine?: 'None' | 'v1' | 'v2.5' | 'v2.6'
  /**
   * Mask Erode or Dilate
   *
   *
   * Positive value will make white area in the mask larger, negative value will
   * make white area smaller. (default is 0, always process before any mask
   * invert)
   *
   */
  inpaint_erode_or_dilate?: number
}

/**
 * ImagePrompt
 */
export type SchemaImagePrompt = {
  /**
   * Weight
   */
  weight?: number
  /**
   * Stop At
   */
  stop_at?: number
  /**
   * Type
   */
  type?: 'ImagePrompt' | 'PyraCanny' | 'CPDS' | 'FaceSwap'
  /**
   * Image Url
   */
  image_url?: string
}

/**
 * FooocusOutput
 */
export type SchemaFooocusImagePromptOutput = {
  /**
   * Images
   *
   * The generated image file info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   *
   * The time taken for the generation process.
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
}

/**
 * FooocusImagePromptInput
 */
export type SchemaFooocusImagePromptInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt?: string
  /**
   * UOV Image URL
   *
   * The image to upscale or vary.
   */
  uov_image_url?: string
  /**
   * Performance
   *
   *
   * You can choose Speed or Quality
   *
   */
  performance?: 'Speed' | 'Quality' | 'Extreme Speed' | 'Lightning'
  image_prompt_3?: SchemaImagePrompt
  /**
   * Styles
   *
   *
   * The style to use.
   *
   */
  styles?: Array<
    | 'Fooocus V2'
    | 'Fooocus Enhance'
    | 'Fooocus Sharp'
    | 'Fooocus Semi Realistic'
    | 'Fooocus Masterpiece'
    | 'Fooocus Photograph'
    | 'Fooocus Negative'
    | 'Fooocus Cinematic'
    | 'SAI 3D Model'
    | 'SAI Analog Film'
    | 'SAI Anime'
    | 'SAI Cinematic'
    | 'SAI Comic Book'
    | 'SAI Craft Clay'
    | 'SAI Digital Art'
    | 'SAI Enhance'
    | 'SAI Fantasy Art'
    | 'SAI Isometric'
    | 'SAI Line Art'
    | 'SAI Lowpoly'
    | 'SAI Neonpunk'
    | 'SAI Origami'
    | 'SAI Photographic'
    | 'SAI Pixel Art'
    | 'SAI Texture'
    | 'MRE Cinematic Dynamic'
    | 'MRE Spontaneous Picture'
    | 'MRE Artistic Vision'
    | 'MRE Dark Dream'
    | 'MRE Gloomy Art'
    | 'MRE Bad Dream'
    | 'MRE Underground'
    | 'MRE Surreal Painting'
    | 'MRE Dynamic Illustration'
    | 'MRE Undead Art'
    | 'MRE Elemental Art'
    | 'MRE Space Art'
    | 'MRE Ancient Illustration'
    | 'MRE Brave Art'
    | 'MRE Heroic Fantasy'
    | 'MRE Dark Cyberpunk'
    | 'MRE Lyrical Geometry'
    | 'MRE Sumi E Symbolic'
    | 'MRE Sumi E Detailed'
    | 'MRE Manga'
    | 'MRE Anime'
    | 'MRE Comic'
    | 'Ads Advertising'
    | 'Ads Automotive'
    | 'Ads Corporate'
    | 'Ads Fashion Editorial'
    | 'Ads Food Photography'
    | 'Ads Gourmet Food Photography'
    | 'Ads Luxury'
    | 'Ads Real Estate'
    | 'Ads Retail'
    | 'Artstyle Abstract'
    | 'Artstyle Abstract Expressionism'
    | 'Artstyle Art Deco'
    | 'Artstyle Art Nouveau'
    | 'Artstyle Constructivist'
    | 'Artstyle Cubist'
    | 'Artstyle Expressionist'
    | 'Artstyle Graffiti'
    | 'Artstyle Hyperrealism'
    | 'Artstyle Impressionist'
    | 'Artstyle Pointillism'
    | 'Artstyle Pop Art'
    | 'Artstyle Psychedelic'
    | 'Artstyle Renaissance'
    | 'Artstyle Steampunk'
    | 'Artstyle Surrealist'
    | 'Artstyle Typography'
    | 'Artstyle Watercolor'
    | 'Futuristic Biomechanical'
    | 'Futuristic Biomechanical Cyberpunk'
    | 'Futuristic Cybernetic'
    | 'Futuristic Cybernetic Robot'
    | 'Futuristic Cyberpunk Cityscape'
    | 'Futuristic Futuristic'
    | 'Futuristic Retro Cyberpunk'
    | 'Futuristic Retro Futurism'
    | 'Futuristic Sci Fi'
    | 'Futuristic Vaporwave'
    | 'Game Bubble Bobble'
    | 'Game Cyberpunk Game'
    | 'Game Fighting Game'
    | 'Game Gta'
    | 'Game Mario'
    | 'Game Minecraft'
    | 'Game Pokemon'
    | 'Game Retro Arcade'
    | 'Game Retro Game'
    | 'Game Rpg Fantasy Game'
    | 'Game Strategy Game'
    | 'Game Streetfighter'
    | 'Game Zelda'
    | 'Misc Architectural'
    | 'Misc Disco'
    | 'Misc Dreamscape'
    | 'Misc Dystopian'
    | 'Misc Fairy Tale'
    | 'Misc Gothic'
    | 'Misc Grunge'
    | 'Misc Horror'
    | 'Misc Kawaii'
    | 'Misc Lovecraftian'
    | 'Misc Macabre'
    | 'Misc Manga'
    | 'Misc Metropolis'
    | 'Misc Minimalist'
    | 'Misc Monochrome'
    | 'Misc Nautical'
    | 'Misc Space'
    | 'Misc Stained Glass'
    | 'Misc Techwear Fashion'
    | 'Misc Tribal'
    | 'Misc Zentangle'
    | 'Papercraft Collage'
    | 'Papercraft Flat Papercut'
    | 'Papercraft Kirigami'
    | 'Papercraft Paper Mache'
    | 'Papercraft Paper Quilling'
    | 'Papercraft Papercut Collage'
    | 'Papercraft Papercut Shadow Box'
    | 'Papercraft Stacked Papercut'
    | 'Papercraft Thick Layered Papercut'
    | 'Photo Alien'
    | 'Photo Film Noir'
    | 'Photo Glamour'
    | 'Photo Hdr'
    | 'Photo Iphone Photographic'
    | 'Photo Long Exposure'
    | 'Photo Neon Noir'
    | 'Photo Silhouette'
    | 'Photo Tilt Shift'
    | 'Cinematic Diva'
    | 'Abstract Expressionism'
    | 'Academia'
    | 'Action Figure'
    | 'Adorable 3D Character'
    | 'Adorable Kawaii'
    | 'Art Deco'
    | 'Art Nouveau'
    | 'Astral Aura'
    | 'Avant Garde'
    | 'Baroque'
    | 'Bauhaus Style Poster'
    | 'Blueprint Schematic Drawing'
    | 'Caricature'
    | 'Cel Shaded Art'
    | 'Character Design Sheet'
    | 'Classicism Art'
    | 'Color Field Painting'
    | 'Colored Pencil Art'
    | 'Conceptual Art'
    | 'Constructivism'
    | 'Cubism'
    | 'Dadaism'
    | 'Dark Fantasy'
    | 'Dark Moody Atmosphere'
    | 'Dmt Art Style'
    | 'Doodle Art'
    | 'Double Exposure'
    | 'Dripping Paint Splatter Art'
    | 'Expressionism'
    | 'Faded Polaroid Photo'
    | 'Fauvism'
    | 'Flat 2d Art'
    | 'Fortnite Art Style'
    | 'Futurism'
    | 'Glitchcore'
    | 'Glo Fi'
    | 'Googie Art Style'
    | 'Graffiti Art'
    | 'Harlem Renaissance Art'
    | 'High Fashion'
    | 'Idyllic'
    | 'Impressionism'
    | 'Infographic Drawing'
    | 'Ink Dripping Drawing'
    | 'Japanese Ink Drawing'
    | 'Knolling Photography'
    | 'Light Cheery Atmosphere'
    | 'Logo Design'
    | 'Luxurious Elegance'
    | 'Macro Photography'
    | 'Mandola Art'
    | 'Marker Drawing'
    | 'Medievalism'
    | 'Minimalism'
    | 'Neo Baroque'
    | 'Neo Byzantine'
    | 'Neo Futurism'
    | 'Neo Impressionism'
    | 'Neo Rococo'
    | 'Neoclassicism'
    | 'Op Art'
    | 'Ornate And Intricate'
    | 'Pencil Sketch Drawing'
    | 'Pop Art 2'
    | 'Rococo'
    | 'Silhouette Art'
    | 'Simple Vector Art'
    | 'Sketchup'
    | 'Steampunk 2'
    | 'Surrealism'
    | 'Suprematism'
    | 'Terragen'
    | 'Tranquil Relaxing Atmosphere'
    | 'Sticker Designs'
    | 'Vibrant Rim Light'
    | 'Volumetric Lighting'
    | 'Watercolor 2'
    | 'Whimsical And Playful'
    | 'Mk Chromolithography'
    | 'Mk Cross Processing Print'
    | 'Mk Dufaycolor Photograph'
    | 'Mk Herbarium'
    | 'Mk Punk Collage'
    | 'Mk Mosaic'
    | 'Mk Van Gogh'
    | 'Mk Coloring Book'
    | 'Mk Singer Sargent'
    | 'Mk Pollock'
    | 'Mk Basquiat'
    | 'Mk Andy Warhol'
    | 'Mk Halftone Print'
    | 'Mk Gond Painting'
    | 'Mk Albumen Print'
    | 'Mk Aquatint Print'
    | 'Mk Anthotype Print'
    | 'Mk Inuit Carving'
    | 'Mk Bromoil Print'
    | 'Mk Calotype Print'
    | 'Mk Color Sketchnote'
    | 'Mk Cibulak Porcelain'
    | 'Mk Alcohol Ink Art'
    | 'Mk One Line Art'
    | 'Mk Blacklight Paint'
    | 'Mk Carnival Glass'
    | 'Mk Cyanotype Print'
    | 'Mk Cross Stitching'
    | 'Mk Encaustic Paint'
    | 'Mk Embroidery'
    | 'Mk Gyotaku'
    | 'Mk Luminogram'
    | 'Mk Lite Brite Art'
    | 'Mk Mokume Gane'
    | 'Pebble Art'
    | 'Mk Palekh'
    | 'Mk Suminagashi'
    | 'Mk Scrimshaw'
    | 'Mk Shibori'
    | 'Mk Vitreous Enamel'
    | 'Mk Ukiyo E'
    | 'Mk Vintage Airline Poster'
    | 'Mk Vintage Travel Poster'
    | 'Mk Bauhaus Style'
    | 'Mk Afrofuturism'
    | 'Mk Atompunk'
    | 'Mk Constructivism'
    | 'Mk Chicano Art'
    | 'Mk De Stijl'
    | 'Mk Dayak Art'
    | 'Mk Fayum Portrait'
    | 'Mk Illuminated Manuscript'
    | 'Mk Kalighat Painting'
    | 'Mk Madhubani Painting'
    | 'Mk Pictorialism'
    | 'Mk Pichwai Painting'
    | 'Mk Patachitra Painting'
    | 'Mk Samoan Art Inspired'
    | 'Mk Tlingit Art'
    | 'Mk Adnate Style'
    | 'Mk Ron English Style'
    | 'Mk Shepard Fairey Style'
  >
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use up to 5 LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  image_prompt_4?: SchemaImagePrompt
  /**
   * Guidance Scale
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Sharpness
   *
   *
   * The sharpness of the generated image. Use it to control how sharp the generated
   * image should be. Higher value means image and texture are sharper.
   *
   */
  sharpness?: number
  /**
   * Mixing Image Prompt and Inpaint
   *
   * Mixing Image Prompt and Inpaint
   */
  mixing_image_prompt_and_inpaint?: boolean
  /**
   * Outpaint Direction
   *
   * The directions to outpaint.
   */
  outpaint_selections?: Array<'Left' | 'Right' | 'Top' | 'Bottom'>
  /**
   * Inpaint Image URL
   *
   * The image to use as a reference for inpainting.
   */
  inpaint_image_url?: string
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Refiner Model
   *
   * Refiner (SDXL or SD 1.5)
   */
  refiner_model?: 'None' | 'realisticVisionV60B1_v51VAE.safetensors'
  image_prompt_2?: SchemaImagePrompt
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Inpaint Mode
   *
   * The mode to use for inpainting.
   */
  inpaint_mode?:
    | 'Inpaint or Outpaint (default)'
    | 'Improve Detail (face, hand, eyes, etc.)'
    | 'Modify Content (add objects, change background, etc.)'
  /**
   * UOV Method
   *
   * The method to use for upscaling or varying.
   */
  uov_method?:
    | 'Disabled'
    | 'Vary (Subtle)'
    | 'Vary (Strong)'
    | 'Upscale (1.5x)'
    | 'Upscale (2x)'
    | 'Upscale (Fast 2x)'
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number | null
  /**
   * Refiner Switch At
   *
   *
   * Use 0.4 for SD1.5 realistic models; 0.667 for SD1.5 anime models
   * 0.8 for XL-refiners; or any value for switching two SDXL models.
   *
   */
  refiner_switch?: number
  /**
   * Mixing Image Prompt and Vary/Upscale
   *
   * Mixing Image Prompt and Vary/Upscale
   */
  mixing_image_prompt_and_vary_upscale?: boolean
  /**
   * Mask Image URL
   *
   * The image to use as a mask for the generated image.
   */
  mask_image_url?: string
  /**
   * Image Prompt 1
   */
  image_prompt_1: SchemaImagePrompt
  /**
   * Enable Safety Checker
   *
   * If set to false, the safety checker will be disabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Num Images
   *
   *
   * Number of images to generate in one request
   *
   */
  num_images?: number
  /**
   * Aspect Ratio
   *
   *
   * The size of the generated image. You can choose between some presets or
   * custom height and width that **must be multiples of 8**.
   *
   */
  aspect_ratio?: string
  /**
   * Inpaint Additional Prompt
   *
   * Describe what you want to inpaint.
   */
  inpaint_additional_prompt?: string
}

/**
 * IllusionDiffusionOutput
 */
export type SchemaIllusionDiffusionOutput = {
  /**
   * Image
   *
   * The generated image file info.
   */
  image: SchemaImage
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * IllusionDiffusionInput
 */
export type SchemaIllusionDiffusionInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   *
   *
   * The size of the generated image. You can choose between some presets or
   * custom height and width that **must be multiples of 8**.
   *
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Controlnet Conditioning Scale
   *
   * The scale of the ControlNet.
   */
  controlnet_conditioning_scale?: number
  /**
   * Image Url
   *
   * Input image url.
   */
  image_url: string
  /**
   * Scheduler
   *
   * Scheduler / sampler to use for the image denoising process.
   */
  scheduler?: 'DPM++ Karras SDE' | 'Euler'
  /**
   * Control Guidance Start
   */
  control_guidance_start?: number
  /**
   * Guidance Scale
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed?: number
  /**
   * Control Guidance End
   */
  control_guidance_end?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Number of inference steps
   *
   *
   * Increasing the amount of steps tells Stable Diffusion that it should take more steps
   * to generate your final result which can increase the amount of detail in your image.
   *
   */
  num_inference_steps?: number
}

/**
 * Output
 */
export type SchemaFastFooocusSdxlOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageFooocusInput
 */
export type SchemaFastFooocusSdxlInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Enable Refiner
   *
   * If set to true, a smaller model will try to refine the output after it was processed.
   */
  enable_refiner?: boolean
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Embeddings
   *
   * The list of embeddings to use.
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Guidance Rescale
   *
   * The rescale factor for the CFG.
   */
  guidance_rescale?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaFastLcmDiffusionOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageLCMInput
 */
export type SchemaFastLcmDiffusionInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Guidance Rescale
   *
   * The rescale factor for the CFG.
   */
  guidance_rescale?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Model Name
   *
   * The name of the model to use.
   */
  model_name?:
    | 'stabilityai/stable-diffusion-xl-base-1.0'
    | 'runwayml/stable-diffusion-v1-5'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaFastSdxlControlnetCannyOutput = {
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageControlNetInput
 */
export type SchemaFastSdxlControlnetCannyInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image. Leave it none to automatically infer from the control image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | null
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Loras
   *
   * The list of LoRA weights to use.
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Controlnet Conditioning Scale
   *
   * The scale of the controlnet conditioning.
   */
  controlnet_conditioning_scale?: number
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Control Image Url
   *
   * The URL of the control image.
   */
  control_image_url: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Deep Cache
   *
   *
   * If set to true, DeepCache will be enabled. TBD
   *
   */
  enable_deep_cache?: boolean
}

/**
 * Output
 */
export type SchemaFastFooocusSdxlImageToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * ImageToImageFooocusInput
 */
export type SchemaFastFooocusSdxlImageToImageInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Enable Refiner
   *
   * If set to true, a smaller model will try to refine the output after it was processed.
   */
  enable_refiner?: boolean
  /**
   * Image Size
   *
   * The size of the generated image. Leave it none to automatically infer from the prompt image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | null
  /**
   * Embeddings
   *
   * The list of embeddings to use.
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Guidance Rescale
   *
   * The rescale factor for the CFG.
   */
  guidance_rescale?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use.Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Url
   *
   * The URL of the image to use as a starting point for the generation.
   */
  image_url: string
  /**
   * Strength
   *
   * determines how much the generated image resembles the initial image
   */
  strength?: number
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaFastLightningSdxlOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageLightningInput
 */
export type SchemaFastLightningSdxlInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Embeddings
   *
   * The list of embeddings to use.
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance Rescale
   *
   * The rescale factor for the CFG.
   */
  guidance_rescale?: number
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: '1' | '2' | '4' | '8'
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
}

/**
 * Output
 */
export type SchemaLayerDiffusionOutput = {
  /**
   * Image
   *
   * The URL of the generated image.
   */
  image: SchemaImage
  /**
   * Seed
   *
   * The seed used to generate the image.
   */
  seed: number
}

/**
 * Input
 */
export type SchemaLayerDiffusionInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt?: string
  /**
   * Guidance Scale
   *
   * The guidance scale for the model.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps for the model.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * The prompt to use for generating the negative image. Be as descriptive as possible for best results.
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to false, the safety checker will be disabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaStableDiffusionV15Output = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageSD15Input
 */
export type SchemaStableDiffusionV15Input = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Embeddings
   *
   * The list of embeddings to use.
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Loras
   *
   * The list of LoRA weights to use.
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaDreamshaperOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * DreamshaperTextToImageInput
 */
export type SchemaDreamshaperInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Embeddings
   *
   * The list of embeddings to use.
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Loras
   *
   * The list of LoRA weights to use.
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   * The negative prompt to use. Use it to address details that you don't want in the image.
   */
  negative_prompt?: string
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Model Name
   *
   * The Dreamshaper model to use.
   */
  model_name?:
    | 'Lykon/dreamshaper-xl-1-0'
    | 'Lykon/dreamshaper-xl-v2-turbo'
    | 'Lykon/dreamshaper-8'
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaRealisticVisionOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * RealisticVisionTextToImageInput
 */
export type SchemaRealisticVisionInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Embeddings
   *
   * The list of embeddings to use.
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Loras
   *
   * The list of LoRA weights to use.
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Guidance Rescale
   *
   * The rescale factor for the CFG.
   */
  guidance_rescale?: number
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   * The negative prompt to use. Use it to address details that you don't want in the image.
   */
  negative_prompt?: string
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Model Name
   *
   * The Realistic Vision model to use.
   */
  model_name?: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaPlaygroundV25Output = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImagePlaygroundv25Input
 */
export type SchemaPlaygroundV25Input = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Embeddings
   *
   * The list of embeddings to use.
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Guidance Rescale
   *
   * The rescale factor for the CFG.
   */
  guidance_rescale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * Output
 */
export type SchemaLightningModelsOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * LightningModelsTextToImageInput
 */
export type SchemaLightningModelsInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Embeddings
   *
   * The list of embeddings to use.
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Loras
   *
   * The list of LoRA weights to use.
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Scheduler
   *
   * Scheduler / sampler to use for the image denoising process.
   */
  scheduler?:
    | 'DPM++ 2M'
    | 'DPM++ 2M Karras'
    | 'DPM++ 2M SDE'
    | 'DPM++ 2M SDE Karras'
    | 'DPM++ SDE'
    | 'DPM++ SDE Karras'
    | 'KDPM 2A'
    | 'Euler'
    | 'Euler (trailing timesteps)'
    | 'Euler A'
    | 'LCM'
    | 'EDMDPMSolverMultistepScheduler'
    | 'TCDScheduler'
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   * The negative prompt to use. Use it to address details that you don't want in the image.
   */
  negative_prompt?: string
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Model Name
   *
   * The Lightning model to use.
   */
  model_name?: string
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * T2IOutput
 */
export type SchemaLumaPhotonOutput = {
  /**
   * Images
   *
   * The generated image
   */
  images: Array<SchemaFile>
}

/**
 * TextToImageRequest
 */
export type SchemaLumaPhotonInput = {
  /**
   * Prompt
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated video
   */
  aspect_ratio?: '16:9' | '9:16' | '1:1' | '4:3' | '3:4' | '21:9' | '9:21'
}

/**
 * Output
 */
export type SchemaStableCascadeSoteDiffusionOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * SoteDiffusionInput
 */
export type SchemaStableCascadeSoteDiffusionInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Decoder Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  second_stage_guidance_scale?: number
  /**
   * Sync Mode
   *
   *
   * If set to true, the image will be returned as base64 encoded string.
   *
   */
  sync_mode?: boolean
  /**
   * First Stage Steps
   *
   * Number of steps to run the first stage for.
   */
  first_stage_steps?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Cascade
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to false, the safety checker will be disabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Second Stage Steps
   *
   * Number of steps to run the second stage for.
   */
  second_stage_steps?: number
}

/**
 * Output
 */
export type SchemaFastSdxlOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * TextToImageInput
 */
export type SchemaFastSdxlInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Embeddings
   *
   * The list of embeddings to use.
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Loras
   *
   * The list of LoRA weights to use.
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaStableCascadeOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * StableCascadeInput
 */
export type SchemaStableCascadeInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Decoder Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  second_stage_guidance_scale?: number
  /**
   * Sync Mode
   *
   *
   * If set to true, the image will be returned as base64 encoded string.
   *
   */
  sync_mode?: boolean
  /**
   * First Stage Steps
   *
   * Number of steps to run the first stage for.
   */
  first_stage_steps?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Cascade
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to false, the safety checker will be disabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Second Stage Steps
   *
   * Number of steps to run the second stage for.
   */
  second_stage_steps?: number
}

/**
 * Output
 */
export type SchemaKolorsOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * KolorsInput
 */
export type SchemaKolorsInput = {
  /**
   * Prompt
   *
   *
   * The prompt to use for generating the image. Be as descriptive as possible
   * for best results.
   *
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and
   * uploaded before returning the response. This will increase the latency of
   * the function but it allows you to get the image directly in the response
   * without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Scheduler
   *
   * The scheduler to use for the model.
   */
  scheduler?:
    | 'EulerDiscreteScheduler'
    | 'EulerAncestralDiscreteScheduler'
    | 'DPMSolverMultistepScheduler'
    | 'DPMSolverMultistepScheduler_SDE_karras'
    | 'UniPCMultistepScheduler'
    | 'DEISMultistepScheduler'
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show
   * you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * Seed
   */
  seed?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small
   * details (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * Enable safety checker.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaSdxlControlnetUnionOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageControlNetUnionInput
 */
export type SchemaSdxlControlnetUnionInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Depth Preprocess
   *
   * Whether to preprocess the depth image.
   */
  depth_preprocess?: boolean
  /**
   * Image Size
   *
   * The size of the generated image. Leave it none to automatically infer from the control image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | null
  /**
   * Normal Image Url
   *
   * The URL of the control image.
   */
  normal_image_url?: string
  /**
   * Embeddings
   *
   * The list of embeddings to use.
   */
  embeddings?: Array<SchemaEmbedding>
  /**
   * Teed Image Url
   *
   * The URL of the control image.
   */
  teed_image_url?: string
  /**
   * Loras
   *
   * The list of LoRA weights to use.
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Canny Image Url
   *
   * The URL of the control image.
   */
  canny_image_url?: string
  /**
   * Segmentation Preprocess
   *
   * Whether to preprocess the segmentation image.
   */
  segmentation_preprocess?: boolean
  /**
   * Format
   *
   * The format of the generated image.
   */
  format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Request Id
   *
   *
   * An id bound to a request, can be used with response to identify the request
   * itself.
   *
   */
  request_id?: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Segmentation Image Url
   *
   * The URL of the control image.
   */
  segmentation_image_url?: string
  /**
   * Openpose Image Url
   *
   * The URL of the control image.
   */
  openpose_image_url?: string
  /**
   * Canny Preprocess
   *
   * Whether to preprocess the canny image.
   */
  canny_preprocess?: boolean
  /**
   * Expand Prompt
   *
   * If set to true, the prompt will be expanded with additional prompts.
   */
  expand_prompt?: boolean
  /**
   * Depth Image Url
   *
   * The URL of the control image.
   */
  depth_image_url?: string
  /**
   * Normal Preprocess
   *
   * Whether to preprocess the normal image.
   */
  normal_preprocess?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Teed Preprocess
   *
   * Whether to preprocess the teed image.
   */
  teed_preprocess?: boolean
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Controlnet Conditioning Scale
   *
   * The scale of the controlnet conditioning.
   */
  controlnet_conditioning_scale?: number
  /**
   * Safety Checker Version
   *
   * The version of the safety checker to use. v1 is the default CompVis safety checker. v2 uses a custom ViT model.
   */
  safety_checker_version?: 'v1' | 'v2'
  /**
   * Openpose Preprocess
   *
   * Whether to preprocess the openpose image.
   */
  openpose_preprocess?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * PixArtSigmaOutput
 */
export type SchemaPixartSigmaOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   *
   * The timings of the different steps of the generation process.
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * PixArtSigmaInput
 */
export type SchemaPixartSigmaInput = {
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Style
   *
   * The style to apply to the image.
   */
  style?:
    | '(No style)'
    | 'Cinematic'
    | 'Photographic'
    | 'Anime'
    | 'Manga'
    | 'Digital Art'
    | 'Pixel art'
    | 'Fantasy art'
    | 'Neonpunk'
    | '3D Model'
  /**
   * Scheduler
   *
   * The scheduler to use for the model.
   */
  scheduler?: 'DPM-SOLVER' | 'SA-SOLVER'
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaFluxSubjectOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * FluxSubjectInput
 */
export type SchemaFluxSubjectInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image Url
   *
   * URL of image of the subject
   */
  image_url: string
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaSanaOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaSanaInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Style Name
   *
   * The style to generate the image in.
   */
  style_name?:
    | '(No style)'
    | 'Cinematic'
    | 'Photographic'
    | 'Anime'
    | 'Manga'
    | 'Digital Art'
    | 'Pixel art'
    | 'Fantasy art'
    | 'Neonpunk'
    | '3D Model'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * FooocusOutput
 */
export type SchemaFooocusUpscaleOrVaryOutput = {
  /**
   * Images
   *
   * The generated image file info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   *
   * The time taken for the generation process.
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
}

/**
 * FooocusUpscaleOrVaryInput
 */
export type SchemaFooocusUpscaleOrVaryInput = {
  /**
   * Styles
   *
   *
   * The style to use.
   *
   */
  styles?: Array<
    | 'Fooocus V2'
    | 'Fooocus Enhance'
    | 'Fooocus Sharp'
    | 'Fooocus Semi Realistic'
    | 'Fooocus Masterpiece'
    | 'Fooocus Photograph'
    | 'Fooocus Negative'
    | 'Fooocus Cinematic'
    | 'SAI 3D Model'
    | 'SAI Analog Film'
    | 'SAI Anime'
    | 'SAI Cinematic'
    | 'SAI Comic Book'
    | 'SAI Craft Clay'
    | 'SAI Digital Art'
    | 'SAI Enhance'
    | 'SAI Fantasy Art'
    | 'SAI Isometric'
    | 'SAI Line Art'
    | 'SAI Lowpoly'
    | 'SAI Neonpunk'
    | 'SAI Origami'
    | 'SAI Photographic'
    | 'SAI Pixel Art'
    | 'SAI Texture'
    | 'MRE Cinematic Dynamic'
    | 'MRE Spontaneous Picture'
    | 'MRE Artistic Vision'
    | 'MRE Dark Dream'
    | 'MRE Gloomy Art'
    | 'MRE Bad Dream'
    | 'MRE Underground'
    | 'MRE Surreal Painting'
    | 'MRE Dynamic Illustration'
    | 'MRE Undead Art'
    | 'MRE Elemental Art'
    | 'MRE Space Art'
    | 'MRE Ancient Illustration'
    | 'MRE Brave Art'
    | 'MRE Heroic Fantasy'
    | 'MRE Dark Cyberpunk'
    | 'MRE Lyrical Geometry'
    | 'MRE Sumi E Symbolic'
    | 'MRE Sumi E Detailed'
    | 'MRE Manga'
    | 'MRE Anime'
    | 'MRE Comic'
    | 'Ads Advertising'
    | 'Ads Automotive'
    | 'Ads Corporate'
    | 'Ads Fashion Editorial'
    | 'Ads Food Photography'
    | 'Ads Gourmet Food Photography'
    | 'Ads Luxury'
    | 'Ads Real Estate'
    | 'Ads Retail'
    | 'Artstyle Abstract'
    | 'Artstyle Abstract Expressionism'
    | 'Artstyle Art Deco'
    | 'Artstyle Art Nouveau'
    | 'Artstyle Constructivist'
    | 'Artstyle Cubist'
    | 'Artstyle Expressionist'
    | 'Artstyle Graffiti'
    | 'Artstyle Hyperrealism'
    | 'Artstyle Impressionist'
    | 'Artstyle Pointillism'
    | 'Artstyle Pop Art'
    | 'Artstyle Psychedelic'
    | 'Artstyle Renaissance'
    | 'Artstyle Steampunk'
    | 'Artstyle Surrealist'
    | 'Artstyle Typography'
    | 'Artstyle Watercolor'
    | 'Futuristic Biomechanical'
    | 'Futuristic Biomechanical Cyberpunk'
    | 'Futuristic Cybernetic'
    | 'Futuristic Cybernetic Robot'
    | 'Futuristic Cyberpunk Cityscape'
    | 'Futuristic Futuristic'
    | 'Futuristic Retro Cyberpunk'
    | 'Futuristic Retro Futurism'
    | 'Futuristic Sci Fi'
    | 'Futuristic Vaporwave'
    | 'Game Bubble Bobble'
    | 'Game Cyberpunk Game'
    | 'Game Fighting Game'
    | 'Game Gta'
    | 'Game Mario'
    | 'Game Minecraft'
    | 'Game Pokemon'
    | 'Game Retro Arcade'
    | 'Game Retro Game'
    | 'Game Rpg Fantasy Game'
    | 'Game Strategy Game'
    | 'Game Streetfighter'
    | 'Game Zelda'
    | 'Misc Architectural'
    | 'Misc Disco'
    | 'Misc Dreamscape'
    | 'Misc Dystopian'
    | 'Misc Fairy Tale'
    | 'Misc Gothic'
    | 'Misc Grunge'
    | 'Misc Horror'
    | 'Misc Kawaii'
    | 'Misc Lovecraftian'
    | 'Misc Macabre'
    | 'Misc Manga'
    | 'Misc Metropolis'
    | 'Misc Minimalist'
    | 'Misc Monochrome'
    | 'Misc Nautical'
    | 'Misc Space'
    | 'Misc Stained Glass'
    | 'Misc Techwear Fashion'
    | 'Misc Tribal'
    | 'Misc Zentangle'
    | 'Papercraft Collage'
    | 'Papercraft Flat Papercut'
    | 'Papercraft Kirigami'
    | 'Papercraft Paper Mache'
    | 'Papercraft Paper Quilling'
    | 'Papercraft Papercut Collage'
    | 'Papercraft Papercut Shadow Box'
    | 'Papercraft Stacked Papercut'
    | 'Papercraft Thick Layered Papercut'
    | 'Photo Alien'
    | 'Photo Film Noir'
    | 'Photo Glamour'
    | 'Photo Hdr'
    | 'Photo Iphone Photographic'
    | 'Photo Long Exposure'
    | 'Photo Neon Noir'
    | 'Photo Silhouette'
    | 'Photo Tilt Shift'
    | 'Cinematic Diva'
    | 'Abstract Expressionism'
    | 'Academia'
    | 'Action Figure'
    | 'Adorable 3D Character'
    | 'Adorable Kawaii'
    | 'Art Deco'
    | 'Art Nouveau'
    | 'Astral Aura'
    | 'Avant Garde'
    | 'Baroque'
    | 'Bauhaus Style Poster'
    | 'Blueprint Schematic Drawing'
    | 'Caricature'
    | 'Cel Shaded Art'
    | 'Character Design Sheet'
    | 'Classicism Art'
    | 'Color Field Painting'
    | 'Colored Pencil Art'
    | 'Conceptual Art'
    | 'Constructivism'
    | 'Cubism'
    | 'Dadaism'
    | 'Dark Fantasy'
    | 'Dark Moody Atmosphere'
    | 'Dmt Art Style'
    | 'Doodle Art'
    | 'Double Exposure'
    | 'Dripping Paint Splatter Art'
    | 'Expressionism'
    | 'Faded Polaroid Photo'
    | 'Fauvism'
    | 'Flat 2d Art'
    | 'Fortnite Art Style'
    | 'Futurism'
    | 'Glitchcore'
    | 'Glo Fi'
    | 'Googie Art Style'
    | 'Graffiti Art'
    | 'Harlem Renaissance Art'
    | 'High Fashion'
    | 'Idyllic'
    | 'Impressionism'
    | 'Infographic Drawing'
    | 'Ink Dripping Drawing'
    | 'Japanese Ink Drawing'
    | 'Knolling Photography'
    | 'Light Cheery Atmosphere'
    | 'Logo Design'
    | 'Luxurious Elegance'
    | 'Macro Photography'
    | 'Mandola Art'
    | 'Marker Drawing'
    | 'Medievalism'
    | 'Minimalism'
    | 'Neo Baroque'
    | 'Neo Byzantine'
    | 'Neo Futurism'
    | 'Neo Impressionism'
    | 'Neo Rococo'
    | 'Neoclassicism'
    | 'Op Art'
    | 'Ornate And Intricate'
    | 'Pencil Sketch Drawing'
    | 'Pop Art 2'
    | 'Rococo'
    | 'Silhouette Art'
    | 'Simple Vector Art'
    | 'Sketchup'
    | 'Steampunk 2'
    | 'Surrealism'
    | 'Suprematism'
    | 'Terragen'
    | 'Tranquil Relaxing Atmosphere'
    | 'Sticker Designs'
    | 'Vibrant Rim Light'
    | 'Volumetric Lighting'
    | 'Watercolor 2'
    | 'Whimsical And Playful'
    | 'Mk Chromolithography'
    | 'Mk Cross Processing Print'
    | 'Mk Dufaycolor Photograph'
    | 'Mk Herbarium'
    | 'Mk Punk Collage'
    | 'Mk Mosaic'
    | 'Mk Van Gogh'
    | 'Mk Coloring Book'
    | 'Mk Singer Sargent'
    | 'Mk Pollock'
    | 'Mk Basquiat'
    | 'Mk Andy Warhol'
    | 'Mk Halftone Print'
    | 'Mk Gond Painting'
    | 'Mk Albumen Print'
    | 'Mk Aquatint Print'
    | 'Mk Anthotype Print'
    | 'Mk Inuit Carving'
    | 'Mk Bromoil Print'
    | 'Mk Calotype Print'
    | 'Mk Color Sketchnote'
    | 'Mk Cibulak Porcelain'
    | 'Mk Alcohol Ink Art'
    | 'Mk One Line Art'
    | 'Mk Blacklight Paint'
    | 'Mk Carnival Glass'
    | 'Mk Cyanotype Print'
    | 'Mk Cross Stitching'
    | 'Mk Encaustic Paint'
    | 'Mk Embroidery'
    | 'Mk Gyotaku'
    | 'Mk Luminogram'
    | 'Mk Lite Brite Art'
    | 'Mk Mokume Gane'
    | 'Pebble Art'
    | 'Mk Palekh'
    | 'Mk Suminagashi'
    | 'Mk Scrimshaw'
    | 'Mk Shibori'
    | 'Mk Vitreous Enamel'
    | 'Mk Ukiyo E'
    | 'Mk Vintage Airline Poster'
    | 'Mk Vintage Travel Poster'
    | 'Mk Bauhaus Style'
    | 'Mk Afrofuturism'
    | 'Mk Atompunk'
    | 'Mk Constructivism'
    | 'Mk Chicano Art'
    | 'Mk De Stijl'
    | 'Mk Dayak Art'
    | 'Mk Fayum Portrait'
    | 'Mk Illuminated Manuscript'
    | 'Mk Kalighat Painting'
    | 'Mk Madhubani Painting'
    | 'Mk Pictorialism'
    | 'Mk Pichwai Painting'
    | 'Mk Patachitra Painting'
    | 'Mk Samoan Art Inspired'
    | 'Mk Tlingit Art'
    | 'Mk Adnate Style'
    | 'Mk Ron English Style'
    | 'Mk Shepard Fairey Style'
  >
  /**
   * UOV Image URL
   *
   * The image to upscale or vary.
   */
  uov_image_url: string
  /**
   * Performance
   *
   *
   * You can choose Speed or Quality
   *
   */
  performance?: 'Speed' | 'Quality' | 'Extreme Speed' | 'Lightning'
  /**
   * Mixing Image Prompt and Vary/Upscale
   *
   * Mixing Image Prompt and Vary/Upscale
   */
  mixing_image_prompt_and_vary_upscale?: boolean
  image_prompt_3?: SchemaImagePrompt
  /**
   * Prompt
   *
   * The prompt to use for generating the image. Be as descriptive as possible for best results.
   */
  prompt?: string
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use up to 5 LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  image_prompt_4?: SchemaImagePrompt
  image_prompt_1?: SchemaImagePrompt
  /**
   * Enable Safety Checker
   *
   * If set to false, the safety checker will be disabled.
   */
  enable_safety_checker?: boolean
  /**
   * Sharpness
   *
   *
   * The sharpness of the generated image. Use it to control how sharp the generated
   * image should be. Higher value means image and texture are sharper.
   *
   */
  sharpness?: number
  /**
   * Guidance Scale
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Aspect Ratio
   *
   *
   * The size of the generated image. You can choose between some presets or
   * custom height and width that **must be multiples of 8**.
   *
   */
  aspect_ratio?: string
  /**
   * Num Images
   *
   *
   * Number of images to generate in one request
   *
   */
  num_images?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Refiner Model
   *
   * Refiner (SDXL or SD 1.5)
   */
  refiner_model?: 'None' | 'realisticVisionV60B1_v51VAE.safetensors'
  image_prompt_2?: SchemaImagePrompt
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * UOV Method
   *
   * The method to use for upscaling or varying.
   */
  uov_method?:
    | 'Disabled'
    | 'Vary (Subtle)'
    | 'Vary (Strong)'
    | 'Upscale (1.5x)'
    | 'Upscale (2x)'
    | 'Upscale (Fast 2x)'
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number | null
  /**
   * Refiner Switch At
   *
   *
   * Use 0.4 for SD1.5 realistic models; 0.667 for SD1.5 anime models
   * 0.8 for XL-refiners; or any value for switching two SDXL models.
   *
   */
  refiner_switch?: number
}

/**
 * SD3Output
 */
export type SchemaStableDiffusionV3MediumOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Number of Images
   *
   * The number of images generated.
   */
  num_images: number
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaStableDiffusionV3MediumInput = {
  /**
   * Enhance Prompt
   *
   * If set to true, prompt will be upsampled with more details.
   */
  prompt_expansion?: boolean
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of Stable Diffusion
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * The negative prompt to generate an image from.
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaFluxLoraInpaintingOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * InpaintInput
 */
export type SchemaFluxLoraInpaintingInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate. This is always set to 1 for streaming output.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image Url
   *
   * URL of image to use for inpainting. or img2img
   */
  image_url: string
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Strength
   *
   * The strength to use for inpainting/image-to-image. Only used if the image_url is provided. 1.0 is completely remakes the image while 0.0 preserves the original.
   */
  strength?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Mask Url
   *
   *
   * The mask to area to Inpaint in.
   *
   */
  mask_url: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaStableDiffusionV35MediumOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaStableDiffusionV35MediumInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaFluxSchnellOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * SchnellTextToImageInput
 */
export type SchemaFluxSchnellInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * Output
 */
export type SchemaOmnigenV1Output = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaOmnigenV1Input = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Image Guidance scale
   *
   *
   * The Image Guidance scale is a measure of how close you want
   * the model to stick to your input image when looking for a related image to show you.
   *
   */
  img_guidance_scale?: number
  /**
   * Input Image Urls
   *
   * URL of images to use while generating the image, Use <img><|image_1|></img> for the first image and so on.
   */
  input_image_urls?: Array<string>
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaAuraFlowOutput = {
  /**
   * Prompt
   *
   * The expanded prompt
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used to generate the images
   */
  seed: number
}

/**
 * Input
 */
export type SchemaAuraFlowInput = {
  /**
   * Prompt
   *
   * The prompt to generate images from
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate
   */
  num_images?: number
  /**
   * Expand Prompt
   *
   * Whether to perform prompt expansion (recommended)
   */
  expand_prompt?: boolean
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * Classifier free guidance scale
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to take
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The seed to use for generating images
   */
  seed?: number
}

/**
 * T2IOutput
 */
export type SchemaLumaPhotonFlashOutput = {
  /**
   * Images
   *
   * The generated image
   */
  images: Array<SchemaFile>
}

/**
 * TextToImageRequest
 */
export type SchemaLumaPhotonFlashInput = {
  /**
   * Prompt
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated video
   */
  aspect_ratio?: '16:9' | '9:16' | '1:1' | '4:3' | '3:4' | '21:9' | '9:21'
}

/**
 * Output
 */
export type SchemaIdeogramV2TurboOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for the random number generator
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaIdeogramV2TurboInput = {
  /**
   * Prompt
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image
   */
  aspect_ratio?:
    | '10:16'
    | '16:10'
    | '9:16'
    | '16:9'
    | '4:3'
    | '3:4'
    | '1:1'
    | '1:3'
    | '3:1'
    | '3:2'
    | '2:3'
  /**
   * Style
   *
   * The style of the generated image
   */
  style?: 'auto' | 'general' | 'realistic' | 'design' | 'render_3D' | 'anime'
  /**
   * Expand Prompt
   *
   * Whether to expand the prompt with MagicPrompt functionality.
   */
  expand_prompt?: boolean
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Seed
   *
   * Seed for the random number generator
   */
  seed?: number | unknown
  /**
   * Negative Prompt
   *
   * A negative prompt to avoid in the generated image
   */
  negative_prompt?: string
}

/**
 * Recraft20BTextToImageOutput
 */
export type SchemaRecraft20bOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
}

/**
 * Recraft20BTextToImageInput
 */
export type SchemaRecraft20bInput = {
  /**
   * Prompt
   */
  prompt: string
  /**
   * Image Size
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Colors
   *
   * An array of preferable colors
   */
  colors?: Array<SchemaRgbColor>
  /**
   * Style
   *
   * The style of the generated images. Vector images cost 2X as much.
   */
  style?:
    | 'any'
    | 'realistic_image'
    | 'digital_illustration'
    | 'vector_illustration'
    | 'realistic_image/b_and_w'
    | 'realistic_image/enterprise'
    | 'realistic_image/hard_flash'
    | 'realistic_image/hdr'
    | 'realistic_image/motion_blur'
    | 'realistic_image/natural_light'
    | 'realistic_image/studio_portrait'
    | 'digital_illustration/2d_art_poster'
    | 'digital_illustration/2d_art_poster_2'
    | 'digital_illustration/3d'
    | 'digital_illustration/80s'
    | 'digital_illustration/engraving_color'
    | 'digital_illustration/glow'
    | 'digital_illustration/grain'
    | 'digital_illustration/hand_drawn'
    | 'digital_illustration/hand_drawn_outline'
    | 'digital_illustration/handmade_3d'
    | 'digital_illustration/infantile_sketch'
    | 'digital_illustration/kawaii'
    | 'digital_illustration/pixel_art'
    | 'digital_illustration/psychedelic'
    | 'digital_illustration/seamless'
    | 'digital_illustration/voxel'
    | 'digital_illustration/watercolor'
    | 'vector_illustration/cartoon'
    | 'vector_illustration/doodle_line_art'
    | 'vector_illustration/engraving'
    | 'vector_illustration/flat_2'
    | 'vector_illustration/kawaii'
    | 'vector_illustration/line_art'
    | 'vector_illustration/line_circuit'
    | 'vector_illustration/linocut'
    | 'vector_illustration/seamless'
  /**
   * Style Id
   *
   * The ID of the custom style reference (optional)
   */
  style_id?: string
}

/**
 * RGBColor
 */
export type SchemaRgbColor = {
  /**
   * R
   *
   * Red color value
   */
  r?: number
  /**
   * B
   *
   * Blue color value
   */
  b?: number
  /**
   * G
   *
   * Green color value
   */
  g?: number
}

/**
 * Output
 */
export type SchemaBriaTextToImageHdOutput = {
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * Seed value used for generation.
   */
  seed: number
}

/**
 * TextToImageRequest
 */
export type SchemaBriaTextToImageHdInput = {
  /**
   * Prompt
   *
   * The prompt you would like to use to generate images.
   */
  prompt: string
  /**
   * Num Images
   *
   * How many images you would like to generate. When using any Guidance Method, Value is set to 1.
   */
  num_images?: number
  /**
   * Prompt Enhancement
   *
   * When set to true, enhances the provided prompt by generating additional, more descriptive variations, resulting in more diverse and creative output images.
   */
  prompt_enhancement?: boolean
  /**
   * Guidance
   *
   * Guidance images to use for the generation. Up to 4 guidance methods can be combined during a single inference.
   */
  guidance?: Array<SchemaGuidanceInput>
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the image. When a guidance method is being used, the aspect ratio is defined by the guidance image and this parameter is ignored.
   */
  aspect_ratio?:
    | '1:1'
    | '2:3'
    | '3:2'
    | '3:4'
    | '4:3'
    | '4:5'
    | '5:4'
    | '9:16'
    | '16:9'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Medium
   *
   * Which medium should be included in your generated images. This parameter is optional.
   */
  medium?: 'photography' | 'art'
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * The negative prompt you would like to use to generate images.
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of iterations the model goes through to refine the generated image. This parameter is optional.
   */
  num_inference_steps?: number
}

/**
 * GuidanceInput
 */
export type SchemaGuidanceInput = {
  /**
   * Scale
   *
   * Impact of the guidance.
   */
  scale?: number
  /**
   * Method
   *
   * Which guidance type you would like to include in the generation. Up to 4 guidance methods can be combined during a single inference. This parameter is optional.
   */
  method?:
    | 'controlnet_canny'
    | 'controlnet_depth'
    | 'controlnet_recoloring'
    | 'controlnet_color_grid'
  /**
   * Image Url
   *
   * The image that should be used as guidance, in base64 format, with the method defined in guidance_method_1. Accepted formats are jpeg, jpg, png, webp. Maximum file size 12MB. If more then one guidance method is used, all guidance images must be of the same aspect ratio, and this will be the aspect ratio of the generated results. If guidance_method_1 is selected, an image must be provided.
   */
  image_url: string
}

/**
 * Output
 */
export type SchemaBriaTextToImageFastOutput = {
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * Seed value used for generation.
   */
  seed: number
}

/**
 * FastTextToImageRequest
 */
export type SchemaBriaTextToImageFastInput = {
  /**
   * Prompt
   *
   * The prompt you would like to use to generate images.
   */
  prompt: string
  /**
   * Num Images
   *
   * How many images you would like to generate. When using any Guidance Method, Value is set to 1.
   */
  num_images?: number
  /**
   * Prompt Enhancement
   *
   * When set to true, enhances the provided prompt by generating additional, more descriptive variations, resulting in more diverse and creative output images.
   */
  prompt_enhancement?: boolean
  /**
   * Guidance
   *
   * Guidance images to use for the generation. Up to 4 guidance methods can be combined during a single inference.
   */
  guidance?: Array<SchemaGuidanceInput>
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the image. When a guidance method is being used, the aspect ratio is defined by the guidance image and this parameter is ignored.
   */
  aspect_ratio?:
    | '1:1'
    | '2:3'
    | '3:2'
    | '3:4'
    | '4:3'
    | '4:5'
    | '5:4'
    | '9:16'
    | '16:9'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Medium
   *
   * Which medium should be included in your generated images. This parameter is optional.
   */
  medium?: 'photography' | 'art'
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * The negative prompt you would like to use to generate images.
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of iterations the model goes through to refine the generated image. This parameter is optional.
   */
  num_inference_steps?: number
}

/**
 * Output
 */
export type SchemaBriaTextToImageBaseOutput = {
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * Seed value used for generation.
   */
  seed: number
}

/**
 * TextToImageRequest
 */
export type SchemaBriaTextToImageBaseInput = {
  /**
   * Prompt
   *
   * The prompt you would like to use to generate images.
   */
  prompt: string
  /**
   * Num Images
   *
   * How many images you would like to generate. When using any Guidance Method, Value is set to 1.
   */
  num_images?: number
  /**
   * Prompt Enhancement
   *
   * When set to true, enhances the provided prompt by generating additional, more descriptive variations, resulting in more diverse and creative output images.
   */
  prompt_enhancement?: boolean
  /**
   * Guidance
   *
   * Guidance images to use for the generation. Up to 4 guidance methods can be combined during a single inference.
   */
  guidance?: Array<SchemaGuidanceInput>
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the image. When a guidance method is being used, the aspect ratio is defined by the guidance image and this parameter is ignored.
   */
  aspect_ratio?:
    | '1:1'
    | '2:3'
    | '3:2'
    | '3:4'
    | '4:3'
    | '4:5'
    | '5:4'
    | '9:16'
    | '16:9'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Medium
   *
   * Which medium should be included in your generated images. This parameter is optional.
   */
  medium?: 'photography' | 'art'
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * The negative prompt you would like to use to generate images.
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of iterations the model goes through to refine the generated image. This parameter is optional.
   */
  num_inference_steps?: number
}

/**
 * SwittiOutput
 */
export type SchemaSwitti512Output = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaSwitti512Input = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Sampling Top-k
   *
   * The number of top-k tokens to sample from.
   */
  sampling_top_k?: number
  /**
   * Disable CFG starting scale
   *
   * Disable CFG starting scale
   */
  turn_off_cfg_start_si?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Smoothing starting scale
   *
   * Smoothing starting scale
   */
  smooth_start_si?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Temperature after disabling CFG
   *
   * Temperature after disabling CFG
   */
  last_scale_temp?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * More Diverse
   *
   * More diverse sampling
   */
  more_diverse?: boolean
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * More Smooth
   *
   * Smoothing with Gumbel softmax sampling
   */
  more_smooth?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Sampling Top-p
   *
   * The top-p probability to sample from.
   */
  sampling_top_p?: number
}

/**
 * SwittiOutput
 */
export type SchemaSwittiOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaSwittiInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Sampling Top-k
   *
   * The number of top-k tokens to sample from.
   */
  sampling_top_k?: number
  /**
   * Disable CFG starting scale
   *
   * Disable CFG starting scale
   */
  turn_off_cfg_start_si?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Smoothing starting scale
   *
   * Smoothing starting scale
   */
  smooth_start_si?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Temperature after disabling CFG
   *
   * Temperature after disabling CFG
   */
  last_scale_temp?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * More Diverse
   *
   * More diverse sampling
   */
  more_diverse?: boolean
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * More Smooth
   *
   * Smoothing with Gumbel softmax sampling
   */
  more_smooth?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Sampling Top-p
   *
   * The top-p probability to sample from.
   */
  sampling_top_p?: number
}

/**
 * Output
 */
export type SchemaFluxProV11Output = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaRegistryImageFastSdxlModelsImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * Image
 */
export type SchemaRegistryImageFastSdxlModelsImage = {
  /**
   * Height
   */
  height: number
  /**
   * Content Type
   */
  content_type?: string
  /**
   * Url
   */
  url: string
  /**
   * Width
   */
  width: number
}

/**
 * FluxProPlusTextToImageInput
 */
export type SchemaFluxProV11Input = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enhance Prompt
   *
   * Whether to enhance the prompt for better results.
   */
  enhance_prompt?: boolean
}

/**
 * Output
 */
export type SchemaFluxProV11UltraFinetunedOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaRegistryImageFastSdxlModelsImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * FluxProUltraTextToImageFinetunedInput
 */
export type SchemaFluxProV11UltraFinetunedInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Fine-tune ID
   *
   * References your specific model
   */
  finetune_id: string
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Image Prompt Strength
   *
   * The strength of the image prompt, between 0 and 1.
   */
  image_prompt_strength?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Enhance Prompt
   *
   * Whether to enhance the prompt for better results.
   */
  enhance_prompt?: boolean
  /**
   * Raw
   *
   * Generate less processed, more natural-looking images.
   */
  raw?: boolean
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
    | string
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The image URL to generate an image from.
   */
  image_url?: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Fine-tune Strength
   *
   *
   * Controls finetune influence.
   * Increase this value if your target concept isn't showing up strongly enough.
   * The optimal setting depends on your finetune and prompt
   *
   */
  finetune_strength: number
}

/**
 * Output
 */
export type SchemaJanusOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * JanusInput
 */
export type SchemaJanusInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of images to generate in parallel.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Cfg Weight
   *
   * Classifier Free Guidance scale - how closely to follow the prompt.
   */
  cfg_weight?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Temperature
   *
   * Controls randomness in the generation. Higher values make output more random.
   */
  temperature?: number
  /**
   * Seed
   *
   * Random seed for reproducible generation.
   */
  seed?: number
}

/**
 * ImageOutput
 */
export type SchemaLuminaImageV2Output = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaLuminaImageV2Input = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Cfg Trunc Ratio
   *
   * The ratio of the timestep interval to apply normalization-based guidance scale.
   */
  cfg_trunc_ratio?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * System Prompt
   *
   * The system prompt to use.
   */
  system_prompt?: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Cfg Normalization
   *
   * Whether to apply normalization-based guidance scale.
   */
  cfg_normalization?: boolean
}

/**
 * Output
 */
export type SchemaImagen3FastOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for generation
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaImagen3FastInput = {
  /**
   * Prompt
   *
   * The text prompt describing what you want to see
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image
   */
  aspect_ratio?: '1:1' | '16:9' | '9:16' | '3:4' | '4:3'
  /**
   * Num Images
   *
   * Number of images to generate (1-4)
   */
  num_images?: number
  /**
   * Seed
   *
   * Random seed for reproducible generation
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * A description of what to discourage in the generated images
   */
  negative_prompt?: string
}

/**
 * Output
 */
export type SchemaImagen3Output = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for generation
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaImagen3Input = {
  /**
   * Prompt
   *
   * The text prompt describing what you want to see
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image
   */
  aspect_ratio?: '1:1' | '16:9' | '9:16' | '3:4' | '4:3'
  /**
   * Num Images
   *
   * Number of images to generate (1-4)
   */
  num_images?: number
  /**
   * Seed
   *
   * Random seed for reproducible generation
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * A description of what to discourage in the generated images
   */
  negative_prompt?: string
}

/**
 * Output
 */
export type SchemaFluxControlLoraDepthOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * DepthLoraInput
 */
export type SchemaFluxControlLoraDepthInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Control Lora Strength
   *
   * The strength of the control lora.
   */
  control_lora_strength?: number
  /**
   * Preprocess Depth
   *
   *
   * If set to true, the input image will be preprocessed to extract depth information.
   * This is useful for generating depth maps from images.
   *
   */
  preprocess_depth?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Control Lora Image Url
   *
   *
   * The image to use for control lora. This is used to control the style of the generated image.
   *
   */
  control_lora_image_url: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaFluxControlLoraCannyOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaFluxControlLoraCannyInput = {
  /**
   * Control Lora Strength
   *
   * The strength of the control lora.
   */
  control_lora_strength?: number
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Control Lora Image Url
   *
   *
   * The image to use for control lora. This is used to control the style of the generated image.
   *
   */
  control_lora_image_url?: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaIdeogramV2aOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for the random number generator
   */
  seed: number
}

/**
 * BaseTextToImageInput
 */
export type SchemaIdeogramV2aInput = {
  /**
   * Prompt
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image
   */
  aspect_ratio?:
    | '10:16'
    | '16:10'
    | '9:16'
    | '16:9'
    | '4:3'
    | '3:4'
    | '1:1'
    | '1:3'
    | '3:1'
    | '3:2'
    | '2:3'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Style
   *
   * The style of the generated image
   */
  style?: 'auto' | 'general' | 'realistic' | 'design' | 'render_3D' | 'anime'
  /**
   * Seed
   *
   * Seed for the random number generator
   */
  seed?: number | unknown
  /**
   * Expand Prompt
   *
   * Whether to expand the prompt with MagicPrompt functionality.
   */
  expand_prompt?: boolean
}

/**
 * Output
 */
export type SchemaIdeogramV2aTurboOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for the random number generator
   */
  seed: number
}

/**
 * BaseTextToImageInput
 */
export type SchemaIdeogramV2aTurboInput = {
  /**
   * Prompt
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image
   */
  aspect_ratio?:
    | '10:16'
    | '16:10'
    | '9:16'
    | '16:9'
    | '4:3'
    | '3:4'
    | '1:1'
    | '1:3'
    | '3:1'
    | '3:2'
    | '2:3'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Style
   *
   * The style of the generated image
   */
  style?: 'auto' | 'general' | 'realistic' | 'design' | 'render_3D' | 'anime'
  /**
   * Seed
   *
   * Seed for the random number generator
   */
  seed?: number | unknown
  /**
   * Expand Prompt
   *
   * Whether to expand the prompt with MagicPrompt functionality.
   */
  expand_prompt?: boolean
}

/**
 * ImageOutput
 */
export type SchemaCogview4Output = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaCogview4Input = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaJuggernautFluxBaseOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * DevTextToImageInput
 */
export type SchemaJuggernautFluxBaseInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaRundiffusionPhotoFluxOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * PhotoLoraT2IInput
 */
export type SchemaRundiffusionPhotoFluxInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Photo Lora Scale
   *
   * LoRA Scale of the photo lora model
   */
  photo_lora_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaJuggernautFluxLoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaJuggernautFluxLoraInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaJuggernautFluxProOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * DevTextToImageInput
 */
export type SchemaJuggernautFluxProInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaJuggernautFluxLightningOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * SchnellTextToImageInput
 */
export type SchemaJuggernautFluxLightningInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * Output
 */
export type SchemaSanaSprintOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * SprintInput
 */
export type SchemaSanaSprintInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Style Name
   *
   * The style to generate the image in.
   */
  style_name?:
    | '(No style)'
    | 'Cinematic'
    | 'Photographic'
    | 'Anime'
    | 'Manga'
    | 'Digital Art'
    | 'Pixel art'
    | 'Fantasy art'
    | 'Neonpunk'
    | '3D Model'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaSanaV1548bOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaSanaV1548bInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Style Name
   *
   * The style to generate the image in.
   */
  style_name?:
    | '(No style)'
    | 'Cinematic'
    | 'Photographic'
    | 'Anime'
    | 'Manga'
    | 'Digital Art'
    | 'Pixel art'
    | 'Fantasy art'
    | 'Neonpunk'
    | '3D Model'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaSanaV1516bOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaSanaV1516bInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Style Name
   *
   * The style to generate the image in.
   */
  style_name?:
    | '(No style)'
    | 'Cinematic'
    | 'Photographic'
    | 'Anime'
    | 'Manga'
    | 'Digital Art'
    | 'Pixel art'
    | 'Fantasy art'
    | 'Neonpunk'
    | '3D Model'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * ImageResponse
 */
export type SchemaGptImage1TextToImageOutput = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImageFile>
}

/**
 * ImageFile
 */
export type SchemaImageFile = {
  /**
   * File Size
   *
   * The size of the file in bytes.
   */
  file_size?: number
  /**
   * Height
   *
   * The height of the image
   */
  height?: number
  /**
   * Url
   *
   * The URL where the file can be downloaded from.
   */
  url: string
  /**
   * Width
   *
   * The width of the image
   */
  width?: number
  /**
   * File Name
   *
   * The name of the file. It will be auto-generated if not provided.
   */
  file_name?: string
  /**
   * Content Type
   *
   * The mime type of the file.
   */
  content_type?: string
  /**
   * File Data
   *
   * File data
   */
  file_data?: Blob | File
}

/**
 * TextToImageRequest
 */
export type SchemaGptImage1TextToImageInput = {
  /**
   * Prompt
   *
   * The prompt for image generation
   */
  prompt: string
  /**
   * Number of Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * Aspect ratio for the generated image
   */
  image_size?: 'auto' | '1024x1024' | '1536x1024' | '1024x1536'
  /**
   * Background
   *
   * Background for the generated image
   */
  background?: 'auto' | 'transparent' | 'opaque'
  /**
   * Quality
   *
   * Quality for the generated image
   */
  quality?: 'auto' | 'low' | 'medium' | 'high'
  /**
   * Output Format
   *
   * Output format for the images
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
}

/**
 * Output
 */
export type SchemaFLiteTextureOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInputTexture
 */
export type SchemaFLiteTextureInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative prompt
   *
   * Negative Prompt for generation.
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaFLiteStandardOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInputStandard
 */
export type SchemaFLiteStandardInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative prompt
   *
   * Negative Prompt for generation.
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * ColorPaletteMember
 */
export type SchemaColorPaletteMember = {
  /**
   * Color Weight
   *
   * The weight of the color in the color palette
   */
  color_weight?: number | unknown
  rgb: SchemaRgbColor
}

/**
 * ColorPalette
 */
export type SchemaColorPalette = {
  /**
   * Members
   *
   * A list of color palette members that define the color palette
   */
  members?: Array<SchemaColorPaletteMember> | unknown
  /**
   * Name
   *
   * A color palette preset value
   */
  name?:
    | 'EMBER'
    | 'FRESH'
    | 'JUNGLE'
    | 'MAGIC'
    | 'MELON'
    | 'MOSAIC'
    | 'PASTEL'
    | 'ULTRAMARINE'
    | unknown
}

/**
 * OutputV3
 */
export type SchemaIdeogramV3Output = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for the random number generator
   */
  seed: number
}

/**
 * BaseTextToImageInputV3
 */
export type SchemaIdeogramV3Input = {
  /**
   * Prompt
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The resolution of the generated image
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | unknown
  /**
   * Style
   *
   * The style type to generate with. Cannot be used with style_codes.
   */
  style?: 'AUTO' | 'GENERAL' | 'REALISTIC' | 'DESIGN' | unknown
  /**
   * Style Preset
   *
   * Style preset for generation. The chosen style preset will guide the generation.
   */
  style_preset?:
    | '80S_ILLUSTRATION'
    | '90S_NOSTALGIA'
    | 'ABSTRACT_ORGANIC'
    | 'ANALOG_NOSTALGIA'
    | 'ART_BRUT'
    | 'ART_DECO'
    | 'ART_POSTER'
    | 'AURA'
    | 'AVANT_GARDE'
    | 'BAUHAUS'
    | 'BLUEPRINT'
    | 'BLURRY_MOTION'
    | 'BRIGHT_ART'
    | 'C4D_CARTOON'
    | 'CHILDRENS_BOOK'
    | 'COLLAGE'
    | 'COLORING_BOOK_I'
    | 'COLORING_BOOK_II'
    | 'CUBISM'
    | 'DARK_AURA'
    | 'DOODLE'
    | 'DOUBLE_EXPOSURE'
    | 'DRAMATIC_CINEMA'
    | 'EDITORIAL'
    | 'EMOTIONAL_MINIMAL'
    | 'ETHEREAL_PARTY'
    | 'EXPIRED_FILM'
    | 'FLAT_ART'
    | 'FLAT_VECTOR'
    | 'FOREST_REVERIE'
    | 'GEO_MINIMALIST'
    | 'GLASS_PRISM'
    | 'GOLDEN_HOUR'
    | 'GRAFFITI_I'
    | 'GRAFFITI_II'
    | 'HALFTONE_PRINT'
    | 'HIGH_CONTRAST'
    | 'HIPPIE_ERA'
    | 'ICONIC'
    | 'JAPANDI_FUSION'
    | 'JAZZY'
    | 'LONG_EXPOSURE'
    | 'MAGAZINE_EDITORIAL'
    | 'MINIMAL_ILLUSTRATION'
    | 'MIXED_MEDIA'
    | 'MONOCHROME'
    | 'NIGHTLIFE'
    | 'OIL_PAINTING'
    | 'OLD_CARTOONS'
    | 'PAINT_GESTURE'
    | 'POP_ART'
    | 'RETRO_ETCHING'
    | 'RIVIERA_POP'
    | 'SPOTLIGHT_80S'
    | 'STYLIZED_RED'
    | 'SURREAL_COLLAGE'
    | 'TRAVEL_POSTER'
    | 'VINTAGE_GEO'
    | 'VINTAGE_POSTER'
    | 'WATERCOLOR'
    | 'WEIRD'
    | 'WOODBLOCK_PRINT'
    | unknown
  /**
   * Expand Prompt
   *
   * Determine if MagicPrompt should be used in generating the request or not.
   */
  expand_prompt?: boolean
  /**
   * Rendering Speed
   *
   * The rendering speed to use.
   */
  rendering_speed?: 'TURBO' | 'BALANCED' | 'QUALITY'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * A color palette for generation, must EITHER be specified via one of the presets (name) or explicitly via hexadecimal representations of the color with optional weights (members)
   */
  color_palette?: SchemaColorPalette | unknown
  /**
   * Style Codes
   *
   * A list of 8 character hexadecimal codes representing the style of the image. Cannot be used in conjunction with style_reference_images or style
   */
  style_codes?: Array<string> | unknown
  /**
   * Seed
   *
   * Seed for the random number generator
   */
  seed?: number | unknown
  /**
   * Image Urls
   *
   * A set of images to use as style references (maximum total size 10MB across all style references). The images should be in JPEG, PNG or WebP format
   */
  image_urls?: Array<string> | unknown
  /**
   * Negative Prompt
   *
   * Description of what to exclude from an image. Descriptions in the prompt take precedence to descriptions in the negative prompt.
   */
  negative_prompt?: string
}

/**
 * ImageOutput
 */
export type SchemaPonyV7Output = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * Input
 */
export type SchemaPonyV7Input = {
  /**
   * Prompt
   *
   * The prompt to generate images from
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Noise Source
   *
   *
   * The source of the noise to use for generating images.
   * If set to 'gpu', the noise will be generated on the GPU.
   * If set to 'cpu', the noise will be generated on the CPU.
   *
   */
  noise_source?: 'gpu' | 'cpu'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * Classifier free guidance scale
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to take
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * The seed to use for generating images
   */
  seed?: number
}

/**
 * MiniMaxTextToImageOutput
 */
export type SchemaMinimaxImage01Output = {
  /**
   * Images
   *
   * Generated images
   */
  images: Array<SchemaFile>
}

/**
 * MiniMaxTextToImageRequest
 */
export type SchemaMinimaxImage01Input = {
  /**
   * Prompt Optimizer
   *
   * Whether to enable automatic prompt optimization
   */
  prompt_optimizer?: boolean
  /**
   * Aspect Ratio
   *
   * Aspect ratio of the generated image
   */
  aspect_ratio?:
    | '1:1'
    | '16:9'
    | '4:3'
    | '3:2'
    | '2:3'
    | '3:4'
    | '9:16'
    | '21:9'
  /**
   * Num Images
   *
   * Number of images to generate (1-9)
   */
  num_images?: number
  /**
   * Prompt
   *
   * Text prompt for image generation (max 1500 characters)
   */
  prompt: string
}

/**
 * Output
 */
export type SchemaFluxLoraStreamOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaFluxLoraStreamInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate. This is always set to 1 for streaming output.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * DreamOOutput
 */
export type SchemaDreamoOutput = {
  /**
   * Prompt
   *
   * The prompt used to generate the image.
   */
  prompt: string
  /**
   * Images
   *
   * The URLs of the generated images.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * DreamOInput
 */
export type SchemaDreamoInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * First Reference Image URL
   *
   * URL of first reference image to use for generation.
   */
  first_image_url?: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Second Reference Image URL
   *
   * URL of second reference image to use for generation.
   */
  second_image_url?: string
  /**
   * Second Reference Task
   *
   * Task for second reference image (ip/id/style).
   */
  second_reference_task?: 'ip' | 'id' | 'style'
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * First Reference Task
   *
   * Task for first reference image (ip/id/style).
   */
  first_reference_task?: 'ip' | 'id' | 'style'
  /**
   * Negative Prompt
   *
   * The prompt to generate an image from.
   */
  negative_prompt?: string
  /**
   * Ref Resolution
   *
   * Resolution for reference images.
   */
  ref_resolution?: number
  /**
   * Sync Mode
   *
   *
   * If set to true, the function will wait for the image to be generated and uploaded
   * before returning the response. This will increase the latency of the function but
   * it allows you to get the image directly in the response without going through the CDN.
   *
   */
  sync_mode?: boolean
  /**
   * True Cfg
   *
   * The weight of the CFG loss.
   */
  true_cfg?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * Imagen4TextToImageUltraOutput
 */
export type SchemaImagen4PreviewUltraOutput = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImageFile>
  /**
   * Description
   *
   * The description of the generated images.
   */
  description: string
}

/**
 * Imagen4TextToImageUltraInput
 */
export type SchemaImagen4PreviewUltraInput = {
  /**
   * Prompt
   *
   * The text prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?: '1:1' | '16:9' | '9:16' | '4:3' | '3:4'
  /**
   * Resolution
   *
   * The resolution of the generated image.
   */
  resolution?: '1K' | '2K'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
}

/**
 * ImageOutput
 */
export type SchemaBagelOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * ImageGenInput
 */
export type SchemaBagelInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * The seed to use for the generation.
   */
  seed?: number
  /**
   * Use Thought
   *
   * Whether to use thought tokens for generation. If set to true, the model will "think" to potentially improve generation quality. Increases generation time and increases the cost by 20%.
   */
  use_thought?: boolean
}

/**
 * Output
 */
export type SchemaFluxProKontextTextToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaRegistryImageFastSdxlModelsImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * FluxProTextToImageInputWithAR
 */
export type SchemaFluxProKontextTextToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enhance Prompt
   *
   * Whether to enhance the prompt for better results.
   */
  enhance_prompt?: boolean
}

/**
 * Output
 */
export type SchemaFluxProKontextMaxTextToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaRegistryImageFastSdxlModelsImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * FluxProTextToImageInputWithAR
 */
export type SchemaFluxProKontextMaxTextToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enhance Prompt
   *
   * Whether to enhance the prompt for better results.
   */
  enhance_prompt?: boolean
}

/**
 * Output
 */
export type SchemaFlux1DevOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseFlux1Input
 */
export type SchemaFlux1DevInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
}

/**
 * Output
 */
export type SchemaFlux1SchnellOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * SchnellFlux1TextToImageInput
 */
export type SchemaFlux1SchnellInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
}

/**
 * SeedDreamOutput
 */
export type SchemaBytedanceSeedreamV3TextToImageOutput = {
  /**
   * Images
   *
   * Generated images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * Seed used for generation
   */
  seed: number
}

/**
 * SeedDreamInput
 */
export type SchemaBytedanceSeedreamV3TextToImageInput = {
  /**
   * Prompt
   *
   * The text prompt used to generate the image
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * Use for finer control over the output image size. Will be used over aspect_ratio, if both are provided. Width and height must be between 512 and 2048.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * Controls how closely the output image aligns with the input prompt. Higher values mean stronger prompt correlation.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed to control the stochasticity of image generation.
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaOmnigenV2Output = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaOmnigenV2Input = {
  /**
   * Prompt
   *
   * The prompt to generate or edit an image. Use specific language like 'Add the bird from image 1 to the desk in image 2' for better results.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Scheduler
   *
   * The scheduler to use for the diffusion process.
   */
  scheduler?: 'euler' | 'dpmsolver'
  /**
   * Cfg Range End
   *
   * CFG range end value.
   */
  cfg_range_end?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   * Negative prompt to guide what should not be in the image.
   */
  negative_prompt?: string
  /**
   * Text Guidance scale
   *
   *
   * The Text Guidance scale controls how closely the model follows the text prompt.
   * Higher values make the model stick more closely to the prompt.
   *
   */
  text_guidance_scale?: number
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Guidance scale
   *
   *
   * The Image Guidance scale controls how closely the model follows the input images.
   * For image editing: 1.3-2.0, for in-context generation: 2.0-3.0
   *
   */
  image_guidance_scale?: number
  /**
   * Input Image Urls
   *
   * URLs of input images to use for image editing or multi-image generation. Support up to 3 images.
   */
  input_image_urls?: Array<string>
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Cfg Range Start
   *
   * CFG range start value.
   */
  cfg_range_start?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * KontextT2IOutput
 */
export type SchemaFluxKontextLoraTextToImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseKontextInput
 */
export type SchemaFluxKontextLoraTextToImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate the image with
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * SkyRaccoonResponse
 */
export type SchemaSkyRaccoonOutput = {
  /**
   * Image
   *
   * The generated image file.
   */
  image: SchemaFile
  /**
   * Seed
   *
   * The seed used for generation.
   */
  seed: number
}

/**
 * SkyRaccoonRequest
 */
export type SchemaSkyRaccoonInput = {
  /**
   * Prompt
   *
   * The text prompt to guide video generation.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Turbo Mode
   *
   * If true, the video will be generated faster with no noticeable degradation in the visual quality.
   */
  turbo_mode?: boolean
  /**
   * Enable Prompt Expansion
   *
   * Whether to enable prompt expansion.
   */
  enable_prompt_expansion?: boolean
  /**
   * Seed
   *
   * Random seed for reproducibility. If None, a random seed is chosen.
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   * Negative prompt for video generation.
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * Number of inference steps for sampling. Higher values give better quality but take longer.
   */
  num_inference_steps?: number
}

/**
 * KreaOutput
 */
export type SchemaFlux1KreaOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseKreaFlux1Input
 */
export type SchemaFlux1KreaInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
}

/**
 * KreaOutput
 */
export type SchemaFluxKreaOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseKreaInput
 */
export type SchemaFluxKreaInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * Output
 */
export type SchemaFluxKreaLoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * TextToImageInput
 */
export type SchemaFluxKreaLoraInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate. This is always set to 1 for streaming output.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaFluxKreaLoraStreamOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * TextToImageInput
 */
export type SchemaFluxKreaLoraStreamInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate. This is always set to 1 for streaming output.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * QwenImageOutput
 */
export type SchemaQwenImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * BaseQwenImageInput
 */
export type SchemaQwenImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate the image with
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Acceleration
   *
   * Acceleration level for image generation. Options: 'none', 'regular', 'high'. Higher acceleration increases speed. 'regular' balances speed and quality. 'high' is recommended for images without text.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use up to 3 LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Use Turbo
   *
   * Enable turbo mode for faster generation with high quality. When enabled, uses optimized settings (10 steps, CFG=1.2).
   */
  use_turbo?: boolean
  /**
   * Negative Prompt
   *
   * The negative prompt for the generation
   */
  negative_prompt?: string
  /**
   * Guidance scale
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
}

/**
 * WanT2IResponse
 */
export type SchemaWanV22A14bTextToImageOutput = {
  /**
   * Image
   *
   * The generated image file.
   */
  image: SchemaFile
  /**
   * Seed
   *
   * The seed used for generation.
   */
  seed: number
}

/**
 * WanT2IRequest
 */
export type SchemaWanV22A14bTextToImageInput = {
  /**
   * Prompt
   *
   * The text prompt to guide image generation.
   */
  prompt: string
  /**
   * Guidance Scale (1st Stage)
   *
   * Classifier-free guidance scale. Higher values give better adherence to the prompt but may decrease quality.
   */
  guidance_scale?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * Acceleration level to use. The more acceleration, the faster the generation, but with lower quality. The recommended value is 'regular'.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Shift
   *
   * Shift value for the image. Must be between 1.0 and 10.0.
   */
  shift?: number
  /**
   * Enable Output Safety Checker
   *
   * If set to true, output video will be checked for safety after generation.
   */
  enable_output_safety_checker?: boolean
  /**
   * Guidance Scale (2nd Stage)
   *
   * Guidance scale for the second stage of the model. This is used to control the adherence to the prompt in the second stage of the model.
   */
  guidance_scale_2?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, input data will be checked for safety before processing.
   */
  enable_safety_checker?: boolean
  /**
   * Number of Inference Steps
   *
   * Number of inference steps for sampling. Higher values give better quality but take longer.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. If None, a random seed is chosen.
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * Negative prompt for video generation.
   */
  negative_prompt?: string
  /**
   * Enable Prompt Expansion
   *
   * Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.
   */
  enable_prompt_expansion?: boolean
}

/**
 * WanSmallT2IResponse
 */
export type SchemaWanV225bTextToImageOutput = {
  /**
   * Image
   *
   * The generated image file.
   */
  image: SchemaFile
  /**
   * Seed
   *
   * The seed used for generation.
   */
  seed: number
}

/**
 * WanSmallT2IRequest
 */
export type SchemaWanV225bTextToImageInput = {
  /**
   * Prompt
   *
   * The text prompt to guide image generation.
   */
  prompt: string
  /**
   * Enable Prompt Expansion
   *
   * Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.
   */
  enable_prompt_expansion?: boolean
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Negative Prompt
   *
   * Negative prompt for video generation.
   */
  negative_prompt?: string
  /**
   * Shift
   *
   * Shift value for the image. Must be between 1.0 and 10.0.
   */
  shift?: number
  /**
   * Enable Output Safety Checker
   *
   * If set to true, output video will be checked for safety after generation.
   */
  enable_output_safety_checker?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, input data will be checked for safety before processing.
   */
  enable_safety_checker?: boolean
  /**
   * Number of Inference Steps
   *
   * Number of inference steps for sampling. Higher values give better quality but take longer.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. If None, a random seed is chosen.
   */
  seed?: number
  /**
   * Image Format
   *
   * The format of the output image.
   */
  image_format?: 'png' | 'jpeg'
  /**
   * Guidance Scale
   *
   * Classifier-free guidance scale. Higher values give better adherence to the prompt but may decrease quality.
   */
  guidance_scale?: number
}

/**
 * LoRAWeight
 */
export type SchemaLoRaWeight = {
  /**
   * Path
   *
   * URL or the path to the LoRA weights.
   */
  path: string
  /**
   * Scale
   *
   *
   * The scale of the LoRA weight. This is used to scale the LoRA weight
   * before merging it with the base model.
   *
   */
  scale?: number
  /**
   * Transformer
   *
   * Specifies the transformer to load the lora weight into. 'high' loads into the high-noise transformer, 'low' loads it into the low-noise transformer, while 'both' loads the LoRA into both transformers.
   */
  transformer?: 'high' | 'low' | 'both'
  /**
   * Weight Name
   *
   * Name of the LoRA weight. Used only if `path` is a Hugging Face repository, and required only if you have more than 1 safetensors file in the repo.
   */
  weight_name?: string
}

/**
 * WanT2IResponse
 */
export type SchemaWanV22A14bTextToImageLoraOutput = {
  /**
   * Image
   *
   * The generated image file.
   */
  image: SchemaFile
  /**
   * Seed
   *
   * The seed used for generation.
   */
  seed: number
}

/**
 * WanLoRAT2IRequest
 */
export type SchemaWanV22A14bTextToImageLoraInput = {
  /**
   * Prompt
   *
   * The text prompt to guide image generation.
   */
  prompt: string
  /**
   * Shift
   *
   * Shift value for the image. Must be between 1.0 and 10.0.
   */
  shift?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * Acceleration level to use. The more acceleration, the faster the generation, but with lower quality. The recommended value is 'regular'.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Reverse Video
   *
   * If true, the video will be reversed.
   */
  reverse_video?: boolean
  /**
   * Loras
   *
   * LoRA weights to be used in the inference.
   */
  loras?: Array<SchemaLoRaWeight>
  /**
   * Enable Safety Checker
   *
   * If set to true, input data will be checked for safety before processing.
   */
  enable_safety_checker?: boolean
  /**
   * Guidance Scale (1st Stage)
   *
   * Classifier-free guidance scale. Higher values give better adherence to the prompt but may decrease quality.
   */
  guidance_scale?: number
  /**
   * Image Format
   *
   * The format of the output image.
   */
  image_format?: 'png' | 'jpeg'
  /**
   * Negative Prompt
   *
   * Negative prompt for video generation.
   */
  negative_prompt?: string
  /**
   * Enable Output Safety Checker
   *
   * If set to true, output video will be checked for safety after generation.
   */
  enable_output_safety_checker?: boolean
  /**
   * Guidance Scale (2nd Stage)
   *
   * Guidance scale for the second stage of the model. This is used to control the adherence to the prompt in the second stage of the model.
   */
  guidance_scale_2?: number
  /**
   * Enable Prompt Expansion
   *
   * Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.
   */
  enable_prompt_expansion?: boolean
  /**
   * Number of Inference Steps
   *
   * Number of inference steps for sampling. Higher values give better quality but take longer.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. If None, a random seed is chosen.
   */
  seed?: number
}

/**
 * DreaminaOutput
 */
export type SchemaBytedanceDreaminaV31TextToImageOutput = {
  /**
   * Images
   *
   * Generated images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * Seed used for generation
   */
  seed: number
}

/**
 * DreaminaInput
 */
export type SchemaBytedanceDreaminaV31TextToImageInput = {
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. Width and height must be between 512 and 2048.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Prompt
   *
   * The text prompt used to generate the image
   */
  prompt: string
  /**
   * Seed
   *
   * Random seed to control the stochasticity of image generation.
   */
  seed?: number
  /**
   * Enhance Prompt
   *
   * Whether to use an LLM to enhance the prompt
   */
  enhance_prompt?: boolean
}

/**
 * NanoBananaTextToImageOutput
 */
export type SchemaNanoBananaOutput = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImageFile>
  /**
   * Description
   *
   * The description of the generated images.
   */
  description: string
}

/**
 * NanoBananaTextToImageInput
 */
export type SchemaNanoBananaInput = {
  /**
   * Prompt
   *
   * The text prompt to generate an image from.
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '3:2'
    | '4:3'
    | '5:4'
    | '1:1'
    | '4:5'
    | '3:4'
    | '2:3'
    | '9:16'
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Limit Generations
   *
   * Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.
   */
  limit_generations?: boolean
}

/**
 * NanoBananaTextToImageOutput
 */
export type SchemaGemini25FlashImageOutput = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImageFile>
  /**
   * Description
   *
   * The description of the generated images.
   */
  description: string
}

/**
 * NanoBananaTextToImageInput
 */
export type SchemaGemini25FlashImageInput = {
  /**
   * Prompt
   *
   * The text prompt to generate an image from.
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '3:2'
    | '4:3'
    | '5:4'
    | '1:1'
    | '4:5'
    | '3:4'
    | '2:3'
    | '9:16'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Limit Generations
   *
   * Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.
   */
  limit_generations?: boolean
}

/**
 * SeedDream4T2IOutput
 */
export type SchemaBytedanceSeedreamV4TextToImageOutput = {
  /**
   * Images
   *
   * Generated images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * Seed used for generation
   */
  seed: number
}

/**
 * SeedDream4T2IInput
 */
export type SchemaBytedanceSeedreamV4TextToImageInput = {
  /**
   * Prompt
   *
   * The text prompt used to generate the image
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of separate model generations to be run with the prompt.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. Total pixels must be between 960x960 and 4096x4096.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | 'auto'
    | 'auto_2K'
    | 'auto_4K'
  /**
   * Enhance Prompt Mode
   *
   * The mode to use for enhancing prompt enhancement. Standard mode provides higher quality results but takes longer to generate. Fast mode provides average quality results but takes less time to generate.
   */
  enhance_prompt_mode?: 'standard' | 'fast'
  /**
   * Max Images
   *
   * If set to a number greater than one, enables multi-image generation. The model will potentially return up to `max_images` images every generation, and in total, `num_images` generations will be carried out. In total, the number of images generated will be between `num_images` and `max_images*num_images`.
   */
  max_images?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * Random seed to control the stochasticity of image generation.
   */
  seed?: number
}

/**
 * HunyuanTextToImageOutput
 */
export type SchemaHunyuanImageV21TextToImageOutput = {
  /**
   * Images
   *
   * A list of the generated images.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The base seed used for the generation process.
   */
  seed: number
}

/**
 * HunyuanTextToImageInput
 */
export type SchemaHunyuanImageV21TextToImageInput = {
  /**
   * Prompt
   *
   * The text prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The desired size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Use Reprompt
   *
   * Enable prompt enhancement for potentially better results.
   */
  use_reprompt?: boolean
  /**
   * Use Refiner
   *
   * Enable the refiner model for improved image quality.
   */
  use_refiner?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * Controls how much the model adheres to the prompt. Higher values mean stricter adherence.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducible results. If None, a random seed is used.
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   * The negative prompt to guide the image generation away from certain concepts.
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * Number of denoising steps.
   */
  num_inference_steps?: number
}

/**
 * SRPOOutput
 */
export type SchemaFlux1SrpoOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseSRPOFlux1Input
 */
export type SchemaFlux1SrpoInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
}

/**
 * SRPOOutput
 */
export type SchemaFluxSrpoOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseSRPOInput
 */
export type SchemaFluxSrpoInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * TextToImageOutput
 *
 * Output for text-to-image generation
 */
export type SchemaWan25PreviewTextToImageOutput = {
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImageFile>
  /**
   * Seeds
   *
   * The seeds used for each generated image
   */
  seeds: Array<number>
  /**
   * Actual Prompt
   *
   * The actual prompt used if prompt rewriting was enabled
   */
  actual_prompt?: string
}

/**
 * TextToImageInput
 *
 * Input for text-to-image generation
 */
export type SchemaWan25PreviewTextToImageInput = {
  /**
   * Prompt
   *
   * The prompt for image generation. Supports Chinese and English, max 2000 characters.
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of images to generate. Values from 1 to 4.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. Can use preset names like 'square', 'landscape_16_9', etc., or specific dimensions. Total pixels must be between 768768 and 14401440, with aspect ratio between [1:4, 4:1].
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * Random seed for reproducibility. If None, a random seed is chosen.
   */
  seed?: number
  /**
   * Enable Prompt Expansion
   *
   * Whether to enable prompt rewriting using LLM. Improves results for short prompts but increases processing time.
   */
  enable_prompt_expansion?: boolean
  /**
   * Negative Prompt
   *
   * Negative prompt to describe content to avoid. Max 500 characters.
   */
  negative_prompt?: string
}

/**
 * HunyuanTextToImageV3Output
 */
export type SchemaHunyuanImageV3TextToImageOutput = {
  /**
   * Images
   *
   * A list of the generated images.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The base seed used for the generation process.
   */
  seed: number
}

/**
 * HunyuanTextToImageInputV3
 */
export type SchemaHunyuanImageV3TextToImageInput = {
  /**
   * Prompt
   *
   * The text prompt for image-to-image.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The desired size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Enable Prompt Expansion
   *
   * Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.
   */
  enable_prompt_expansion?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * Controls how much the model adheres to the prompt. Higher values mean stricter adherence.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducible results. If None, a random seed is used.
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   * The negative prompt to guide the image generation away from certain concepts.
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * Number of denoising steps.
   */
  num_inference_steps?: number
}

/**
 * ReveCreateOutput
 *
 * Output for Reve text-to-image generation
 */
export type SchemaReveTextToImageOutput = {
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImage>
}

/**
 * ReveCreateInput
 *
 * Input for Reve text-to-image generation
 */
export type SchemaReveTextToImageInput = {
  /**
   * Prompt
   *
   * The text description of the desired image.
   */
  prompt: string
  /**
   * Number of Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Aspect Ratio
   *
   * The desired aspect ratio of the generated image.
   */
  aspect_ratio?: '16:9' | '9:16' | '3:2' | '2:3' | '4:3' | '3:4' | '1:1'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Output Format
   *
   * Output format for the generated image.
   */
  output_format?: 'png' | 'jpeg' | 'webp'
}

/**
 * ImageResponseMini
 */
export type SchemaGptImage1MiniOutput = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImageFile>
}

/**
 * TextToImageRequestMini
 */
export type SchemaGptImage1MiniInput = {
  /**
   * Prompt
   *
   * The prompt for image generation
   */
  prompt: string
  /**
   * Number of Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * Aspect ratio for the generated image
   */
  image_size?: 'auto' | '1024x1024' | '1536x1024' | '1024x1536'
  /**
   * Background
   *
   * Background for the generated image
   */
  background?: 'auto' | 'transparent' | 'opaque'
  /**
   * Quality
   *
   * Quality for the generated image
   */
  quality?: 'auto' | 'low' | 'medium' | 'high'
  /**
   * Output Format
   *
   * Output format for the images
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
}

/**
 * PiQwenOutput
 */
export type SchemaPiflowOutput = {
  /**
   * Images
   *
   * The URLs of the generated images.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation.
   */
  seed: number
}

/**
 * PiQwenInput
 */
export type SchemaPiflowInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   *
   * The size of the generated image. You can choose between some presets or custom height and width
   * that **must be multiples of 8**.
   *
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * Random seed for reproducible generation. If set to None, a random seed will be used.
   */
  seed?: number
}

/**
 * GaiaOutputModel
 */
export type SchemaFiboGenerateOutput = {
  /**
   * Images
   *
   * Generated images.
   */
  images?: Array<{
    [key: string]: unknown
  }>
  image: SchemaImage
  /**
   * Structured Prompt
   *
   * Current prompt.
   */
  structured_prompt: {
    [key: string]: unknown
  }
}

/**
 * GaiaInputModel
 */
export type SchemaFiboGenerateInput = {
  /**
   * Prompt
   *
   * Prompt for image generation.
   */
  prompt?: string | unknown
  /**
   * Steps Num
   *
   * Number of inference steps.
   */
  steps_num?: number
  /**
   * Aspect Ratio
   *
   * Aspect ratio. Options: 1:1, 2:3, 3:2, 3:4, 4:3, 4:5, 5:4, 9:16, 16:9
   */
  aspect_ratio?:
    | '1:1'
    | '2:3'
    | '3:2'
    | '3:4'
    | '4:3'
    | '4:5'
    | '5:4'
    | '9:16'
    | '16:9'
  /**
   * Image Url
   *
   * Reference image (file or URL).
   */
  image_url?: string | unknown
  /**
   * Sync Mode
   *
   * If true, returns the image directly in the response (increases latency).
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * Guidance scale for text.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility.
   */
  seed?: number
  /**
   * The structured prompt to generate an image from.
   */
  structured_prompt?: SchemaStructuredPrompt | unknown
  /**
   * Negative Prompt
   *
   * Negative prompt for image generation.
   */
  negative_prompt?: string
}

/**
 * Lighting
 */
export type SchemaLighting = {
  /**
   * Shadows
   *
   * The shadows in the image to be generated.
   */
  shadows?: string | unknown
  /**
   * Conditions
   *
   * The conditions of the lighting in the image to be generated.
   */
  conditions?: string | unknown
  /**
   * Direction
   *
   * The direction of the lighting in the image to be generated.
   */
  direction?: string | unknown
}

/**
 * PhotographicCharacteristics
 */
export type SchemaPhotographicCharacteristics = {
  /**
   * Focus
   *
   * The focus in the image to be generated.
   */
  focus?: string | unknown
  /**
   * Lens Focal Length
   *
   * The focal length of the lens in the image to be generated.
   */
  lens_focal_length?: string | unknown
  /**
   * Camera Angle
   *
   * The angle of the camera in the image to be generated.
   */
  camera_angle?: string | unknown
  /**
   * Depth Of Field
   *
   * The depth of field in the image to be generated.
   */
  depth_of_field?: string | unknown
}

/**
 * PromptObject
 */
export type SchemaPromptObject = {
  /**
   * Clothing
   *
   * The clothing of the object in the image.
   */
  clothing?: string | unknown
  /**
   * Description
   *
   * A description of the object to be generated.
   */
  description?: string | unknown
  /**
   * Skin Tone And Texture
   *
   * The skin tone and texture of the object in the image.
   */
  skin_tone_and_texture?: string | unknown
  /**
   * Appearance Details
   *
   * The appearance details of the object.
   */
  appearance_details?: string | unknown
  /**
   * Number Of Objects
   *
   * The number of objects in the image.
   */
  number_of_objects?: number | unknown
  /**
   * Expression
   *
   * The expression of the object in the image.
   */
  expression?: string | unknown
  /**
   * Pose
   *
   * The pose of the object in the image.
   */
  pose?: string | unknown
  /**
   * Shape And Color
   *
   * The shape and color of the object.
   */
  shape_and_color?: string | unknown
  /**
   * Relationship
   *
   * The relationship of the object to other objects in the image.
   */
  relationship: string
  /**
   * Texture
   *
   * The texture of the object.
   */
  texture?: string | unknown
  /**
   * Gender
   *
   * The gender of the object in the image.
   */
  gender?: string | unknown
  /**
   * Relative Size
   *
   * The relative size of the object in the image.
   */
  relative_size?: string | unknown
  /**
   * Location
   *
   * The location of the object in the image.
   */
  location?: string | unknown
  /**
   * Orientation
   *
   * The orientation of the object in the image.
   */
  orientation?: string | unknown
  /**
   * Action
   *
   * The action of the object in the image.
   */
  action?: string | unknown
}

/**
 * Aesthetics
 */
export type SchemaAesthetics = {
  /**
   * Composition
   *
   * The composition of the image to be generated.
   */
  composition?: string | unknown
  /**
   * Mood Atmosphere
   *
   * The mood and atmosphere of the image to be generated.
   */
  mood_atmosphere?: string | unknown
  /**
   * Color Scheme
   *
   * The color scheme of the image to be generated.
   */
  color_scheme?: string | unknown
}

/**
 * StructuredPrompt
 */
export type SchemaStructuredPrompt = {
  /**
   * Background Setting
   *
   * The background setting of the image to be generated.
   */
  background_setting?: string | unknown
  /**
   * Artistic Style
   *
   * The artistic style of the image to be generated.
   */
  artistic_style?: string | unknown
  /**
   * The aesthetics of the image to be generated.
   */
  aesthetics?: SchemaAesthetics | unknown
  /**
   * Text Render
   *
   * A list of text to be rendered in the image.
   */
  text_render?: Array<unknown> | unknown
  /**
   * Objects
   *
   * A list of objects in the image to be generated, along with their attributes and relationships to other objects in the image.
   */
  objects?: Array<SchemaPromptObject> | unknown
  /**
   * Style Medium
   *
   * The style medium of the image to be generated.
   */
  style_medium?: string | unknown
  /**
   * The photographic characteristics of the image to be generated.
   */
  photographic_characteristics?: SchemaPhotographicCharacteristics | unknown
  /**
   * Context
   *
   * The context of the image to be generated.
   */
  context?: string | unknown
  /**
   * The lighting of the image to be generated.
   */
  lighting?: SchemaLighting | unknown
  /**
   * Short Description
   *
   * A short description of the image to be generated.
   */
  short_description?: string | unknown
}

/**
 * Emu35Output
 */
export type SchemaEmu35ImageTextToImageOutput = {
  /**
   * Images
   *
   * The edited image.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * The seed for the inference.
   */
  seed: number
}

/**
 * Emu35ImageInput
 */
export type SchemaEmu35ImageTextToImageInput = {
  /**
   * Prompt
   *
   * The prompt to create the image.
   */
  prompt: string
  /**
   * Resolution
   *
   * The resolution of the output image.
   */
  resolution?: '480p' | '720p'
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the output image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
  /**
   * Output Format
   *
   * The format of the output image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * Whether to return the image in sync mode.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * The seed for the inference.
   */
  seed?: number
}

/**
 * Image
 *
 * Represents an image file.
 */
export type SchemaImageOutput = {
  /**
   * File Size
   *
   * The size of the file in bytes.
   */
  file_size?: number | unknown
  /**
   * Height
   *
   * The height of the image in pixels.
   */
  height?: number | unknown
  /**
   * File Name
   *
   * The name of the file. It will be auto-generated if not provided.
   */
  file_name?: string | unknown
  /**
   * Content Type
   *
   * The mime type of the file.
   */
  content_type?: string | unknown
  /**
   * Url
   *
   * The URL where the file can be downloaded from.
   */
  url: string
  /**
   * Width
   *
   * The width of the image in pixels.
   */
  width?: number | unknown
}

/**
 * ImagineArt_1_5_Output
 */
export type SchemaImagineart15PreviewTextToImageOutput = {
  /**
   * Images
   *
   * Generated image
   */
  images: Array<SchemaImageOutput>
}

/**
 * ImagineArt_1_5_Input
 */
export type SchemaImagineart15PreviewTextToImageInput = {
  /**
   * Prompt
   *
   * Text prompt describing the desired image
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * Image aspect ratio: 1:1, 3:1, 1:3, 16:9, 9:16, 4:3, 3:4, 3:2, 2:3
   */
  aspect_ratio?:
    | '1:1'
    | '16:9'
    | '9:16'
    | '4:3'
    | '3:4'
    | '3:1'
    | '1:3'
    | '3:2'
    | '2:3'
  /**
   * Seed
   *
   * Seed for the image generation
   */
  seed?: number
}

/**
 * NanoBananaTextToImageOutput
 */
export type SchemaNanoBananaProOutput = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImageFile>
  /**
   * Description
   *
   * The description of the generated images.
   */
  description: string
}

/**
 * NanoBananaTextToImageInput
 */
export type SchemaNanoBananaProInput = {
  /**
   * Prompt
   *
   * The text prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Enable Web Search
   *
   * Enable web search for the image generation task. This will allow the model to use the latest information from the web to generate the image.
   */
  enable_web_search?: boolean
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '3:2'
    | '4:3'
    | '5:4'
    | '1:1'
    | '4:5'
    | '3:4'
    | '2:3'
    | '9:16'
  /**
   * Resolution
   *
   * The resolution of the image to generate.
   */
  resolution?: '1K' | '2K' | '4K'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Seed
   *
   * The seed for the random number generator.
   */
  seed?: number
  /**
   * Limit Generations
   *
   * Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.
   */
  limit_generations?: boolean
}

/**
 * NanoBananaTextToImageOutput
 */
export type SchemaGemini3ProImagePreviewOutput = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImageFile>
  /**
   * Description
   *
   * The description of the generated images.
   */
  description: string
}

/**
 * NanoBananaTextToImageInput
 */
export type SchemaGemini3ProImagePreviewInput = {
  /**
   * Prompt
   *
   * The text prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Enable Web Search
   *
   * Enable web search for the image generation task. This will allow the model to use the latest information from the web to generate the image.
   */
  enable_web_search?: boolean
  /**
   * Resolution
   *
   * The resolution of the image to generate.
   */
  resolution?: '1K' | '2K' | '4K'
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '3:2'
    | '4:3'
    | '5:4'
    | '1:1'
    | '4:5'
    | '3:4'
    | '2:3'
    | '9:16'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Seed
   *
   * The seed for the random number generator.
   */
  seed?: number
  /**
   * Limit Generations
   *
   * Experimental parameter to limit the number of generations from each round of prompting to 1. Set to `True` to to disregard any instructions in the prompt regarding the number of images to generate.
   */
  limit_generations?: boolean
}

/**
 * Flux2FlexOutput
 */
export type SchemaFlux2FlexOutput = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * The seed used for the generation.
   */
  seed: number
}

/**
 * Flux2FlexTextToImageInput
 */
export type SchemaFlux2FlexInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5'
  /**
   * Enable Prompt Expansion
   *
   * Whether to expand the prompt using the model's own knowledge.
   */
  enable_prompt_expansion?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * The seed to use for the generation.
   */
  seed?: number
  /**
   * Guidance Scale
   *
   * The guidance scale to use for the generation.
   */
  guidance_scale?: number
}

/**
 * BallpointPenSketchOutput
 */
export type SchemaFlux2LoraGalleryBallpointPenSketchOutput = {
  /**
   * Prompt
   *
   * The prompt used for generation
   */
  prompt: string
  /**
   * Images
   *
   * The generated ballpoint pen sketch style images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * BallpointPenSketchInput
 *
 * Input model for Ballpoint Pen Sketch endpoint - Generate ballpoint pen sketch style images
 */
export type SchemaFlux2LoraGalleryBallpointPenSketchInput = {
  /**
   * Prompt
   *
   * The prompt to generate a ballpoint pen sketch style image. Use 'b4llp01nt' trigger word for best results.
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The strength of the ballpoint pen sketch effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * DigitalComicArtOutput
 */
export type SchemaFlux2LoraGalleryDigitalComicArtOutput = {
  /**
   * Prompt
   *
   * The prompt used for generation
   */
  prompt: string
  /**
   * Images
   *
   * The generated digital comic art style images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * DigitalComicArtInput
 *
 * Input model for Digital Comic Art endpoint - Generate digital comic art style images
 */
export type SchemaFlux2LoraGalleryDigitalComicArtInput = {
  /**
   * Prompt
   *
   * The prompt to generate a digital comic art style image. Use 'd1g1t4l' trigger word for best results.
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The strength of the digital comic art effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * HdrStyleOutput
 */
export type SchemaFlux2LoraGalleryHdrStyleOutput = {
  /**
   * Prompt
   *
   * The prompt used for generation
   */
  prompt: string
  /**
   * Images
   *
   * The generated HDR style images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * HdrStyleInput
 *
 * Input model for HDR Style endpoint - Generate HDR style images with vibrant colors
 */
export type SchemaFlux2LoraGalleryHdrStyleInput = {
  /**
   * Prompt
   *
   * The prompt to generate an HDR style image. The trigger word 'Hyp3rRe4list1c' will be automatically prepended.
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The strength of the HDR style effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * RealismOutput
 */
export type SchemaFlux2LoraGalleryRealismOutput = {
  /**
   * Prompt
   *
   * The prompt used for generation
   */
  prompt: string
  /**
   * Images
   *
   * The generated realistic style images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * RealismInput
 *
 * Input model for Realism endpoint - Generate realistic style images
 */
export type SchemaFlux2LoraGalleryRealismInput = {
  /**
   * Prompt
   *
   * The prompt to generate a realistic image with natural lighting and authentic details.
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The strength of the realism effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * SatelliteViewStyleOutput
 */
export type SchemaFlux2LoraGallerySatelliteViewStyleOutput = {
  /**
   * Prompt
   *
   * The prompt used for generation
   */
  prompt: string
  /**
   * Images
   *
   * The generated satellite view style images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * SatelliteViewStyleInput
 *
 * Input model for Satellite View Style endpoint - Generate satellite/aerial view style images
 */
export type SchemaFlux2LoraGallerySatelliteViewStyleInput = {
  /**
   * Prompt
   *
   * The prompt to generate a satellite/aerial view style image.
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The strength of the satellite view style effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * SepiaVintageOutput
 */
export type SchemaFlux2LoraGallerySepiaVintageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generation
   */
  prompt: string
  /**
   * Images
   *
   * The generated sepia vintage photography style images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
}

/**
 * SepiaVintageInput
 *
 * Input model for Sepia Vintage Photography endpoint - Generate vintage sepia style images
 */
export type SchemaFlux2LoraGallerySepiaVintageInput = {
  /**
   * Prompt
   *
   * The prompt to generate a sepia vintage photography style image.
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * Acceleration level for image generation. 'regular' balances speed and quality.
   */
  acceleration?: 'none' | 'regular'
  /**
   * Lora Scale
   *
   * The strength of the sepia vintage photography effect.
   */
  lora_scale?: number
  /**
   * Output Format
   *
   * The format of the output image
   */
  output_format?: 'png' | 'jpeg' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and won't be saved in history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The CFG (Classifier Free Guidance) scale. Controls how closely the model follows the prompt.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. Same seed with same prompt will produce same result.
   */
  seed?: number | unknown
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker for the generated image.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * ZImageTurboOutput
 */
export type SchemaZImageTurboOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   *
   * The timings of the generation process.
   */
  timings: {
    [key: string]: number
  }
}

/**
 * ZImageTurboTextToImageInput
 */
export type SchemaZImageTurboInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The acceleration level to use.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Prompt Expansion
   *
   * Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.
   */
  enable_prompt_expansion?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * OvisImageOutput
 */
export type SchemaOvisImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * TextToImageInput
 */
export type SchemaOvisImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Acceleration
   *
   * The acceleration level to use.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Guidance Scale
   *
   * The guidance scale to use for the image generation.
   */
  guidance_scale?: number
  /**
   * Negative Prompt
   *
   * The negative prompt to generate an image from.
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * ZImageTurboOutput
 */
export type SchemaZImageTurboLoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   *
   * The timings of the generation process.
   */
  timings: {
    [key: string]: number
  }
}

/**
 * ZImageTurboTextToImageLoRAInput
 */
export type SchemaZImageTurboLoraInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The acceleration level to use.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Loras
   *
   * List of LoRA weights to apply (maximum 3).
   */
  loras?: Array<SchemaLoRaInput>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Prompt Expansion
   *
   * Whether to enable prompt expansion. Note: this will increase the price by 0.0025 credits per request.
   */
  enable_prompt_expansion?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * LoRAInput
 *
 * LoRA weight configuration.
 */
export type SchemaLoRaInput = {
  /**
   * Path
   *
   * URL, HuggingFace repo ID (owner/repo) to lora weights.
   */
  path: string
  /**
   * Scale
   *
   * Scale factor for LoRA application (0.0 to 4.0).
   */
  scale?: number
}

/**
 * TextToImageOutput
 */
export type SchemaViduQ2TextToImageOutput = {
  /**
   * Image
   *
   * The edited image
   */
  image: SchemaImage
}

/**
 * TextToImageRequest
 */
export type SchemaViduQ2TextToImageInput = {
  /**
   * Prompt
   *
   * Text prompt for video generation, max 1500 characters
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the output video
   */
  aspect_ratio?: '16:9' | '9:16' | '1:1'
  /**
   * Seed
   *
   * Random seed for generation
   */
  seed?: number
}

/**
 * SeedDream45T2IOutput
 */
export type SchemaBytedanceSeedreamV45TextToImageOutput = {
  /**
   * Images
   *
   * Generated images
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   * Seed used for generation
   */
  seed: number
}

/**
 * SeedDream45T2IInput
 */
export type SchemaBytedanceSeedreamV45TextToImageInput = {
  /**
   * Prompt
   *
   * The text prompt used to generate the image
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of separate model generations to be run with the prompt.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. Width and height must be between 1920 and 4096, or total number of pixels must be between 2560*1440 and 4096*4096.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | 'auto_2K'
    | 'auto_4K'
  /**
   * Max Images
   *
   * If set to a number greater than one, enables multi-image generation. The model will potentially return up to `max_images` images every generation, and in total, `num_images` generations will be carried out. In total, the number of images generated will be between `num_images` and `max_images*num_images`.
   */
  max_images?: number
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * Random seed to control the stochasticity of image generation.
   */
  seed?: number
}

/**
 * TextToImageOutput
 */
export type SchemaLongcatImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaLongcatImageInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Acceleration
   *
   * The acceleration level to use.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Guidance Scale
   *
   * The guidance scale to use for the image generation.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * Flux2MaxOutput
 */
export type SchemaFlux2MaxOutput = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * The seed used for the generation.
   */
  seed: number
}

/**
 * Flux2MaxTextToImageInput
 */
export type SchemaFlux2MaxInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5'
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * The seed to use for the generation.
   */
  seed?: number
}

/**
 * Flux2TurboT2IOutput
 */
export type SchemaFlux2TurboOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * Flux2TurboTextToImageInput
 */
export type SchemaFlux2TurboInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the image to generate. The width and height must be between 512 and 2048 pixels.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
  /**
   * Enable Prompt Expansion
   *
   * If set to true, the prompt will be expanded for better results.
   */
  enable_prompt_expansion?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * GaiaOutputModel
 */
export type SchemaFiboLiteGenerateOutput = {
  /**
   * Images
   *
   * Generated images.
   */
  images?: Array<{
    [key: string]: unknown
  }>
  image: SchemaImage
  /**
   * Structured Prompt
   *
   * Current prompt.
   */
  structured_prompt: {
    [key: string]: unknown
  }
}

/**
 * GaiaLiteInputModel
 */
export type SchemaFiboLiteGenerateInput = {
  /**
   * Prompt
   *
   * Prompt for image generation.
   */
  prompt?: string | unknown
  /**
   * Steps Num
   *
   * Number of inference steps for Fibo Lite.
   */
  steps_num?: number
  /**
   * Aspect Ratio
   *
   * Aspect ratio. Options: 1:1, 2:3, 3:2, 3:4, 4:3, 4:5, 5:4, 9:16, 16:9
   */
  aspect_ratio?:
    | '1:1'
    | '2:3'
    | '3:2'
    | '3:4'
    | '4:3'
    | '4:5'
    | '5:4'
    | '9:16'
    | '16:9'
  /**
   * Image Url
   *
   * Reference image (file or URL).
   */
  image_url?: string | unknown
  /**
   * Sync Mode
   *
   * If true, returns the image directly in the response (increases latency).
   */
  sync_mode?: boolean
  /**
   * Seed
   *
   * Random seed for reproducibility.
   */
  seed?: number
  /**
   * The structured prompt to generate an image from.
   */
  structured_prompt?: SchemaStructuredPrompt | unknown
}

/**
 * ImageResponse
 */
export type SchemaGptImage15Output = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImageFile>
}

/**
 * TextToImageRequest
 */
export type SchemaGptImage15Input = {
  /**
   * Prompt
   *
   * The prompt for image generation
   */
  prompt: string
  /**
   * Number of Images
   *
   * Number of images to generate
   */
  num_images?: number
  /**
   * Image Size
   *
   * Aspect ratio for the generated image
   */
  image_size?: '1024x1024' | '1536x1024' | '1024x1536'
  /**
   * Background
   *
   * Background for the generated image
   */
  background?: 'auto' | 'transparent' | 'opaque'
  /**
   * Quality
   *
   * Quality for the generated image
   */
  quality?: 'low' | 'medium' | 'high'
  /**
   * Output Format
   *
   * Output format for the images
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
}

/**
 * Flux2FlashT2IOutput
 */
export type SchemaFlux2FlashOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * Flux2FlashTextToImageInput
 */
export type SchemaFlux2FlashInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the image to generate. The width and height must be between 512 and 2048 pixels.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
  /**
   * Enable Prompt Expansion
   *
   * If set to true, the prompt will be expanded for better results.
   */
  enable_prompt_expansion?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * TextToImageWanOutput
 *
 * Output for Wan 2.6 text-to-image (can include generated text in mixed mode)
 */
export type SchemaV26TextToImageOutput = {
  /**
   * Images
   *
   * Generated images in PNG format
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * The seed used for generation
   */
  seed: number
  /**
   * Generated Text
   *
   * Generated text content (in mixed text-and-image mode). May be None if only images were generated.
   */
  generated_text?: string
}

/**
 * TextToImageWanInput
 *
 * Input for Wan 2.6 text-to-image or mixed text-and-image generation (enable_interleave=true)
 */
export type SchemaV26TextToImageInput = {
  /**
   * Prompt
   *
   * Text prompt describing the desired image. Supports Chinese and English. Max 2000 characters.
   */
  prompt: string
  /**
   * Image Size
   *
   * Output image size. If not set: matches input image size (up to 1280*1280). Use presets like 'square_hd', 'landscape_16_9', or specify exact dimensions.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Max Images
   *
   * Maximum number of images to generate (1-5). Actual count may be less depending on model inference.
   */
  max_images?: number
  /**
   * Image Url
   *
   * Optional reference image (0 or 1). When provided, can be used for style guidance. Resolution: 384-5000px each dimension. Max size: 10MB. Formats: JPEG, JPG, PNG (no alpha), BMP, WEBP.
   */
  image_url?: string
  /**
   * Enable Safety Checker
   *
   * Enable content moderation for input and output.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * Random seed for reproducibility (0-2147483647).
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * Content to avoid in the generated image. Max 500 characters.
   */
  negative_prompt?: string
}

/**
 * QwenImage2512Output
 */
export type SchemaQwenImage2512Output = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaQwenImage2512Input = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Acceleration
   *
   * The acceleration level to use.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Guidance Scale
   *
   * The guidance scale to use for the image generation.
   */
  guidance_scale?: number
  /**
   * Negative Prompt
   *
   * The negative prompt to generate an image from.
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * QwenImage2512Output
 */
export type SchemaQwenImage2512LoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * LoraInput
 */
export type SchemaQwenImage2512LoraInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Acceleration
   *
   * The acceleration level to use.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use up to 3 LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Guidance Scale
   *
   * The guidance scale to use for the image generation.
   */
  guidance_scale?: number
  /**
   * Negative Prompt
   *
   * The negative prompt to generate an image from.
   */
  negative_prompt?: string
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * GlmImageOutput
 */
export type SchemaGlmImageOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * List of URLs to the generated images.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * GlmImageInput
 */
export type SchemaGlmImageInput = {
  /**
   * Prompt
   *
   * Text prompt for image generation.
   */
  prompt: string
  /**
   * Num Images
   *
   * Number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * Output image size.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
    | 'portrait_3_2'
    | 'landscape_3_2'
    | 'portrait_hd'
    | 'landscape_hd'
  /**
   * Output Format
   *
   * Output image format.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If True, the image will be returned as a base64 data URI instead of a URL.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * Classifier-free guidance scale. Higher values make the model follow the prompt more closely.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * Random seed for reproducibility. The same seed with the same prompt will produce the same image.
   */
  seed?: number
  /**
   * Enable Prompt Expansion
   *
   * If True, the prompt will be enhanced using an LLM for more detailed and higher quality results.
   */
  enable_prompt_expansion?: boolean
  /**
   * Num Inference Steps
   *
   * Number of diffusion denoising steps. More steps generally produce higher quality images.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * Enable NSFW safety checking on the generated images.
   */
  enable_safety_checker?: boolean
}

/**
 * ImagineArt_1_5_Output
 */
export type SchemaImagineart15ProPreviewTextToImageOutput = {
  /**
   * Images
   *
   * Generated image
   */
  images: Array<SchemaImage>
}

/**
 * ImagineArt_1_5_Input
 */
export type SchemaImagineart15ProPreviewTextToImageInput = {
  /**
   * Prompt
   *
   * Text prompt describing the desired image
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * Image aspect ratio: 1:1, 3:1, 1:3, 16:9, 9:16, 4:3, 3:4, 3:2, 2:3
   */
  aspect_ratio?:
    | '1:1'
    | '16:9'
    | '9:16'
    | '4:3'
    | '3:4'
    | '3:1'
    | '1:3'
    | '3:2'
    | '2:3'
  /**
   * Seed
   *
   * Seed for the image generation
   */
  seed?: number
}

/**
 * Klein4BDistilledT2IOutput
 */
export type SchemaFlux2Klein4bOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImageFile>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * KleinDistilledInput
 */
export type SchemaFlux2Klein4bInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the image to generate.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI. Output is not stored when this is True.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
}

/**
 * Klein9BDistilledT2IOutput
 */
export type SchemaFlux2Klein9bOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImageFile>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * Klein9BDistilledInput
 */
export type SchemaFlux2Klein9bInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the image to generate.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI. Output is not stored when this is True.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
}

/**
 * Klein4BT2IOutput
 */
export type SchemaFlux2Klein4bBaseOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImageFile>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * Klein4BBaseInput
 */
export type SchemaFlux2Klein4bBaseInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the image to generate.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The acceleration level to use for image generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI. Output is not stored when this is True.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * Negative prompt for classifier-free guidance. Describes what to avoid in the image.
   */
  negative_prompt?: string
  /**
   * Guidance Scale
   *
   * Guidance scale for classifier-free guidance.
   */
  guidance_scale?: number
}

/**
 * Klein9BT2IOutput
 */
export type SchemaFlux2Klein9bBaseOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImageFile>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * Klein9BBaseInput
 */
export type SchemaFlux2Klein9bBaseInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the image to generate.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The acceleration level to use for image generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI. Output is not stored when this is True.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * Negative prompt for classifier-free guidance. Describes what to avoid in the image.
   */
  negative_prompt?: string
  /**
   * Guidance Scale
   *
   * Guidance scale for classifier-free guidance.
   */
  guidance_scale?: number
}

/**
 * KleinT2IOutput
 */
export type SchemaFlux2Klein4bBaseLoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImageFile>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * KleinBaseLoRAInput
 */
export type SchemaFlux2Klein4bBaseLoraInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the image to generate.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The acceleration level to use for image generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Loras
   *
   * List of LoRA weights to apply (maximum 3).
   */
  loras?: Array<SchemaFalAiFlux2KleinLoRaInput>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI. Output is not stored when this is True.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * Negative prompt for classifier-free guidance. Describes what to avoid in the image.
   */
  negative_prompt?: string
  /**
   * Guidance Scale
   *
   * Guidance scale for classifier-free guidance.
   */
  guidance_scale?: number
}

/**
 * LoRAInput
 */
export type SchemaFalAiFlux2KleinLoRaInput = {
  /**
   * Path
   *
   * URL, HuggingFace repo ID (owner/repo), or local path to LoRA weights.
   */
  path: string
  /**
   * Scale
   *
   * Scale factor for LoRA application (0.0 to 4.0).
   */
  scale?: number
}

/**
 * KleinT2IOutput
 */
export type SchemaFlux2Klein9bBaseLoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImageFile>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * KleinBaseLoRAInput
 */
export type SchemaFlux2Klein9bBaseLoraInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the image to generate.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The acceleration level to use for image generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Loras
   *
   * List of LoRA weights to apply (maximum 3).
   */
  loras?: Array<SchemaFalAiFlux2KleinLoRaInput>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI. Output is not stored when this is True.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * Negative prompt for classifier-free guidance. Describes what to avoid in the image.
   */
  negative_prompt?: string
  /**
   * Guidance Scale
   *
   * Guidance scale for classifier-free guidance.
   */
  guidance_scale?: number
}

/**
 * ZImageBaseOutput
 */
export type SchemaZImageBaseOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   *
   * The timings of the generation process.
   */
  timings: {
    [key: string]: number
  }
}

/**
 * ZImageBaseTextToImageInput
 */
export type SchemaZImageBaseInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The acceleration level to use.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The guidance scale to use for the image generation.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Negative Prompt
   *
   * The negative prompt to use for the image generation.
   */
  negative_prompt?: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * ZImageBaseOutput
 */
export type SchemaZImageBaseLoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * Seed of the generated Image. It will be the same value of the one passed in the input or the randomly generated that was used in case none was passed.
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   *
   * The timings of the generation process.
   */
  timings: {
    [key: string]: number
  }
}

/**
 * ZImageBaseTextToImageLoRAInput
 */
export type SchemaZImageBaseLoraInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The acceleration level to use.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Loras
   *
   * List of LoRA weights to apply (maximum 3).
   */
  loras?: Array<SchemaLoRaInput>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * The guidance scale to use for the image generation.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * The negative prompt to use for the image generation.
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Output
 */
export type SchemaFluxLoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaFluxLoraInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate. This is always set to 1 for streaming output.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * ControlNetUnionInput
 */
export type SchemaControlNetUnionInput = {
  /**
   * Conditioning Scale
   *
   *
   * The scale of the control net weight. This is used to scale the control net weight
   * before merging it with the base model.
   *
   */
  conditioning_scale?: number
  /**
   * Mask Threshold
   *
   * Threshold for mask.
   */
  mask_threshold?: number
  /**
   * End Percentage
   *
   *
   * The percentage of the image to end applying the controlnet in terms of the total timesteps.
   *
   */
  end_percentage?: number
  /**
   * Mask Image Url
   *
   * URL of the mask for the control image.
   */
  mask_image_url?: string | null
  /**
   * Control Image Url
   *
   * URL of the image to be used as the control image.
   */
  control_image_url: string
  /**
   * Control Mode
   *
   * Control Mode for Flux Controlnet Union. Supported values are:
   * - canny: Uses the edges for guided generation.
   * - tile: Uses the tiles for guided generation.
   * - depth: Utilizes a grayscale depth map for guided generation.
   * - blur: Adds a blur to the image.
   * - pose: Uses the pose of the image for guided generation.
   * - gray: Converts the image to grayscale.
   * - low-quality: Converts the image to a low-quality image.
   */
  control_mode:
    | 'canny'
    | 'tile'
    | 'depth'
    | 'blur'
    | 'pose'
    | 'gray'
    | 'low-quality'
  /**
   * Start Percentage
   *
   *
   * The percentage of the image to start applying the controlnet in terms of the total timesteps.
   *
   */
  start_percentage?: number
}

/**
 * ControlNetUnion
 */
export type SchemaControlNetUnion = {
  /**
   * Controls
   *
   * The control images and modes to use for the control net.
   */
  controls: Array<SchemaControlNetUnionInput>
  /**
   * Path
   *
   * URL or the path to the control net weights.
   */
  path: string
  /**
   * Variant
   *
   * The optional variant if a Hugging Face repo key is used.
   */
  variant?: string
  /**
   * Config Url
   *
   * optional URL to the controlnet config.json file.
   */
  config_url?: string
}

/**
 * ImageFillInput
 */
export type SchemaImageFillInput = {
  /**
   * Fill Image Url
   *
   * URLs of images to be filled for redux prompting
   */
  fill_image_url?: string | Array<string>
}

/**
 * EasyControlWeight
 */
export type SchemaEasyControlWeight = {
  /**
   * Scale
   *
   * Scale for the control method.
   */
  scale?: number
  /**
   * Image Control Type
   *
   * Control type of the image. Must be one of `spatial` or `subject`.
   */
  image_control_type: 'subject' | 'spatial'
  /**
   * Control Method Url
   *
   * URL to safetensor weights of control method to be applied. Can also be one of `canny`, `depth`, `hedsketch`, `inpainting`, `pose`, `seg`, `subject`, `ghibli`
   */
  control_method_url: string
  /**
   * Image Url
   *
   * URL of an image to use as a control
   */
  image_url: string
}

/**
 * ControlLoraWeight
 */
export type SchemaControlLoraWeight = {
  /**
   * Path
   *
   * URL or the path to the LoRA weights.
   */
  path: string
  /**
   * Scale
   *
   *
   * The scale of the LoRA weight. This is used to scale the LoRA weight
   * before merging it with the base model. Providing a dictionary as {"layer_name":layer_scale} allows per-layer lora scale settings. Layers with no scale provided will have scale 1.0.
   *
   */
  scale?:
    | {
        [key: string]: unknown
      }
    | number
  /**
   * Control Image Url
   *
   * URL of the image to be used as the control image.
   */
  control_image_url: string
  /**
   * Preprocess
   *
   * Type of preprocessing to apply to the input image.
   */
  preprocess?: 'canny' | 'depth' | 'None'
}

/**
 * Output
 */
export type SchemaFluxGeneralOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaFluxGeneralInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Proportion of steps to apply NAG
   *
   *
   * The proportion of steps to apply NAG. After the specified proportion
   * of steps has been iterated, the remaining steps will use original
   * attention processors in FLUX.
   *
   */
  nag_end?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Control Loras
   *
   *
   * The LoRAs to use for the image generation which use a control image. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  control_loras?: Array<SchemaControlLoraWeight>
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Scheduler
   *
   * Scheduler for the denoising process.
   */
  scheduler?: 'euler' | 'dpmpp_2m'
  /**
   * Easycontrols
   *
   *
   * EasyControl Inputs to use for image generation.
   *
   */
  easycontrols?: Array<SchemaEasyControlWeight>
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Real CFG scale
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  real_cfg_scale?: number
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Use CFG-Zero-Init
   *
   *
   * Uses CFG-zero init sampling as in https://arxiv.org/abs/2503.18886.
   *
   */
  use_cfg_zero?: boolean
  /**
   * Fill Image
   *
   * Use an image input to influence the generation. Can be used to fill images in masked areas.
   */
  fill_image?: SchemaImageFillInput
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Sigma Schedule
   *
   * Sigmas schedule for the denoising process.
   */
  sigma_schedule?: 'sgm_uniform'
  /**
   * Reference End
   *
   *
   * The percentage of the total timesteps when the reference guidance is to be ended.
   *
   */
  reference_end?: number
  /**
   * Reference Strength
   *
   * Strength of reference_only generation. Only used if a reference image is provided.
   */
  reference_strength?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * NAG scale
   *
   *
   * The scale for NAG. Higher values will result in a image that is more distant
   * to the negative prompt.
   *
   */
  nag_scale?: number
  /**
   * Reference Image Url
   *
   * URL of Image for Reference-Only
   */
  reference_image_url?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Controlnet Unions
   *
   *
   * The controlnet unions to use for the image generation. Only one controlnet is supported at the moment.
   *
   */
  controlnet_unions?: Array<SchemaControlNetUnion>
  /**
   * Negative Prompt
   *
   *
   * Negative prompt to steer the image generation away from unwanted features.
   * By default, we will be using NAG for processing the negative prompt.
   *
   */
  negative_prompt?: string
  /**
   * NAG Tau
   *
   *
   * The tau for NAG. Controls the normalization of the hidden state.
   * Higher values will result in a less aggressive normalization,
   * but may also lead to unexpected changes with respect to the original image.
   * Not recommended to change this value.
   *
   */
  nag_tau?: number
  /**
   * Num Images
   *
   * The number of images to generate. This is always set to 1 for streaming output.
   */
  num_images?: number
  /**
   * Use Beta Schedule
   *
   * Specifies whether beta sigmas ought to be used.
   */
  use_beta_schedule?: boolean
  /**
   * Ip Adapters
   *
   *
   * IP-Adapter to use for image generation.
   *
   */
  ip_adapters?: Array<SchemaIpAdapter>
  /**
   * Base Shift
   *
   * Base shift for the scheduled timesteps
   */
  base_shift?: number
  /**
   * NAG alpha
   *
   *
   * The alpha value for NAG. This value is used as a final weighting
   * factor for steering the normalized guidance (positive and negative prompts)
   * in the direction of the positive prompt. Higher values will result in less
   * steering on the normalized guidance where lower values will result in
   * considering the positive prompt guidance more.
   *
   */
  nag_alpha?: number
  /**
   * Use Real CFG
   *
   *
   * Uses classical CFG as in SD1.5, SDXL, etc. Increases generation times and price when set to be true.
   * If using XLabs IP-Adapter v1, this will be turned on!.
   *
   */
  use_real_cfg?: boolean
  /**
   * Max Shift
   *
   * Max shift for the scheduled timesteps
   */
  max_shift?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Controlnets
   *
   *
   * The controlnets to use for the image generation. Only one controlnet is supported at the moment.
   *
   */
  controlnets?: Array<SchemaControlNet>
  /**
   * Reference Start
   *
   *
   * The percentage of the total timesteps when the reference guidance is to bestarted.
   *
   */
  reference_start?: number
}

/**
 * Output
 */
export type SchemaStableDiffusionV35LargeOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * TextToImageInput
 */
export type SchemaStableDiffusionV35LargeInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image. Defaults to landscape_4_3 if no controlnet has been passed, otherwise defaults to the size of the controlnet conditioning image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Controlnet
   *
   *
   * ControlNet for inference.
   *
   */
  controlnet?: SchemaControlNet
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Ip Adapter
   *
   *
   * IP-Adapter to use during inference.
   *
   */
  ip_adapter?: SchemaIpAdapter
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Loras
   *
   *
   * The LoRAs to use for the image generation. You can use any number of LoRAs
   * and they will be merged together to generate the final image.
   *
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
}

/**
 * Output
 */
export type SchemaIdeogramV2Output = {
  /**
   * Images
   */
  images: Array<SchemaFile>
  /**
   * Seed
   *
   * Seed used for the random number generator
   */
  seed: number
}

/**
 * TextToImageInput
 */
export type SchemaIdeogramV2Input = {
  /**
   * Prompt
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image
   */
  aspect_ratio?:
    | '10:16'
    | '16:10'
    | '9:16'
    | '16:9'
    | '4:3'
    | '3:4'
    | '1:1'
    | '1:3'
    | '3:1'
    | '3:2'
    | '2:3'
  /**
   * Style
   *
   * The style of the generated image
   */
  style?: 'auto' | 'general' | 'realistic' | 'design' | 'render_3D' | 'anime'
  /**
   * Expand Prompt
   *
   * Whether to expand the prompt with MagicPrompt functionality.
   */
  expand_prompt?: boolean
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Seed
   *
   * Seed for the random number generator
   */
  seed?: number | unknown
  /**
   * Negative Prompt
   *
   * A negative prompt to avoid in the generated image
   */
  negative_prompt?: string
}

/**
 * Output
 */
export type SchemaFluxDevOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * BaseInput
 */
export type SchemaFluxDevInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The speed of the generation. The higher the speed, the faster the generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
}

/**
 * Output
 */
export type SchemaHidreamI1FastOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * FastInput
 */
export type SchemaHidreamI1FastInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number | unknown
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
}

/**
 * Output
 */
export type SchemaHidreamI1DevOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * DevInput
 */
export type SchemaHidreamI1DevInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
}

export type SchemaHidreamI1FullOutput = unknown

/**
 * TextToImageInput
 */
export type SchemaHidreamI1FullInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Loras
   *
   * A list of LoRAs to apply to the model. Each LoRA specifies its path, scale, and optional weight name.
   */
  loras?: Array<SchemaLoraWeight>
  /**
   * Guidance scale (CFG)
   *
   *
   * The CFG (Classifier Free Guidance) scale is a measure of how close you want
   * the model to stick to your prompt when looking for a related image to show you.
   *
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Negative Prompt
   *
   *
   * The negative prompt to use. Use it to address details that you don't want
   * in the image. This could be colors, objects, scenery and even the small details
   * (e.g. moustache, blurry, low resolution).
   *
   */
  negative_prompt?: string
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Imagen4TextToImageFastOutput
 */
export type SchemaImagen4PreviewFastOutput = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImageFile>
  /**
   * Description
   *
   * The description of the generated images.
   */
  description: string
}

/**
 * Imagen4TextToImageFastInput
 */
export type SchemaImagen4PreviewFastInput = {
  /**
   * Prompt
   *
   * The text prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?: '1:1' | '16:9' | '9:16' | '4:3' | '3:4'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
}

/**
 * OutputModel
 */
export type SchemaTextToImage32Output = {
  image: SchemaImage
}

/**
 * InputModel
 */
export type SchemaTextToImage32Input = {
  /**
   * Prompt
   *
   * Prompt for image generation.
   */
  prompt: string
  /**
   * Aspect Ratio
   *
   * Aspect ratio. Options: 1:1, 2:3, 3:2, 3:4, 4:3, 4:5, 5:4, 9:16, 16:9
   */
  aspect_ratio?:
    | '1:1'
    | '2:3'
    | '3:2'
    | '3:4'
    | '4:3'
    | '4:5'
    | '5:4'
    | '9:16'
    | '16:9'
  /**
   * Prompt Enhancer
   *
   * Whether to improve the prompt.
   */
  prompt_enhancer?: boolean
  /**
   * Sync Mode
   *
   * If true, returns the image directly in the response (increases latency).
   */
  sync_mode?: boolean
  /**
   * Truncate Prompt
   *
   * Whether to truncate the prompt.
   */
  truncate_prompt?: boolean
  /**
   * Guidance Scale
   *
   * Guidance scale for text.
   */
  guidance_scale?: number
  /**
   * Num Inference Steps
   *
   * Number of inference steps.
   */
  num_inference_steps?: number
  /**
   * Seed
   *
   * Random seed for reproducibility.
   */
  seed?: number
  /**
   * Negative Prompt
   *
   * Negative prompt for image generation.
   */
  negative_prompt?: string
}

/**
 * Flux2ProOutput
 */
export type SchemaFlux2ProOutput = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   * The seed used for the generation.
   */
  seed: number
}

/**
 * Flux2ProTextToImageInput
 */
export type SchemaFlux2ProInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Image Size
   *
   * The size of the generated image.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5'
  /**
   * Enable Safety Checker
   *
   * Whether to enable the safety checker.
   */
  enable_safety_checker?: boolean
  /**
   * Seed
   *
   * The seed to use for the generation.
   */
  seed?: number
}

/**
 * Flux2T2IOutput
 */
export type SchemaFlux2Output = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * Flux2TextToImageInput
 */
export type SchemaFlux2Input = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the image to generate. The width and height must be between 512 and 2048 pixels.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The acceleration level to use for the image generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
  /**
   * Enable Prompt Expansion
   *
   * If set to true, the prompt will be expanded for better results.
   */
  enable_prompt_expansion?: boolean
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * Flux2T2ILoRAOutput
 */
export type SchemaFlux2LoraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated images
   */
  images: Array<SchemaImageFile>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
}

/**
 * Flux2TextToImageLoRAInput
 */
export type SchemaFlux2LoraInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Image Size
   *
   * The size of the image to generate. The width and height must be between 512 and 2048 pixels.
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Acceleration
   *
   * The acceleration level to use for the image generation.
   */
  acceleration?: 'none' | 'regular' | 'high'
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
  /**
   * Loras
   *
   * List of LoRA weights to apply (maximum 3). Each LoRA can be a URL, HuggingFace repo ID, or local path.
   */
  loras?: Array<SchemaLoRaInput>
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Guidance Scale
   *
   * Guidance Scale is a measure of how close you want the model to stick to your prompt when looking for a related image to show you.
   */
  guidance_scale?: number
  /**
   * Seed
   *
   * The seed to use for the generation. If not provided, a random seed will be used.
   */
  seed?: number
  /**
   * Number of Inference Steps
   *
   * The number of inference steps to perform.
   */
  num_inference_steps?: number
  /**
   * Enable Prompt Expansion
   *
   * If set to true, the prompt will be expanded for better results.
   */
  enable_prompt_expansion?: boolean
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
}

/**
 * TextToImageOutput
 */
export type SchemaRecraftV3TextToImageOutput = {
  /**
   * Images
   */
  images: Array<SchemaFile>
}

/**
 * TextToImageInput
 */
export type SchemaRecraftV3TextToImageInput = {
  /**
   * Prompt
   */
  prompt: string
  /**
   * Image Size
   */
  image_size?:
    | SchemaImageSize
    | 'square_hd'
    | 'square'
    | 'portrait_4_3'
    | 'portrait_16_9'
    | 'landscape_4_3'
    | 'landscape_16_9'
  /**
   * Style
   *
   * The style of the generated images. Vector images cost 2X as much.
   */
  style?:
    | 'any'
    | 'realistic_image'
    | 'digital_illustration'
    | 'vector_illustration'
    | 'realistic_image/b_and_w'
    | 'realistic_image/hard_flash'
    | 'realistic_image/hdr'
    | 'realistic_image/natural_light'
    | 'realistic_image/studio_portrait'
    | 'realistic_image/enterprise'
    | 'realistic_image/motion_blur'
    | 'realistic_image/evening_light'
    | 'realistic_image/faded_nostalgia'
    | 'realistic_image/forest_life'
    | 'realistic_image/mystic_naturalism'
    | 'realistic_image/natural_tones'
    | 'realistic_image/organic_calm'
    | 'realistic_image/real_life_glow'
    | 'realistic_image/retro_realism'
    | 'realistic_image/retro_snapshot'
    | 'realistic_image/urban_drama'
    | 'realistic_image/village_realism'
    | 'realistic_image/warm_folk'
    | 'digital_illustration/pixel_art'
    | 'digital_illustration/hand_drawn'
    | 'digital_illustration/grain'
    | 'digital_illustration/infantile_sketch'
    | 'digital_illustration/2d_art_poster'
    | 'digital_illustration/handmade_3d'
    | 'digital_illustration/hand_drawn_outline'
    | 'digital_illustration/engraving_color'
    | 'digital_illustration/2d_art_poster_2'
    | 'digital_illustration/antiquarian'
    | 'digital_illustration/bold_fantasy'
    | 'digital_illustration/child_book'
    | 'digital_illustration/child_books'
    | 'digital_illustration/cover'
    | 'digital_illustration/crosshatch'
    | 'digital_illustration/digital_engraving'
    | 'digital_illustration/expressionism'
    | 'digital_illustration/freehand_details'
    | 'digital_illustration/grain_20'
    | 'digital_illustration/graphic_intensity'
    | 'digital_illustration/hard_comics'
    | 'digital_illustration/long_shadow'
    | 'digital_illustration/modern_folk'
    | 'digital_illustration/multicolor'
    | 'digital_illustration/neon_calm'
    | 'digital_illustration/noir'
    | 'digital_illustration/nostalgic_pastel'
    | 'digital_illustration/outline_details'
    | 'digital_illustration/pastel_gradient'
    | 'digital_illustration/pastel_sketch'
    | 'digital_illustration/pop_art'
    | 'digital_illustration/pop_renaissance'
    | 'digital_illustration/street_art'
    | 'digital_illustration/tablet_sketch'
    | 'digital_illustration/urban_glow'
    | 'digital_illustration/urban_sketching'
    | 'digital_illustration/vanilla_dreams'
    | 'digital_illustration/young_adult_book'
    | 'digital_illustration/young_adult_book_2'
    | 'vector_illustration/bold_stroke'
    | 'vector_illustration/chemistry'
    | 'vector_illustration/colored_stencil'
    | 'vector_illustration/contour_pop_art'
    | 'vector_illustration/cosmics'
    | 'vector_illustration/cutout'
    | 'vector_illustration/depressive'
    | 'vector_illustration/editorial'
    | 'vector_illustration/emotional_flat'
    | 'vector_illustration/infographical'
    | 'vector_illustration/marker_outline'
    | 'vector_illustration/mosaic'
    | 'vector_illustration/naivector'
    | 'vector_illustration/roundish_flat'
    | 'vector_illustration/segmented_colors'
    | 'vector_illustration/sharp_contrast'
    | 'vector_illustration/thin'
    | 'vector_illustration/vector_photo'
    | 'vector_illustration/vivid_shapes'
    | 'vector_illustration/engraving'
    | 'vector_illustration/line_art'
    | 'vector_illustration/line_circuit'
    | 'vector_illustration/linocut'
  /**
   * Colors
   *
   * An array of preferable colors
   */
  colors?: Array<SchemaRgbColor>
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Style Id
   *
   * The ID of the custom style reference (optional)
   */
  style_id?: string
}

/**
 * Output
 */
export type SchemaFluxProV11UltraOutput = {
  /**
   * Prompt
   *
   * The prompt used for generating the image.
   */
  prompt: string
  /**
   * Images
   *
   * The generated image files info.
   */
  images: Array<SchemaRegistryImageFastSdxlModelsImage>
  /**
   * Timings
   */
  timings: {
    [key: string]: number
  }
  /**
   * Has Nsfw Concepts
   *
   * Whether the generated images contain NSFW concepts.
   */
  has_nsfw_concepts: Array<boolean>
  /**
   * Seed
   *
   *
   * Seed of the generated Image. It will be the same value of the one passed in the
   * input or the randomly generated that was used in case none was passed.
   *
   */
  seed: number
}

/**
 * FluxProUltraTextToImageInput
 */
export type SchemaFluxProV11UltraInput = {
  /**
   * Prompt
   *
   * The prompt to generate an image from.
   */
  prompt: string
  /**
   * Num Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?:
    | '21:9'
    | '16:9'
    | '4:3'
    | '3:2'
    | '1:1'
    | '2:3'
    | '3:4'
    | '9:16'
    | '9:21'
    | string
  /**
   * Enhance Prompt
   *
   * Whether to enhance the prompt for better results.
   */
  enhance_prompt?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png'
  /**
   * Image URL
   *
   * The image URL to generate an image from.
   */
  image_url?: string
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Safety Tolerance
   *
   * The safety tolerance level for the generated image. 1 being the most strict and 5 being the most permissive.
   */
  safety_tolerance?: '1' | '2' | '3' | '4' | '5' | '6'
  /**
   * Image Prompt Strength
   *
   * The strength of the image prompt, between 0 and 1.
   */
  image_prompt_strength?: number
  /**
   * Seed
   *
   *
   * The same seed and the same prompt given to the same version of the model
   * will output the same image every time.
   *
   */
  seed?: number
  /**
   * Enable Safety Checker
   *
   * If set to true, the safety checker will be enabled.
   */
  enable_safety_checker?: boolean
  /**
   * Raw
   *
   * Generate less processed, more natural-looking images.
   */
  raw?: boolean
}

/**
 * Imagen4TextToImageOutput
 */
export type SchemaImagen4PreviewOutput = {
  /**
   * Images
   *
   * The generated images.
   */
  images: Array<SchemaImageFile>
  /**
   * Description
   *
   * The description of the generated images.
   */
  description: string
}

/**
 * Imagen4TextToImageInput
 */
export type SchemaImagen4PreviewInput = {
  /**
   * Prompt
   *
   * The text prompt to generate an image from.
   */
  prompt: string
  /**
   * Number of Images
   *
   * The number of images to generate.
   */
  num_images?: number
  /**
   * Aspect Ratio
   *
   * The aspect ratio of the generated image.
   */
  aspect_ratio?: '1:1' | '16:9' | '9:16' | '4:3' | '3:4'
  /**
   * Resolution
   *
   * The resolution of the generated image.
   */
  resolution?: '1K' | '2K'
  /**
   * Sync Mode
   *
   * If `True`, the media will be returned as a data URI and the output data won't be available in the request history.
   */
  sync_mode?: boolean
  /**
   * Output Format
   *
   * The format of the generated image.
   */
  output_format?: 'jpeg' | 'png' | 'webp'
}

export type SchemaQueueStatus = {
  status: 'IN_QUEUE' | 'IN_PROGRESS' | 'COMPLETED'
  /**
   * The request id.
   */
  request_id: string
  /**
   * The response url.
   */
  response_url?: string
  /**
   * The status url.
   */
  status_url?: string
  /**
   * The cancel url.
   */
  cancel_url?: string
  /**
   * The logs.
   */
  logs?: {
    [key: string]: unknown
  }
  /**
   * The metrics.
   */
  metrics?: {
    [key: string]: unknown
  }
  /**
   * The queue position.
   */
  queue_position?: number
}

export type GetFalAiImagen4PreviewRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/imagen4/preview/requests/{request_id}/status'
}

export type GetFalAiImagen4PreviewRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImagen4PreviewRequestsByRequestIdStatusResponse =
  GetFalAiImagen4PreviewRequestsByRequestIdStatusResponses[keyof GetFalAiImagen4PreviewRequestsByRequestIdStatusResponses]

export type PutFalAiImagen4PreviewRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/imagen4/preview/requests/{request_id}/cancel'
}

export type PutFalAiImagen4PreviewRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImagen4PreviewRequestsByRequestIdCancelResponse =
  PutFalAiImagen4PreviewRequestsByRequestIdCancelResponses[keyof PutFalAiImagen4PreviewRequestsByRequestIdCancelResponses]

export type PostFalAiImagen4PreviewData = {
  body: SchemaImagen4PreviewInput
  path?: never
  query?: never
  url: '/fal-ai/imagen4/preview'
}

export type PostFalAiImagen4PreviewResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImagen4PreviewResponse =
  PostFalAiImagen4PreviewResponses[keyof PostFalAiImagen4PreviewResponses]

export type GetFalAiImagen4PreviewRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/imagen4/preview/requests/{request_id}'
}

export type GetFalAiImagen4PreviewRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImagen4PreviewOutput
}

export type GetFalAiImagen4PreviewRequestsByRequestIdResponse =
  GetFalAiImagen4PreviewRequestsByRequestIdResponses[keyof GetFalAiImagen4PreviewRequestsByRequestIdResponses]

export type GetFalAiFluxProV11UltraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-pro/v1.1-ultra/requests/{request_id}/status'
}

export type GetFalAiFluxProV11UltraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxProV11UltraRequestsByRequestIdStatusResponse =
  GetFalAiFluxProV11UltraRequestsByRequestIdStatusResponses[keyof GetFalAiFluxProV11UltraRequestsByRequestIdStatusResponses]

export type PutFalAiFluxProV11UltraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/v1.1-ultra/requests/{request_id}/cancel'
}

export type PutFalAiFluxProV11UltraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxProV11UltraRequestsByRequestIdCancelResponse =
  PutFalAiFluxProV11UltraRequestsByRequestIdCancelResponses[keyof PutFalAiFluxProV11UltraRequestsByRequestIdCancelResponses]

export type PostFalAiFluxProV11UltraData = {
  body: SchemaFluxProV11UltraInput
  path?: never
  query?: never
  url: '/fal-ai/flux-pro/v1.1-ultra'
}

export type PostFalAiFluxProV11UltraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxProV11UltraResponse =
  PostFalAiFluxProV11UltraResponses[keyof PostFalAiFluxProV11UltraResponses]

export type GetFalAiFluxProV11UltraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/v1.1-ultra/requests/{request_id}'
}

export type GetFalAiFluxProV11UltraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxProV11UltraOutput
}

export type GetFalAiFluxProV11UltraRequestsByRequestIdResponse =
  GetFalAiFluxProV11UltraRequestsByRequestIdResponses[keyof GetFalAiFluxProV11UltraRequestsByRequestIdResponses]

export type GetFalAiRecraftV3TextToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/recraft/v3/text-to-image/requests/{request_id}/status'
}

export type GetFalAiRecraftV3TextToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiRecraftV3TextToImageRequestsByRequestIdStatusResponse =
  GetFalAiRecraftV3TextToImageRequestsByRequestIdStatusResponses[keyof GetFalAiRecraftV3TextToImageRequestsByRequestIdStatusResponses]

export type PutFalAiRecraftV3TextToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/recraft/v3/text-to-image/requests/{request_id}/cancel'
}

export type PutFalAiRecraftV3TextToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiRecraftV3TextToImageRequestsByRequestIdCancelResponse =
  PutFalAiRecraftV3TextToImageRequestsByRequestIdCancelResponses[keyof PutFalAiRecraftV3TextToImageRequestsByRequestIdCancelResponses]

export type PostFalAiRecraftV3TextToImageData = {
  body: SchemaRecraftV3TextToImageInput
  path?: never
  query?: never
  url: '/fal-ai/recraft/v3/text-to-image'
}

export type PostFalAiRecraftV3TextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiRecraftV3TextToImageResponse =
  PostFalAiRecraftV3TextToImageResponses[keyof PostFalAiRecraftV3TextToImageResponses]

export type GetFalAiRecraftV3TextToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/recraft/v3/text-to-image/requests/{request_id}'
}

export type GetFalAiRecraftV3TextToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaRecraftV3TextToImageOutput
}

export type GetFalAiRecraftV3TextToImageRequestsByRequestIdResponse =
  GetFalAiRecraftV3TextToImageRequestsByRequestIdResponses[keyof GetFalAiRecraftV3TextToImageRequestsByRequestIdResponses]

export type GetFalAiFlux2LoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/lora/requests/{request_id}/status'
}

export type GetFalAiFlux2LoraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2LoraRequestsByRequestIdStatusResponse =
  GetFalAiFlux2LoraRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2LoraRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2LoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/lora/requests/{request_id}/cancel'
}

export type PutFalAiFlux2LoraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2LoraRequestsByRequestIdCancelResponse =
  PutFalAiFlux2LoraRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2LoraRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2LoraData = {
  body: SchemaFlux2LoraInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2/lora'
}

export type PostFalAiFlux2LoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2LoraResponse =
  PostFalAiFlux2LoraResponses[keyof PostFalAiFlux2LoraResponses]

export type GetFalAiFlux2LoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/lora/requests/{request_id}'
}

export type GetFalAiFlux2LoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2LoraOutput
}

export type GetFalAiFlux2LoraRequestsByRequestIdResponse =
  GetFalAiFlux2LoraRequestsByRequestIdResponses[keyof GetFalAiFlux2LoraRequestsByRequestIdResponses]

export type GetFalAiFlux2RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/requests/{request_id}/status'
}

export type GetFalAiFlux2RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2RequestsByRequestIdStatusResponse =
  GetFalAiFlux2RequestsByRequestIdStatusResponses[keyof GetFalAiFlux2RequestsByRequestIdStatusResponses]

export type PutFalAiFlux2RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/requests/{request_id}/cancel'
}

export type PutFalAiFlux2RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2RequestsByRequestIdCancelResponse =
  PutFalAiFlux2RequestsByRequestIdCancelResponses[keyof PutFalAiFlux2RequestsByRequestIdCancelResponses]

export type PostFalAiFlux2Data = {
  body: SchemaFlux2Input
  path?: never
  query?: never
  url: '/fal-ai/flux-2'
}

export type PostFalAiFlux2Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2Response =
  PostFalAiFlux2Responses[keyof PostFalAiFlux2Responses]

export type GetFalAiFlux2RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/requests/{request_id}'
}

export type GetFalAiFlux2RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2Output
}

export type GetFalAiFlux2RequestsByRequestIdResponse =
  GetFalAiFlux2RequestsByRequestIdResponses[keyof GetFalAiFlux2RequestsByRequestIdResponses]

export type GetFalAiFlux2ProRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2-pro/requests/{request_id}/status'
}

export type GetFalAiFlux2ProRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2ProRequestsByRequestIdStatusResponse =
  GetFalAiFlux2ProRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2ProRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2ProRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-pro/requests/{request_id}/cancel'
}

export type PutFalAiFlux2ProRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2ProRequestsByRequestIdCancelResponse =
  PutFalAiFlux2ProRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2ProRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2ProData = {
  body: SchemaFlux2ProInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2-pro'
}

export type PostFalAiFlux2ProResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2ProResponse =
  PostFalAiFlux2ProResponses[keyof PostFalAiFlux2ProResponses]

export type GetFalAiFlux2ProRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-pro/requests/{request_id}'
}

export type GetFalAiFlux2ProRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2ProOutput
}

export type GetFalAiFlux2ProRequestsByRequestIdResponse =
  GetFalAiFlux2ProRequestsByRequestIdResponses[keyof GetFalAiFlux2ProRequestsByRequestIdResponses]

export type GetBriaTextToImage32RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/bria/text-to-image/3.2/requests/{request_id}/status'
}

export type GetBriaTextToImage32RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetBriaTextToImage32RequestsByRequestIdStatusResponse =
  GetBriaTextToImage32RequestsByRequestIdStatusResponses[keyof GetBriaTextToImage32RequestsByRequestIdStatusResponses]

export type PutBriaTextToImage32RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/text-to-image/3.2/requests/{request_id}/cancel'
}

export type PutBriaTextToImage32RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutBriaTextToImage32RequestsByRequestIdCancelResponse =
  PutBriaTextToImage32RequestsByRequestIdCancelResponses[keyof PutBriaTextToImage32RequestsByRequestIdCancelResponses]

export type PostBriaTextToImage32Data = {
  body: SchemaTextToImage32Input
  path?: never
  query?: never
  url: '/bria/text-to-image/3.2'
}

export type PostBriaTextToImage32Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostBriaTextToImage32Response =
  PostBriaTextToImage32Responses[keyof PostBriaTextToImage32Responses]

export type GetBriaTextToImage32RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/text-to-image/3.2/requests/{request_id}'
}

export type GetBriaTextToImage32RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaTextToImage32Output
}

export type GetBriaTextToImage32RequestsByRequestIdResponse =
  GetBriaTextToImage32RequestsByRequestIdResponses[keyof GetBriaTextToImage32RequestsByRequestIdResponses]

export type GetFalAiImagen4PreviewFastRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/imagen4/preview/fast/requests/{request_id}/status'
}

export type GetFalAiImagen4PreviewFastRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImagen4PreviewFastRequestsByRequestIdStatusResponse =
  GetFalAiImagen4PreviewFastRequestsByRequestIdStatusResponses[keyof GetFalAiImagen4PreviewFastRequestsByRequestIdStatusResponses]

export type PutFalAiImagen4PreviewFastRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/imagen4/preview/fast/requests/{request_id}/cancel'
}

export type PutFalAiImagen4PreviewFastRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImagen4PreviewFastRequestsByRequestIdCancelResponse =
  PutFalAiImagen4PreviewFastRequestsByRequestIdCancelResponses[keyof PutFalAiImagen4PreviewFastRequestsByRequestIdCancelResponses]

export type PostFalAiImagen4PreviewFastData = {
  body: SchemaImagen4PreviewFastInput
  path?: never
  query?: never
  url: '/fal-ai/imagen4/preview/fast'
}

export type PostFalAiImagen4PreviewFastResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImagen4PreviewFastResponse =
  PostFalAiImagen4PreviewFastResponses[keyof PostFalAiImagen4PreviewFastResponses]

export type GetFalAiImagen4PreviewFastRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/imagen4/preview/fast/requests/{request_id}'
}

export type GetFalAiImagen4PreviewFastRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImagen4PreviewFastOutput
}

export type GetFalAiImagen4PreviewFastRequestsByRequestIdResponse =
  GetFalAiImagen4PreviewFastRequestsByRequestIdResponses[keyof GetFalAiImagen4PreviewFastRequestsByRequestIdResponses]

export type GetFalAiHidreamI1FullRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/hidream-i1-full/requests/{request_id}/status'
}

export type GetFalAiHidreamI1FullRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiHidreamI1FullRequestsByRequestIdStatusResponse =
  GetFalAiHidreamI1FullRequestsByRequestIdStatusResponses[keyof GetFalAiHidreamI1FullRequestsByRequestIdStatusResponses]

export type PutFalAiHidreamI1FullRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/hidream-i1-full/requests/{request_id}/cancel'
}

export type PutFalAiHidreamI1FullRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiHidreamI1FullRequestsByRequestIdCancelResponse =
  PutFalAiHidreamI1FullRequestsByRequestIdCancelResponses[keyof PutFalAiHidreamI1FullRequestsByRequestIdCancelResponses]

export type PostFalAiHidreamI1FullData = {
  body: SchemaHidreamI1FullInput
  path?: never
  query?: never
  url: '/fal-ai/hidream-i1-full'
}

export type PostFalAiHidreamI1FullResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiHidreamI1FullResponse =
  PostFalAiHidreamI1FullResponses[keyof PostFalAiHidreamI1FullResponses]

export type GetFalAiHidreamI1FullRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/hidream-i1-full/requests/{request_id}'
}

export type GetFalAiHidreamI1FullRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaHidreamI1FullOutput
}

export type GetFalAiHidreamI1FullRequestsByRequestIdResponse =
  GetFalAiHidreamI1FullRequestsByRequestIdResponses[keyof GetFalAiHidreamI1FullRequestsByRequestIdResponses]

export type GetFalAiHidreamI1DevRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/hidream-i1-dev/requests/{request_id}/status'
}

export type GetFalAiHidreamI1DevRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiHidreamI1DevRequestsByRequestIdStatusResponse =
  GetFalAiHidreamI1DevRequestsByRequestIdStatusResponses[keyof GetFalAiHidreamI1DevRequestsByRequestIdStatusResponses]

export type PutFalAiHidreamI1DevRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/hidream-i1-dev/requests/{request_id}/cancel'
}

export type PutFalAiHidreamI1DevRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiHidreamI1DevRequestsByRequestIdCancelResponse =
  PutFalAiHidreamI1DevRequestsByRequestIdCancelResponses[keyof PutFalAiHidreamI1DevRequestsByRequestIdCancelResponses]

export type PostFalAiHidreamI1DevData = {
  body: SchemaHidreamI1DevInput
  path?: never
  query?: never
  url: '/fal-ai/hidream-i1-dev'
}

export type PostFalAiHidreamI1DevResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiHidreamI1DevResponse =
  PostFalAiHidreamI1DevResponses[keyof PostFalAiHidreamI1DevResponses]

export type GetFalAiHidreamI1DevRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/hidream-i1-dev/requests/{request_id}'
}

export type GetFalAiHidreamI1DevRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaHidreamI1DevOutput
}

export type GetFalAiHidreamI1DevRequestsByRequestIdResponse =
  GetFalAiHidreamI1DevRequestsByRequestIdResponses[keyof GetFalAiHidreamI1DevRequestsByRequestIdResponses]

export type GetFalAiHidreamI1FastRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/hidream-i1-fast/requests/{request_id}/status'
}

export type GetFalAiHidreamI1FastRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiHidreamI1FastRequestsByRequestIdStatusResponse =
  GetFalAiHidreamI1FastRequestsByRequestIdStatusResponses[keyof GetFalAiHidreamI1FastRequestsByRequestIdStatusResponses]

export type PutFalAiHidreamI1FastRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/hidream-i1-fast/requests/{request_id}/cancel'
}

export type PutFalAiHidreamI1FastRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiHidreamI1FastRequestsByRequestIdCancelResponse =
  PutFalAiHidreamI1FastRequestsByRequestIdCancelResponses[keyof PutFalAiHidreamI1FastRequestsByRequestIdCancelResponses]

export type PostFalAiHidreamI1FastData = {
  body: SchemaHidreamI1FastInput
  path?: never
  query?: never
  url: '/fal-ai/hidream-i1-fast'
}

export type PostFalAiHidreamI1FastResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiHidreamI1FastResponse =
  PostFalAiHidreamI1FastResponses[keyof PostFalAiHidreamI1FastResponses]

export type GetFalAiHidreamI1FastRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/hidream-i1-fast/requests/{request_id}'
}

export type GetFalAiHidreamI1FastRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaHidreamI1FastOutput
}

export type GetFalAiHidreamI1FastRequestsByRequestIdResponse =
  GetFalAiHidreamI1FastRequestsByRequestIdResponses[keyof GetFalAiHidreamI1FastRequestsByRequestIdResponses]

export type GetFalAiFluxDevRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux/dev/requests/{request_id}/status'
}

export type GetFalAiFluxDevRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxDevRequestsByRequestIdStatusResponse =
  GetFalAiFluxDevRequestsByRequestIdStatusResponses[keyof GetFalAiFluxDevRequestsByRequestIdStatusResponses]

export type PutFalAiFluxDevRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/dev/requests/{request_id}/cancel'
}

export type PutFalAiFluxDevRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxDevRequestsByRequestIdCancelResponse =
  PutFalAiFluxDevRequestsByRequestIdCancelResponses[keyof PutFalAiFluxDevRequestsByRequestIdCancelResponses]

export type PostFalAiFluxDevData = {
  body: SchemaFluxDevInput
  path?: never
  query?: never
  url: '/fal-ai/flux/dev'
}

export type PostFalAiFluxDevResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxDevResponse =
  PostFalAiFluxDevResponses[keyof PostFalAiFluxDevResponses]

export type GetFalAiFluxDevRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/dev/requests/{request_id}'
}

export type GetFalAiFluxDevRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxDevOutput
}

export type GetFalAiFluxDevRequestsByRequestIdResponse =
  GetFalAiFluxDevRequestsByRequestIdResponses[keyof GetFalAiFluxDevRequestsByRequestIdResponses]

export type GetFalAiIdeogramV2RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ideogram/v2/requests/{request_id}/status'
}

export type GetFalAiIdeogramV2RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIdeogramV2RequestsByRequestIdStatusResponse =
  GetFalAiIdeogramV2RequestsByRequestIdStatusResponses[keyof GetFalAiIdeogramV2RequestsByRequestIdStatusResponses]

export type PutFalAiIdeogramV2RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2/requests/{request_id}/cancel'
}

export type PutFalAiIdeogramV2RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIdeogramV2RequestsByRequestIdCancelResponse =
  PutFalAiIdeogramV2RequestsByRequestIdCancelResponses[keyof PutFalAiIdeogramV2RequestsByRequestIdCancelResponses]

export type PostFalAiIdeogramV2Data = {
  body: SchemaIdeogramV2Input
  path?: never
  query?: never
  url: '/fal-ai/ideogram/v2'
}

export type PostFalAiIdeogramV2Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIdeogramV2Response =
  PostFalAiIdeogramV2Responses[keyof PostFalAiIdeogramV2Responses]

export type GetFalAiIdeogramV2RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2/requests/{request_id}'
}

export type GetFalAiIdeogramV2RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIdeogramV2Output
}

export type GetFalAiIdeogramV2RequestsByRequestIdResponse =
  GetFalAiIdeogramV2RequestsByRequestIdResponses[keyof GetFalAiIdeogramV2RequestsByRequestIdResponses]

export type GetFalAiStableDiffusionV35LargeRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/stable-diffusion-v35-large/requests/{request_id}/status'
}

export type GetFalAiStableDiffusionV35LargeRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiStableDiffusionV35LargeRequestsByRequestIdStatusResponse =
  GetFalAiStableDiffusionV35LargeRequestsByRequestIdStatusResponses[keyof GetFalAiStableDiffusionV35LargeRequestsByRequestIdStatusResponses]

export type PutFalAiStableDiffusionV35LargeRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/stable-diffusion-v35-large/requests/{request_id}/cancel'
}

export type PutFalAiStableDiffusionV35LargeRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiStableDiffusionV35LargeRequestsByRequestIdCancelResponse =
  PutFalAiStableDiffusionV35LargeRequestsByRequestIdCancelResponses[keyof PutFalAiStableDiffusionV35LargeRequestsByRequestIdCancelResponses]

export type PostFalAiStableDiffusionV35LargeData = {
  body: SchemaStableDiffusionV35LargeInput
  path?: never
  query?: never
  url: '/fal-ai/stable-diffusion-v35-large'
}

export type PostFalAiStableDiffusionV35LargeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiStableDiffusionV35LargeResponse =
  PostFalAiStableDiffusionV35LargeResponses[keyof PostFalAiStableDiffusionV35LargeResponses]

export type GetFalAiStableDiffusionV35LargeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/stable-diffusion-v35-large/requests/{request_id}'
}

export type GetFalAiStableDiffusionV35LargeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaStableDiffusionV35LargeOutput
}

export type GetFalAiStableDiffusionV35LargeRequestsByRequestIdResponse =
  GetFalAiStableDiffusionV35LargeRequestsByRequestIdResponses[keyof GetFalAiStableDiffusionV35LargeRequestsByRequestIdResponses]

export type GetFalAiFluxGeneralRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-general/requests/{request_id}/status'
}

export type GetFalAiFluxGeneralRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxGeneralRequestsByRequestIdStatusResponse =
  GetFalAiFluxGeneralRequestsByRequestIdStatusResponses[keyof GetFalAiFluxGeneralRequestsByRequestIdStatusResponses]

export type PutFalAiFluxGeneralRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-general/requests/{request_id}/cancel'
}

export type PutFalAiFluxGeneralRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxGeneralRequestsByRequestIdCancelResponse =
  PutFalAiFluxGeneralRequestsByRequestIdCancelResponses[keyof PutFalAiFluxGeneralRequestsByRequestIdCancelResponses]

export type PostFalAiFluxGeneralData = {
  body: SchemaFluxGeneralInput
  path?: never
  query?: never
  url: '/fal-ai/flux-general'
}

export type PostFalAiFluxGeneralResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxGeneralResponse =
  PostFalAiFluxGeneralResponses[keyof PostFalAiFluxGeneralResponses]

export type GetFalAiFluxGeneralRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-general/requests/{request_id}'
}

export type GetFalAiFluxGeneralRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxGeneralOutput
}

export type GetFalAiFluxGeneralRequestsByRequestIdResponse =
  GetFalAiFluxGeneralRequestsByRequestIdResponses[keyof GetFalAiFluxGeneralRequestsByRequestIdResponses]

export type GetFalAiFluxLoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-lora/requests/{request_id}/status'
}

export type GetFalAiFluxLoraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxLoraRequestsByRequestIdStatusResponse =
  GetFalAiFluxLoraRequestsByRequestIdStatusResponses[keyof GetFalAiFluxLoraRequestsByRequestIdStatusResponses]

export type PutFalAiFluxLoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-lora/requests/{request_id}/cancel'
}

export type PutFalAiFluxLoraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxLoraRequestsByRequestIdCancelResponse =
  PutFalAiFluxLoraRequestsByRequestIdCancelResponses[keyof PutFalAiFluxLoraRequestsByRequestIdCancelResponses]

export type PostFalAiFluxLoraData = {
  body: SchemaFluxLoraInput
  path?: never
  query?: never
  url: '/fal-ai/flux-lora'
}

export type PostFalAiFluxLoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxLoraResponse =
  PostFalAiFluxLoraResponses[keyof PostFalAiFluxLoraResponses]

export type GetFalAiFluxLoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-lora/requests/{request_id}'
}

export type GetFalAiFluxLoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxLoraOutput
}

export type GetFalAiFluxLoraRequestsByRequestIdResponse =
  GetFalAiFluxLoraRequestsByRequestIdResponses[keyof GetFalAiFluxLoraRequestsByRequestIdResponses]

export type GetFalAiZImageBaseLoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/z-image/base/lora/requests/{request_id}/status'
}

export type GetFalAiZImageBaseLoraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiZImageBaseLoraRequestsByRequestIdStatusResponse =
  GetFalAiZImageBaseLoraRequestsByRequestIdStatusResponses[keyof GetFalAiZImageBaseLoraRequestsByRequestIdStatusResponses]

export type PutFalAiZImageBaseLoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/base/lora/requests/{request_id}/cancel'
}

export type PutFalAiZImageBaseLoraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiZImageBaseLoraRequestsByRequestIdCancelResponse =
  PutFalAiZImageBaseLoraRequestsByRequestIdCancelResponses[keyof PutFalAiZImageBaseLoraRequestsByRequestIdCancelResponses]

export type PostFalAiZImageBaseLoraData = {
  body: SchemaZImageBaseLoraInput
  path?: never
  query?: never
  url: '/fal-ai/z-image/base/lora'
}

export type PostFalAiZImageBaseLoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiZImageBaseLoraResponse =
  PostFalAiZImageBaseLoraResponses[keyof PostFalAiZImageBaseLoraResponses]

export type GetFalAiZImageBaseLoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/base/lora/requests/{request_id}'
}

export type GetFalAiZImageBaseLoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaZImageBaseLoraOutput
}

export type GetFalAiZImageBaseLoraRequestsByRequestIdResponse =
  GetFalAiZImageBaseLoraRequestsByRequestIdResponses[keyof GetFalAiZImageBaseLoraRequestsByRequestIdResponses]

export type GetFalAiZImageBaseRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/z-image/base/requests/{request_id}/status'
}

export type GetFalAiZImageBaseRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiZImageBaseRequestsByRequestIdStatusResponse =
  GetFalAiZImageBaseRequestsByRequestIdStatusResponses[keyof GetFalAiZImageBaseRequestsByRequestIdStatusResponses]

export type PutFalAiZImageBaseRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/base/requests/{request_id}/cancel'
}

export type PutFalAiZImageBaseRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiZImageBaseRequestsByRequestIdCancelResponse =
  PutFalAiZImageBaseRequestsByRequestIdCancelResponses[keyof PutFalAiZImageBaseRequestsByRequestIdCancelResponses]

export type PostFalAiZImageBaseData = {
  body: SchemaZImageBaseInput
  path?: never
  query?: never
  url: '/fal-ai/z-image/base'
}

export type PostFalAiZImageBaseResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiZImageBaseResponse =
  PostFalAiZImageBaseResponses[keyof PostFalAiZImageBaseResponses]

export type GetFalAiZImageBaseRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/base/requests/{request_id}'
}

export type GetFalAiZImageBaseRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaZImageBaseOutput
}

export type GetFalAiZImageBaseRequestsByRequestIdResponse =
  GetFalAiZImageBaseRequestsByRequestIdResponses[keyof GetFalAiZImageBaseRequestsByRequestIdResponses]

export type GetFalAiFlux2Klein9bBaseLoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/klein/9b/base/lora/requests/{request_id}/status'
}

export type GetFalAiFlux2Klein9bBaseLoraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2Klein9bBaseLoraRequestsByRequestIdStatusResponse =
  GetFalAiFlux2Klein9bBaseLoraRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2Klein9bBaseLoraRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2Klein9bBaseLoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/9b/base/lora/requests/{request_id}/cancel'
}

export type PutFalAiFlux2Klein9bBaseLoraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2Klein9bBaseLoraRequestsByRequestIdCancelResponse =
  PutFalAiFlux2Klein9bBaseLoraRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2Klein9bBaseLoraRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2Klein9bBaseLoraData = {
  body: SchemaFlux2Klein9bBaseLoraInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2/klein/9b/base/lora'
}

export type PostFalAiFlux2Klein9bBaseLoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2Klein9bBaseLoraResponse =
  PostFalAiFlux2Klein9bBaseLoraResponses[keyof PostFalAiFlux2Klein9bBaseLoraResponses]

export type GetFalAiFlux2Klein9bBaseLoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/9b/base/lora/requests/{request_id}'
}

export type GetFalAiFlux2Klein9bBaseLoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2Klein9bBaseLoraOutput
}

export type GetFalAiFlux2Klein9bBaseLoraRequestsByRequestIdResponse =
  GetFalAiFlux2Klein9bBaseLoraRequestsByRequestIdResponses[keyof GetFalAiFlux2Klein9bBaseLoraRequestsByRequestIdResponses]

export type GetFalAiFlux2Klein4bBaseLoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/klein/4b/base/lora/requests/{request_id}/status'
}

export type GetFalAiFlux2Klein4bBaseLoraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2Klein4bBaseLoraRequestsByRequestIdStatusResponse =
  GetFalAiFlux2Klein4bBaseLoraRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2Klein4bBaseLoraRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2Klein4bBaseLoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/4b/base/lora/requests/{request_id}/cancel'
}

export type PutFalAiFlux2Klein4bBaseLoraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2Klein4bBaseLoraRequestsByRequestIdCancelResponse =
  PutFalAiFlux2Klein4bBaseLoraRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2Klein4bBaseLoraRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2Klein4bBaseLoraData = {
  body: SchemaFlux2Klein4bBaseLoraInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2/klein/4b/base/lora'
}

export type PostFalAiFlux2Klein4bBaseLoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2Klein4bBaseLoraResponse =
  PostFalAiFlux2Klein4bBaseLoraResponses[keyof PostFalAiFlux2Klein4bBaseLoraResponses]

export type GetFalAiFlux2Klein4bBaseLoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/4b/base/lora/requests/{request_id}'
}

export type GetFalAiFlux2Klein4bBaseLoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2Klein4bBaseLoraOutput
}

export type GetFalAiFlux2Klein4bBaseLoraRequestsByRequestIdResponse =
  GetFalAiFlux2Klein4bBaseLoraRequestsByRequestIdResponses[keyof GetFalAiFlux2Klein4bBaseLoraRequestsByRequestIdResponses]

export type GetFalAiFlux2Klein9bBaseRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/klein/9b/base/requests/{request_id}/status'
}

export type GetFalAiFlux2Klein9bBaseRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2Klein9bBaseRequestsByRequestIdStatusResponse =
  GetFalAiFlux2Klein9bBaseRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2Klein9bBaseRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2Klein9bBaseRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/9b/base/requests/{request_id}/cancel'
}

export type PutFalAiFlux2Klein9bBaseRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2Klein9bBaseRequestsByRequestIdCancelResponse =
  PutFalAiFlux2Klein9bBaseRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2Klein9bBaseRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2Klein9bBaseData = {
  body: SchemaFlux2Klein9bBaseInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2/klein/9b/base'
}

export type PostFalAiFlux2Klein9bBaseResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2Klein9bBaseResponse =
  PostFalAiFlux2Klein9bBaseResponses[keyof PostFalAiFlux2Klein9bBaseResponses]

export type GetFalAiFlux2Klein9bBaseRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/9b/base/requests/{request_id}'
}

export type GetFalAiFlux2Klein9bBaseRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2Klein9bBaseOutput
}

export type GetFalAiFlux2Klein9bBaseRequestsByRequestIdResponse =
  GetFalAiFlux2Klein9bBaseRequestsByRequestIdResponses[keyof GetFalAiFlux2Klein9bBaseRequestsByRequestIdResponses]

export type GetFalAiFlux2Klein4bBaseRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/klein/4b/base/requests/{request_id}/status'
}

export type GetFalAiFlux2Klein4bBaseRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2Klein4bBaseRequestsByRequestIdStatusResponse =
  GetFalAiFlux2Klein4bBaseRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2Klein4bBaseRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2Klein4bBaseRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/4b/base/requests/{request_id}/cancel'
}

export type PutFalAiFlux2Klein4bBaseRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2Klein4bBaseRequestsByRequestIdCancelResponse =
  PutFalAiFlux2Klein4bBaseRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2Klein4bBaseRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2Klein4bBaseData = {
  body: SchemaFlux2Klein4bBaseInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2/klein/4b/base'
}

export type PostFalAiFlux2Klein4bBaseResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2Klein4bBaseResponse =
  PostFalAiFlux2Klein4bBaseResponses[keyof PostFalAiFlux2Klein4bBaseResponses]

export type GetFalAiFlux2Klein4bBaseRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/4b/base/requests/{request_id}'
}

export type GetFalAiFlux2Klein4bBaseRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2Klein4bBaseOutput
}

export type GetFalAiFlux2Klein4bBaseRequestsByRequestIdResponse =
  GetFalAiFlux2Klein4bBaseRequestsByRequestIdResponses[keyof GetFalAiFlux2Klein4bBaseRequestsByRequestIdResponses]

export type GetFalAiFlux2Klein9bRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/klein/9b/requests/{request_id}/status'
}

export type GetFalAiFlux2Klein9bRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2Klein9bRequestsByRequestIdStatusResponse =
  GetFalAiFlux2Klein9bRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2Klein9bRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2Klein9bRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/9b/requests/{request_id}/cancel'
}

export type PutFalAiFlux2Klein9bRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2Klein9bRequestsByRequestIdCancelResponse =
  PutFalAiFlux2Klein9bRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2Klein9bRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2Klein9bData = {
  body: SchemaFlux2Klein9bInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2/klein/9b'
}

export type PostFalAiFlux2Klein9bResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2Klein9bResponse =
  PostFalAiFlux2Klein9bResponses[keyof PostFalAiFlux2Klein9bResponses]

export type GetFalAiFlux2Klein9bRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/9b/requests/{request_id}'
}

export type GetFalAiFlux2Klein9bRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2Klein9bOutput
}

export type GetFalAiFlux2Klein9bRequestsByRequestIdResponse =
  GetFalAiFlux2Klein9bRequestsByRequestIdResponses[keyof GetFalAiFlux2Klein9bRequestsByRequestIdResponses]

export type GetFalAiFlux2Klein4bRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/klein/4b/requests/{request_id}/status'
}

export type GetFalAiFlux2Klein4bRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2Klein4bRequestsByRequestIdStatusResponse =
  GetFalAiFlux2Klein4bRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2Klein4bRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2Klein4bRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/4b/requests/{request_id}/cancel'
}

export type PutFalAiFlux2Klein4bRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2Klein4bRequestsByRequestIdCancelResponse =
  PutFalAiFlux2Klein4bRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2Klein4bRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2Klein4bData = {
  body: SchemaFlux2Klein4bInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2/klein/4b'
}

export type PostFalAiFlux2Klein4bResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2Klein4bResponse =
  PostFalAiFlux2Klein4bResponses[keyof PostFalAiFlux2Klein4bResponses]

export type GetFalAiFlux2Klein4bRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/klein/4b/requests/{request_id}'
}

export type GetFalAiFlux2Klein4bRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2Klein4bOutput
}

export type GetFalAiFlux2Klein4bRequestsByRequestIdResponse =
  GetFalAiFlux2Klein4bRequestsByRequestIdResponses[keyof GetFalAiFlux2Klein4bRequestsByRequestIdResponses]

export type GetImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/imagineart/imagineart-1.5-pro-preview/text-to-image/requests/{request_id}/status'
  }

export type GetImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdStatusResponse =
  GetImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdStatusResponses[keyof GetImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdStatusResponses]

export type PutImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/imagineart/imagineart-1.5-pro-preview/text-to-image/requests/{request_id}/cancel'
  }

export type PutImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdCancelResponse =
  PutImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdCancelResponses[keyof PutImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdCancelResponses]

export type PostImagineartImagineart15ProPreviewTextToImageData = {
  body: SchemaImagineart15ProPreviewTextToImageInput
  path?: never
  query?: never
  url: '/imagineart/imagineart-1.5-pro-preview/text-to-image'
}

export type PostImagineartImagineart15ProPreviewTextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostImagineartImagineart15ProPreviewTextToImageResponse =
  PostImagineartImagineart15ProPreviewTextToImageResponses[keyof PostImagineartImagineart15ProPreviewTextToImageResponses]

export type GetImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/imagineart/imagineart-1.5-pro-preview/text-to-image/requests/{request_id}'
  }

export type GetImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaImagineart15ProPreviewTextToImageOutput
  }

export type GetImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdResponse =
  GetImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdResponses[keyof GetImagineartImagineart15ProPreviewTextToImageRequestsByRequestIdResponses]

export type GetFalAiGlmImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/glm-image/requests/{request_id}/status'
}

export type GetFalAiGlmImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiGlmImageRequestsByRequestIdStatusResponse =
  GetFalAiGlmImageRequestsByRequestIdStatusResponses[keyof GetFalAiGlmImageRequestsByRequestIdStatusResponses]

export type PutFalAiGlmImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/glm-image/requests/{request_id}/cancel'
}

export type PutFalAiGlmImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiGlmImageRequestsByRequestIdCancelResponse =
  PutFalAiGlmImageRequestsByRequestIdCancelResponses[keyof PutFalAiGlmImageRequestsByRequestIdCancelResponses]

export type PostFalAiGlmImageData = {
  body: SchemaGlmImageInput
  path?: never
  query?: never
  url: '/fal-ai/glm-image'
}

export type PostFalAiGlmImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiGlmImageResponse =
  PostFalAiGlmImageResponses[keyof PostFalAiGlmImageResponses]

export type GetFalAiGlmImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/glm-image/requests/{request_id}'
}

export type GetFalAiGlmImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaGlmImageOutput
}

export type GetFalAiGlmImageRequestsByRequestIdResponse =
  GetFalAiGlmImageRequestsByRequestIdResponses[keyof GetFalAiGlmImageRequestsByRequestIdResponses]

export type GetFalAiQwenImage2512LoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/qwen-image-2512/lora/requests/{request_id}/status'
}

export type GetFalAiQwenImage2512LoraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiQwenImage2512LoraRequestsByRequestIdStatusResponse =
  GetFalAiQwenImage2512LoraRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImage2512LoraRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImage2512LoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-2512/lora/requests/{request_id}/cancel'
}

export type PutFalAiQwenImage2512LoraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiQwenImage2512LoraRequestsByRequestIdCancelResponse =
  PutFalAiQwenImage2512LoraRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImage2512LoraRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImage2512LoraData = {
  body: SchemaQwenImage2512LoraInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-2512/lora'
}

export type PostFalAiQwenImage2512LoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImage2512LoraResponse =
  PostFalAiQwenImage2512LoraResponses[keyof PostFalAiQwenImage2512LoraResponses]

export type GetFalAiQwenImage2512LoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-2512/lora/requests/{request_id}'
}

export type GetFalAiQwenImage2512LoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaQwenImage2512LoraOutput
}

export type GetFalAiQwenImage2512LoraRequestsByRequestIdResponse =
  GetFalAiQwenImage2512LoraRequestsByRequestIdResponses[keyof GetFalAiQwenImage2512LoraRequestsByRequestIdResponses]

export type GetFalAiQwenImage2512RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/qwen-image-2512/requests/{request_id}/status'
}

export type GetFalAiQwenImage2512RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiQwenImage2512RequestsByRequestIdStatusResponse =
  GetFalAiQwenImage2512RequestsByRequestIdStatusResponses[keyof GetFalAiQwenImage2512RequestsByRequestIdStatusResponses]

export type PutFalAiQwenImage2512RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-2512/requests/{request_id}/cancel'
}

export type PutFalAiQwenImage2512RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiQwenImage2512RequestsByRequestIdCancelResponse =
  PutFalAiQwenImage2512RequestsByRequestIdCancelResponses[keyof PutFalAiQwenImage2512RequestsByRequestIdCancelResponses]

export type PostFalAiQwenImage2512Data = {
  body: SchemaQwenImage2512Input
  path?: never
  query?: never
  url: '/fal-ai/qwen-image-2512'
}

export type PostFalAiQwenImage2512Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImage2512Response =
  PostFalAiQwenImage2512Responses[keyof PostFalAiQwenImage2512Responses]

export type GetFalAiQwenImage2512RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image-2512/requests/{request_id}'
}

export type GetFalAiQwenImage2512RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaQwenImage2512Output
}

export type GetFalAiQwenImage2512RequestsByRequestIdResponse =
  GetFalAiQwenImage2512RequestsByRequestIdResponses[keyof GetFalAiQwenImage2512RequestsByRequestIdResponses]

export type GetWanV26TextToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/wan/v2.6/text-to-image/requests/{request_id}/status'
}

export type GetWanV26TextToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetWanV26TextToImageRequestsByRequestIdStatusResponse =
  GetWanV26TextToImageRequestsByRequestIdStatusResponses[keyof GetWanV26TextToImageRequestsByRequestIdStatusResponses]

export type PutWanV26TextToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/wan/v2.6/text-to-image/requests/{request_id}/cancel'
}

export type PutWanV26TextToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutWanV26TextToImageRequestsByRequestIdCancelResponse =
  PutWanV26TextToImageRequestsByRequestIdCancelResponses[keyof PutWanV26TextToImageRequestsByRequestIdCancelResponses]

export type PostWanV26TextToImageData = {
  body: SchemaV26TextToImageInput
  path?: never
  query?: never
  url: '/wan/v2.6/text-to-image'
}

export type PostWanV26TextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostWanV26TextToImageResponse =
  PostWanV26TextToImageResponses[keyof PostWanV26TextToImageResponses]

export type GetWanV26TextToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/wan/v2.6/text-to-image/requests/{request_id}'
}

export type GetWanV26TextToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaV26TextToImageOutput
}

export type GetWanV26TextToImageRequestsByRequestIdResponse =
  GetWanV26TextToImageRequestsByRequestIdResponses[keyof GetWanV26TextToImageRequestsByRequestIdResponses]

export type GetFalAiFlux2FlashRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/flash/requests/{request_id}/status'
}

export type GetFalAiFlux2FlashRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2FlashRequestsByRequestIdStatusResponse =
  GetFalAiFlux2FlashRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2FlashRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2FlashRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/flash/requests/{request_id}/cancel'
}

export type PutFalAiFlux2FlashRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2FlashRequestsByRequestIdCancelResponse =
  PutFalAiFlux2FlashRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2FlashRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2FlashData = {
  body: SchemaFlux2FlashInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2/flash'
}

export type PostFalAiFlux2FlashResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2FlashResponse =
  PostFalAiFlux2FlashResponses[keyof PostFalAiFlux2FlashResponses]

export type GetFalAiFlux2FlashRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/flash/requests/{request_id}'
}

export type GetFalAiFlux2FlashRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2FlashOutput
}

export type GetFalAiFlux2FlashRequestsByRequestIdResponse =
  GetFalAiFlux2FlashRequestsByRequestIdResponses[keyof GetFalAiFlux2FlashRequestsByRequestIdResponses]

export type GetFalAiGptImage15RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/gpt-image-1.5/requests/{request_id}/status'
}

export type GetFalAiGptImage15RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiGptImage15RequestsByRequestIdStatusResponse =
  GetFalAiGptImage15RequestsByRequestIdStatusResponses[keyof GetFalAiGptImage15RequestsByRequestIdStatusResponses]

export type PutFalAiGptImage15RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gpt-image-1.5/requests/{request_id}/cancel'
}

export type PutFalAiGptImage15RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiGptImage15RequestsByRequestIdCancelResponse =
  PutFalAiGptImage15RequestsByRequestIdCancelResponses[keyof PutFalAiGptImage15RequestsByRequestIdCancelResponses]

export type PostFalAiGptImage15Data = {
  body: SchemaGptImage15Input
  path?: never
  query?: never
  url: '/fal-ai/gpt-image-1.5'
}

export type PostFalAiGptImage15Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiGptImage15Response =
  PostFalAiGptImage15Responses[keyof PostFalAiGptImage15Responses]

export type GetFalAiGptImage15RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gpt-image-1.5/requests/{request_id}'
}

export type GetFalAiGptImage15RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaGptImage15Output
}

export type GetFalAiGptImage15RequestsByRequestIdResponse =
  GetFalAiGptImage15RequestsByRequestIdResponses[keyof GetFalAiGptImage15RequestsByRequestIdResponses]

export type GetBriaFiboLiteGenerateRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/bria/fibo-lite/generate/requests/{request_id}/status'
}

export type GetBriaFiboLiteGenerateRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetBriaFiboLiteGenerateRequestsByRequestIdStatusResponse =
  GetBriaFiboLiteGenerateRequestsByRequestIdStatusResponses[keyof GetBriaFiboLiteGenerateRequestsByRequestIdStatusResponses]

export type PutBriaFiboLiteGenerateRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-lite/generate/requests/{request_id}/cancel'
}

export type PutBriaFiboLiteGenerateRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutBriaFiboLiteGenerateRequestsByRequestIdCancelResponse =
  PutBriaFiboLiteGenerateRequestsByRequestIdCancelResponses[keyof PutBriaFiboLiteGenerateRequestsByRequestIdCancelResponses]

export type PostBriaFiboLiteGenerateData = {
  body: SchemaFiboLiteGenerateInput
  path?: never
  query?: never
  url: '/bria/fibo-lite/generate'
}

export type PostBriaFiboLiteGenerateResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostBriaFiboLiteGenerateResponse =
  PostBriaFiboLiteGenerateResponses[keyof PostBriaFiboLiteGenerateResponses]

export type GetBriaFiboLiteGenerateRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo-lite/generate/requests/{request_id}'
}

export type GetBriaFiboLiteGenerateRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFiboLiteGenerateOutput
}

export type GetBriaFiboLiteGenerateRequestsByRequestIdResponse =
  GetBriaFiboLiteGenerateRequestsByRequestIdResponses[keyof GetBriaFiboLiteGenerateRequestsByRequestIdResponses]

export type GetFalAiFlux2TurboRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2/turbo/requests/{request_id}/status'
}

export type GetFalAiFlux2TurboRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2TurboRequestsByRequestIdStatusResponse =
  GetFalAiFlux2TurboRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2TurboRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2TurboRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/turbo/requests/{request_id}/cancel'
}

export type PutFalAiFlux2TurboRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2TurboRequestsByRequestIdCancelResponse =
  PutFalAiFlux2TurboRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2TurboRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2TurboData = {
  body: SchemaFlux2TurboInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2/turbo'
}

export type PostFalAiFlux2TurboResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2TurboResponse =
  PostFalAiFlux2TurboResponses[keyof PostFalAiFlux2TurboResponses]

export type GetFalAiFlux2TurboRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2/turbo/requests/{request_id}'
}

export type GetFalAiFlux2TurboRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2TurboOutput
}

export type GetFalAiFlux2TurboRequestsByRequestIdResponse =
  GetFalAiFlux2TurboRequestsByRequestIdResponses[keyof GetFalAiFlux2TurboRequestsByRequestIdResponses]

export type GetFalAiFlux2MaxRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2-max/requests/{request_id}/status'
}

export type GetFalAiFlux2MaxRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2MaxRequestsByRequestIdStatusResponse =
  GetFalAiFlux2MaxRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2MaxRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2MaxRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-max/requests/{request_id}/cancel'
}

export type PutFalAiFlux2MaxRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2MaxRequestsByRequestIdCancelResponse =
  PutFalAiFlux2MaxRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2MaxRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2MaxData = {
  body: SchemaFlux2MaxInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2-max'
}

export type PostFalAiFlux2MaxResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2MaxResponse =
  PostFalAiFlux2MaxResponses[keyof PostFalAiFlux2MaxResponses]

export type GetFalAiFlux2MaxRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-max/requests/{request_id}'
}

export type GetFalAiFlux2MaxRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2MaxOutput
}

export type GetFalAiFlux2MaxRequestsByRequestIdResponse =
  GetFalAiFlux2MaxRequestsByRequestIdResponses[keyof GetFalAiFlux2MaxRequestsByRequestIdResponses]

export type GetFalAiLongcatImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/longcat-image/requests/{request_id}/status'
}

export type GetFalAiLongcatImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLongcatImageRequestsByRequestIdStatusResponse =
  GetFalAiLongcatImageRequestsByRequestIdStatusResponses[keyof GetFalAiLongcatImageRequestsByRequestIdStatusResponses]

export type PutFalAiLongcatImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/longcat-image/requests/{request_id}/cancel'
}

export type PutFalAiLongcatImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLongcatImageRequestsByRequestIdCancelResponse =
  PutFalAiLongcatImageRequestsByRequestIdCancelResponses[keyof PutFalAiLongcatImageRequestsByRequestIdCancelResponses]

export type PostFalAiLongcatImageData = {
  body: SchemaLongcatImageInput
  path?: never
  query?: never
  url: '/fal-ai/longcat-image'
}

export type PostFalAiLongcatImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLongcatImageResponse =
  PostFalAiLongcatImageResponses[keyof PostFalAiLongcatImageResponses]

export type GetFalAiLongcatImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/longcat-image/requests/{request_id}'
}

export type GetFalAiLongcatImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLongcatImageOutput
}

export type GetFalAiLongcatImageRequestsByRequestIdResponse =
  GetFalAiLongcatImageRequestsByRequestIdResponses[keyof GetFalAiLongcatImageRequestsByRequestIdResponses]

export type GetFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/bytedance/seedream/v4.5/text-to-image/requests/{request_id}/status'
  }

export type GetFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdStatusResponse =
  GetFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdStatusResponses[keyof GetFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdStatusResponses]

export type PutFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/bytedance/seedream/v4.5/text-to-image/requests/{request_id}/cancel'
  }

export type PutFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdCancelResponse =
  PutFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdCancelResponses[keyof PutFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdCancelResponses]

export type PostFalAiBytedanceSeedreamV45TextToImageData = {
  body: SchemaBytedanceSeedreamV45TextToImageInput
  path?: never
  query?: never
  url: '/fal-ai/bytedance/seedream/v4.5/text-to-image'
}

export type PostFalAiBytedanceSeedreamV45TextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBytedanceSeedreamV45TextToImageResponse =
  PostFalAiBytedanceSeedreamV45TextToImageResponses[keyof PostFalAiBytedanceSeedreamV45TextToImageResponses]

export type GetFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bytedance/seedream/v4.5/text-to-image/requests/{request_id}'
}

export type GetFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaBytedanceSeedreamV45TextToImageOutput
  }

export type GetFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdResponse =
  GetFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdResponses[keyof GetFalAiBytedanceSeedreamV45TextToImageRequestsByRequestIdResponses]

export type GetFalAiViduQ2TextToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/vidu/q2/text-to-image/requests/{request_id}/status'
}

export type GetFalAiViduQ2TextToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiViduQ2TextToImageRequestsByRequestIdStatusResponse =
  GetFalAiViduQ2TextToImageRequestsByRequestIdStatusResponses[keyof GetFalAiViduQ2TextToImageRequestsByRequestIdStatusResponses]

export type PutFalAiViduQ2TextToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/vidu/q2/text-to-image/requests/{request_id}/cancel'
}

export type PutFalAiViduQ2TextToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiViduQ2TextToImageRequestsByRequestIdCancelResponse =
  PutFalAiViduQ2TextToImageRequestsByRequestIdCancelResponses[keyof PutFalAiViduQ2TextToImageRequestsByRequestIdCancelResponses]

export type PostFalAiViduQ2TextToImageData = {
  body: SchemaViduQ2TextToImageInput
  path?: never
  query?: never
  url: '/fal-ai/vidu/q2/text-to-image'
}

export type PostFalAiViduQ2TextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiViduQ2TextToImageResponse =
  PostFalAiViduQ2TextToImageResponses[keyof PostFalAiViduQ2TextToImageResponses]

export type GetFalAiViduQ2TextToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/vidu/q2/text-to-image/requests/{request_id}'
}

export type GetFalAiViduQ2TextToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaViduQ2TextToImageOutput
}

export type GetFalAiViduQ2TextToImageRequestsByRequestIdResponse =
  GetFalAiViduQ2TextToImageRequestsByRequestIdResponses[keyof GetFalAiViduQ2TextToImageRequestsByRequestIdResponses]

export type GetFalAiZImageTurboLoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/z-image/turbo/lora/requests/{request_id}/status'
}

export type GetFalAiZImageTurboLoraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiZImageTurboLoraRequestsByRequestIdStatusResponse =
  GetFalAiZImageTurboLoraRequestsByRequestIdStatusResponses[keyof GetFalAiZImageTurboLoraRequestsByRequestIdStatusResponses]

export type PutFalAiZImageTurboLoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/turbo/lora/requests/{request_id}/cancel'
}

export type PutFalAiZImageTurboLoraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiZImageTurboLoraRequestsByRequestIdCancelResponse =
  PutFalAiZImageTurboLoraRequestsByRequestIdCancelResponses[keyof PutFalAiZImageTurboLoraRequestsByRequestIdCancelResponses]

export type PostFalAiZImageTurboLoraData = {
  body: SchemaZImageTurboLoraInput
  path?: never
  query?: never
  url: '/fal-ai/z-image/turbo/lora'
}

export type PostFalAiZImageTurboLoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiZImageTurboLoraResponse =
  PostFalAiZImageTurboLoraResponses[keyof PostFalAiZImageTurboLoraResponses]

export type GetFalAiZImageTurboLoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/turbo/lora/requests/{request_id}'
}

export type GetFalAiZImageTurboLoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaZImageTurboLoraOutput
}

export type GetFalAiZImageTurboLoraRequestsByRequestIdResponse =
  GetFalAiZImageTurboLoraRequestsByRequestIdResponses[keyof GetFalAiZImageTurboLoraRequestsByRequestIdResponses]

export type GetFalAiOvisImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ovis-image/requests/{request_id}/status'
}

export type GetFalAiOvisImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiOvisImageRequestsByRequestIdStatusResponse =
  GetFalAiOvisImageRequestsByRequestIdStatusResponses[keyof GetFalAiOvisImageRequestsByRequestIdStatusResponses]

export type PutFalAiOvisImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ovis-image/requests/{request_id}/cancel'
}

export type PutFalAiOvisImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiOvisImageRequestsByRequestIdCancelResponse =
  PutFalAiOvisImageRequestsByRequestIdCancelResponses[keyof PutFalAiOvisImageRequestsByRequestIdCancelResponses]

export type PostFalAiOvisImageData = {
  body: SchemaOvisImageInput
  path?: never
  query?: never
  url: '/fal-ai/ovis-image'
}

export type PostFalAiOvisImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiOvisImageResponse =
  PostFalAiOvisImageResponses[keyof PostFalAiOvisImageResponses]

export type GetFalAiOvisImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ovis-image/requests/{request_id}'
}

export type GetFalAiOvisImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaOvisImageOutput
}

export type GetFalAiOvisImageRequestsByRequestIdResponse =
  GetFalAiOvisImageRequestsByRequestIdResponses[keyof GetFalAiOvisImageRequestsByRequestIdResponses]

export type GetFalAiZImageTurboRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/z-image/turbo/requests/{request_id}/status'
}

export type GetFalAiZImageTurboRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiZImageTurboRequestsByRequestIdStatusResponse =
  GetFalAiZImageTurboRequestsByRequestIdStatusResponses[keyof GetFalAiZImageTurboRequestsByRequestIdStatusResponses]

export type PutFalAiZImageTurboRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/turbo/requests/{request_id}/cancel'
}

export type PutFalAiZImageTurboRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiZImageTurboRequestsByRequestIdCancelResponse =
  PutFalAiZImageTurboRequestsByRequestIdCancelResponses[keyof PutFalAiZImageTurboRequestsByRequestIdCancelResponses]

export type PostFalAiZImageTurboData = {
  body: SchemaZImageTurboInput
  path?: never
  query?: never
  url: '/fal-ai/z-image/turbo'
}

export type PostFalAiZImageTurboResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiZImageTurboResponse =
  PostFalAiZImageTurboResponses[keyof PostFalAiZImageTurboResponses]

export type GetFalAiZImageTurboRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/z-image/turbo/requests/{request_id}'
}

export type GetFalAiZImageTurboRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaZImageTurboOutput
}

export type GetFalAiZImageTurboRequestsByRequestIdResponse =
  GetFalAiZImageTurboRequestsByRequestIdResponses[keyof GetFalAiZImageTurboRequestsByRequestIdResponses]

export type GetFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/flux-2-lora-gallery/sepia-vintage/requests/{request_id}/status'
  }

export type GetFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdStatusResponse =
  GetFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/flux-2-lora-gallery/sepia-vintage/requests/{request_id}/cancel'
  }

export type PutFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdCancelResponse =
  PutFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2LoraGallerySepiaVintageData = {
  body: SchemaFlux2LoraGallerySepiaVintageInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/sepia-vintage'
}

export type PostFalAiFlux2LoraGallerySepiaVintageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2LoraGallerySepiaVintageResponse =
  PostFalAiFlux2LoraGallerySepiaVintageResponses[keyof PostFalAiFlux2LoraGallerySepiaVintageResponses]

export type GetFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/sepia-vintage/requests/{request_id}'
}

export type GetFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2LoraGallerySepiaVintageOutput
}

export type GetFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdResponse =
  GetFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdResponses[keyof GetFalAiFlux2LoraGallerySepiaVintageRequestsByRequestIdResponses]

export type GetFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/flux-2-lora-gallery/satellite-view-style/requests/{request_id}/status'
  }

export type GetFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdStatusResponse =
  GetFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/flux-2-lora-gallery/satellite-view-style/requests/{request_id}/cancel'
  }

export type PutFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdCancelResponse =
  PutFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2LoraGallerySatelliteViewStyleData = {
  body: SchemaFlux2LoraGallerySatelliteViewStyleInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/satellite-view-style'
}

export type PostFalAiFlux2LoraGallerySatelliteViewStyleResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2LoraGallerySatelliteViewStyleResponse =
  PostFalAiFlux2LoraGallerySatelliteViewStyleResponses[keyof PostFalAiFlux2LoraGallerySatelliteViewStyleResponses]

export type GetFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/flux-2-lora-gallery/satellite-view-style/requests/{request_id}'
  }

export type GetFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaFlux2LoraGallerySatelliteViewStyleOutput
  }

export type GetFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdResponse =
  GetFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdResponses[keyof GetFalAiFlux2LoraGallerySatelliteViewStyleRequestsByRequestIdResponses]

export type GetFalAiFlux2LoraGalleryRealismRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2-lora-gallery/realism/requests/{request_id}/status'
}

export type GetFalAiFlux2LoraGalleryRealismRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlux2LoraGalleryRealismRequestsByRequestIdStatusResponse =
  GetFalAiFlux2LoraGalleryRealismRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2LoraGalleryRealismRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2LoraGalleryRealismRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/realism/requests/{request_id}/cancel'
}

export type PutFalAiFlux2LoraGalleryRealismRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlux2LoraGalleryRealismRequestsByRequestIdCancelResponse =
  PutFalAiFlux2LoraGalleryRealismRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2LoraGalleryRealismRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2LoraGalleryRealismData = {
  body: SchemaFlux2LoraGalleryRealismInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/realism'
}

export type PostFalAiFlux2LoraGalleryRealismResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2LoraGalleryRealismResponse =
  PostFalAiFlux2LoraGalleryRealismResponses[keyof PostFalAiFlux2LoraGalleryRealismResponses]

export type GetFalAiFlux2LoraGalleryRealismRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/realism/requests/{request_id}'
}

export type GetFalAiFlux2LoraGalleryRealismRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2LoraGalleryRealismOutput
}

export type GetFalAiFlux2LoraGalleryRealismRequestsByRequestIdResponse =
  GetFalAiFlux2LoraGalleryRealismRequestsByRequestIdResponses[keyof GetFalAiFlux2LoraGalleryRealismRequestsByRequestIdResponses]

export type GetFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2-lora-gallery/hdr-style/requests/{request_id}/status'
}

export type GetFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdStatusResponse =
  GetFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/hdr-style/requests/{request_id}/cancel'
}

export type PutFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdCancelResponse =
  PutFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2LoraGalleryHdrStyleData = {
  body: SchemaFlux2LoraGalleryHdrStyleInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/hdr-style'
}

export type PostFalAiFlux2LoraGalleryHdrStyleResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2LoraGalleryHdrStyleResponse =
  PostFalAiFlux2LoraGalleryHdrStyleResponses[keyof PostFalAiFlux2LoraGalleryHdrStyleResponses]

export type GetFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/hdr-style/requests/{request_id}'
}

export type GetFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2LoraGalleryHdrStyleOutput
}

export type GetFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdResponse =
  GetFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdResponses[keyof GetFalAiFlux2LoraGalleryHdrStyleRequestsByRequestIdResponses]

export type GetFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/flux-2-lora-gallery/digital-comic-art/requests/{request_id}/status'
  }

export type GetFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdStatusResponse =
  GetFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/flux-2-lora-gallery/digital-comic-art/requests/{request_id}/cancel'
  }

export type PutFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdCancelResponse =
  PutFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2LoraGalleryDigitalComicArtData = {
  body: SchemaFlux2LoraGalleryDigitalComicArtInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/digital-comic-art'
}

export type PostFalAiFlux2LoraGalleryDigitalComicArtResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2LoraGalleryDigitalComicArtResponse =
  PostFalAiFlux2LoraGalleryDigitalComicArtResponses[keyof PostFalAiFlux2LoraGalleryDigitalComicArtResponses]

export type GetFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/digital-comic-art/requests/{request_id}'
}

export type GetFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaFlux2LoraGalleryDigitalComicArtOutput
  }

export type GetFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdResponse =
  GetFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdResponses[keyof GetFalAiFlux2LoraGalleryDigitalComicArtRequestsByRequestIdResponses]

export type GetFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/flux-2-lora-gallery/ballpoint-pen-sketch/requests/{request_id}/status'
  }

export type GetFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdStatusResponse =
  GetFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/flux-2-lora-gallery/ballpoint-pen-sketch/requests/{request_id}/cancel'
  }

export type PutFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdCancelResponse =
  PutFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2LoraGalleryBallpointPenSketchData = {
  body: SchemaFlux2LoraGalleryBallpointPenSketchInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2-lora-gallery/ballpoint-pen-sketch'
}

export type PostFalAiFlux2LoraGalleryBallpointPenSketchResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2LoraGalleryBallpointPenSketchResponse =
  PostFalAiFlux2LoraGalleryBallpointPenSketchResponses[keyof PostFalAiFlux2LoraGalleryBallpointPenSketchResponses]

export type GetFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/flux-2-lora-gallery/ballpoint-pen-sketch/requests/{request_id}'
  }

export type GetFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaFlux2LoraGalleryBallpointPenSketchOutput
  }

export type GetFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdResponse =
  GetFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdResponses[keyof GetFalAiFlux2LoraGalleryBallpointPenSketchRequestsByRequestIdResponses]

export type GetFalAiFlux2FlexRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-2-flex/requests/{request_id}/status'
}

export type GetFalAiFlux2FlexRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux2FlexRequestsByRequestIdStatusResponse =
  GetFalAiFlux2FlexRequestsByRequestIdStatusResponses[keyof GetFalAiFlux2FlexRequestsByRequestIdStatusResponses]

export type PutFalAiFlux2FlexRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-flex/requests/{request_id}/cancel'
}

export type PutFalAiFlux2FlexRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux2FlexRequestsByRequestIdCancelResponse =
  PutFalAiFlux2FlexRequestsByRequestIdCancelResponses[keyof PutFalAiFlux2FlexRequestsByRequestIdCancelResponses]

export type PostFalAiFlux2FlexData = {
  body: SchemaFlux2FlexInput
  path?: never
  query?: never
  url: '/fal-ai/flux-2-flex'
}

export type PostFalAiFlux2FlexResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux2FlexResponse =
  PostFalAiFlux2FlexResponses[keyof PostFalAiFlux2FlexResponses]

export type GetFalAiFlux2FlexRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-2-flex/requests/{request_id}'
}

export type GetFalAiFlux2FlexRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux2FlexOutput
}

export type GetFalAiFlux2FlexRequestsByRequestIdResponse =
  GetFalAiFlux2FlexRequestsByRequestIdResponses[keyof GetFalAiFlux2FlexRequestsByRequestIdResponses]

export type GetFalAiGemini3ProImagePreviewRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/gemini-3-pro-image-preview/requests/{request_id}/status'
}

export type GetFalAiGemini3ProImagePreviewRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiGemini3ProImagePreviewRequestsByRequestIdStatusResponse =
  GetFalAiGemini3ProImagePreviewRequestsByRequestIdStatusResponses[keyof GetFalAiGemini3ProImagePreviewRequestsByRequestIdStatusResponses]

export type PutFalAiGemini3ProImagePreviewRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gemini-3-pro-image-preview/requests/{request_id}/cancel'
}

export type PutFalAiGemini3ProImagePreviewRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiGemini3ProImagePreviewRequestsByRequestIdCancelResponse =
  PutFalAiGemini3ProImagePreviewRequestsByRequestIdCancelResponses[keyof PutFalAiGemini3ProImagePreviewRequestsByRequestIdCancelResponses]

export type PostFalAiGemini3ProImagePreviewData = {
  body: SchemaGemini3ProImagePreviewInput
  path?: never
  query?: never
  url: '/fal-ai/gemini-3-pro-image-preview'
}

export type PostFalAiGemini3ProImagePreviewResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiGemini3ProImagePreviewResponse =
  PostFalAiGemini3ProImagePreviewResponses[keyof PostFalAiGemini3ProImagePreviewResponses]

export type GetFalAiGemini3ProImagePreviewRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gemini-3-pro-image-preview/requests/{request_id}'
}

export type GetFalAiGemini3ProImagePreviewRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaGemini3ProImagePreviewOutput
}

export type GetFalAiGemini3ProImagePreviewRequestsByRequestIdResponse =
  GetFalAiGemini3ProImagePreviewRequestsByRequestIdResponses[keyof GetFalAiGemini3ProImagePreviewRequestsByRequestIdResponses]

export type GetFalAiNanoBananaProRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/nano-banana-pro/requests/{request_id}/status'
}

export type GetFalAiNanoBananaProRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiNanoBananaProRequestsByRequestIdStatusResponse =
  GetFalAiNanoBananaProRequestsByRequestIdStatusResponses[keyof GetFalAiNanoBananaProRequestsByRequestIdStatusResponses]

export type PutFalAiNanoBananaProRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/nano-banana-pro/requests/{request_id}/cancel'
}

export type PutFalAiNanoBananaProRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiNanoBananaProRequestsByRequestIdCancelResponse =
  PutFalAiNanoBananaProRequestsByRequestIdCancelResponses[keyof PutFalAiNanoBananaProRequestsByRequestIdCancelResponses]

export type PostFalAiNanoBananaProData = {
  body: SchemaNanoBananaProInput
  path?: never
  query?: never
  url: '/fal-ai/nano-banana-pro'
}

export type PostFalAiNanoBananaProResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiNanoBananaProResponse =
  PostFalAiNanoBananaProResponses[keyof PostFalAiNanoBananaProResponses]

export type GetFalAiNanoBananaProRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/nano-banana-pro/requests/{request_id}'
}

export type GetFalAiNanoBananaProRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaNanoBananaProOutput
}

export type GetFalAiNanoBananaProRequestsByRequestIdResponse =
  GetFalAiNanoBananaProRequestsByRequestIdResponses[keyof GetFalAiNanoBananaProRequestsByRequestIdResponses]

export type GetImagineartImagineart15PreviewTextToImageRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/imagineart/imagineart-1.5-preview/text-to-image/requests/{request_id}/status'
  }

export type GetImagineartImagineart15PreviewTextToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetImagineartImagineart15PreviewTextToImageRequestsByRequestIdStatusResponse =
  GetImagineartImagineart15PreviewTextToImageRequestsByRequestIdStatusResponses[keyof GetImagineartImagineart15PreviewTextToImageRequestsByRequestIdStatusResponses]

export type PutImagineartImagineart15PreviewTextToImageRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/imagineart/imagineart-1.5-preview/text-to-image/requests/{request_id}/cancel'
  }

export type PutImagineartImagineart15PreviewTextToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutImagineartImagineart15PreviewTextToImageRequestsByRequestIdCancelResponse =
  PutImagineartImagineart15PreviewTextToImageRequestsByRequestIdCancelResponses[keyof PutImagineartImagineart15PreviewTextToImageRequestsByRequestIdCancelResponses]

export type PostImagineartImagineart15PreviewTextToImageData = {
  body: SchemaImagineart15PreviewTextToImageInput
  path?: never
  query?: never
  url: '/imagineart/imagineart-1.5-preview/text-to-image'
}

export type PostImagineartImagineart15PreviewTextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostImagineartImagineart15PreviewTextToImageResponse =
  PostImagineartImagineart15PreviewTextToImageResponses[keyof PostImagineartImagineart15PreviewTextToImageResponses]

export type GetImagineartImagineart15PreviewTextToImageRequestsByRequestIdData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/imagineart/imagineart-1.5-preview/text-to-image/requests/{request_id}'
  }

export type GetImagineartImagineart15PreviewTextToImageRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaImagineart15PreviewTextToImageOutput
  }

export type GetImagineartImagineart15PreviewTextToImageRequestsByRequestIdResponse =
  GetImagineartImagineart15PreviewTextToImageRequestsByRequestIdResponses[keyof GetImagineartImagineart15PreviewTextToImageRequestsByRequestIdResponses]

export type GetFalAiEmu35ImageTextToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/emu-3.5-image/text-to-image/requests/{request_id}/status'
}

export type GetFalAiEmu35ImageTextToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiEmu35ImageTextToImageRequestsByRequestIdStatusResponse =
  GetFalAiEmu35ImageTextToImageRequestsByRequestIdStatusResponses[keyof GetFalAiEmu35ImageTextToImageRequestsByRequestIdStatusResponses]

export type PutFalAiEmu35ImageTextToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/emu-3.5-image/text-to-image/requests/{request_id}/cancel'
}

export type PutFalAiEmu35ImageTextToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiEmu35ImageTextToImageRequestsByRequestIdCancelResponse =
  PutFalAiEmu35ImageTextToImageRequestsByRequestIdCancelResponses[keyof PutFalAiEmu35ImageTextToImageRequestsByRequestIdCancelResponses]

export type PostFalAiEmu35ImageTextToImageData = {
  body: SchemaEmu35ImageTextToImageInput
  path?: never
  query?: never
  url: '/fal-ai/emu-3.5-image/text-to-image'
}

export type PostFalAiEmu35ImageTextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiEmu35ImageTextToImageResponse =
  PostFalAiEmu35ImageTextToImageResponses[keyof PostFalAiEmu35ImageTextToImageResponses]

export type GetFalAiEmu35ImageTextToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/emu-3.5-image/text-to-image/requests/{request_id}'
}

export type GetFalAiEmu35ImageTextToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaEmu35ImageTextToImageOutput
}

export type GetFalAiEmu35ImageTextToImageRequestsByRequestIdResponse =
  GetFalAiEmu35ImageTextToImageRequestsByRequestIdResponses[keyof GetFalAiEmu35ImageTextToImageRequestsByRequestIdResponses]

export type GetBriaFiboGenerateRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/bria/fibo/generate/requests/{request_id}/status'
}

export type GetBriaFiboGenerateRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetBriaFiboGenerateRequestsByRequestIdStatusResponse =
  GetBriaFiboGenerateRequestsByRequestIdStatusResponses[keyof GetBriaFiboGenerateRequestsByRequestIdStatusResponses]

export type PutBriaFiboGenerateRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo/generate/requests/{request_id}/cancel'
}

export type PutBriaFiboGenerateRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutBriaFiboGenerateRequestsByRequestIdCancelResponse =
  PutBriaFiboGenerateRequestsByRequestIdCancelResponses[keyof PutBriaFiboGenerateRequestsByRequestIdCancelResponses]

export type PostBriaFiboGenerateData = {
  body: SchemaFiboGenerateInput
  path?: never
  query?: never
  url: '/bria/fibo/generate'
}

export type PostBriaFiboGenerateResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostBriaFiboGenerateResponse =
  PostBriaFiboGenerateResponses[keyof PostBriaFiboGenerateResponses]

export type GetBriaFiboGenerateRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/bria/fibo/generate/requests/{request_id}'
}

export type GetBriaFiboGenerateRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFiboGenerateOutput
}

export type GetBriaFiboGenerateRequestsByRequestIdResponse =
  GetBriaFiboGenerateRequestsByRequestIdResponses[keyof GetBriaFiboGenerateRequestsByRequestIdResponses]

export type GetFalAiPiflowRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/piflow/requests/{request_id}/status'
}

export type GetFalAiPiflowRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiPiflowRequestsByRequestIdStatusResponse =
  GetFalAiPiflowRequestsByRequestIdStatusResponses[keyof GetFalAiPiflowRequestsByRequestIdStatusResponses]

export type PutFalAiPiflowRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/piflow/requests/{request_id}/cancel'
}

export type PutFalAiPiflowRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiPiflowRequestsByRequestIdCancelResponse =
  PutFalAiPiflowRequestsByRequestIdCancelResponses[keyof PutFalAiPiflowRequestsByRequestIdCancelResponses]

export type PostFalAiPiflowData = {
  body: SchemaPiflowInput
  path?: never
  query?: never
  url: '/fal-ai/piflow'
}

export type PostFalAiPiflowResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPiflowResponse =
  PostFalAiPiflowResponses[keyof PostFalAiPiflowResponses]

export type GetFalAiPiflowRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/piflow/requests/{request_id}'
}

export type GetFalAiPiflowRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPiflowOutput
}

export type GetFalAiPiflowRequestsByRequestIdResponse =
  GetFalAiPiflowRequestsByRequestIdResponses[keyof GetFalAiPiflowRequestsByRequestIdResponses]

export type GetFalAiGptImage1MiniRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/gpt-image-1-mini/requests/{request_id}/status'
}

export type GetFalAiGptImage1MiniRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiGptImage1MiniRequestsByRequestIdStatusResponse =
  GetFalAiGptImage1MiniRequestsByRequestIdStatusResponses[keyof GetFalAiGptImage1MiniRequestsByRequestIdStatusResponses]

export type PutFalAiGptImage1MiniRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gpt-image-1-mini/requests/{request_id}/cancel'
}

export type PutFalAiGptImage1MiniRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiGptImage1MiniRequestsByRequestIdCancelResponse =
  PutFalAiGptImage1MiniRequestsByRequestIdCancelResponses[keyof PutFalAiGptImage1MiniRequestsByRequestIdCancelResponses]

export type PostFalAiGptImage1MiniData = {
  body: SchemaGptImage1MiniInput
  path?: never
  query?: never
  url: '/fal-ai/gpt-image-1-mini'
}

export type PostFalAiGptImage1MiniResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiGptImage1MiniResponse =
  PostFalAiGptImage1MiniResponses[keyof PostFalAiGptImage1MiniResponses]

export type GetFalAiGptImage1MiniRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gpt-image-1-mini/requests/{request_id}'
}

export type GetFalAiGptImage1MiniRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaGptImage1MiniOutput
}

export type GetFalAiGptImage1MiniRequestsByRequestIdResponse =
  GetFalAiGptImage1MiniRequestsByRequestIdResponses[keyof GetFalAiGptImage1MiniRequestsByRequestIdResponses]

export type GetFalAiReveTextToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/reve/text-to-image/requests/{request_id}/status'
}

export type GetFalAiReveTextToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiReveTextToImageRequestsByRequestIdStatusResponse =
  GetFalAiReveTextToImageRequestsByRequestIdStatusResponses[keyof GetFalAiReveTextToImageRequestsByRequestIdStatusResponses]

export type PutFalAiReveTextToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/reve/text-to-image/requests/{request_id}/cancel'
}

export type PutFalAiReveTextToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiReveTextToImageRequestsByRequestIdCancelResponse =
  PutFalAiReveTextToImageRequestsByRequestIdCancelResponses[keyof PutFalAiReveTextToImageRequestsByRequestIdCancelResponses]

export type PostFalAiReveTextToImageData = {
  body: SchemaReveTextToImageInput
  path?: never
  query?: never
  url: '/fal-ai/reve/text-to-image'
}

export type PostFalAiReveTextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiReveTextToImageResponse =
  PostFalAiReveTextToImageResponses[keyof PostFalAiReveTextToImageResponses]

export type GetFalAiReveTextToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/reve/text-to-image/requests/{request_id}'
}

export type GetFalAiReveTextToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaReveTextToImageOutput
}

export type GetFalAiReveTextToImageRequestsByRequestIdResponse =
  GetFalAiReveTextToImageRequestsByRequestIdResponses[keyof GetFalAiReveTextToImageRequestsByRequestIdResponses]

export type GetFalAiHunyuanImageV3TextToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/hunyuan-image/v3/text-to-image/requests/{request_id}/status'
}

export type GetFalAiHunyuanImageV3TextToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiHunyuanImageV3TextToImageRequestsByRequestIdStatusResponse =
  GetFalAiHunyuanImageV3TextToImageRequestsByRequestIdStatusResponses[keyof GetFalAiHunyuanImageV3TextToImageRequestsByRequestIdStatusResponses]

export type PutFalAiHunyuanImageV3TextToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/hunyuan-image/v3/text-to-image/requests/{request_id}/cancel'
}

export type PutFalAiHunyuanImageV3TextToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiHunyuanImageV3TextToImageRequestsByRequestIdCancelResponse =
  PutFalAiHunyuanImageV3TextToImageRequestsByRequestIdCancelResponses[keyof PutFalAiHunyuanImageV3TextToImageRequestsByRequestIdCancelResponses]

export type PostFalAiHunyuanImageV3TextToImageData = {
  body: SchemaHunyuanImageV3TextToImageInput
  path?: never
  query?: never
  url: '/fal-ai/hunyuan-image/v3/text-to-image'
}

export type PostFalAiHunyuanImageV3TextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiHunyuanImageV3TextToImageResponse =
  PostFalAiHunyuanImageV3TextToImageResponses[keyof PostFalAiHunyuanImageV3TextToImageResponses]

export type GetFalAiHunyuanImageV3TextToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/hunyuan-image/v3/text-to-image/requests/{request_id}'
}

export type GetFalAiHunyuanImageV3TextToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaHunyuanImageV3TextToImageOutput
}

export type GetFalAiHunyuanImageV3TextToImageRequestsByRequestIdResponse =
  GetFalAiHunyuanImageV3TextToImageRequestsByRequestIdResponses[keyof GetFalAiHunyuanImageV3TextToImageRequestsByRequestIdResponses]

export type GetFalAiWan25PreviewTextToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/wan-25-preview/text-to-image/requests/{request_id}/status'
}

export type GetFalAiWan25PreviewTextToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiWan25PreviewTextToImageRequestsByRequestIdStatusResponse =
  GetFalAiWan25PreviewTextToImageRequestsByRequestIdStatusResponses[keyof GetFalAiWan25PreviewTextToImageRequestsByRequestIdStatusResponses]

export type PutFalAiWan25PreviewTextToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/wan-25-preview/text-to-image/requests/{request_id}/cancel'
}

export type PutFalAiWan25PreviewTextToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiWan25PreviewTextToImageRequestsByRequestIdCancelResponse =
  PutFalAiWan25PreviewTextToImageRequestsByRequestIdCancelResponses[keyof PutFalAiWan25PreviewTextToImageRequestsByRequestIdCancelResponses]

export type PostFalAiWan25PreviewTextToImageData = {
  body: SchemaWan25PreviewTextToImageInput
  path?: never
  query?: never
  url: '/fal-ai/wan-25-preview/text-to-image'
}

export type PostFalAiWan25PreviewTextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiWan25PreviewTextToImageResponse =
  PostFalAiWan25PreviewTextToImageResponses[keyof PostFalAiWan25PreviewTextToImageResponses]

export type GetFalAiWan25PreviewTextToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/wan-25-preview/text-to-image/requests/{request_id}'
}

export type GetFalAiWan25PreviewTextToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaWan25PreviewTextToImageOutput
}

export type GetFalAiWan25PreviewTextToImageRequestsByRequestIdResponse =
  GetFalAiWan25PreviewTextToImageRequestsByRequestIdResponses[keyof GetFalAiWan25PreviewTextToImageRequestsByRequestIdResponses]

export type GetFalAiFluxSrpoRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux/srpo/requests/{request_id}/status'
}

export type GetFalAiFluxSrpoRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxSrpoRequestsByRequestIdStatusResponse =
  GetFalAiFluxSrpoRequestsByRequestIdStatusResponses[keyof GetFalAiFluxSrpoRequestsByRequestIdStatusResponses]

export type PutFalAiFluxSrpoRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/srpo/requests/{request_id}/cancel'
}

export type PutFalAiFluxSrpoRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxSrpoRequestsByRequestIdCancelResponse =
  PutFalAiFluxSrpoRequestsByRequestIdCancelResponses[keyof PutFalAiFluxSrpoRequestsByRequestIdCancelResponses]

export type PostFalAiFluxSrpoData = {
  body: SchemaFluxSrpoInput
  path?: never
  query?: never
  url: '/fal-ai/flux/srpo'
}

export type PostFalAiFluxSrpoResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxSrpoResponse =
  PostFalAiFluxSrpoResponses[keyof PostFalAiFluxSrpoResponses]

export type GetFalAiFluxSrpoRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/srpo/requests/{request_id}'
}

export type GetFalAiFluxSrpoRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxSrpoOutput
}

export type GetFalAiFluxSrpoRequestsByRequestIdResponse =
  GetFalAiFluxSrpoRequestsByRequestIdResponses[keyof GetFalAiFluxSrpoRequestsByRequestIdResponses]

export type GetFalAiFlux1SrpoRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-1/srpo/requests/{request_id}/status'
}

export type GetFalAiFlux1SrpoRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux1SrpoRequestsByRequestIdStatusResponse =
  GetFalAiFlux1SrpoRequestsByRequestIdStatusResponses[keyof GetFalAiFlux1SrpoRequestsByRequestIdStatusResponses]

export type PutFalAiFlux1SrpoRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/srpo/requests/{request_id}/cancel'
}

export type PutFalAiFlux1SrpoRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux1SrpoRequestsByRequestIdCancelResponse =
  PutFalAiFlux1SrpoRequestsByRequestIdCancelResponses[keyof PutFalAiFlux1SrpoRequestsByRequestIdCancelResponses]

export type PostFalAiFlux1SrpoData = {
  body: SchemaFlux1SrpoInput
  path?: never
  query?: never
  url: '/fal-ai/flux-1/srpo'
}

export type PostFalAiFlux1SrpoResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux1SrpoResponse =
  PostFalAiFlux1SrpoResponses[keyof PostFalAiFlux1SrpoResponses]

export type GetFalAiFlux1SrpoRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/srpo/requests/{request_id}'
}

export type GetFalAiFlux1SrpoRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux1SrpoOutput
}

export type GetFalAiFlux1SrpoRequestsByRequestIdResponse =
  GetFalAiFlux1SrpoRequestsByRequestIdResponses[keyof GetFalAiFlux1SrpoRequestsByRequestIdResponses]

export type GetFalAiHunyuanImageV21TextToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/hunyuan-image/v2.1/text-to-image/requests/{request_id}/status'
}

export type GetFalAiHunyuanImageV21TextToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiHunyuanImageV21TextToImageRequestsByRequestIdStatusResponse =
  GetFalAiHunyuanImageV21TextToImageRequestsByRequestIdStatusResponses[keyof GetFalAiHunyuanImageV21TextToImageRequestsByRequestIdStatusResponses]

export type PutFalAiHunyuanImageV21TextToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/hunyuan-image/v2.1/text-to-image/requests/{request_id}/cancel'
}

export type PutFalAiHunyuanImageV21TextToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiHunyuanImageV21TextToImageRequestsByRequestIdCancelResponse =
  PutFalAiHunyuanImageV21TextToImageRequestsByRequestIdCancelResponses[keyof PutFalAiHunyuanImageV21TextToImageRequestsByRequestIdCancelResponses]

export type PostFalAiHunyuanImageV21TextToImageData = {
  body: SchemaHunyuanImageV21TextToImageInput
  path?: never
  query?: never
  url: '/fal-ai/hunyuan-image/v2.1/text-to-image'
}

export type PostFalAiHunyuanImageV21TextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiHunyuanImageV21TextToImageResponse =
  PostFalAiHunyuanImageV21TextToImageResponses[keyof PostFalAiHunyuanImageV21TextToImageResponses]

export type GetFalAiHunyuanImageV21TextToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/hunyuan-image/v2.1/text-to-image/requests/{request_id}'
}

export type GetFalAiHunyuanImageV21TextToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaHunyuanImageV21TextToImageOutput
}

export type GetFalAiHunyuanImageV21TextToImageRequestsByRequestIdResponse =
  GetFalAiHunyuanImageV21TextToImageRequestsByRequestIdResponses[keyof GetFalAiHunyuanImageV21TextToImageRequestsByRequestIdResponses]

export type GetFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/bytedance/seedream/v4/text-to-image/requests/{request_id}/status'
  }

export type GetFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdStatusResponse =
  GetFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdStatusResponses[keyof GetFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdStatusResponses]

export type PutFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/bytedance/seedream/v4/text-to-image/requests/{request_id}/cancel'
  }

export type PutFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdCancelResponse =
  PutFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdCancelResponses[keyof PutFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdCancelResponses]

export type PostFalAiBytedanceSeedreamV4TextToImageData = {
  body: SchemaBytedanceSeedreamV4TextToImageInput
  path?: never
  query?: never
  url: '/fal-ai/bytedance/seedream/v4/text-to-image'
}

export type PostFalAiBytedanceSeedreamV4TextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBytedanceSeedreamV4TextToImageResponse =
  PostFalAiBytedanceSeedreamV4TextToImageResponses[keyof PostFalAiBytedanceSeedreamV4TextToImageResponses]

export type GetFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bytedance/seedream/v4/text-to-image/requests/{request_id}'
}

export type GetFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaBytedanceSeedreamV4TextToImageOutput
  }

export type GetFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdResponse =
  GetFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdResponses[keyof GetFalAiBytedanceSeedreamV4TextToImageRequestsByRequestIdResponses]

export type GetFalAiGemini25FlashImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/gemini-25-flash-image/requests/{request_id}/status'
}

export type GetFalAiGemini25FlashImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiGemini25FlashImageRequestsByRequestIdStatusResponse =
  GetFalAiGemini25FlashImageRequestsByRequestIdStatusResponses[keyof GetFalAiGemini25FlashImageRequestsByRequestIdStatusResponses]

export type PutFalAiGemini25FlashImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gemini-25-flash-image/requests/{request_id}/cancel'
}

export type PutFalAiGemini25FlashImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiGemini25FlashImageRequestsByRequestIdCancelResponse =
  PutFalAiGemini25FlashImageRequestsByRequestIdCancelResponses[keyof PutFalAiGemini25FlashImageRequestsByRequestIdCancelResponses]

export type PostFalAiGemini25FlashImageData = {
  body: SchemaGemini25FlashImageInput
  path?: never
  query?: never
  url: '/fal-ai/gemini-25-flash-image'
}

export type PostFalAiGemini25FlashImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiGemini25FlashImageResponse =
  PostFalAiGemini25FlashImageResponses[keyof PostFalAiGemini25FlashImageResponses]

export type GetFalAiGemini25FlashImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gemini-25-flash-image/requests/{request_id}'
}

export type GetFalAiGemini25FlashImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaGemini25FlashImageOutput
}

export type GetFalAiGemini25FlashImageRequestsByRequestIdResponse =
  GetFalAiGemini25FlashImageRequestsByRequestIdResponses[keyof GetFalAiGemini25FlashImageRequestsByRequestIdResponses]

export type GetFalAiNanoBananaRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/nano-banana/requests/{request_id}/status'
}

export type GetFalAiNanoBananaRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiNanoBananaRequestsByRequestIdStatusResponse =
  GetFalAiNanoBananaRequestsByRequestIdStatusResponses[keyof GetFalAiNanoBananaRequestsByRequestIdStatusResponses]

export type PutFalAiNanoBananaRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/nano-banana/requests/{request_id}/cancel'
}

export type PutFalAiNanoBananaRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiNanoBananaRequestsByRequestIdCancelResponse =
  PutFalAiNanoBananaRequestsByRequestIdCancelResponses[keyof PutFalAiNanoBananaRequestsByRequestIdCancelResponses]

export type PostFalAiNanoBananaData = {
  body: SchemaNanoBananaInput
  path?: never
  query?: never
  url: '/fal-ai/nano-banana'
}

export type PostFalAiNanoBananaResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiNanoBananaResponse =
  PostFalAiNanoBananaResponses[keyof PostFalAiNanoBananaResponses]

export type GetFalAiNanoBananaRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/nano-banana/requests/{request_id}'
}

export type GetFalAiNanoBananaRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaNanoBananaOutput
}

export type GetFalAiNanoBananaRequestsByRequestIdResponse =
  GetFalAiNanoBananaRequestsByRequestIdResponses[keyof GetFalAiNanoBananaRequestsByRequestIdResponses]

export type GetFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/bytedance/dreamina/v3.1/text-to-image/requests/{request_id}/status'
  }

export type GetFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdStatusResponse =
  GetFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdStatusResponses[keyof GetFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdStatusResponses]

export type PutFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/bytedance/dreamina/v3.1/text-to-image/requests/{request_id}/cancel'
  }

export type PutFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdCancelResponse =
  PutFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdCancelResponses[keyof PutFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdCancelResponses]

export type PostFalAiBytedanceDreaminaV31TextToImageData = {
  body: SchemaBytedanceDreaminaV31TextToImageInput
  path?: never
  query?: never
  url: '/fal-ai/bytedance/dreamina/v3.1/text-to-image'
}

export type PostFalAiBytedanceDreaminaV31TextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBytedanceDreaminaV31TextToImageResponse =
  PostFalAiBytedanceDreaminaV31TextToImageResponses[keyof PostFalAiBytedanceDreaminaV31TextToImageResponses]

export type GetFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bytedance/dreamina/v3.1/text-to-image/requests/{request_id}'
}

export type GetFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaBytedanceDreaminaV31TextToImageOutput
  }

export type GetFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdResponse =
  GetFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdResponses[keyof GetFalAiBytedanceDreaminaV31TextToImageRequestsByRequestIdResponses]

export type GetFalAiWanV22A14bTextToImageLoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/wan/v2.2-a14b/text-to-image/lora/requests/{request_id}/status'
}

export type GetFalAiWanV22A14bTextToImageLoraRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiWanV22A14bTextToImageLoraRequestsByRequestIdStatusResponse =
  GetFalAiWanV22A14bTextToImageLoraRequestsByRequestIdStatusResponses[keyof GetFalAiWanV22A14bTextToImageLoraRequestsByRequestIdStatusResponses]

export type PutFalAiWanV22A14bTextToImageLoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/wan/v2.2-a14b/text-to-image/lora/requests/{request_id}/cancel'
}

export type PutFalAiWanV22A14bTextToImageLoraRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiWanV22A14bTextToImageLoraRequestsByRequestIdCancelResponse =
  PutFalAiWanV22A14bTextToImageLoraRequestsByRequestIdCancelResponses[keyof PutFalAiWanV22A14bTextToImageLoraRequestsByRequestIdCancelResponses]

export type PostFalAiWanV22A14bTextToImageLoraData = {
  body: SchemaWanV22A14bTextToImageLoraInput
  path?: never
  query?: never
  url: '/fal-ai/wan/v2.2-a14b/text-to-image/lora'
}

export type PostFalAiWanV22A14bTextToImageLoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiWanV22A14bTextToImageLoraResponse =
  PostFalAiWanV22A14bTextToImageLoraResponses[keyof PostFalAiWanV22A14bTextToImageLoraResponses]

export type GetFalAiWanV22A14bTextToImageLoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/wan/v2.2-a14b/text-to-image/lora/requests/{request_id}'
}

export type GetFalAiWanV22A14bTextToImageLoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaWanV22A14bTextToImageLoraOutput
}

export type GetFalAiWanV22A14bTextToImageLoraRequestsByRequestIdResponse =
  GetFalAiWanV22A14bTextToImageLoraRequestsByRequestIdResponses[keyof GetFalAiWanV22A14bTextToImageLoraRequestsByRequestIdResponses]

export type GetFalAiWanV225bTextToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/wan/v2.2-5b/text-to-image/requests/{request_id}/status'
}

export type GetFalAiWanV225bTextToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiWanV225bTextToImageRequestsByRequestIdStatusResponse =
  GetFalAiWanV225bTextToImageRequestsByRequestIdStatusResponses[keyof GetFalAiWanV225bTextToImageRequestsByRequestIdStatusResponses]

export type PutFalAiWanV225bTextToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/wan/v2.2-5b/text-to-image/requests/{request_id}/cancel'
}

export type PutFalAiWanV225bTextToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiWanV225bTextToImageRequestsByRequestIdCancelResponse =
  PutFalAiWanV225bTextToImageRequestsByRequestIdCancelResponses[keyof PutFalAiWanV225bTextToImageRequestsByRequestIdCancelResponses]

export type PostFalAiWanV225bTextToImageData = {
  body: SchemaWanV225bTextToImageInput
  path?: never
  query?: never
  url: '/fal-ai/wan/v2.2-5b/text-to-image'
}

export type PostFalAiWanV225bTextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiWanV225bTextToImageResponse =
  PostFalAiWanV225bTextToImageResponses[keyof PostFalAiWanV225bTextToImageResponses]

export type GetFalAiWanV225bTextToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/wan/v2.2-5b/text-to-image/requests/{request_id}'
}

export type GetFalAiWanV225bTextToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaWanV225bTextToImageOutput
}

export type GetFalAiWanV225bTextToImageRequestsByRequestIdResponse =
  GetFalAiWanV225bTextToImageRequestsByRequestIdResponses[keyof GetFalAiWanV225bTextToImageRequestsByRequestIdResponses]

export type GetFalAiWanV22A14bTextToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/wan/v2.2-a14b/text-to-image/requests/{request_id}/status'
}

export type GetFalAiWanV22A14bTextToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiWanV22A14bTextToImageRequestsByRequestIdStatusResponse =
  GetFalAiWanV22A14bTextToImageRequestsByRequestIdStatusResponses[keyof GetFalAiWanV22A14bTextToImageRequestsByRequestIdStatusResponses]

export type PutFalAiWanV22A14bTextToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/wan/v2.2-a14b/text-to-image/requests/{request_id}/cancel'
}

export type PutFalAiWanV22A14bTextToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiWanV22A14bTextToImageRequestsByRequestIdCancelResponse =
  PutFalAiWanV22A14bTextToImageRequestsByRequestIdCancelResponses[keyof PutFalAiWanV22A14bTextToImageRequestsByRequestIdCancelResponses]

export type PostFalAiWanV22A14bTextToImageData = {
  body: SchemaWanV22A14bTextToImageInput
  path?: never
  query?: never
  url: '/fal-ai/wan/v2.2-a14b/text-to-image'
}

export type PostFalAiWanV22A14bTextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiWanV22A14bTextToImageResponse =
  PostFalAiWanV22A14bTextToImageResponses[keyof PostFalAiWanV22A14bTextToImageResponses]

export type GetFalAiWanV22A14bTextToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/wan/v2.2-a14b/text-to-image/requests/{request_id}'
}

export type GetFalAiWanV22A14bTextToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaWanV22A14bTextToImageOutput
}

export type GetFalAiWanV22A14bTextToImageRequestsByRequestIdResponse =
  GetFalAiWanV22A14bTextToImageRequestsByRequestIdResponses[keyof GetFalAiWanV22A14bTextToImageRequestsByRequestIdResponses]

export type GetFalAiQwenImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/qwen-image/requests/{request_id}/status'
}

export type GetFalAiQwenImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiQwenImageRequestsByRequestIdStatusResponse =
  GetFalAiQwenImageRequestsByRequestIdStatusResponses[keyof GetFalAiQwenImageRequestsByRequestIdStatusResponses]

export type PutFalAiQwenImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image/requests/{request_id}/cancel'
}

export type PutFalAiQwenImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiQwenImageRequestsByRequestIdCancelResponse =
  PutFalAiQwenImageRequestsByRequestIdCancelResponses[keyof PutFalAiQwenImageRequestsByRequestIdCancelResponses]

export type PostFalAiQwenImageData = {
  body: SchemaQwenImageInput
  path?: never
  query?: never
  url: '/fal-ai/qwen-image'
}

export type PostFalAiQwenImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiQwenImageResponse =
  PostFalAiQwenImageResponses[keyof PostFalAiQwenImageResponses]

export type GetFalAiQwenImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/qwen-image/requests/{request_id}'
}

export type GetFalAiQwenImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaQwenImageOutput
}

export type GetFalAiQwenImageRequestsByRequestIdResponse =
  GetFalAiQwenImageRequestsByRequestIdResponses[keyof GetFalAiQwenImageRequestsByRequestIdResponses]

export type GetFalAiFluxKreaLoraStreamRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-krea-lora/stream/requests/{request_id}/status'
}

export type GetFalAiFluxKreaLoraStreamRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxKreaLoraStreamRequestsByRequestIdStatusResponse =
  GetFalAiFluxKreaLoraStreamRequestsByRequestIdStatusResponses[keyof GetFalAiFluxKreaLoraStreamRequestsByRequestIdStatusResponses]

export type PutFalAiFluxKreaLoraStreamRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-krea-lora/stream/requests/{request_id}/cancel'
}

export type PutFalAiFluxKreaLoraStreamRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxKreaLoraStreamRequestsByRequestIdCancelResponse =
  PutFalAiFluxKreaLoraStreamRequestsByRequestIdCancelResponses[keyof PutFalAiFluxKreaLoraStreamRequestsByRequestIdCancelResponses]

export type PostFalAiFluxKreaLoraStreamData = {
  body: SchemaFluxKreaLoraStreamInput
  path?: never
  query?: never
  url: '/fal-ai/flux-krea-lora/stream'
}

export type PostFalAiFluxKreaLoraStreamResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxKreaLoraStreamResponse =
  PostFalAiFluxKreaLoraStreamResponses[keyof PostFalAiFluxKreaLoraStreamResponses]

export type GetFalAiFluxKreaLoraStreamRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-krea-lora/stream/requests/{request_id}'
}

export type GetFalAiFluxKreaLoraStreamRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxKreaLoraStreamOutput
}

export type GetFalAiFluxKreaLoraStreamRequestsByRequestIdResponse =
  GetFalAiFluxKreaLoraStreamRequestsByRequestIdResponses[keyof GetFalAiFluxKreaLoraStreamRequestsByRequestIdResponses]

export type GetFalAiFluxKreaLoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-krea-lora/requests/{request_id}/status'
}

export type GetFalAiFluxKreaLoraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxKreaLoraRequestsByRequestIdStatusResponse =
  GetFalAiFluxKreaLoraRequestsByRequestIdStatusResponses[keyof GetFalAiFluxKreaLoraRequestsByRequestIdStatusResponses]

export type PutFalAiFluxKreaLoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-krea-lora/requests/{request_id}/cancel'
}

export type PutFalAiFluxKreaLoraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxKreaLoraRequestsByRequestIdCancelResponse =
  PutFalAiFluxKreaLoraRequestsByRequestIdCancelResponses[keyof PutFalAiFluxKreaLoraRequestsByRequestIdCancelResponses]

export type PostFalAiFluxKreaLoraData = {
  body: SchemaFluxKreaLoraInput
  path?: never
  query?: never
  url: '/fal-ai/flux-krea-lora'
}

export type PostFalAiFluxKreaLoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxKreaLoraResponse =
  PostFalAiFluxKreaLoraResponses[keyof PostFalAiFluxKreaLoraResponses]

export type GetFalAiFluxKreaLoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-krea-lora/requests/{request_id}'
}

export type GetFalAiFluxKreaLoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxKreaLoraOutput
}

export type GetFalAiFluxKreaLoraRequestsByRequestIdResponse =
  GetFalAiFluxKreaLoraRequestsByRequestIdResponses[keyof GetFalAiFluxKreaLoraRequestsByRequestIdResponses]

export type GetFalAiFluxKreaRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux/krea/requests/{request_id}/status'
}

export type GetFalAiFluxKreaRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxKreaRequestsByRequestIdStatusResponse =
  GetFalAiFluxKreaRequestsByRequestIdStatusResponses[keyof GetFalAiFluxKreaRequestsByRequestIdStatusResponses]

export type PutFalAiFluxKreaRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/krea/requests/{request_id}/cancel'
}

export type PutFalAiFluxKreaRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxKreaRequestsByRequestIdCancelResponse =
  PutFalAiFluxKreaRequestsByRequestIdCancelResponses[keyof PutFalAiFluxKreaRequestsByRequestIdCancelResponses]

export type PostFalAiFluxKreaData = {
  body: SchemaFluxKreaInput
  path?: never
  query?: never
  url: '/fal-ai/flux/krea'
}

export type PostFalAiFluxKreaResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxKreaResponse =
  PostFalAiFluxKreaResponses[keyof PostFalAiFluxKreaResponses]

export type GetFalAiFluxKreaRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/krea/requests/{request_id}'
}

export type GetFalAiFluxKreaRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxKreaOutput
}

export type GetFalAiFluxKreaRequestsByRequestIdResponse =
  GetFalAiFluxKreaRequestsByRequestIdResponses[keyof GetFalAiFluxKreaRequestsByRequestIdResponses]

export type GetFalAiFlux1KreaRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-1/krea/requests/{request_id}/status'
}

export type GetFalAiFlux1KreaRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux1KreaRequestsByRequestIdStatusResponse =
  GetFalAiFlux1KreaRequestsByRequestIdStatusResponses[keyof GetFalAiFlux1KreaRequestsByRequestIdStatusResponses]

export type PutFalAiFlux1KreaRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/krea/requests/{request_id}/cancel'
}

export type PutFalAiFlux1KreaRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux1KreaRequestsByRequestIdCancelResponse =
  PutFalAiFlux1KreaRequestsByRequestIdCancelResponses[keyof PutFalAiFlux1KreaRequestsByRequestIdCancelResponses]

export type PostFalAiFlux1KreaData = {
  body: SchemaFlux1KreaInput
  path?: never
  query?: never
  url: '/fal-ai/flux-1/krea'
}

export type PostFalAiFlux1KreaResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux1KreaResponse =
  PostFalAiFlux1KreaResponses[keyof PostFalAiFlux1KreaResponses]

export type GetFalAiFlux1KreaRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/krea/requests/{request_id}'
}

export type GetFalAiFlux1KreaRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux1KreaOutput
}

export type GetFalAiFlux1KreaRequestsByRequestIdResponse =
  GetFalAiFlux1KreaRequestsByRequestIdResponses[keyof GetFalAiFlux1KreaRequestsByRequestIdResponses]

export type GetFalAiSkyRaccoonRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/sky-raccoon/requests/{request_id}/status'
}

export type GetFalAiSkyRaccoonRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiSkyRaccoonRequestsByRequestIdStatusResponse =
  GetFalAiSkyRaccoonRequestsByRequestIdStatusResponses[keyof GetFalAiSkyRaccoonRequestsByRequestIdStatusResponses]

export type PutFalAiSkyRaccoonRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sky-raccoon/requests/{request_id}/cancel'
}

export type PutFalAiSkyRaccoonRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiSkyRaccoonRequestsByRequestIdCancelResponse =
  PutFalAiSkyRaccoonRequestsByRequestIdCancelResponses[keyof PutFalAiSkyRaccoonRequestsByRequestIdCancelResponses]

export type PostFalAiSkyRaccoonData = {
  body: SchemaSkyRaccoonInput
  path?: never
  query?: never
  url: '/fal-ai/sky-raccoon'
}

export type PostFalAiSkyRaccoonResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiSkyRaccoonResponse =
  PostFalAiSkyRaccoonResponses[keyof PostFalAiSkyRaccoonResponses]

export type GetFalAiSkyRaccoonRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sky-raccoon/requests/{request_id}'
}

export type GetFalAiSkyRaccoonRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaSkyRaccoonOutput
}

export type GetFalAiSkyRaccoonRequestsByRequestIdResponse =
  GetFalAiSkyRaccoonRequestsByRequestIdResponses[keyof GetFalAiSkyRaccoonRequestsByRequestIdResponses]

export type GetFalAiFluxKontextLoraTextToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-kontext-lora/text-to-image/requests/{request_id}/status'
}

export type GetFalAiFluxKontextLoraTextToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFluxKontextLoraTextToImageRequestsByRequestIdStatusResponse =
  GetFalAiFluxKontextLoraTextToImageRequestsByRequestIdStatusResponses[keyof GetFalAiFluxKontextLoraTextToImageRequestsByRequestIdStatusResponses]

export type PutFalAiFluxKontextLoraTextToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-kontext-lora/text-to-image/requests/{request_id}/cancel'
}

export type PutFalAiFluxKontextLoraTextToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFluxKontextLoraTextToImageRequestsByRequestIdCancelResponse =
  PutFalAiFluxKontextLoraTextToImageRequestsByRequestIdCancelResponses[keyof PutFalAiFluxKontextLoraTextToImageRequestsByRequestIdCancelResponses]

export type PostFalAiFluxKontextLoraTextToImageData = {
  body: SchemaFluxKontextLoraTextToImageInput
  path?: never
  query?: never
  url: '/fal-ai/flux-kontext-lora/text-to-image'
}

export type PostFalAiFluxKontextLoraTextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxKontextLoraTextToImageResponse =
  PostFalAiFluxKontextLoraTextToImageResponses[keyof PostFalAiFluxKontextLoraTextToImageResponses]

export type GetFalAiFluxKontextLoraTextToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-kontext-lora/text-to-image/requests/{request_id}'
}

export type GetFalAiFluxKontextLoraTextToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxKontextLoraTextToImageOutput
}

export type GetFalAiFluxKontextLoraTextToImageRequestsByRequestIdResponse =
  GetFalAiFluxKontextLoraTextToImageRequestsByRequestIdResponses[keyof GetFalAiFluxKontextLoraTextToImageRequestsByRequestIdResponses]

export type GetFalAiOmnigenV2RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/omnigen-v2/requests/{request_id}/status'
}

export type GetFalAiOmnigenV2RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiOmnigenV2RequestsByRequestIdStatusResponse =
  GetFalAiOmnigenV2RequestsByRequestIdStatusResponses[keyof GetFalAiOmnigenV2RequestsByRequestIdStatusResponses]

export type PutFalAiOmnigenV2RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/omnigen-v2/requests/{request_id}/cancel'
}

export type PutFalAiOmnigenV2RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiOmnigenV2RequestsByRequestIdCancelResponse =
  PutFalAiOmnigenV2RequestsByRequestIdCancelResponses[keyof PutFalAiOmnigenV2RequestsByRequestIdCancelResponses]

export type PostFalAiOmnigenV2Data = {
  body: SchemaOmnigenV2Input
  path?: never
  query?: never
  url: '/fal-ai/omnigen-v2'
}

export type PostFalAiOmnigenV2Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiOmnigenV2Response =
  PostFalAiOmnigenV2Responses[keyof PostFalAiOmnigenV2Responses]

export type GetFalAiOmnigenV2RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/omnigen-v2/requests/{request_id}'
}

export type GetFalAiOmnigenV2RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaOmnigenV2Output
}

export type GetFalAiOmnigenV2RequestsByRequestIdResponse =
  GetFalAiOmnigenV2RequestsByRequestIdResponses[keyof GetFalAiOmnigenV2RequestsByRequestIdResponses]

export type GetFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/bytedance/seedream/v3/text-to-image/requests/{request_id}/status'
  }

export type GetFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdStatusResponse =
  GetFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdStatusResponses[keyof GetFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdStatusResponses]

export type PutFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/bytedance/seedream/v3/text-to-image/requests/{request_id}/cancel'
  }

export type PutFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdCancelResponse =
  PutFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdCancelResponses[keyof PutFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdCancelResponses]

export type PostFalAiBytedanceSeedreamV3TextToImageData = {
  body: SchemaBytedanceSeedreamV3TextToImageInput
  path?: never
  query?: never
  url: '/fal-ai/bytedance/seedream/v3/text-to-image'
}

export type PostFalAiBytedanceSeedreamV3TextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBytedanceSeedreamV3TextToImageResponse =
  PostFalAiBytedanceSeedreamV3TextToImageResponses[keyof PostFalAiBytedanceSeedreamV3TextToImageResponses]

export type GetFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bytedance/seedream/v3/text-to-image/requests/{request_id}'
}

export type GetFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaBytedanceSeedreamV3TextToImageOutput
  }

export type GetFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdResponse =
  GetFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdResponses[keyof GetFalAiBytedanceSeedreamV3TextToImageRequestsByRequestIdResponses]

export type GetFalAiFlux1SchnellRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-1/schnell/requests/{request_id}/status'
}

export type GetFalAiFlux1SchnellRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux1SchnellRequestsByRequestIdStatusResponse =
  GetFalAiFlux1SchnellRequestsByRequestIdStatusResponses[keyof GetFalAiFlux1SchnellRequestsByRequestIdStatusResponses]

export type PutFalAiFlux1SchnellRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/schnell/requests/{request_id}/cancel'
}

export type PutFalAiFlux1SchnellRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux1SchnellRequestsByRequestIdCancelResponse =
  PutFalAiFlux1SchnellRequestsByRequestIdCancelResponses[keyof PutFalAiFlux1SchnellRequestsByRequestIdCancelResponses]

export type PostFalAiFlux1SchnellData = {
  body: SchemaFlux1SchnellInput
  path?: never
  query?: never
  url: '/fal-ai/flux-1/schnell'
}

export type PostFalAiFlux1SchnellResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux1SchnellResponse =
  PostFalAiFlux1SchnellResponses[keyof PostFalAiFlux1SchnellResponses]

export type GetFalAiFlux1SchnellRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/schnell/requests/{request_id}'
}

export type GetFalAiFlux1SchnellRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux1SchnellOutput
}

export type GetFalAiFlux1SchnellRequestsByRequestIdResponse =
  GetFalAiFlux1SchnellRequestsByRequestIdResponses[keyof GetFalAiFlux1SchnellRequestsByRequestIdResponses]

export type GetFalAiFlux1DevRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-1/dev/requests/{request_id}/status'
}

export type GetFalAiFlux1DevRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFlux1DevRequestsByRequestIdStatusResponse =
  GetFalAiFlux1DevRequestsByRequestIdStatusResponses[keyof GetFalAiFlux1DevRequestsByRequestIdStatusResponses]

export type PutFalAiFlux1DevRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/dev/requests/{request_id}/cancel'
}

export type PutFalAiFlux1DevRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFlux1DevRequestsByRequestIdCancelResponse =
  PutFalAiFlux1DevRequestsByRequestIdCancelResponses[keyof PutFalAiFlux1DevRequestsByRequestIdCancelResponses]

export type PostFalAiFlux1DevData = {
  body: SchemaFlux1DevInput
  path?: never
  query?: never
  url: '/fal-ai/flux-1/dev'
}

export type PostFalAiFlux1DevResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFlux1DevResponse =
  PostFalAiFlux1DevResponses[keyof PostFalAiFlux1DevResponses]

export type GetFalAiFlux1DevRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-1/dev/requests/{request_id}'
}

export type GetFalAiFlux1DevRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFlux1DevOutput
}

export type GetFalAiFlux1DevRequestsByRequestIdResponse =
  GetFalAiFlux1DevRequestsByRequestIdResponses[keyof GetFalAiFlux1DevRequestsByRequestIdResponses]

export type GetFalAiFluxProKontextMaxTextToImageRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/fal-ai/flux-pro/kontext/max/text-to-image/requests/{request_id}/status'
  }

export type GetFalAiFluxProKontextMaxTextToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFluxProKontextMaxTextToImageRequestsByRequestIdStatusResponse =
  GetFalAiFluxProKontextMaxTextToImageRequestsByRequestIdStatusResponses[keyof GetFalAiFluxProKontextMaxTextToImageRequestsByRequestIdStatusResponses]

export type PutFalAiFluxProKontextMaxTextToImageRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/fal-ai/flux-pro/kontext/max/text-to-image/requests/{request_id}/cancel'
  }

export type PutFalAiFluxProKontextMaxTextToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFluxProKontextMaxTextToImageRequestsByRequestIdCancelResponse =
  PutFalAiFluxProKontextMaxTextToImageRequestsByRequestIdCancelResponses[keyof PutFalAiFluxProKontextMaxTextToImageRequestsByRequestIdCancelResponses]

export type PostFalAiFluxProKontextMaxTextToImageData = {
  body: SchemaFluxProKontextMaxTextToImageInput
  path?: never
  query?: never
  url: '/fal-ai/flux-pro/kontext/max/text-to-image'
}

export type PostFalAiFluxProKontextMaxTextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxProKontextMaxTextToImageResponse =
  PostFalAiFluxProKontextMaxTextToImageResponses[keyof PostFalAiFluxProKontextMaxTextToImageResponses]

export type GetFalAiFluxProKontextMaxTextToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/kontext/max/text-to-image/requests/{request_id}'
}

export type GetFalAiFluxProKontextMaxTextToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxProKontextMaxTextToImageOutput
}

export type GetFalAiFluxProKontextMaxTextToImageRequestsByRequestIdResponse =
  GetFalAiFluxProKontextMaxTextToImageRequestsByRequestIdResponses[keyof GetFalAiFluxProKontextMaxTextToImageRequestsByRequestIdResponses]

export type GetFalAiFluxProKontextTextToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-pro/kontext/text-to-image/requests/{request_id}/status'
}

export type GetFalAiFluxProKontextTextToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFluxProKontextTextToImageRequestsByRequestIdStatusResponse =
  GetFalAiFluxProKontextTextToImageRequestsByRequestIdStatusResponses[keyof GetFalAiFluxProKontextTextToImageRequestsByRequestIdStatusResponses]

export type PutFalAiFluxProKontextTextToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/kontext/text-to-image/requests/{request_id}/cancel'
}

export type PutFalAiFluxProKontextTextToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFluxProKontextTextToImageRequestsByRequestIdCancelResponse =
  PutFalAiFluxProKontextTextToImageRequestsByRequestIdCancelResponses[keyof PutFalAiFluxProKontextTextToImageRequestsByRequestIdCancelResponses]

export type PostFalAiFluxProKontextTextToImageData = {
  body: SchemaFluxProKontextTextToImageInput
  path?: never
  query?: never
  url: '/fal-ai/flux-pro/kontext/text-to-image'
}

export type PostFalAiFluxProKontextTextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxProKontextTextToImageResponse =
  PostFalAiFluxProKontextTextToImageResponses[keyof PostFalAiFluxProKontextTextToImageResponses]

export type GetFalAiFluxProKontextTextToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/kontext/text-to-image/requests/{request_id}'
}

export type GetFalAiFluxProKontextTextToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxProKontextTextToImageOutput
}

export type GetFalAiFluxProKontextTextToImageRequestsByRequestIdResponse =
  GetFalAiFluxProKontextTextToImageRequestsByRequestIdResponses[keyof GetFalAiFluxProKontextTextToImageRequestsByRequestIdResponses]

export type GetFalAiBagelRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/bagel/requests/{request_id}/status'
}

export type GetFalAiBagelRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiBagelRequestsByRequestIdStatusResponse =
  GetFalAiBagelRequestsByRequestIdStatusResponses[keyof GetFalAiBagelRequestsByRequestIdStatusResponses]

export type PutFalAiBagelRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bagel/requests/{request_id}/cancel'
}

export type PutFalAiBagelRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiBagelRequestsByRequestIdCancelResponse =
  PutFalAiBagelRequestsByRequestIdCancelResponses[keyof PutFalAiBagelRequestsByRequestIdCancelResponses]

export type PostFalAiBagelData = {
  body: SchemaBagelInput
  path?: never
  query?: never
  url: '/fal-ai/bagel'
}

export type PostFalAiBagelResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBagelResponse =
  PostFalAiBagelResponses[keyof PostFalAiBagelResponses]

export type GetFalAiBagelRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bagel/requests/{request_id}'
}

export type GetFalAiBagelRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaBagelOutput
}

export type GetFalAiBagelRequestsByRequestIdResponse =
  GetFalAiBagelRequestsByRequestIdResponses[keyof GetFalAiBagelRequestsByRequestIdResponses]

export type GetFalAiImagen4PreviewUltraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/imagen4/preview/ultra/requests/{request_id}/status'
}

export type GetFalAiImagen4PreviewUltraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImagen4PreviewUltraRequestsByRequestIdStatusResponse =
  GetFalAiImagen4PreviewUltraRequestsByRequestIdStatusResponses[keyof GetFalAiImagen4PreviewUltraRequestsByRequestIdStatusResponses]

export type PutFalAiImagen4PreviewUltraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/imagen4/preview/ultra/requests/{request_id}/cancel'
}

export type PutFalAiImagen4PreviewUltraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImagen4PreviewUltraRequestsByRequestIdCancelResponse =
  PutFalAiImagen4PreviewUltraRequestsByRequestIdCancelResponses[keyof PutFalAiImagen4PreviewUltraRequestsByRequestIdCancelResponses]

export type PostFalAiImagen4PreviewUltraData = {
  body: SchemaImagen4PreviewUltraInput
  path?: never
  query?: never
  url: '/fal-ai/imagen4/preview/ultra'
}

export type PostFalAiImagen4PreviewUltraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImagen4PreviewUltraResponse =
  PostFalAiImagen4PreviewUltraResponses[keyof PostFalAiImagen4PreviewUltraResponses]

export type GetFalAiImagen4PreviewUltraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/imagen4/preview/ultra/requests/{request_id}'
}

export type GetFalAiImagen4PreviewUltraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImagen4PreviewUltraOutput
}

export type GetFalAiImagen4PreviewUltraRequestsByRequestIdResponse =
  GetFalAiImagen4PreviewUltraRequestsByRequestIdResponses[keyof GetFalAiImagen4PreviewUltraRequestsByRequestIdResponses]

export type GetFalAiDreamoRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/dreamo/requests/{request_id}/status'
}

export type GetFalAiDreamoRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiDreamoRequestsByRequestIdStatusResponse =
  GetFalAiDreamoRequestsByRequestIdStatusResponses[keyof GetFalAiDreamoRequestsByRequestIdStatusResponses]

export type PutFalAiDreamoRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/dreamo/requests/{request_id}/cancel'
}

export type PutFalAiDreamoRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiDreamoRequestsByRequestIdCancelResponse =
  PutFalAiDreamoRequestsByRequestIdCancelResponses[keyof PutFalAiDreamoRequestsByRequestIdCancelResponses]

export type PostFalAiDreamoData = {
  body: SchemaDreamoInput
  path?: never
  query?: never
  url: '/fal-ai/dreamo'
}

export type PostFalAiDreamoResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiDreamoResponse =
  PostFalAiDreamoResponses[keyof PostFalAiDreamoResponses]

export type GetFalAiDreamoRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/dreamo/requests/{request_id}'
}

export type GetFalAiDreamoRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaDreamoOutput
}

export type GetFalAiDreamoRequestsByRequestIdResponse =
  GetFalAiDreamoRequestsByRequestIdResponses[keyof GetFalAiDreamoRequestsByRequestIdResponses]

export type GetFalAiFluxLoraStreamRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-lora/stream/requests/{request_id}/status'
}

export type GetFalAiFluxLoraStreamRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxLoraStreamRequestsByRequestIdStatusResponse =
  GetFalAiFluxLoraStreamRequestsByRequestIdStatusResponses[keyof GetFalAiFluxLoraStreamRequestsByRequestIdStatusResponses]

export type PutFalAiFluxLoraStreamRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-lora/stream/requests/{request_id}/cancel'
}

export type PutFalAiFluxLoraStreamRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxLoraStreamRequestsByRequestIdCancelResponse =
  PutFalAiFluxLoraStreamRequestsByRequestIdCancelResponses[keyof PutFalAiFluxLoraStreamRequestsByRequestIdCancelResponses]

export type PostFalAiFluxLoraStreamData = {
  body: SchemaFluxLoraStreamInput
  path?: never
  query?: never
  url: '/fal-ai/flux-lora/stream'
}

export type PostFalAiFluxLoraStreamResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxLoraStreamResponse =
  PostFalAiFluxLoraStreamResponses[keyof PostFalAiFluxLoraStreamResponses]

export type GetFalAiFluxLoraStreamRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-lora/stream/requests/{request_id}'
}

export type GetFalAiFluxLoraStreamRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxLoraStreamOutput
}

export type GetFalAiFluxLoraStreamRequestsByRequestIdResponse =
  GetFalAiFluxLoraStreamRequestsByRequestIdResponses[keyof GetFalAiFluxLoraStreamRequestsByRequestIdResponses]

export type GetFalAiMinimaxImage01RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/minimax/image-01/requests/{request_id}/status'
}

export type GetFalAiMinimaxImage01RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiMinimaxImage01RequestsByRequestIdStatusResponse =
  GetFalAiMinimaxImage01RequestsByRequestIdStatusResponses[keyof GetFalAiMinimaxImage01RequestsByRequestIdStatusResponses]

export type PutFalAiMinimaxImage01RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/minimax/image-01/requests/{request_id}/cancel'
}

export type PutFalAiMinimaxImage01RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiMinimaxImage01RequestsByRequestIdCancelResponse =
  PutFalAiMinimaxImage01RequestsByRequestIdCancelResponses[keyof PutFalAiMinimaxImage01RequestsByRequestIdCancelResponses]

export type PostFalAiMinimaxImage01Data = {
  body: SchemaMinimaxImage01Input
  path?: never
  query?: never
  url: '/fal-ai/minimax/image-01'
}

export type PostFalAiMinimaxImage01Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiMinimaxImage01Response =
  PostFalAiMinimaxImage01Responses[keyof PostFalAiMinimaxImage01Responses]

export type GetFalAiMinimaxImage01RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/minimax/image-01/requests/{request_id}'
}

export type GetFalAiMinimaxImage01RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaMinimaxImage01Output
}

export type GetFalAiMinimaxImage01RequestsByRequestIdResponse =
  GetFalAiMinimaxImage01RequestsByRequestIdResponses[keyof GetFalAiMinimaxImage01RequestsByRequestIdResponses]

export type GetFalAiPonyV7RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/pony-v7/requests/{request_id}/status'
}

export type GetFalAiPonyV7RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiPonyV7RequestsByRequestIdStatusResponse =
  GetFalAiPonyV7RequestsByRequestIdStatusResponses[keyof GetFalAiPonyV7RequestsByRequestIdStatusResponses]

export type PutFalAiPonyV7RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/pony-v7/requests/{request_id}/cancel'
}

export type PutFalAiPonyV7RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiPonyV7RequestsByRequestIdCancelResponse =
  PutFalAiPonyV7RequestsByRequestIdCancelResponses[keyof PutFalAiPonyV7RequestsByRequestIdCancelResponses]

export type PostFalAiPonyV7Data = {
  body: SchemaPonyV7Input
  path?: never
  query?: never
  url: '/fal-ai/pony-v7'
}

export type PostFalAiPonyV7Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPonyV7Response =
  PostFalAiPonyV7Responses[keyof PostFalAiPonyV7Responses]

export type GetFalAiPonyV7RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/pony-v7/requests/{request_id}'
}

export type GetFalAiPonyV7RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPonyV7Output
}

export type GetFalAiPonyV7RequestsByRequestIdResponse =
  GetFalAiPonyV7RequestsByRequestIdResponses[keyof GetFalAiPonyV7RequestsByRequestIdResponses]

export type GetFalAiIdeogramV3RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ideogram/v3/requests/{request_id}/status'
}

export type GetFalAiIdeogramV3RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIdeogramV3RequestsByRequestIdStatusResponse =
  GetFalAiIdeogramV3RequestsByRequestIdStatusResponses[keyof GetFalAiIdeogramV3RequestsByRequestIdStatusResponses]

export type PutFalAiIdeogramV3RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v3/requests/{request_id}/cancel'
}

export type PutFalAiIdeogramV3RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIdeogramV3RequestsByRequestIdCancelResponse =
  PutFalAiIdeogramV3RequestsByRequestIdCancelResponses[keyof PutFalAiIdeogramV3RequestsByRequestIdCancelResponses]

export type PostFalAiIdeogramV3Data = {
  body: SchemaIdeogramV3Input
  path?: never
  query?: never
  url: '/fal-ai/ideogram/v3'
}

export type PostFalAiIdeogramV3Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIdeogramV3Response =
  PostFalAiIdeogramV3Responses[keyof PostFalAiIdeogramV3Responses]

export type GetFalAiIdeogramV3RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v3/requests/{request_id}'
}

export type GetFalAiIdeogramV3RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIdeogramV3Output
}

export type GetFalAiIdeogramV3RequestsByRequestIdResponse =
  GetFalAiIdeogramV3RequestsByRequestIdResponses[keyof GetFalAiIdeogramV3RequestsByRequestIdResponses]

export type GetFalAiFLiteStandardRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/f-lite/standard/requests/{request_id}/status'
}

export type GetFalAiFLiteStandardRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFLiteStandardRequestsByRequestIdStatusResponse =
  GetFalAiFLiteStandardRequestsByRequestIdStatusResponses[keyof GetFalAiFLiteStandardRequestsByRequestIdStatusResponses]

export type PutFalAiFLiteStandardRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/f-lite/standard/requests/{request_id}/cancel'
}

export type PutFalAiFLiteStandardRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFLiteStandardRequestsByRequestIdCancelResponse =
  PutFalAiFLiteStandardRequestsByRequestIdCancelResponses[keyof PutFalAiFLiteStandardRequestsByRequestIdCancelResponses]

export type PostFalAiFLiteStandardData = {
  body: SchemaFLiteStandardInput
  path?: never
  query?: never
  url: '/fal-ai/f-lite/standard'
}

export type PostFalAiFLiteStandardResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFLiteStandardResponse =
  PostFalAiFLiteStandardResponses[keyof PostFalAiFLiteStandardResponses]

export type GetFalAiFLiteStandardRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/f-lite/standard/requests/{request_id}'
}

export type GetFalAiFLiteStandardRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFLiteStandardOutput
}

export type GetFalAiFLiteStandardRequestsByRequestIdResponse =
  GetFalAiFLiteStandardRequestsByRequestIdResponses[keyof GetFalAiFLiteStandardRequestsByRequestIdResponses]

export type GetFalAiFLiteTextureRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/f-lite/texture/requests/{request_id}/status'
}

export type GetFalAiFLiteTextureRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFLiteTextureRequestsByRequestIdStatusResponse =
  GetFalAiFLiteTextureRequestsByRequestIdStatusResponses[keyof GetFalAiFLiteTextureRequestsByRequestIdStatusResponses]

export type PutFalAiFLiteTextureRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/f-lite/texture/requests/{request_id}/cancel'
}

export type PutFalAiFLiteTextureRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFLiteTextureRequestsByRequestIdCancelResponse =
  PutFalAiFLiteTextureRequestsByRequestIdCancelResponses[keyof PutFalAiFLiteTextureRequestsByRequestIdCancelResponses]

export type PostFalAiFLiteTextureData = {
  body: SchemaFLiteTextureInput
  path?: never
  query?: never
  url: '/fal-ai/f-lite/texture'
}

export type PostFalAiFLiteTextureResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFLiteTextureResponse =
  PostFalAiFLiteTextureResponses[keyof PostFalAiFLiteTextureResponses]

export type GetFalAiFLiteTextureRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/f-lite/texture/requests/{request_id}'
}

export type GetFalAiFLiteTextureRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFLiteTextureOutput
}

export type GetFalAiFLiteTextureRequestsByRequestIdResponse =
  GetFalAiFLiteTextureRequestsByRequestIdResponses[keyof GetFalAiFLiteTextureRequestsByRequestIdResponses]

export type GetFalAiGptImage1TextToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/gpt-image-1/text-to-image/requests/{request_id}/status'
}

export type GetFalAiGptImage1TextToImageRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiGptImage1TextToImageRequestsByRequestIdStatusResponse =
  GetFalAiGptImage1TextToImageRequestsByRequestIdStatusResponses[keyof GetFalAiGptImage1TextToImageRequestsByRequestIdStatusResponses]

export type PutFalAiGptImage1TextToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gpt-image-1/text-to-image/requests/{request_id}/cancel'
}

export type PutFalAiGptImage1TextToImageRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiGptImage1TextToImageRequestsByRequestIdCancelResponse =
  PutFalAiGptImage1TextToImageRequestsByRequestIdCancelResponses[keyof PutFalAiGptImage1TextToImageRequestsByRequestIdCancelResponses]

export type PostFalAiGptImage1TextToImageData = {
  body: SchemaGptImage1TextToImageInput
  path?: never
  query?: never
  url: '/fal-ai/gpt-image-1/text-to-image'
}

export type PostFalAiGptImage1TextToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiGptImage1TextToImageResponse =
  PostFalAiGptImage1TextToImageResponses[keyof PostFalAiGptImage1TextToImageResponses]

export type GetFalAiGptImage1TextToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/gpt-image-1/text-to-image/requests/{request_id}'
}

export type GetFalAiGptImage1TextToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaGptImage1TextToImageOutput
}

export type GetFalAiGptImage1TextToImageRequestsByRequestIdResponse =
  GetFalAiGptImage1TextToImageRequestsByRequestIdResponses[keyof GetFalAiGptImage1TextToImageRequestsByRequestIdResponses]

export type GetFalAiSanaV1516bRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/sana/v1.5/1.6b/requests/{request_id}/status'
}

export type GetFalAiSanaV1516bRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiSanaV1516bRequestsByRequestIdStatusResponse =
  GetFalAiSanaV1516bRequestsByRequestIdStatusResponses[keyof GetFalAiSanaV1516bRequestsByRequestIdStatusResponses]

export type PutFalAiSanaV1516bRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sana/v1.5/1.6b/requests/{request_id}/cancel'
}

export type PutFalAiSanaV1516bRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiSanaV1516bRequestsByRequestIdCancelResponse =
  PutFalAiSanaV1516bRequestsByRequestIdCancelResponses[keyof PutFalAiSanaV1516bRequestsByRequestIdCancelResponses]

export type PostFalAiSanaV1516bData = {
  body: SchemaSanaV1516bInput
  path?: never
  query?: never
  url: '/fal-ai/sana/v1.5/1.6b'
}

export type PostFalAiSanaV1516bResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiSanaV1516bResponse =
  PostFalAiSanaV1516bResponses[keyof PostFalAiSanaV1516bResponses]

export type GetFalAiSanaV1516bRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sana/v1.5/1.6b/requests/{request_id}'
}

export type GetFalAiSanaV1516bRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaSanaV1516bOutput
}

export type GetFalAiSanaV1516bRequestsByRequestIdResponse =
  GetFalAiSanaV1516bRequestsByRequestIdResponses[keyof GetFalAiSanaV1516bRequestsByRequestIdResponses]

export type GetFalAiSanaV1548bRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/sana/v1.5/4.8b/requests/{request_id}/status'
}

export type GetFalAiSanaV1548bRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiSanaV1548bRequestsByRequestIdStatusResponse =
  GetFalAiSanaV1548bRequestsByRequestIdStatusResponses[keyof GetFalAiSanaV1548bRequestsByRequestIdStatusResponses]

export type PutFalAiSanaV1548bRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sana/v1.5/4.8b/requests/{request_id}/cancel'
}

export type PutFalAiSanaV1548bRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiSanaV1548bRequestsByRequestIdCancelResponse =
  PutFalAiSanaV1548bRequestsByRequestIdCancelResponses[keyof PutFalAiSanaV1548bRequestsByRequestIdCancelResponses]

export type PostFalAiSanaV1548bData = {
  body: SchemaSanaV1548bInput
  path?: never
  query?: never
  url: '/fal-ai/sana/v1.5/4.8b'
}

export type PostFalAiSanaV1548bResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiSanaV1548bResponse =
  PostFalAiSanaV1548bResponses[keyof PostFalAiSanaV1548bResponses]

export type GetFalAiSanaV1548bRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sana/v1.5/4.8b/requests/{request_id}'
}

export type GetFalAiSanaV1548bRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaSanaV1548bOutput
}

export type GetFalAiSanaV1548bRequestsByRequestIdResponse =
  GetFalAiSanaV1548bRequestsByRequestIdResponses[keyof GetFalAiSanaV1548bRequestsByRequestIdResponses]

export type GetFalAiSanaSprintRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/sana/sprint/requests/{request_id}/status'
}

export type GetFalAiSanaSprintRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiSanaSprintRequestsByRequestIdStatusResponse =
  GetFalAiSanaSprintRequestsByRequestIdStatusResponses[keyof GetFalAiSanaSprintRequestsByRequestIdStatusResponses]

export type PutFalAiSanaSprintRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sana/sprint/requests/{request_id}/cancel'
}

export type PutFalAiSanaSprintRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiSanaSprintRequestsByRequestIdCancelResponse =
  PutFalAiSanaSprintRequestsByRequestIdCancelResponses[keyof PutFalAiSanaSprintRequestsByRequestIdCancelResponses]

export type PostFalAiSanaSprintData = {
  body: SchemaSanaSprintInput
  path?: never
  query?: never
  url: '/fal-ai/sana/sprint'
}

export type PostFalAiSanaSprintResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiSanaSprintResponse =
  PostFalAiSanaSprintResponses[keyof PostFalAiSanaSprintResponses]

export type GetFalAiSanaSprintRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sana/sprint/requests/{request_id}'
}

export type GetFalAiSanaSprintRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaSanaSprintOutput
}

export type GetFalAiSanaSprintRequestsByRequestIdResponse =
  GetFalAiSanaSprintRequestsByRequestIdResponses[keyof GetFalAiSanaSprintRequestsByRequestIdResponses]

export type GetRundiffusionFalJuggernautFluxLightningRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/rundiffusion-fal/juggernaut-flux/lightning/requests/{request_id}/status'
  }

export type GetRundiffusionFalJuggernautFluxLightningRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetRundiffusionFalJuggernautFluxLightningRequestsByRequestIdStatusResponse =
  GetRundiffusionFalJuggernautFluxLightningRequestsByRequestIdStatusResponses[keyof GetRundiffusionFalJuggernautFluxLightningRequestsByRequestIdStatusResponses]

export type PutRundiffusionFalJuggernautFluxLightningRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/rundiffusion-fal/juggernaut-flux/lightning/requests/{request_id}/cancel'
  }

export type PutRundiffusionFalJuggernautFluxLightningRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutRundiffusionFalJuggernautFluxLightningRequestsByRequestIdCancelResponse =
  PutRundiffusionFalJuggernautFluxLightningRequestsByRequestIdCancelResponses[keyof PutRundiffusionFalJuggernautFluxLightningRequestsByRequestIdCancelResponses]

export type PostRundiffusionFalJuggernautFluxLightningData = {
  body: SchemaJuggernautFluxLightningInput
  path?: never
  query?: never
  url: '/rundiffusion-fal/juggernaut-flux/lightning'
}

export type PostRundiffusionFalJuggernautFluxLightningResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostRundiffusionFalJuggernautFluxLightningResponse =
  PostRundiffusionFalJuggernautFluxLightningResponses[keyof PostRundiffusionFalJuggernautFluxLightningResponses]

export type GetRundiffusionFalJuggernautFluxLightningRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/rundiffusion-fal/juggernaut-flux/lightning/requests/{request_id}'
}

export type GetRundiffusionFalJuggernautFluxLightningRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaJuggernautFluxLightningOutput
  }

export type GetRundiffusionFalJuggernautFluxLightningRequestsByRequestIdResponse =
  GetRundiffusionFalJuggernautFluxLightningRequestsByRequestIdResponses[keyof GetRundiffusionFalJuggernautFluxLightningRequestsByRequestIdResponses]

export type GetRundiffusionFalJuggernautFluxProRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/rundiffusion-fal/juggernaut-flux/pro/requests/{request_id}/status'
}

export type GetRundiffusionFalJuggernautFluxProRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetRundiffusionFalJuggernautFluxProRequestsByRequestIdStatusResponse =
  GetRundiffusionFalJuggernautFluxProRequestsByRequestIdStatusResponses[keyof GetRundiffusionFalJuggernautFluxProRequestsByRequestIdStatusResponses]

export type PutRundiffusionFalJuggernautFluxProRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/rundiffusion-fal/juggernaut-flux/pro/requests/{request_id}/cancel'
}

export type PutRundiffusionFalJuggernautFluxProRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutRundiffusionFalJuggernautFluxProRequestsByRequestIdCancelResponse =
  PutRundiffusionFalJuggernautFluxProRequestsByRequestIdCancelResponses[keyof PutRundiffusionFalJuggernautFluxProRequestsByRequestIdCancelResponses]

export type PostRundiffusionFalJuggernautFluxProData = {
  body: SchemaJuggernautFluxProInput
  path?: never
  query?: never
  url: '/rundiffusion-fal/juggernaut-flux/pro'
}

export type PostRundiffusionFalJuggernautFluxProResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostRundiffusionFalJuggernautFluxProResponse =
  PostRundiffusionFalJuggernautFluxProResponses[keyof PostRundiffusionFalJuggernautFluxProResponses]

export type GetRundiffusionFalJuggernautFluxProRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/rundiffusion-fal/juggernaut-flux/pro/requests/{request_id}'
}

export type GetRundiffusionFalJuggernautFluxProRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaJuggernautFluxProOutput
}

export type GetRundiffusionFalJuggernautFluxProRequestsByRequestIdResponse =
  GetRundiffusionFalJuggernautFluxProRequestsByRequestIdResponses[keyof GetRundiffusionFalJuggernautFluxProRequestsByRequestIdResponses]

export type GetRundiffusionFalJuggernautFluxLoraRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/rundiffusion-fal/juggernaut-flux-lora/requests/{request_id}/status'
  }

export type GetRundiffusionFalJuggernautFluxLoraRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetRundiffusionFalJuggernautFluxLoraRequestsByRequestIdStatusResponse =
  GetRundiffusionFalJuggernautFluxLoraRequestsByRequestIdStatusResponses[keyof GetRundiffusionFalJuggernautFluxLoraRequestsByRequestIdStatusResponses]

export type PutRundiffusionFalJuggernautFluxLoraRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/rundiffusion-fal/juggernaut-flux-lora/requests/{request_id}/cancel'
  }

export type PutRundiffusionFalJuggernautFluxLoraRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutRundiffusionFalJuggernautFluxLoraRequestsByRequestIdCancelResponse =
  PutRundiffusionFalJuggernautFluxLoraRequestsByRequestIdCancelResponses[keyof PutRundiffusionFalJuggernautFluxLoraRequestsByRequestIdCancelResponses]

export type PostRundiffusionFalJuggernautFluxLoraData = {
  body: SchemaJuggernautFluxLoraInput
  path?: never
  query?: never
  url: '/rundiffusion-fal/juggernaut-flux-lora'
}

export type PostRundiffusionFalJuggernautFluxLoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostRundiffusionFalJuggernautFluxLoraResponse =
  PostRundiffusionFalJuggernautFluxLoraResponses[keyof PostRundiffusionFalJuggernautFluxLoraResponses]

export type GetRundiffusionFalJuggernautFluxLoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/rundiffusion-fal/juggernaut-flux-lora/requests/{request_id}'
}

export type GetRundiffusionFalJuggernautFluxLoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaJuggernautFluxLoraOutput
}

export type GetRundiffusionFalJuggernautFluxLoraRequestsByRequestIdResponse =
  GetRundiffusionFalJuggernautFluxLoraRequestsByRequestIdResponses[keyof GetRundiffusionFalJuggernautFluxLoraRequestsByRequestIdResponses]

export type GetRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/rundiffusion-fal/rundiffusion-photo-flux/requests/{request_id}/status'
  }

export type GetRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdStatusResponse =
  GetRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdStatusResponses[keyof GetRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdStatusResponses]

export type PutRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/rundiffusion-fal/rundiffusion-photo-flux/requests/{request_id}/cancel'
  }

export type PutRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdCancelResponse =
  PutRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdCancelResponses[keyof PutRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdCancelResponses]

export type PostRundiffusionFalRundiffusionPhotoFluxData = {
  body: SchemaRundiffusionPhotoFluxInput
  path?: never
  query?: never
  url: '/rundiffusion-fal/rundiffusion-photo-flux'
}

export type PostRundiffusionFalRundiffusionPhotoFluxResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostRundiffusionFalRundiffusionPhotoFluxResponse =
  PostRundiffusionFalRundiffusionPhotoFluxResponses[keyof PostRundiffusionFalRundiffusionPhotoFluxResponses]

export type GetRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/rundiffusion-fal/rundiffusion-photo-flux/requests/{request_id}'
}

export type GetRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdResponses =
  {
    /**
     * Result of the request.
     */
    200: SchemaRundiffusionPhotoFluxOutput
  }

export type GetRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdResponse =
  GetRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdResponses[keyof GetRundiffusionFalRundiffusionPhotoFluxRequestsByRequestIdResponses]

export type GetRundiffusionFalJuggernautFluxBaseRequestsByRequestIdStatusData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: {
      /**
       * Whether to include logs (`1`) in the response or not (`0`).
       */
      logs?: number
    }
    url: '/rundiffusion-fal/juggernaut-flux/base/requests/{request_id}/status'
  }

export type GetRundiffusionFalJuggernautFluxBaseRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetRundiffusionFalJuggernautFluxBaseRequestsByRequestIdStatusResponse =
  GetRundiffusionFalJuggernautFluxBaseRequestsByRequestIdStatusResponses[keyof GetRundiffusionFalJuggernautFluxBaseRequestsByRequestIdStatusResponses]

export type PutRundiffusionFalJuggernautFluxBaseRequestsByRequestIdCancelData =
  {
    body?: never
    path: {
      /**
       * Request ID
       */
      request_id: string
    }
    query?: never
    url: '/rundiffusion-fal/juggernaut-flux/base/requests/{request_id}/cancel'
  }

export type PutRundiffusionFalJuggernautFluxBaseRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutRundiffusionFalJuggernautFluxBaseRequestsByRequestIdCancelResponse =
  PutRundiffusionFalJuggernautFluxBaseRequestsByRequestIdCancelResponses[keyof PutRundiffusionFalJuggernautFluxBaseRequestsByRequestIdCancelResponses]

export type PostRundiffusionFalJuggernautFluxBaseData = {
  body: SchemaJuggernautFluxBaseInput
  path?: never
  query?: never
  url: '/rundiffusion-fal/juggernaut-flux/base'
}

export type PostRundiffusionFalJuggernautFluxBaseResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostRundiffusionFalJuggernautFluxBaseResponse =
  PostRundiffusionFalJuggernautFluxBaseResponses[keyof PostRundiffusionFalJuggernautFluxBaseResponses]

export type GetRundiffusionFalJuggernautFluxBaseRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/rundiffusion-fal/juggernaut-flux/base/requests/{request_id}'
}

export type GetRundiffusionFalJuggernautFluxBaseRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaJuggernautFluxBaseOutput
}

export type GetRundiffusionFalJuggernautFluxBaseRequestsByRequestIdResponse =
  GetRundiffusionFalJuggernautFluxBaseRequestsByRequestIdResponses[keyof GetRundiffusionFalJuggernautFluxBaseRequestsByRequestIdResponses]

export type GetFalAiCogview4RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/cogview4/requests/{request_id}/status'
}

export type GetFalAiCogview4RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiCogview4RequestsByRequestIdStatusResponse =
  GetFalAiCogview4RequestsByRequestIdStatusResponses[keyof GetFalAiCogview4RequestsByRequestIdStatusResponses]

export type PutFalAiCogview4RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/cogview4/requests/{request_id}/cancel'
}

export type PutFalAiCogview4RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiCogview4RequestsByRequestIdCancelResponse =
  PutFalAiCogview4RequestsByRequestIdCancelResponses[keyof PutFalAiCogview4RequestsByRequestIdCancelResponses]

export type PostFalAiCogview4Data = {
  body: SchemaCogview4Input
  path?: never
  query?: never
  url: '/fal-ai/cogview4'
}

export type PostFalAiCogview4Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiCogview4Response =
  PostFalAiCogview4Responses[keyof PostFalAiCogview4Responses]

export type GetFalAiCogview4RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/cogview4/requests/{request_id}'
}

export type GetFalAiCogview4RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaCogview4Output
}

export type GetFalAiCogview4RequestsByRequestIdResponse =
  GetFalAiCogview4RequestsByRequestIdResponses[keyof GetFalAiCogview4RequestsByRequestIdResponses]

export type GetFalAiIdeogramV2aTurboRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ideogram/v2a/turbo/requests/{request_id}/status'
}

export type GetFalAiIdeogramV2aTurboRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIdeogramV2aTurboRequestsByRequestIdStatusResponse =
  GetFalAiIdeogramV2aTurboRequestsByRequestIdStatusResponses[keyof GetFalAiIdeogramV2aTurboRequestsByRequestIdStatusResponses]

export type PutFalAiIdeogramV2aTurboRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2a/turbo/requests/{request_id}/cancel'
}

export type PutFalAiIdeogramV2aTurboRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIdeogramV2aTurboRequestsByRequestIdCancelResponse =
  PutFalAiIdeogramV2aTurboRequestsByRequestIdCancelResponses[keyof PutFalAiIdeogramV2aTurboRequestsByRequestIdCancelResponses]

export type PostFalAiIdeogramV2aTurboData = {
  body: SchemaIdeogramV2aTurboInput
  path?: never
  query?: never
  url: '/fal-ai/ideogram/v2a/turbo'
}

export type PostFalAiIdeogramV2aTurboResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIdeogramV2aTurboResponse =
  PostFalAiIdeogramV2aTurboResponses[keyof PostFalAiIdeogramV2aTurboResponses]

export type GetFalAiIdeogramV2aTurboRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2a/turbo/requests/{request_id}'
}

export type GetFalAiIdeogramV2aTurboRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIdeogramV2aTurboOutput
}

export type GetFalAiIdeogramV2aTurboRequestsByRequestIdResponse =
  GetFalAiIdeogramV2aTurboRequestsByRequestIdResponses[keyof GetFalAiIdeogramV2aTurboRequestsByRequestIdResponses]

export type GetFalAiIdeogramV2aRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ideogram/v2a/requests/{request_id}/status'
}

export type GetFalAiIdeogramV2aRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIdeogramV2aRequestsByRequestIdStatusResponse =
  GetFalAiIdeogramV2aRequestsByRequestIdStatusResponses[keyof GetFalAiIdeogramV2aRequestsByRequestIdStatusResponses]

export type PutFalAiIdeogramV2aRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2a/requests/{request_id}/cancel'
}

export type PutFalAiIdeogramV2aRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIdeogramV2aRequestsByRequestIdCancelResponse =
  PutFalAiIdeogramV2aRequestsByRequestIdCancelResponses[keyof PutFalAiIdeogramV2aRequestsByRequestIdCancelResponses]

export type PostFalAiIdeogramV2aData = {
  body: SchemaIdeogramV2aInput
  path?: never
  query?: never
  url: '/fal-ai/ideogram/v2a'
}

export type PostFalAiIdeogramV2aResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIdeogramV2aResponse =
  PostFalAiIdeogramV2aResponses[keyof PostFalAiIdeogramV2aResponses]

export type GetFalAiIdeogramV2aRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2a/requests/{request_id}'
}

export type GetFalAiIdeogramV2aRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIdeogramV2aOutput
}

export type GetFalAiIdeogramV2aRequestsByRequestIdResponse =
  GetFalAiIdeogramV2aRequestsByRequestIdResponses[keyof GetFalAiIdeogramV2aRequestsByRequestIdResponses]

export type GetFalAiFluxControlLoraCannyRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-control-lora-canny/requests/{request_id}/status'
}

export type GetFalAiFluxControlLoraCannyRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxControlLoraCannyRequestsByRequestIdStatusResponse =
  GetFalAiFluxControlLoraCannyRequestsByRequestIdStatusResponses[keyof GetFalAiFluxControlLoraCannyRequestsByRequestIdStatusResponses]

export type PutFalAiFluxControlLoraCannyRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-control-lora-canny/requests/{request_id}/cancel'
}

export type PutFalAiFluxControlLoraCannyRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxControlLoraCannyRequestsByRequestIdCancelResponse =
  PutFalAiFluxControlLoraCannyRequestsByRequestIdCancelResponses[keyof PutFalAiFluxControlLoraCannyRequestsByRequestIdCancelResponses]

export type PostFalAiFluxControlLoraCannyData = {
  body: SchemaFluxControlLoraCannyInput
  path?: never
  query?: never
  url: '/fal-ai/flux-control-lora-canny'
}

export type PostFalAiFluxControlLoraCannyResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxControlLoraCannyResponse =
  PostFalAiFluxControlLoraCannyResponses[keyof PostFalAiFluxControlLoraCannyResponses]

export type GetFalAiFluxControlLoraCannyRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-control-lora-canny/requests/{request_id}'
}

export type GetFalAiFluxControlLoraCannyRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxControlLoraCannyOutput
}

export type GetFalAiFluxControlLoraCannyRequestsByRequestIdResponse =
  GetFalAiFluxControlLoraCannyRequestsByRequestIdResponses[keyof GetFalAiFluxControlLoraCannyRequestsByRequestIdResponses]

export type GetFalAiFluxControlLoraDepthRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-control-lora-depth/requests/{request_id}/status'
}

export type GetFalAiFluxControlLoraDepthRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxControlLoraDepthRequestsByRequestIdStatusResponse =
  GetFalAiFluxControlLoraDepthRequestsByRequestIdStatusResponses[keyof GetFalAiFluxControlLoraDepthRequestsByRequestIdStatusResponses]

export type PutFalAiFluxControlLoraDepthRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-control-lora-depth/requests/{request_id}/cancel'
}

export type PutFalAiFluxControlLoraDepthRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxControlLoraDepthRequestsByRequestIdCancelResponse =
  PutFalAiFluxControlLoraDepthRequestsByRequestIdCancelResponses[keyof PutFalAiFluxControlLoraDepthRequestsByRequestIdCancelResponses]

export type PostFalAiFluxControlLoraDepthData = {
  body: SchemaFluxControlLoraDepthInput
  path?: never
  query?: never
  url: '/fal-ai/flux-control-lora-depth'
}

export type PostFalAiFluxControlLoraDepthResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxControlLoraDepthResponse =
  PostFalAiFluxControlLoraDepthResponses[keyof PostFalAiFluxControlLoraDepthResponses]

export type GetFalAiFluxControlLoraDepthRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-control-lora-depth/requests/{request_id}'
}

export type GetFalAiFluxControlLoraDepthRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxControlLoraDepthOutput
}

export type GetFalAiFluxControlLoraDepthRequestsByRequestIdResponse =
  GetFalAiFluxControlLoraDepthRequestsByRequestIdResponses[keyof GetFalAiFluxControlLoraDepthRequestsByRequestIdResponses]

export type GetFalAiImagen3RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/imagen3/requests/{request_id}/status'
}

export type GetFalAiImagen3RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImagen3RequestsByRequestIdStatusResponse =
  GetFalAiImagen3RequestsByRequestIdStatusResponses[keyof GetFalAiImagen3RequestsByRequestIdStatusResponses]

export type PutFalAiImagen3RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/imagen3/requests/{request_id}/cancel'
}

export type PutFalAiImagen3RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImagen3RequestsByRequestIdCancelResponse =
  PutFalAiImagen3RequestsByRequestIdCancelResponses[keyof PutFalAiImagen3RequestsByRequestIdCancelResponses]

export type PostFalAiImagen3Data = {
  body: SchemaImagen3Input
  path?: never
  query?: never
  url: '/fal-ai/imagen3'
}

export type PostFalAiImagen3Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImagen3Response =
  PostFalAiImagen3Responses[keyof PostFalAiImagen3Responses]

export type GetFalAiImagen3RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/imagen3/requests/{request_id}'
}

export type GetFalAiImagen3RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImagen3Output
}

export type GetFalAiImagen3RequestsByRequestIdResponse =
  GetFalAiImagen3RequestsByRequestIdResponses[keyof GetFalAiImagen3RequestsByRequestIdResponses]

export type GetFalAiImagen3FastRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/imagen3/fast/requests/{request_id}/status'
}

export type GetFalAiImagen3FastRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiImagen3FastRequestsByRequestIdStatusResponse =
  GetFalAiImagen3FastRequestsByRequestIdStatusResponses[keyof GetFalAiImagen3FastRequestsByRequestIdStatusResponses]

export type PutFalAiImagen3FastRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/imagen3/fast/requests/{request_id}/cancel'
}

export type PutFalAiImagen3FastRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiImagen3FastRequestsByRequestIdCancelResponse =
  PutFalAiImagen3FastRequestsByRequestIdCancelResponses[keyof PutFalAiImagen3FastRequestsByRequestIdCancelResponses]

export type PostFalAiImagen3FastData = {
  body: SchemaImagen3FastInput
  path?: never
  query?: never
  url: '/fal-ai/imagen3/fast'
}

export type PostFalAiImagen3FastResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiImagen3FastResponse =
  PostFalAiImagen3FastResponses[keyof PostFalAiImagen3FastResponses]

export type GetFalAiImagen3FastRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/imagen3/fast/requests/{request_id}'
}

export type GetFalAiImagen3FastRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaImagen3FastOutput
}

export type GetFalAiImagen3FastRequestsByRequestIdResponse =
  GetFalAiImagen3FastRequestsByRequestIdResponses[keyof GetFalAiImagen3FastRequestsByRequestIdResponses]

export type GetFalAiLuminaImageV2RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/lumina-image/v2/requests/{request_id}/status'
}

export type GetFalAiLuminaImageV2RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLuminaImageV2RequestsByRequestIdStatusResponse =
  GetFalAiLuminaImageV2RequestsByRequestIdStatusResponses[keyof GetFalAiLuminaImageV2RequestsByRequestIdStatusResponses]

export type PutFalAiLuminaImageV2RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/lumina-image/v2/requests/{request_id}/cancel'
}

export type PutFalAiLuminaImageV2RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLuminaImageV2RequestsByRequestIdCancelResponse =
  PutFalAiLuminaImageV2RequestsByRequestIdCancelResponses[keyof PutFalAiLuminaImageV2RequestsByRequestIdCancelResponses]

export type PostFalAiLuminaImageV2Data = {
  body: SchemaLuminaImageV2Input
  path?: never
  query?: never
  url: '/fal-ai/lumina-image/v2'
}

export type PostFalAiLuminaImageV2Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLuminaImageV2Response =
  PostFalAiLuminaImageV2Responses[keyof PostFalAiLuminaImageV2Responses]

export type GetFalAiLuminaImageV2RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/lumina-image/v2/requests/{request_id}'
}

export type GetFalAiLuminaImageV2RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLuminaImageV2Output
}

export type GetFalAiLuminaImageV2RequestsByRequestIdResponse =
  GetFalAiLuminaImageV2RequestsByRequestIdResponses[keyof GetFalAiLuminaImageV2RequestsByRequestIdResponses]

export type GetFalAiJanusRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/janus/requests/{request_id}/status'
}

export type GetFalAiJanusRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiJanusRequestsByRequestIdStatusResponse =
  GetFalAiJanusRequestsByRequestIdStatusResponses[keyof GetFalAiJanusRequestsByRequestIdStatusResponses]

export type PutFalAiJanusRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/janus/requests/{request_id}/cancel'
}

export type PutFalAiJanusRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiJanusRequestsByRequestIdCancelResponse =
  PutFalAiJanusRequestsByRequestIdCancelResponses[keyof PutFalAiJanusRequestsByRequestIdCancelResponses]

export type PostFalAiJanusData = {
  body: SchemaJanusInput
  path?: never
  query?: never
  url: '/fal-ai/janus'
}

export type PostFalAiJanusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiJanusResponse =
  PostFalAiJanusResponses[keyof PostFalAiJanusResponses]

export type GetFalAiJanusRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/janus/requests/{request_id}'
}

export type GetFalAiJanusRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaJanusOutput
}

export type GetFalAiJanusRequestsByRequestIdResponse =
  GetFalAiJanusRequestsByRequestIdResponses[keyof GetFalAiJanusRequestsByRequestIdResponses]

export type GetFalAiFluxProV11UltraFinetunedRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-pro/v1.1-ultra-finetuned/requests/{request_id}/status'
}

export type GetFalAiFluxProV11UltraFinetunedRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFluxProV11UltraFinetunedRequestsByRequestIdStatusResponse =
  GetFalAiFluxProV11UltraFinetunedRequestsByRequestIdStatusResponses[keyof GetFalAiFluxProV11UltraFinetunedRequestsByRequestIdStatusResponses]

export type PutFalAiFluxProV11UltraFinetunedRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/v1.1-ultra-finetuned/requests/{request_id}/cancel'
}

export type PutFalAiFluxProV11UltraFinetunedRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFluxProV11UltraFinetunedRequestsByRequestIdCancelResponse =
  PutFalAiFluxProV11UltraFinetunedRequestsByRequestIdCancelResponses[keyof PutFalAiFluxProV11UltraFinetunedRequestsByRequestIdCancelResponses]

export type PostFalAiFluxProV11UltraFinetunedData = {
  body: SchemaFluxProV11UltraFinetunedInput
  path?: never
  query?: never
  url: '/fal-ai/flux-pro/v1.1-ultra-finetuned'
}

export type PostFalAiFluxProV11UltraFinetunedResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxProV11UltraFinetunedResponse =
  PostFalAiFluxProV11UltraFinetunedResponses[keyof PostFalAiFluxProV11UltraFinetunedResponses]

export type GetFalAiFluxProV11UltraFinetunedRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/v1.1-ultra-finetuned/requests/{request_id}'
}

export type GetFalAiFluxProV11UltraFinetunedRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxProV11UltraFinetunedOutput
}

export type GetFalAiFluxProV11UltraFinetunedRequestsByRequestIdResponse =
  GetFalAiFluxProV11UltraFinetunedRequestsByRequestIdResponses[keyof GetFalAiFluxProV11UltraFinetunedRequestsByRequestIdResponses]

export type GetFalAiFluxProV11RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-pro/v1.1/requests/{request_id}/status'
}

export type GetFalAiFluxProV11RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxProV11RequestsByRequestIdStatusResponse =
  GetFalAiFluxProV11RequestsByRequestIdStatusResponses[keyof GetFalAiFluxProV11RequestsByRequestIdStatusResponses]

export type PutFalAiFluxProV11RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/v1.1/requests/{request_id}/cancel'
}

export type PutFalAiFluxProV11RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxProV11RequestsByRequestIdCancelResponse =
  PutFalAiFluxProV11RequestsByRequestIdCancelResponses[keyof PutFalAiFluxProV11RequestsByRequestIdCancelResponses]

export type PostFalAiFluxProV11Data = {
  body: SchemaFluxProV11Input
  path?: never
  query?: never
  url: '/fal-ai/flux-pro/v1.1'
}

export type PostFalAiFluxProV11Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxProV11Response =
  PostFalAiFluxProV11Responses[keyof PostFalAiFluxProV11Responses]

export type GetFalAiFluxProV11RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-pro/v1.1/requests/{request_id}'
}

export type GetFalAiFluxProV11RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxProV11Output
}

export type GetFalAiFluxProV11RequestsByRequestIdResponse =
  GetFalAiFluxProV11RequestsByRequestIdResponses[keyof GetFalAiFluxProV11RequestsByRequestIdResponses]

export type GetFalAiSwittiRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/switti/requests/{request_id}/status'
}

export type GetFalAiSwittiRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiSwittiRequestsByRequestIdStatusResponse =
  GetFalAiSwittiRequestsByRequestIdStatusResponses[keyof GetFalAiSwittiRequestsByRequestIdStatusResponses]

export type PutFalAiSwittiRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/switti/requests/{request_id}/cancel'
}

export type PutFalAiSwittiRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiSwittiRequestsByRequestIdCancelResponse =
  PutFalAiSwittiRequestsByRequestIdCancelResponses[keyof PutFalAiSwittiRequestsByRequestIdCancelResponses]

export type PostFalAiSwittiData = {
  body: SchemaSwittiInput
  path?: never
  query?: never
  url: '/fal-ai/switti'
}

export type PostFalAiSwittiResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiSwittiResponse =
  PostFalAiSwittiResponses[keyof PostFalAiSwittiResponses]

export type GetFalAiSwittiRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/switti/requests/{request_id}'
}

export type GetFalAiSwittiRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaSwittiOutput
}

export type GetFalAiSwittiRequestsByRequestIdResponse =
  GetFalAiSwittiRequestsByRequestIdResponses[keyof GetFalAiSwittiRequestsByRequestIdResponses]

export type GetFalAiSwitti512RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/switti/512/requests/{request_id}/status'
}

export type GetFalAiSwitti512RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiSwitti512RequestsByRequestIdStatusResponse =
  GetFalAiSwitti512RequestsByRequestIdStatusResponses[keyof GetFalAiSwitti512RequestsByRequestIdStatusResponses]

export type PutFalAiSwitti512RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/switti/512/requests/{request_id}/cancel'
}

export type PutFalAiSwitti512RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiSwitti512RequestsByRequestIdCancelResponse =
  PutFalAiSwitti512RequestsByRequestIdCancelResponses[keyof PutFalAiSwitti512RequestsByRequestIdCancelResponses]

export type PostFalAiSwitti512Data = {
  body: SchemaSwitti512Input
  path?: never
  query?: never
  url: '/fal-ai/switti/512'
}

export type PostFalAiSwitti512Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiSwitti512Response =
  PostFalAiSwitti512Responses[keyof PostFalAiSwitti512Responses]

export type GetFalAiSwitti512RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/switti/512/requests/{request_id}'
}

export type GetFalAiSwitti512RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaSwitti512Output
}

export type GetFalAiSwitti512RequestsByRequestIdResponse =
  GetFalAiSwitti512RequestsByRequestIdResponses[keyof GetFalAiSwitti512RequestsByRequestIdResponses]

export type GetFalAiBriaTextToImageBaseRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/bria/text-to-image/base/requests/{request_id}/status'
}

export type GetFalAiBriaTextToImageBaseRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiBriaTextToImageBaseRequestsByRequestIdStatusResponse =
  GetFalAiBriaTextToImageBaseRequestsByRequestIdStatusResponses[keyof GetFalAiBriaTextToImageBaseRequestsByRequestIdStatusResponses]

export type PutFalAiBriaTextToImageBaseRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/text-to-image/base/requests/{request_id}/cancel'
}

export type PutFalAiBriaTextToImageBaseRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiBriaTextToImageBaseRequestsByRequestIdCancelResponse =
  PutFalAiBriaTextToImageBaseRequestsByRequestIdCancelResponses[keyof PutFalAiBriaTextToImageBaseRequestsByRequestIdCancelResponses]

export type PostFalAiBriaTextToImageBaseData = {
  body: SchemaBriaTextToImageBaseInput
  path?: never
  query?: never
  url: '/fal-ai/bria/text-to-image/base'
}

export type PostFalAiBriaTextToImageBaseResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBriaTextToImageBaseResponse =
  PostFalAiBriaTextToImageBaseResponses[keyof PostFalAiBriaTextToImageBaseResponses]

export type GetFalAiBriaTextToImageBaseRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/text-to-image/base/requests/{request_id}'
}

export type GetFalAiBriaTextToImageBaseRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaBriaTextToImageBaseOutput
}

export type GetFalAiBriaTextToImageBaseRequestsByRequestIdResponse =
  GetFalAiBriaTextToImageBaseRequestsByRequestIdResponses[keyof GetFalAiBriaTextToImageBaseRequestsByRequestIdResponses]

export type GetFalAiBriaTextToImageFastRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/bria/text-to-image/fast/requests/{request_id}/status'
}

export type GetFalAiBriaTextToImageFastRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiBriaTextToImageFastRequestsByRequestIdStatusResponse =
  GetFalAiBriaTextToImageFastRequestsByRequestIdStatusResponses[keyof GetFalAiBriaTextToImageFastRequestsByRequestIdStatusResponses]

export type PutFalAiBriaTextToImageFastRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/text-to-image/fast/requests/{request_id}/cancel'
}

export type PutFalAiBriaTextToImageFastRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiBriaTextToImageFastRequestsByRequestIdCancelResponse =
  PutFalAiBriaTextToImageFastRequestsByRequestIdCancelResponses[keyof PutFalAiBriaTextToImageFastRequestsByRequestIdCancelResponses]

export type PostFalAiBriaTextToImageFastData = {
  body: SchemaBriaTextToImageFastInput
  path?: never
  query?: never
  url: '/fal-ai/bria/text-to-image/fast'
}

export type PostFalAiBriaTextToImageFastResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBriaTextToImageFastResponse =
  PostFalAiBriaTextToImageFastResponses[keyof PostFalAiBriaTextToImageFastResponses]

export type GetFalAiBriaTextToImageFastRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/text-to-image/fast/requests/{request_id}'
}

export type GetFalAiBriaTextToImageFastRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaBriaTextToImageFastOutput
}

export type GetFalAiBriaTextToImageFastRequestsByRequestIdResponse =
  GetFalAiBriaTextToImageFastRequestsByRequestIdResponses[keyof GetFalAiBriaTextToImageFastRequestsByRequestIdResponses]

export type GetFalAiBriaTextToImageHdRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/bria/text-to-image/hd/requests/{request_id}/status'
}

export type GetFalAiBriaTextToImageHdRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiBriaTextToImageHdRequestsByRequestIdStatusResponse =
  GetFalAiBriaTextToImageHdRequestsByRequestIdStatusResponses[keyof GetFalAiBriaTextToImageHdRequestsByRequestIdStatusResponses]

export type PutFalAiBriaTextToImageHdRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/text-to-image/hd/requests/{request_id}/cancel'
}

export type PutFalAiBriaTextToImageHdRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiBriaTextToImageHdRequestsByRequestIdCancelResponse =
  PutFalAiBriaTextToImageHdRequestsByRequestIdCancelResponses[keyof PutFalAiBriaTextToImageHdRequestsByRequestIdCancelResponses]

export type PostFalAiBriaTextToImageHdData = {
  body: SchemaBriaTextToImageHdInput
  path?: never
  query?: never
  url: '/fal-ai/bria/text-to-image/hd'
}

export type PostFalAiBriaTextToImageHdResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiBriaTextToImageHdResponse =
  PostFalAiBriaTextToImageHdResponses[keyof PostFalAiBriaTextToImageHdResponses]

export type GetFalAiBriaTextToImageHdRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/bria/text-to-image/hd/requests/{request_id}'
}

export type GetFalAiBriaTextToImageHdRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaBriaTextToImageHdOutput
}

export type GetFalAiBriaTextToImageHdRequestsByRequestIdResponse =
  GetFalAiBriaTextToImageHdRequestsByRequestIdResponses[keyof GetFalAiBriaTextToImageHdRequestsByRequestIdResponses]

export type GetFalAiRecraft20bRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/recraft-20b/requests/{request_id}/status'
}

export type GetFalAiRecraft20bRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiRecraft20bRequestsByRequestIdStatusResponse =
  GetFalAiRecraft20bRequestsByRequestIdStatusResponses[keyof GetFalAiRecraft20bRequestsByRequestIdStatusResponses]

export type PutFalAiRecraft20bRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/recraft-20b/requests/{request_id}/cancel'
}

export type PutFalAiRecraft20bRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiRecraft20bRequestsByRequestIdCancelResponse =
  PutFalAiRecraft20bRequestsByRequestIdCancelResponses[keyof PutFalAiRecraft20bRequestsByRequestIdCancelResponses]

export type PostFalAiRecraft20bData = {
  body: SchemaRecraft20bInput
  path?: never
  query?: never
  url: '/fal-ai/recraft-20b'
}

export type PostFalAiRecraft20bResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiRecraft20bResponse =
  PostFalAiRecraft20bResponses[keyof PostFalAiRecraft20bResponses]

export type GetFalAiRecraft20bRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/recraft-20b/requests/{request_id}'
}

export type GetFalAiRecraft20bRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaRecraft20bOutput
}

export type GetFalAiRecraft20bRequestsByRequestIdResponse =
  GetFalAiRecraft20bRequestsByRequestIdResponses[keyof GetFalAiRecraft20bRequestsByRequestIdResponses]

export type GetFalAiIdeogramV2TurboRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/ideogram/v2/turbo/requests/{request_id}/status'
}

export type GetFalAiIdeogramV2TurboRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIdeogramV2TurboRequestsByRequestIdStatusResponse =
  GetFalAiIdeogramV2TurboRequestsByRequestIdStatusResponses[keyof GetFalAiIdeogramV2TurboRequestsByRequestIdStatusResponses]

export type PutFalAiIdeogramV2TurboRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2/turbo/requests/{request_id}/cancel'
}

export type PutFalAiIdeogramV2TurboRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIdeogramV2TurboRequestsByRequestIdCancelResponse =
  PutFalAiIdeogramV2TurboRequestsByRequestIdCancelResponses[keyof PutFalAiIdeogramV2TurboRequestsByRequestIdCancelResponses]

export type PostFalAiIdeogramV2TurboData = {
  body: SchemaIdeogramV2TurboInput
  path?: never
  query?: never
  url: '/fal-ai/ideogram/v2/turbo'
}

export type PostFalAiIdeogramV2TurboResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIdeogramV2TurboResponse =
  PostFalAiIdeogramV2TurboResponses[keyof PostFalAiIdeogramV2TurboResponses]

export type GetFalAiIdeogramV2TurboRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/ideogram/v2/turbo/requests/{request_id}'
}

export type GetFalAiIdeogramV2TurboRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIdeogramV2TurboOutput
}

export type GetFalAiIdeogramV2TurboRequestsByRequestIdResponse =
  GetFalAiIdeogramV2TurboRequestsByRequestIdResponses[keyof GetFalAiIdeogramV2TurboRequestsByRequestIdResponses]

export type GetFalAiLumaPhotonFlashRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/luma-photon/flash/requests/{request_id}/status'
}

export type GetFalAiLumaPhotonFlashRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLumaPhotonFlashRequestsByRequestIdStatusResponse =
  GetFalAiLumaPhotonFlashRequestsByRequestIdStatusResponses[keyof GetFalAiLumaPhotonFlashRequestsByRequestIdStatusResponses]

export type PutFalAiLumaPhotonFlashRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/luma-photon/flash/requests/{request_id}/cancel'
}

export type PutFalAiLumaPhotonFlashRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLumaPhotonFlashRequestsByRequestIdCancelResponse =
  PutFalAiLumaPhotonFlashRequestsByRequestIdCancelResponses[keyof PutFalAiLumaPhotonFlashRequestsByRequestIdCancelResponses]

export type PostFalAiLumaPhotonFlashData = {
  body: SchemaLumaPhotonFlashInput
  path?: never
  query?: never
  url: '/fal-ai/luma-photon/flash'
}

export type PostFalAiLumaPhotonFlashResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLumaPhotonFlashResponse =
  PostFalAiLumaPhotonFlashResponses[keyof PostFalAiLumaPhotonFlashResponses]

export type GetFalAiLumaPhotonFlashRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/luma-photon/flash/requests/{request_id}'
}

export type GetFalAiLumaPhotonFlashRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLumaPhotonFlashOutput
}

export type GetFalAiLumaPhotonFlashRequestsByRequestIdResponse =
  GetFalAiLumaPhotonFlashRequestsByRequestIdResponses[keyof GetFalAiLumaPhotonFlashRequestsByRequestIdResponses]

export type GetFalAiAuraFlowRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/aura-flow/requests/{request_id}/status'
}

export type GetFalAiAuraFlowRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiAuraFlowRequestsByRequestIdStatusResponse =
  GetFalAiAuraFlowRequestsByRequestIdStatusResponses[keyof GetFalAiAuraFlowRequestsByRequestIdStatusResponses]

export type PutFalAiAuraFlowRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/aura-flow/requests/{request_id}/cancel'
}

export type PutFalAiAuraFlowRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiAuraFlowRequestsByRequestIdCancelResponse =
  PutFalAiAuraFlowRequestsByRequestIdCancelResponses[keyof PutFalAiAuraFlowRequestsByRequestIdCancelResponses]

export type PostFalAiAuraFlowData = {
  body: SchemaAuraFlowInput
  path?: never
  query?: never
  url: '/fal-ai/aura-flow'
}

export type PostFalAiAuraFlowResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiAuraFlowResponse =
  PostFalAiAuraFlowResponses[keyof PostFalAiAuraFlowResponses]

export type GetFalAiAuraFlowRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/aura-flow/requests/{request_id}'
}

export type GetFalAiAuraFlowRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaAuraFlowOutput
}

export type GetFalAiAuraFlowRequestsByRequestIdResponse =
  GetFalAiAuraFlowRequestsByRequestIdResponses[keyof GetFalAiAuraFlowRequestsByRequestIdResponses]

export type GetFalAiOmnigenV1RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/omnigen-v1/requests/{request_id}/status'
}

export type GetFalAiOmnigenV1RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiOmnigenV1RequestsByRequestIdStatusResponse =
  GetFalAiOmnigenV1RequestsByRequestIdStatusResponses[keyof GetFalAiOmnigenV1RequestsByRequestIdStatusResponses]

export type PutFalAiOmnigenV1RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/omnigen-v1/requests/{request_id}/cancel'
}

export type PutFalAiOmnigenV1RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiOmnigenV1RequestsByRequestIdCancelResponse =
  PutFalAiOmnigenV1RequestsByRequestIdCancelResponses[keyof PutFalAiOmnigenV1RequestsByRequestIdCancelResponses]

export type PostFalAiOmnigenV1Data = {
  body: SchemaOmnigenV1Input
  path?: never
  query?: never
  url: '/fal-ai/omnigen-v1'
}

export type PostFalAiOmnigenV1Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiOmnigenV1Response =
  PostFalAiOmnigenV1Responses[keyof PostFalAiOmnigenV1Responses]

export type GetFalAiOmnigenV1RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/omnigen-v1/requests/{request_id}'
}

export type GetFalAiOmnigenV1RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaOmnigenV1Output
}

export type GetFalAiOmnigenV1RequestsByRequestIdResponse =
  GetFalAiOmnigenV1RequestsByRequestIdResponses[keyof GetFalAiOmnigenV1RequestsByRequestIdResponses]

export type GetFalAiFluxSchnellRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux/schnell/requests/{request_id}/status'
}

export type GetFalAiFluxSchnellRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxSchnellRequestsByRequestIdStatusResponse =
  GetFalAiFluxSchnellRequestsByRequestIdStatusResponses[keyof GetFalAiFluxSchnellRequestsByRequestIdStatusResponses]

export type PutFalAiFluxSchnellRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/schnell/requests/{request_id}/cancel'
}

export type PutFalAiFluxSchnellRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxSchnellRequestsByRequestIdCancelResponse =
  PutFalAiFluxSchnellRequestsByRequestIdCancelResponses[keyof PutFalAiFluxSchnellRequestsByRequestIdCancelResponses]

export type PostFalAiFluxSchnellData = {
  body: SchemaFluxSchnellInput
  path?: never
  query?: never
  url: '/fal-ai/flux/schnell'
}

export type PostFalAiFluxSchnellResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxSchnellResponse =
  PostFalAiFluxSchnellResponses[keyof PostFalAiFluxSchnellResponses]

export type GetFalAiFluxSchnellRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux/schnell/requests/{request_id}'
}

export type GetFalAiFluxSchnellRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxSchnellOutput
}

export type GetFalAiFluxSchnellRequestsByRequestIdResponse =
  GetFalAiFluxSchnellRequestsByRequestIdResponses[keyof GetFalAiFluxSchnellRequestsByRequestIdResponses]

export type GetFalAiStableDiffusionV35MediumRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/stable-diffusion-v35-medium/requests/{request_id}/status'
}

export type GetFalAiStableDiffusionV35MediumRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiStableDiffusionV35MediumRequestsByRequestIdStatusResponse =
  GetFalAiStableDiffusionV35MediumRequestsByRequestIdStatusResponses[keyof GetFalAiStableDiffusionV35MediumRequestsByRequestIdStatusResponses]

export type PutFalAiStableDiffusionV35MediumRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/stable-diffusion-v35-medium/requests/{request_id}/cancel'
}

export type PutFalAiStableDiffusionV35MediumRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiStableDiffusionV35MediumRequestsByRequestIdCancelResponse =
  PutFalAiStableDiffusionV35MediumRequestsByRequestIdCancelResponses[keyof PutFalAiStableDiffusionV35MediumRequestsByRequestIdCancelResponses]

export type PostFalAiStableDiffusionV35MediumData = {
  body: SchemaStableDiffusionV35MediumInput
  path?: never
  query?: never
  url: '/fal-ai/stable-diffusion-v35-medium'
}

export type PostFalAiStableDiffusionV35MediumResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiStableDiffusionV35MediumResponse =
  PostFalAiStableDiffusionV35MediumResponses[keyof PostFalAiStableDiffusionV35MediumResponses]

export type GetFalAiStableDiffusionV35MediumRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/stable-diffusion-v35-medium/requests/{request_id}'
}

export type GetFalAiStableDiffusionV35MediumRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaStableDiffusionV35MediumOutput
}

export type GetFalAiStableDiffusionV35MediumRequestsByRequestIdResponse =
  GetFalAiStableDiffusionV35MediumRequestsByRequestIdResponses[keyof GetFalAiStableDiffusionV35MediumRequestsByRequestIdResponses]

export type GetFalAiFluxLoraInpaintingRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-lora/inpainting/requests/{request_id}/status'
}

export type GetFalAiFluxLoraInpaintingRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxLoraInpaintingRequestsByRequestIdStatusResponse =
  GetFalAiFluxLoraInpaintingRequestsByRequestIdStatusResponses[keyof GetFalAiFluxLoraInpaintingRequestsByRequestIdStatusResponses]

export type PutFalAiFluxLoraInpaintingRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-lora/inpainting/requests/{request_id}/cancel'
}

export type PutFalAiFluxLoraInpaintingRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxLoraInpaintingRequestsByRequestIdCancelResponse =
  PutFalAiFluxLoraInpaintingRequestsByRequestIdCancelResponses[keyof PutFalAiFluxLoraInpaintingRequestsByRequestIdCancelResponses]

export type PostFalAiFluxLoraInpaintingData = {
  body: SchemaFluxLoraInpaintingInput
  path?: never
  query?: never
  url: '/fal-ai/flux-lora/inpainting'
}

export type PostFalAiFluxLoraInpaintingResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxLoraInpaintingResponse =
  PostFalAiFluxLoraInpaintingResponses[keyof PostFalAiFluxLoraInpaintingResponses]

export type GetFalAiFluxLoraInpaintingRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-lora/inpainting/requests/{request_id}'
}

export type GetFalAiFluxLoraInpaintingRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxLoraInpaintingOutput
}

export type GetFalAiFluxLoraInpaintingRequestsByRequestIdResponse =
  GetFalAiFluxLoraInpaintingRequestsByRequestIdResponses[keyof GetFalAiFluxLoraInpaintingRequestsByRequestIdResponses]

export type GetFalAiStableDiffusionV3MediumRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/stable-diffusion-v3-medium/requests/{request_id}/status'
}

export type GetFalAiStableDiffusionV3MediumRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiStableDiffusionV3MediumRequestsByRequestIdStatusResponse =
  GetFalAiStableDiffusionV3MediumRequestsByRequestIdStatusResponses[keyof GetFalAiStableDiffusionV3MediumRequestsByRequestIdStatusResponses]

export type PutFalAiStableDiffusionV3MediumRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/stable-diffusion-v3-medium/requests/{request_id}/cancel'
}

export type PutFalAiStableDiffusionV3MediumRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiStableDiffusionV3MediumRequestsByRequestIdCancelResponse =
  PutFalAiStableDiffusionV3MediumRequestsByRequestIdCancelResponses[keyof PutFalAiStableDiffusionV3MediumRequestsByRequestIdCancelResponses]

export type PostFalAiStableDiffusionV3MediumData = {
  body: SchemaStableDiffusionV3MediumInput
  path?: never
  query?: never
  url: '/fal-ai/stable-diffusion-v3-medium'
}

export type PostFalAiStableDiffusionV3MediumResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiStableDiffusionV3MediumResponse =
  PostFalAiStableDiffusionV3MediumResponses[keyof PostFalAiStableDiffusionV3MediumResponses]

export type GetFalAiStableDiffusionV3MediumRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/stable-diffusion-v3-medium/requests/{request_id}'
}

export type GetFalAiStableDiffusionV3MediumRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaStableDiffusionV3MediumOutput
}

export type GetFalAiStableDiffusionV3MediumRequestsByRequestIdResponse =
  GetFalAiStableDiffusionV3MediumRequestsByRequestIdResponses[keyof GetFalAiStableDiffusionV3MediumRequestsByRequestIdResponses]

export type GetFalAiFooocusUpscaleOrVaryRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/fooocus/upscale-or-vary/requests/{request_id}/status'
}

export type GetFalAiFooocusUpscaleOrVaryRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFooocusUpscaleOrVaryRequestsByRequestIdStatusResponse =
  GetFalAiFooocusUpscaleOrVaryRequestsByRequestIdStatusResponses[keyof GetFalAiFooocusUpscaleOrVaryRequestsByRequestIdStatusResponses]

export type PutFalAiFooocusUpscaleOrVaryRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fooocus/upscale-or-vary/requests/{request_id}/cancel'
}

export type PutFalAiFooocusUpscaleOrVaryRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFooocusUpscaleOrVaryRequestsByRequestIdCancelResponse =
  PutFalAiFooocusUpscaleOrVaryRequestsByRequestIdCancelResponses[keyof PutFalAiFooocusUpscaleOrVaryRequestsByRequestIdCancelResponses]

export type PostFalAiFooocusUpscaleOrVaryData = {
  body: SchemaFooocusUpscaleOrVaryInput
  path?: never
  query?: never
  url: '/fal-ai/fooocus/upscale-or-vary'
}

export type PostFalAiFooocusUpscaleOrVaryResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFooocusUpscaleOrVaryResponse =
  PostFalAiFooocusUpscaleOrVaryResponses[keyof PostFalAiFooocusUpscaleOrVaryResponses]

export type GetFalAiFooocusUpscaleOrVaryRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fooocus/upscale-or-vary/requests/{request_id}'
}

export type GetFalAiFooocusUpscaleOrVaryRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFooocusUpscaleOrVaryOutput
}

export type GetFalAiFooocusUpscaleOrVaryRequestsByRequestIdResponse =
  GetFalAiFooocusUpscaleOrVaryRequestsByRequestIdResponses[keyof GetFalAiFooocusUpscaleOrVaryRequestsByRequestIdResponses]

export type GetFalAiSanaRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/sana/requests/{request_id}/status'
}

export type GetFalAiSanaRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiSanaRequestsByRequestIdStatusResponse =
  GetFalAiSanaRequestsByRequestIdStatusResponses[keyof GetFalAiSanaRequestsByRequestIdStatusResponses]

export type PutFalAiSanaRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sana/requests/{request_id}/cancel'
}

export type PutFalAiSanaRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiSanaRequestsByRequestIdCancelResponse =
  PutFalAiSanaRequestsByRequestIdCancelResponses[keyof PutFalAiSanaRequestsByRequestIdCancelResponses]

export type PostFalAiSanaData = {
  body: SchemaSanaInput
  path?: never
  query?: never
  url: '/fal-ai/sana'
}

export type PostFalAiSanaResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiSanaResponse =
  PostFalAiSanaResponses[keyof PostFalAiSanaResponses]

export type GetFalAiSanaRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sana/requests/{request_id}'
}

export type GetFalAiSanaRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaSanaOutput
}

export type GetFalAiSanaRequestsByRequestIdResponse =
  GetFalAiSanaRequestsByRequestIdResponses[keyof GetFalAiSanaRequestsByRequestIdResponses]

export type GetFalAiFluxSubjectRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/flux-subject/requests/{request_id}/status'
}

export type GetFalAiFluxSubjectRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFluxSubjectRequestsByRequestIdStatusResponse =
  GetFalAiFluxSubjectRequestsByRequestIdStatusResponses[keyof GetFalAiFluxSubjectRequestsByRequestIdStatusResponses]

export type PutFalAiFluxSubjectRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-subject/requests/{request_id}/cancel'
}

export type PutFalAiFluxSubjectRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFluxSubjectRequestsByRequestIdCancelResponse =
  PutFalAiFluxSubjectRequestsByRequestIdCancelResponses[keyof PutFalAiFluxSubjectRequestsByRequestIdCancelResponses]

export type PostFalAiFluxSubjectData = {
  body: SchemaFluxSubjectInput
  path?: never
  query?: never
  url: '/fal-ai/flux-subject'
}

export type PostFalAiFluxSubjectResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFluxSubjectResponse =
  PostFalAiFluxSubjectResponses[keyof PostFalAiFluxSubjectResponses]

export type GetFalAiFluxSubjectRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/flux-subject/requests/{request_id}'
}

export type GetFalAiFluxSubjectRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFluxSubjectOutput
}

export type GetFalAiFluxSubjectRequestsByRequestIdResponse =
  GetFalAiFluxSubjectRequestsByRequestIdResponses[keyof GetFalAiFluxSubjectRequestsByRequestIdResponses]

export type GetFalAiPixartSigmaRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/pixart-sigma/requests/{request_id}/status'
}

export type GetFalAiPixartSigmaRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiPixartSigmaRequestsByRequestIdStatusResponse =
  GetFalAiPixartSigmaRequestsByRequestIdStatusResponses[keyof GetFalAiPixartSigmaRequestsByRequestIdStatusResponses]

export type PutFalAiPixartSigmaRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/pixart-sigma/requests/{request_id}/cancel'
}

export type PutFalAiPixartSigmaRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiPixartSigmaRequestsByRequestIdCancelResponse =
  PutFalAiPixartSigmaRequestsByRequestIdCancelResponses[keyof PutFalAiPixartSigmaRequestsByRequestIdCancelResponses]

export type PostFalAiPixartSigmaData = {
  body: SchemaPixartSigmaInput
  path?: never
  query?: never
  url: '/fal-ai/pixart-sigma'
}

export type PostFalAiPixartSigmaResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPixartSigmaResponse =
  PostFalAiPixartSigmaResponses[keyof PostFalAiPixartSigmaResponses]

export type GetFalAiPixartSigmaRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/pixart-sigma/requests/{request_id}'
}

export type GetFalAiPixartSigmaRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPixartSigmaOutput
}

export type GetFalAiPixartSigmaRequestsByRequestIdResponse =
  GetFalAiPixartSigmaRequestsByRequestIdResponses[keyof GetFalAiPixartSigmaRequestsByRequestIdResponses]

export type GetFalAiSdxlControlnetUnionRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/sdxl-controlnet-union/requests/{request_id}/status'
}

export type GetFalAiSdxlControlnetUnionRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiSdxlControlnetUnionRequestsByRequestIdStatusResponse =
  GetFalAiSdxlControlnetUnionRequestsByRequestIdStatusResponses[keyof GetFalAiSdxlControlnetUnionRequestsByRequestIdStatusResponses]

export type PutFalAiSdxlControlnetUnionRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sdxl-controlnet-union/requests/{request_id}/cancel'
}

export type PutFalAiSdxlControlnetUnionRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiSdxlControlnetUnionRequestsByRequestIdCancelResponse =
  PutFalAiSdxlControlnetUnionRequestsByRequestIdCancelResponses[keyof PutFalAiSdxlControlnetUnionRequestsByRequestIdCancelResponses]

export type PostFalAiSdxlControlnetUnionData = {
  body: SchemaSdxlControlnetUnionInput
  path?: never
  query?: never
  url: '/fal-ai/sdxl-controlnet-union'
}

export type PostFalAiSdxlControlnetUnionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiSdxlControlnetUnionResponse =
  PostFalAiSdxlControlnetUnionResponses[keyof PostFalAiSdxlControlnetUnionResponses]

export type GetFalAiSdxlControlnetUnionRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/sdxl-controlnet-union/requests/{request_id}'
}

export type GetFalAiSdxlControlnetUnionRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaSdxlControlnetUnionOutput
}

export type GetFalAiSdxlControlnetUnionRequestsByRequestIdResponse =
  GetFalAiSdxlControlnetUnionRequestsByRequestIdResponses[keyof GetFalAiSdxlControlnetUnionRequestsByRequestIdResponses]

export type GetFalAiKolorsRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/kolors/requests/{request_id}/status'
}

export type GetFalAiKolorsRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiKolorsRequestsByRequestIdStatusResponse =
  GetFalAiKolorsRequestsByRequestIdStatusResponses[keyof GetFalAiKolorsRequestsByRequestIdStatusResponses]

export type PutFalAiKolorsRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/kolors/requests/{request_id}/cancel'
}

export type PutFalAiKolorsRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiKolorsRequestsByRequestIdCancelResponse =
  PutFalAiKolorsRequestsByRequestIdCancelResponses[keyof PutFalAiKolorsRequestsByRequestIdCancelResponses]

export type PostFalAiKolorsData = {
  body: SchemaKolorsInput
  path?: never
  query?: never
  url: '/fal-ai/kolors'
}

export type PostFalAiKolorsResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiKolorsResponse =
  PostFalAiKolorsResponses[keyof PostFalAiKolorsResponses]

export type GetFalAiKolorsRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/kolors/requests/{request_id}'
}

export type GetFalAiKolorsRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaKolorsOutput
}

export type GetFalAiKolorsRequestsByRequestIdResponse =
  GetFalAiKolorsRequestsByRequestIdResponses[keyof GetFalAiKolorsRequestsByRequestIdResponses]

export type GetFalAiStableCascadeRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/stable-cascade/requests/{request_id}/status'
}

export type GetFalAiStableCascadeRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiStableCascadeRequestsByRequestIdStatusResponse =
  GetFalAiStableCascadeRequestsByRequestIdStatusResponses[keyof GetFalAiStableCascadeRequestsByRequestIdStatusResponses]

export type PutFalAiStableCascadeRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/stable-cascade/requests/{request_id}/cancel'
}

export type PutFalAiStableCascadeRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiStableCascadeRequestsByRequestIdCancelResponse =
  PutFalAiStableCascadeRequestsByRequestIdCancelResponses[keyof PutFalAiStableCascadeRequestsByRequestIdCancelResponses]

export type PostFalAiStableCascadeData = {
  body: SchemaStableCascadeInput
  path?: never
  query?: never
  url: '/fal-ai/stable-cascade'
}

export type PostFalAiStableCascadeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiStableCascadeResponse =
  PostFalAiStableCascadeResponses[keyof PostFalAiStableCascadeResponses]

export type GetFalAiStableCascadeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/stable-cascade/requests/{request_id}'
}

export type GetFalAiStableCascadeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaStableCascadeOutput
}

export type GetFalAiStableCascadeRequestsByRequestIdResponse =
  GetFalAiStableCascadeRequestsByRequestIdResponses[keyof GetFalAiStableCascadeRequestsByRequestIdResponses]

export type GetFalAiFastSdxlRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/fast-sdxl/requests/{request_id}/status'
}

export type GetFalAiFastSdxlRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFastSdxlRequestsByRequestIdStatusResponse =
  GetFalAiFastSdxlRequestsByRequestIdStatusResponses[keyof GetFalAiFastSdxlRequestsByRequestIdStatusResponses]

export type PutFalAiFastSdxlRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-sdxl/requests/{request_id}/cancel'
}

export type PutFalAiFastSdxlRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFastSdxlRequestsByRequestIdCancelResponse =
  PutFalAiFastSdxlRequestsByRequestIdCancelResponses[keyof PutFalAiFastSdxlRequestsByRequestIdCancelResponses]

export type PostFalAiFastSdxlData = {
  body: SchemaFastSdxlInput
  path?: never
  query?: never
  url: '/fal-ai/fast-sdxl'
}

export type PostFalAiFastSdxlResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFastSdxlResponse =
  PostFalAiFastSdxlResponses[keyof PostFalAiFastSdxlResponses]

export type GetFalAiFastSdxlRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-sdxl/requests/{request_id}'
}

export type GetFalAiFastSdxlRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFastSdxlOutput
}

export type GetFalAiFastSdxlRequestsByRequestIdResponse =
  GetFalAiFastSdxlRequestsByRequestIdResponses[keyof GetFalAiFastSdxlRequestsByRequestIdResponses]

export type GetFalAiStableCascadeSoteDiffusionRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/stable-cascade/sote-diffusion/requests/{request_id}/status'
}

export type GetFalAiStableCascadeSoteDiffusionRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiStableCascadeSoteDiffusionRequestsByRequestIdStatusResponse =
  GetFalAiStableCascadeSoteDiffusionRequestsByRequestIdStatusResponses[keyof GetFalAiStableCascadeSoteDiffusionRequestsByRequestIdStatusResponses]

export type PutFalAiStableCascadeSoteDiffusionRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/stable-cascade/sote-diffusion/requests/{request_id}/cancel'
}

export type PutFalAiStableCascadeSoteDiffusionRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiStableCascadeSoteDiffusionRequestsByRequestIdCancelResponse =
  PutFalAiStableCascadeSoteDiffusionRequestsByRequestIdCancelResponses[keyof PutFalAiStableCascadeSoteDiffusionRequestsByRequestIdCancelResponses]

export type PostFalAiStableCascadeSoteDiffusionData = {
  body: SchemaStableCascadeSoteDiffusionInput
  path?: never
  query?: never
  url: '/fal-ai/stable-cascade/sote-diffusion'
}

export type PostFalAiStableCascadeSoteDiffusionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiStableCascadeSoteDiffusionResponse =
  PostFalAiStableCascadeSoteDiffusionResponses[keyof PostFalAiStableCascadeSoteDiffusionResponses]

export type GetFalAiStableCascadeSoteDiffusionRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/stable-cascade/sote-diffusion/requests/{request_id}'
}

export type GetFalAiStableCascadeSoteDiffusionRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaStableCascadeSoteDiffusionOutput
}

export type GetFalAiStableCascadeSoteDiffusionRequestsByRequestIdResponse =
  GetFalAiStableCascadeSoteDiffusionRequestsByRequestIdResponses[keyof GetFalAiStableCascadeSoteDiffusionRequestsByRequestIdResponses]

export type GetFalAiLumaPhotonRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/luma-photon/requests/{request_id}/status'
}

export type GetFalAiLumaPhotonRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLumaPhotonRequestsByRequestIdStatusResponse =
  GetFalAiLumaPhotonRequestsByRequestIdStatusResponses[keyof GetFalAiLumaPhotonRequestsByRequestIdStatusResponses]

export type PutFalAiLumaPhotonRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/luma-photon/requests/{request_id}/cancel'
}

export type PutFalAiLumaPhotonRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLumaPhotonRequestsByRequestIdCancelResponse =
  PutFalAiLumaPhotonRequestsByRequestIdCancelResponses[keyof PutFalAiLumaPhotonRequestsByRequestIdCancelResponses]

export type PostFalAiLumaPhotonData = {
  body: SchemaLumaPhotonInput
  path?: never
  query?: never
  url: '/fal-ai/luma-photon'
}

export type PostFalAiLumaPhotonResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLumaPhotonResponse =
  PostFalAiLumaPhotonResponses[keyof PostFalAiLumaPhotonResponses]

export type GetFalAiLumaPhotonRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/luma-photon/requests/{request_id}'
}

export type GetFalAiLumaPhotonRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLumaPhotonOutput
}

export type GetFalAiLumaPhotonRequestsByRequestIdResponse =
  GetFalAiLumaPhotonRequestsByRequestIdResponses[keyof GetFalAiLumaPhotonRequestsByRequestIdResponses]

export type GetFalAiLightningModelsRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/lightning-models/requests/{request_id}/status'
}

export type GetFalAiLightningModelsRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLightningModelsRequestsByRequestIdStatusResponse =
  GetFalAiLightningModelsRequestsByRequestIdStatusResponses[keyof GetFalAiLightningModelsRequestsByRequestIdStatusResponses]

export type PutFalAiLightningModelsRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/lightning-models/requests/{request_id}/cancel'
}

export type PutFalAiLightningModelsRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLightningModelsRequestsByRequestIdCancelResponse =
  PutFalAiLightningModelsRequestsByRequestIdCancelResponses[keyof PutFalAiLightningModelsRequestsByRequestIdCancelResponses]

export type PostFalAiLightningModelsData = {
  body: SchemaLightningModelsInput
  path?: never
  query?: never
  url: '/fal-ai/lightning-models'
}

export type PostFalAiLightningModelsResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLightningModelsResponse =
  PostFalAiLightningModelsResponses[keyof PostFalAiLightningModelsResponses]

export type GetFalAiLightningModelsRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/lightning-models/requests/{request_id}'
}

export type GetFalAiLightningModelsRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLightningModelsOutput
}

export type GetFalAiLightningModelsRequestsByRequestIdResponse =
  GetFalAiLightningModelsRequestsByRequestIdResponses[keyof GetFalAiLightningModelsRequestsByRequestIdResponses]

export type GetFalAiPlaygroundV25RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/playground-v25/requests/{request_id}/status'
}

export type GetFalAiPlaygroundV25RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiPlaygroundV25RequestsByRequestIdStatusResponse =
  GetFalAiPlaygroundV25RequestsByRequestIdStatusResponses[keyof GetFalAiPlaygroundV25RequestsByRequestIdStatusResponses]

export type PutFalAiPlaygroundV25RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/playground-v25/requests/{request_id}/cancel'
}

export type PutFalAiPlaygroundV25RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiPlaygroundV25RequestsByRequestIdCancelResponse =
  PutFalAiPlaygroundV25RequestsByRequestIdCancelResponses[keyof PutFalAiPlaygroundV25RequestsByRequestIdCancelResponses]

export type PostFalAiPlaygroundV25Data = {
  body: SchemaPlaygroundV25Input
  path?: never
  query?: never
  url: '/fal-ai/playground-v25'
}

export type PostFalAiPlaygroundV25Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiPlaygroundV25Response =
  PostFalAiPlaygroundV25Responses[keyof PostFalAiPlaygroundV25Responses]

export type GetFalAiPlaygroundV25RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/playground-v25/requests/{request_id}'
}

export type GetFalAiPlaygroundV25RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaPlaygroundV25Output
}

export type GetFalAiPlaygroundV25RequestsByRequestIdResponse =
  GetFalAiPlaygroundV25RequestsByRequestIdResponses[keyof GetFalAiPlaygroundV25RequestsByRequestIdResponses]

export type GetFalAiRealisticVisionRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/realistic-vision/requests/{request_id}/status'
}

export type GetFalAiRealisticVisionRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiRealisticVisionRequestsByRequestIdStatusResponse =
  GetFalAiRealisticVisionRequestsByRequestIdStatusResponses[keyof GetFalAiRealisticVisionRequestsByRequestIdStatusResponses]

export type PutFalAiRealisticVisionRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/realistic-vision/requests/{request_id}/cancel'
}

export type PutFalAiRealisticVisionRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiRealisticVisionRequestsByRequestIdCancelResponse =
  PutFalAiRealisticVisionRequestsByRequestIdCancelResponses[keyof PutFalAiRealisticVisionRequestsByRequestIdCancelResponses]

export type PostFalAiRealisticVisionData = {
  body: SchemaRealisticVisionInput
  path?: never
  query?: never
  url: '/fal-ai/realistic-vision'
}

export type PostFalAiRealisticVisionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiRealisticVisionResponse =
  PostFalAiRealisticVisionResponses[keyof PostFalAiRealisticVisionResponses]

export type GetFalAiRealisticVisionRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/realistic-vision/requests/{request_id}'
}

export type GetFalAiRealisticVisionRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaRealisticVisionOutput
}

export type GetFalAiRealisticVisionRequestsByRequestIdResponse =
  GetFalAiRealisticVisionRequestsByRequestIdResponses[keyof GetFalAiRealisticVisionRequestsByRequestIdResponses]

export type GetFalAiDreamshaperRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/dreamshaper/requests/{request_id}/status'
}

export type GetFalAiDreamshaperRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiDreamshaperRequestsByRequestIdStatusResponse =
  GetFalAiDreamshaperRequestsByRequestIdStatusResponses[keyof GetFalAiDreamshaperRequestsByRequestIdStatusResponses]

export type PutFalAiDreamshaperRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/dreamshaper/requests/{request_id}/cancel'
}

export type PutFalAiDreamshaperRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiDreamshaperRequestsByRequestIdCancelResponse =
  PutFalAiDreamshaperRequestsByRequestIdCancelResponses[keyof PutFalAiDreamshaperRequestsByRequestIdCancelResponses]

export type PostFalAiDreamshaperData = {
  body: SchemaDreamshaperInput
  path?: never
  query?: never
  url: '/fal-ai/dreamshaper'
}

export type PostFalAiDreamshaperResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiDreamshaperResponse =
  PostFalAiDreamshaperResponses[keyof PostFalAiDreamshaperResponses]

export type GetFalAiDreamshaperRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/dreamshaper/requests/{request_id}'
}

export type GetFalAiDreamshaperRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaDreamshaperOutput
}

export type GetFalAiDreamshaperRequestsByRequestIdResponse =
  GetFalAiDreamshaperRequestsByRequestIdResponses[keyof GetFalAiDreamshaperRequestsByRequestIdResponses]

export type GetFalAiStableDiffusionV15RequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/stable-diffusion-v15/requests/{request_id}/status'
}

export type GetFalAiStableDiffusionV15RequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiStableDiffusionV15RequestsByRequestIdStatusResponse =
  GetFalAiStableDiffusionV15RequestsByRequestIdStatusResponses[keyof GetFalAiStableDiffusionV15RequestsByRequestIdStatusResponses]

export type PutFalAiStableDiffusionV15RequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/stable-diffusion-v15/requests/{request_id}/cancel'
}

export type PutFalAiStableDiffusionV15RequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiStableDiffusionV15RequestsByRequestIdCancelResponse =
  PutFalAiStableDiffusionV15RequestsByRequestIdCancelResponses[keyof PutFalAiStableDiffusionV15RequestsByRequestIdCancelResponses]

export type PostFalAiStableDiffusionV15Data = {
  body: SchemaStableDiffusionV15Input
  path?: never
  query?: never
  url: '/fal-ai/stable-diffusion-v15'
}

export type PostFalAiStableDiffusionV15Responses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiStableDiffusionV15Response =
  PostFalAiStableDiffusionV15Responses[keyof PostFalAiStableDiffusionV15Responses]

export type GetFalAiStableDiffusionV15RequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/stable-diffusion-v15/requests/{request_id}'
}

export type GetFalAiStableDiffusionV15RequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaStableDiffusionV15Output
}

export type GetFalAiStableDiffusionV15RequestsByRequestIdResponse =
  GetFalAiStableDiffusionV15RequestsByRequestIdResponses[keyof GetFalAiStableDiffusionV15RequestsByRequestIdResponses]

export type GetFalAiLayerDiffusionRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/layer-diffusion/requests/{request_id}/status'
}

export type GetFalAiLayerDiffusionRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLayerDiffusionRequestsByRequestIdStatusResponse =
  GetFalAiLayerDiffusionRequestsByRequestIdStatusResponses[keyof GetFalAiLayerDiffusionRequestsByRequestIdStatusResponses]

export type PutFalAiLayerDiffusionRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/layer-diffusion/requests/{request_id}/cancel'
}

export type PutFalAiLayerDiffusionRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLayerDiffusionRequestsByRequestIdCancelResponse =
  PutFalAiLayerDiffusionRequestsByRequestIdCancelResponses[keyof PutFalAiLayerDiffusionRequestsByRequestIdCancelResponses]

export type PostFalAiLayerDiffusionData = {
  body: SchemaLayerDiffusionInput
  path?: never
  query?: never
  url: '/fal-ai/layer-diffusion'
}

export type PostFalAiLayerDiffusionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLayerDiffusionResponse =
  PostFalAiLayerDiffusionResponses[keyof PostFalAiLayerDiffusionResponses]

export type GetFalAiLayerDiffusionRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/layer-diffusion/requests/{request_id}'
}

export type GetFalAiLayerDiffusionRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLayerDiffusionOutput
}

export type GetFalAiLayerDiffusionRequestsByRequestIdResponse =
  GetFalAiLayerDiffusionRequestsByRequestIdResponses[keyof GetFalAiLayerDiffusionRequestsByRequestIdResponses]

export type GetFalAiFastLightningSdxlRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/fast-lightning-sdxl/requests/{request_id}/status'
}

export type GetFalAiFastLightningSdxlRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFastLightningSdxlRequestsByRequestIdStatusResponse =
  GetFalAiFastLightningSdxlRequestsByRequestIdStatusResponses[keyof GetFalAiFastLightningSdxlRequestsByRequestIdStatusResponses]

export type PutFalAiFastLightningSdxlRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-lightning-sdxl/requests/{request_id}/cancel'
}

export type PutFalAiFastLightningSdxlRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFastLightningSdxlRequestsByRequestIdCancelResponse =
  PutFalAiFastLightningSdxlRequestsByRequestIdCancelResponses[keyof PutFalAiFastLightningSdxlRequestsByRequestIdCancelResponses]

export type PostFalAiFastLightningSdxlData = {
  body: SchemaFastLightningSdxlInput
  path?: never
  query?: never
  url: '/fal-ai/fast-lightning-sdxl'
}

export type PostFalAiFastLightningSdxlResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFastLightningSdxlResponse =
  PostFalAiFastLightningSdxlResponses[keyof PostFalAiFastLightningSdxlResponses]

export type GetFalAiFastLightningSdxlRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-lightning-sdxl/requests/{request_id}'
}

export type GetFalAiFastLightningSdxlRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFastLightningSdxlOutput
}

export type GetFalAiFastLightningSdxlRequestsByRequestIdResponse =
  GetFalAiFastLightningSdxlRequestsByRequestIdResponses[keyof GetFalAiFastLightningSdxlRequestsByRequestIdResponses]

export type GetFalAiFastFooocusSdxlImageToImageRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/fast-fooocus-sdxl/image-to-image/requests/{request_id}/status'
}

export type GetFalAiFastFooocusSdxlImageToImageRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFastFooocusSdxlImageToImageRequestsByRequestIdStatusResponse =
  GetFalAiFastFooocusSdxlImageToImageRequestsByRequestIdStatusResponses[keyof GetFalAiFastFooocusSdxlImageToImageRequestsByRequestIdStatusResponses]

export type PutFalAiFastFooocusSdxlImageToImageRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-fooocus-sdxl/image-to-image/requests/{request_id}/cancel'
}

export type PutFalAiFastFooocusSdxlImageToImageRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFastFooocusSdxlImageToImageRequestsByRequestIdCancelResponse =
  PutFalAiFastFooocusSdxlImageToImageRequestsByRequestIdCancelResponses[keyof PutFalAiFastFooocusSdxlImageToImageRequestsByRequestIdCancelResponses]

export type PostFalAiFastFooocusSdxlImageToImageData = {
  body: SchemaFastFooocusSdxlImageToImageInput
  path?: never
  query?: never
  url: '/fal-ai/fast-fooocus-sdxl/image-to-image'
}

export type PostFalAiFastFooocusSdxlImageToImageResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFastFooocusSdxlImageToImageResponse =
  PostFalAiFastFooocusSdxlImageToImageResponses[keyof PostFalAiFastFooocusSdxlImageToImageResponses]

export type GetFalAiFastFooocusSdxlImageToImageRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-fooocus-sdxl/image-to-image/requests/{request_id}'
}

export type GetFalAiFastFooocusSdxlImageToImageRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFastFooocusSdxlImageToImageOutput
}

export type GetFalAiFastFooocusSdxlImageToImageRequestsByRequestIdResponse =
  GetFalAiFastFooocusSdxlImageToImageRequestsByRequestIdResponses[keyof GetFalAiFastFooocusSdxlImageToImageRequestsByRequestIdResponses]

export type GetFalAiFastSdxlControlnetCannyRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/fast-sdxl-controlnet-canny/requests/{request_id}/status'
}

export type GetFalAiFastSdxlControlnetCannyRequestsByRequestIdStatusResponses =
  {
    /**
     * The request status.
     */
    200: SchemaQueueStatus
  }

export type GetFalAiFastSdxlControlnetCannyRequestsByRequestIdStatusResponse =
  GetFalAiFastSdxlControlnetCannyRequestsByRequestIdStatusResponses[keyof GetFalAiFastSdxlControlnetCannyRequestsByRequestIdStatusResponses]

export type PutFalAiFastSdxlControlnetCannyRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-sdxl-controlnet-canny/requests/{request_id}/cancel'
}

export type PutFalAiFastSdxlControlnetCannyRequestsByRequestIdCancelResponses =
  {
    /**
     * The request was cancelled.
     */
    200: {
      /**
       * Whether the request was cancelled successfully.
       */
      success?: boolean
    }
  }

export type PutFalAiFastSdxlControlnetCannyRequestsByRequestIdCancelResponse =
  PutFalAiFastSdxlControlnetCannyRequestsByRequestIdCancelResponses[keyof PutFalAiFastSdxlControlnetCannyRequestsByRequestIdCancelResponses]

export type PostFalAiFastSdxlControlnetCannyData = {
  body: SchemaFastSdxlControlnetCannyInput
  path?: never
  query?: never
  url: '/fal-ai/fast-sdxl-controlnet-canny'
}

export type PostFalAiFastSdxlControlnetCannyResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFastSdxlControlnetCannyResponse =
  PostFalAiFastSdxlControlnetCannyResponses[keyof PostFalAiFastSdxlControlnetCannyResponses]

export type GetFalAiFastSdxlControlnetCannyRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-sdxl-controlnet-canny/requests/{request_id}'
}

export type GetFalAiFastSdxlControlnetCannyRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFastSdxlControlnetCannyOutput
}

export type GetFalAiFastSdxlControlnetCannyRequestsByRequestIdResponse =
  GetFalAiFastSdxlControlnetCannyRequestsByRequestIdResponses[keyof GetFalAiFastSdxlControlnetCannyRequestsByRequestIdResponses]

export type GetFalAiFastLcmDiffusionRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/fast-lcm-diffusion/requests/{request_id}/status'
}

export type GetFalAiFastLcmDiffusionRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFastLcmDiffusionRequestsByRequestIdStatusResponse =
  GetFalAiFastLcmDiffusionRequestsByRequestIdStatusResponses[keyof GetFalAiFastLcmDiffusionRequestsByRequestIdStatusResponses]

export type PutFalAiFastLcmDiffusionRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-lcm-diffusion/requests/{request_id}/cancel'
}

export type PutFalAiFastLcmDiffusionRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFastLcmDiffusionRequestsByRequestIdCancelResponse =
  PutFalAiFastLcmDiffusionRequestsByRequestIdCancelResponses[keyof PutFalAiFastLcmDiffusionRequestsByRequestIdCancelResponses]

export type PostFalAiFastLcmDiffusionData = {
  body: SchemaFastLcmDiffusionInput
  path?: never
  query?: never
  url: '/fal-ai/fast-lcm-diffusion'
}

export type PostFalAiFastLcmDiffusionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFastLcmDiffusionResponse =
  PostFalAiFastLcmDiffusionResponses[keyof PostFalAiFastLcmDiffusionResponses]

export type GetFalAiFastLcmDiffusionRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-lcm-diffusion/requests/{request_id}'
}

export type GetFalAiFastLcmDiffusionRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFastLcmDiffusionOutput
}

export type GetFalAiFastLcmDiffusionRequestsByRequestIdResponse =
  GetFalAiFastLcmDiffusionRequestsByRequestIdResponses[keyof GetFalAiFastLcmDiffusionRequestsByRequestIdResponses]

export type GetFalAiFastFooocusSdxlRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/fast-fooocus-sdxl/requests/{request_id}/status'
}

export type GetFalAiFastFooocusSdxlRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFastFooocusSdxlRequestsByRequestIdStatusResponse =
  GetFalAiFastFooocusSdxlRequestsByRequestIdStatusResponses[keyof GetFalAiFastFooocusSdxlRequestsByRequestIdStatusResponses]

export type PutFalAiFastFooocusSdxlRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-fooocus-sdxl/requests/{request_id}/cancel'
}

export type PutFalAiFastFooocusSdxlRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFastFooocusSdxlRequestsByRequestIdCancelResponse =
  PutFalAiFastFooocusSdxlRequestsByRequestIdCancelResponses[keyof PutFalAiFastFooocusSdxlRequestsByRequestIdCancelResponses]

export type PostFalAiFastFooocusSdxlData = {
  body: SchemaFastFooocusSdxlInput
  path?: never
  query?: never
  url: '/fal-ai/fast-fooocus-sdxl'
}

export type PostFalAiFastFooocusSdxlResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFastFooocusSdxlResponse =
  PostFalAiFastFooocusSdxlResponses[keyof PostFalAiFastFooocusSdxlResponses]

export type GetFalAiFastFooocusSdxlRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fast-fooocus-sdxl/requests/{request_id}'
}

export type GetFalAiFastFooocusSdxlRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFastFooocusSdxlOutput
}

export type GetFalAiFastFooocusSdxlRequestsByRequestIdResponse =
  GetFalAiFastFooocusSdxlRequestsByRequestIdResponses[keyof GetFalAiFastFooocusSdxlRequestsByRequestIdResponses]

export type GetFalAiIllusionDiffusionRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/illusion-diffusion/requests/{request_id}/status'
}

export type GetFalAiIllusionDiffusionRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiIllusionDiffusionRequestsByRequestIdStatusResponse =
  GetFalAiIllusionDiffusionRequestsByRequestIdStatusResponses[keyof GetFalAiIllusionDiffusionRequestsByRequestIdStatusResponses]

export type PutFalAiIllusionDiffusionRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/illusion-diffusion/requests/{request_id}/cancel'
}

export type PutFalAiIllusionDiffusionRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiIllusionDiffusionRequestsByRequestIdCancelResponse =
  PutFalAiIllusionDiffusionRequestsByRequestIdCancelResponses[keyof PutFalAiIllusionDiffusionRequestsByRequestIdCancelResponses]

export type PostFalAiIllusionDiffusionData = {
  body: SchemaIllusionDiffusionInput
  path?: never
  query?: never
  url: '/fal-ai/illusion-diffusion'
}

export type PostFalAiIllusionDiffusionResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiIllusionDiffusionResponse =
  PostFalAiIllusionDiffusionResponses[keyof PostFalAiIllusionDiffusionResponses]

export type GetFalAiIllusionDiffusionRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/illusion-diffusion/requests/{request_id}'
}

export type GetFalAiIllusionDiffusionRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaIllusionDiffusionOutput
}

export type GetFalAiIllusionDiffusionRequestsByRequestIdResponse =
  GetFalAiIllusionDiffusionRequestsByRequestIdResponses[keyof GetFalAiIllusionDiffusionRequestsByRequestIdResponses]

export type GetFalAiFooocusImagePromptRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/fooocus/image-prompt/requests/{request_id}/status'
}

export type GetFalAiFooocusImagePromptRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFooocusImagePromptRequestsByRequestIdStatusResponse =
  GetFalAiFooocusImagePromptRequestsByRequestIdStatusResponses[keyof GetFalAiFooocusImagePromptRequestsByRequestIdStatusResponses]

export type PutFalAiFooocusImagePromptRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fooocus/image-prompt/requests/{request_id}/cancel'
}

export type PutFalAiFooocusImagePromptRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFooocusImagePromptRequestsByRequestIdCancelResponse =
  PutFalAiFooocusImagePromptRequestsByRequestIdCancelResponses[keyof PutFalAiFooocusImagePromptRequestsByRequestIdCancelResponses]

export type PostFalAiFooocusImagePromptData = {
  body: SchemaFooocusImagePromptInput
  path?: never
  query?: never
  url: '/fal-ai/fooocus/image-prompt'
}

export type PostFalAiFooocusImagePromptResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFooocusImagePromptResponse =
  PostFalAiFooocusImagePromptResponses[keyof PostFalAiFooocusImagePromptResponses]

export type GetFalAiFooocusImagePromptRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fooocus/image-prompt/requests/{request_id}'
}

export type GetFalAiFooocusImagePromptRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFooocusImagePromptOutput
}

export type GetFalAiFooocusImagePromptRequestsByRequestIdResponse =
  GetFalAiFooocusImagePromptRequestsByRequestIdResponses[keyof GetFalAiFooocusImagePromptRequestsByRequestIdResponses]

export type GetFalAiFooocusInpaintRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/fooocus/inpaint/requests/{request_id}/status'
}

export type GetFalAiFooocusInpaintRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFooocusInpaintRequestsByRequestIdStatusResponse =
  GetFalAiFooocusInpaintRequestsByRequestIdStatusResponses[keyof GetFalAiFooocusInpaintRequestsByRequestIdStatusResponses]

export type PutFalAiFooocusInpaintRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fooocus/inpaint/requests/{request_id}/cancel'
}

export type PutFalAiFooocusInpaintRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFooocusInpaintRequestsByRequestIdCancelResponse =
  PutFalAiFooocusInpaintRequestsByRequestIdCancelResponses[keyof PutFalAiFooocusInpaintRequestsByRequestIdCancelResponses]

export type PostFalAiFooocusInpaintData = {
  body: SchemaFooocusInpaintInput
  path?: never
  query?: never
  url: '/fal-ai/fooocus/inpaint'
}

export type PostFalAiFooocusInpaintResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFooocusInpaintResponse =
  PostFalAiFooocusInpaintResponses[keyof PostFalAiFooocusInpaintResponses]

export type GetFalAiFooocusInpaintRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fooocus/inpaint/requests/{request_id}'
}

export type GetFalAiFooocusInpaintRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFooocusInpaintOutput
}

export type GetFalAiFooocusInpaintRequestsByRequestIdResponse =
  GetFalAiFooocusInpaintRequestsByRequestIdResponses[keyof GetFalAiFooocusInpaintRequestsByRequestIdResponses]

export type GetFalAiLcmRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/lcm/requests/{request_id}/status'
}

export type GetFalAiLcmRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLcmRequestsByRequestIdStatusResponse =
  GetFalAiLcmRequestsByRequestIdStatusResponses[keyof GetFalAiLcmRequestsByRequestIdStatusResponses]

export type PutFalAiLcmRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/lcm/requests/{request_id}/cancel'
}

export type PutFalAiLcmRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLcmRequestsByRequestIdCancelResponse =
  PutFalAiLcmRequestsByRequestIdCancelResponses[keyof PutFalAiLcmRequestsByRequestIdCancelResponses]

export type PostFalAiLcmData = {
  body: SchemaLcmInput
  path?: never
  query?: never
  url: '/fal-ai/lcm'
}

export type PostFalAiLcmResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLcmResponse =
  PostFalAiLcmResponses[keyof PostFalAiLcmResponses]

export type GetFalAiLcmRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/lcm/requests/{request_id}'
}

export type GetFalAiLcmRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLcmOutput
}

export type GetFalAiLcmRequestsByRequestIdResponse =
  GetFalAiLcmRequestsByRequestIdResponses[keyof GetFalAiLcmRequestsByRequestIdResponses]

export type GetFalAiDiffusionEdgeRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/diffusion-edge/requests/{request_id}/status'
}

export type GetFalAiDiffusionEdgeRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiDiffusionEdgeRequestsByRequestIdStatusResponse =
  GetFalAiDiffusionEdgeRequestsByRequestIdStatusResponses[keyof GetFalAiDiffusionEdgeRequestsByRequestIdStatusResponses]

export type PutFalAiDiffusionEdgeRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/diffusion-edge/requests/{request_id}/cancel'
}

export type PutFalAiDiffusionEdgeRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiDiffusionEdgeRequestsByRequestIdCancelResponse =
  PutFalAiDiffusionEdgeRequestsByRequestIdCancelResponses[keyof PutFalAiDiffusionEdgeRequestsByRequestIdCancelResponses]

export type PostFalAiDiffusionEdgeData = {
  body: SchemaDiffusionEdgeInput
  path?: never
  query?: never
  url: '/fal-ai/diffusion-edge'
}

export type PostFalAiDiffusionEdgeResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiDiffusionEdgeResponse =
  PostFalAiDiffusionEdgeResponses[keyof PostFalAiDiffusionEdgeResponses]

export type GetFalAiDiffusionEdgeRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/diffusion-edge/requests/{request_id}'
}

export type GetFalAiDiffusionEdgeRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaDiffusionEdgeOutput
}

export type GetFalAiDiffusionEdgeRequestsByRequestIdResponse =
  GetFalAiDiffusionEdgeRequestsByRequestIdResponses[keyof GetFalAiDiffusionEdgeRequestsByRequestIdResponses]

export type GetFalAiFooocusRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/fooocus/requests/{request_id}/status'
}

export type GetFalAiFooocusRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiFooocusRequestsByRequestIdStatusResponse =
  GetFalAiFooocusRequestsByRequestIdStatusResponses[keyof GetFalAiFooocusRequestsByRequestIdStatusResponses]

export type PutFalAiFooocusRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fooocus/requests/{request_id}/cancel'
}

export type PutFalAiFooocusRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiFooocusRequestsByRequestIdCancelResponse =
  PutFalAiFooocusRequestsByRequestIdCancelResponses[keyof PutFalAiFooocusRequestsByRequestIdCancelResponses]

export type PostFalAiFooocusData = {
  body: SchemaFooocusInput
  path?: never
  query?: never
  url: '/fal-ai/fooocus'
}

export type PostFalAiFooocusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiFooocusResponse =
  PostFalAiFooocusResponses[keyof PostFalAiFooocusResponses]

export type GetFalAiFooocusRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/fooocus/requests/{request_id}'
}

export type GetFalAiFooocusRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaFooocusOutput
}

export type GetFalAiFooocusRequestsByRequestIdResponse =
  GetFalAiFooocusRequestsByRequestIdResponses[keyof GetFalAiFooocusRequestsByRequestIdResponses]

export type GetFalAiLoraRequestsByRequestIdStatusData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: {
    /**
     * Whether to include logs (`1`) in the response or not (`0`).
     */
    logs?: number
  }
  url: '/fal-ai/lora/requests/{request_id}/status'
}

export type GetFalAiLoraRequestsByRequestIdStatusResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type GetFalAiLoraRequestsByRequestIdStatusResponse =
  GetFalAiLoraRequestsByRequestIdStatusResponses[keyof GetFalAiLoraRequestsByRequestIdStatusResponses]

export type PutFalAiLoraRequestsByRequestIdCancelData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/lora/requests/{request_id}/cancel'
}

export type PutFalAiLoraRequestsByRequestIdCancelResponses = {
  /**
   * The request was cancelled.
   */
  200: {
    /**
     * Whether the request was cancelled successfully.
     */
    success?: boolean
  }
}

export type PutFalAiLoraRequestsByRequestIdCancelResponse =
  PutFalAiLoraRequestsByRequestIdCancelResponses[keyof PutFalAiLoraRequestsByRequestIdCancelResponses]

export type PostFalAiLoraData = {
  body: SchemaLoraInput
  path?: never
  query?: never
  url: '/fal-ai/lora'
}

export type PostFalAiLoraResponses = {
  /**
   * The request status.
   */
  200: SchemaQueueStatus
}

export type PostFalAiLoraResponse =
  PostFalAiLoraResponses[keyof PostFalAiLoraResponses]

export type GetFalAiLoraRequestsByRequestIdData = {
  body?: never
  path: {
    /**
     * Request ID
     */
    request_id: string
  }
  query?: never
  url: '/fal-ai/lora/requests/{request_id}'
}

export type GetFalAiLoraRequestsByRequestIdResponses = {
  /**
   * Result of the request.
   */
  200: SchemaLoraOutput
}

export type GetFalAiLoraRequestsByRequestIdResponse =
  GetFalAiLoraRequestsByRequestIdResponses[keyof GetFalAiLoraRequestsByRequestIdResponses]
