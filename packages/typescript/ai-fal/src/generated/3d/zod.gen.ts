// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod'

/**
 * File
 */
export const zSchemaFile = z.object({
  file_size: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The size of the file in bytes.',
    }),
  ),
  file_name: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'The name of the file. It will be auto-generated if not provided.',
    }),
  ),
  content_type: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The mime type of the file.',
    }),
  ),
  url: z.string().register(z.globalRegistry, {
    description: 'The URL where the file can be downloaded from.',
  }),
  file_data: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'File data',
    }),
  ),
})

/**
 * ModelUrls
 *
 * 3D model files in various formats
 */
export const zSchemaModelUrls = z
  .object({
    usdz: z.optional(zSchemaFile),
    fbx: z.optional(zSchemaFile),
    blend: z.optional(zSchemaFile),
    stl: z.optional(zSchemaFile),
    glb: z.optional(zSchemaFile),
    obj: z.optional(zSchemaFile),
  })
  .register(z.globalRegistry, {
    description: '3D model files in various formats',
  })

/**
 * TextureFiles
 *
 * Texture files downloaded and uploaded to CDN
 */
export const zSchemaTextureFiles = z
  .object({
    base_color: zSchemaFile,
    normal: z.optional(zSchemaFile),
    roughness: z.optional(zSchemaFile),
    metallic: z.optional(zSchemaFile),
  })
  .register(z.globalRegistry, {
    description: 'Texture files downloaded and uploaded to CDN',
  })

/**
 * TextTo3DOutput
 *
 * Output for Text to 3D generation
 */
export const zSchemaMeshyV6PreviewTextTo3dOutput = z
  .object({
    prompt: z.string().register(z.globalRegistry, {
      description: 'The text prompt used for generation',
    }),
    thumbnail: z.optional(zSchemaFile),
    actual_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The actual prompt used if prompt expansion was enabled',
      }),
    ),
    texture_urls: z.optional(
      z.array(zSchemaTextureFiles).register(z.globalRegistry, {
        description: 'Array of texture file objects',
      }),
    ),
    model_glb: zSchemaFile,
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The seed used for generation',
      }),
    ),
    model_urls: zSchemaModelUrls,
  })
  .register(z.globalRegistry, {
    description: 'Output for Text to 3D generation',
  })

/**
 * TextTo3DInput
 *
 * Input for Text to 3D conversion
 */
export const zSchemaMeshyV6PreviewTextTo3dInput = z
  .object({
    prompt: z.string().max(600).register(z.globalRegistry, {
      description:
        'Describe what kind of object the 3D model is. Maximum 600 characters.',
    }),
    enable_pbr: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Generate PBR Maps (metallic, roughness, normal) in addition to base color. Should be false for sculpture style.',
        }),
      )
      .default(false),
    target_polycount: z
      .optional(
        z.int().gte(100).lte(300000).register(z.globalRegistry, {
          description: 'Target number of polygons in the generated model',
        }),
      )
      .default(30000),
    art_style: z.optional(
      z.enum(['realistic', 'sculpture']).register(z.globalRegistry, {
        description:
          'Desired art style of the object. Note: enable_pbr should be false for sculpture style.',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If set to true, input data will be checked for safety before processing.',
        }),
      )
      .default(true),
    mode: z.optional(
      z.enum(['preview', 'full']).register(z.globalRegistry, {
        description:
          "Generation mode. 'preview' returns untextured geometry only, 'full' returns textured model (preview + refine).",
      }),
    ),
    symmetry_mode: z.optional(
      z.enum(['off', 'auto', 'on']).register(z.globalRegistry, {
        description: 'Controls symmetry behavior during model generation.',
      }),
    ),
    should_remesh: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the remesh phase. When false, returns unprocessed triangular mesh.',
        }),
      )
      .default(true),
    texture_image_url: z.optional(z.union([z.string(), z.string()])),
    topology: z.optional(
      z.enum(['quad', 'triangle']).register(z.globalRegistry, {
        description:
          'Specify the topology of the generated model. Quad for smooth surfaces, Triangle for detailed geometry.',
      }),
    ),
    enable_prompt_expansion: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable prompt expansion. This will use a large language model to expand the prompt with additional details while maintaining the original meaning.',
        }),
      )
      .default(false),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description:
          'Seed for reproducible results. Same prompt and seed usually generate the same result.',
      }),
    ),
    is_a_t_pose: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to generate the model in an A/T pose',
        }),
      )
      .default(false),
    texture_prompt: z.optional(
      z.string().max(600).register(z.globalRegistry, {
        description:
          "Additional text prompt to guide the texturing process (only used in 'full' mode)",
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Input for Text to 3D conversion',
  })

/**
 * TextTo3DOutput
 */
export const zSchemaHunyuan3dV3TextTo3dOutput = z.object({
  model_urls: zSchemaModelUrls,
  thumbnail: z.optional(zSchemaFile),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
  ),
  model_glb: zSchemaFile,
})

/**
 * TextTo3DInput
 */
export const zSchemaHunyuan3dV3TextTo3dInput = z.object({
  enable_pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable PBR material generation',
      }),
    )
    .default(false),
  polygon_type: z.optional(
    z.enum(['triangle', 'quadrilateral']).register(z.globalRegistry, {
      description:
        'Polygon type. Only takes effect when GenerateType is LowPoly.',
    }),
  ),
  face_count: z
    .optional(
      z.int().gte(40000).lte(1500000).register(z.globalRegistry, {
        description: 'Target face count. Range: 40000-1500000',
      }),
    )
    .default(500000),
  prompt: z.string().max(1024).register(z.globalRegistry, {
    description:
      'Text description of the 3D content to generate. Supports up to 1024 UTF-8 characters.',
  }),
  generate_type: z.optional(
    z.enum(['Normal', 'LowPoly', 'Geometry']).register(z.globalRegistry, {
      description:
        'Generation type. Normal: textured model. LowPoly: polygon reduction. Geometry: white model without texture.',
    }),
  ),
})

/**
 * HYMotionOutput
 */
export const zSchemaHunyuanMotionOutput = z.object({
  fbx_file: z.optional(zSchemaFile),
  motion_json: z.optional(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation.',
  }),
})

/**
 * HYMotionInput
 */
export const zSchemaHunyuanMotionInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text prompt describing the motion to generate.',
  }),
  duration: z
    .optional(
      z.number().gte(0.5).lte(12).register(z.globalRegistry, {
        description: 'Motion duration in seconds (0.5-12.0).',
      }),
    )
    .default(5),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher = more faithful to prompt.',
      }),
    )
    .default(5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducible generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['fbx', 'dict']).register(z.globalRegistry, {
      description:
        "Output format: 'fbx' for animation files, 'dict' for raw JSON.",
    }),
  ),
})

/**
 * HYMotionOutput
 */
export const zSchemaHunyuanMotionFastOutput = z.object({
  fbx_file: z.optional(zSchemaFile),
  motion_json: z.optional(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed used for generation.',
  }),
})

/**
 * HYMotionInput
 */
export const zSchemaHunyuanMotionFastInput = z.object({
  prompt: z.string().register(z.globalRegistry, {
    description: 'Text prompt describing the motion to generate.',
  }),
  duration: z
    .optional(
      z.number().gte(0.5).lte(12).register(z.globalRegistry, {
        description: 'Motion duration in seconds (0.5-12.0).',
      }),
    )
    .default(5),
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Classifier-free guidance scale. Higher = more faithful to prompt.',
      }),
    )
    .default(5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducible generation.',
    }),
  ),
  output_format: z.optional(
    z.enum(['fbx', 'dict']).register(z.globalRegistry, {
      description:
        "Output format: 'fbx' for animation files, 'dict' for raw JSON.",
    }),
  ),
})

/**
 * ObjectOutput
 */
export const zSchemaTriposrOutput = z.object({
  remeshing_dir: z.optional(zSchemaFile),
  model_mesh: zSchemaFile,
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'Inference timings.',
  }),
})

/**
 * TripoSRInput
 */
export const zSchemaTriposrInput = z.object({
  mc_resolution: z
    .optional(
      z.int().gte(32).lte(1024).register(z.globalRegistry, {
        description:
          'Resolution of the marching cubes. Above 512 is not recommended.',
      }),
    )
    .default(256),
  do_remove_background: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to remove the background from the input image.',
      }),
    )
    .default(true),
  foreground_ratio: z
    .optional(
      z.number().gte(0.5).lte(1).register(z.globalRegistry, {
        description: 'Ratio of the foreground image to the original image.',
      }),
    )
    .default(0.9),
  output_format: z.optional(
    z.enum(['glb', 'obj']).register(z.globalRegistry, {
      description: 'Output format for the 3D model.',
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
})

/**
 * ObjectOutput
 */
export const zSchemaTrellisOutput = z.object({
  model_mesh: zSchemaFile,
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'Processing timings',
  }),
})

/**
 * InputModel
 */
export const zSchemaTrellisInput = z.object({
  slat_sampling_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Sampling steps for structured latent generation',
      }),
    )
    .default(12),
  ss_sampling_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Sampling steps for sparse structure generation',
      }),
    )
    .default(12),
  image_url: z.union([z.string(), z.string()]),
  slat_guidance_strength: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Guidance strength for structured latent generation',
      }),
    )
    .default(3),
  ss_guidance_strength: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Guidance strength for sparse structure generation',
      }),
    )
    .default(7.5),
  mesh_simplify: z
    .optional(
      z.number().gte(0.9).lte(0.98).register(z.globalRegistry, {
        description: 'Mesh simplification factor',
      }),
    )
    .default(0.95),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  texture_size: z.optional(
    z
      .union([z.literal(512), z.literal(1024), z.literal(2048)])
      .register(z.globalRegistry, {
        description: 'Texture resolution',
      }),
  ),
})

/**
 * Image
 *
 * Represents an image file.
 */
export const zSchemaImage = z
  .object({
    height: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The height of the image in pixels.',
      }),
    ),
    file_size: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The size of the file in bytes.',
      }),
    ),
    url: z.string().register(z.globalRegistry, {
      description: 'The URL where the file can be downloaded from.',
    }),
    width: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The width of the image in pixels.',
      }),
    ),
    file_name: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'The name of the file. It will be auto-generated if not provided.',
      }),
    ),
    content_type: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The mime type of the file.',
      }),
    ),
    file_data: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'File data',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Represents an image file.',
  })

/**
 * ObjectOutput
 */
export const zSchemaHyper3dRodinOutput = z.object({
  model_mesh: zSchemaFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
  textures: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Generated textures for the 3D object.',
  }),
})

/**
 * Rodin3DInput
 */
export const zSchemaHyper3dRodinInput = z.object({
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'A textual prompt to guide model generation. Required for Text-to-3D mode. Optional for Image-to-3D mode.',
      }),
    )
    .default(''),
  condition_mode: z.optional(
    z.enum(['fuse', 'concat']).register(z.globalRegistry, {
      description:
        'For fuse mode, One or more images are required.It will generate a model by extracting and fusing features of objects from multiple images.For concat mode, need to upload multiple multi-view images of the same object and generate the model. (You can upload multi-view images in any order, regardless of the order of view.)',
    }),
  ),
  bbox_condition: z.optional(
    z.array(z.int()).register(z.globalRegistry, {
      description:
        'An array that specifies the dimensions and scaling factor of the bounding box. Typically, this array contains 3 elements, Length(X-axis), Width(Y-axis) and Height(Z-axis).',
    }),
  ),
  tier: z.optional(
    z.enum(['Regular', 'Sketch']).register(z.globalRegistry, {
      description:
        'Tier of generation. For Rodin Sketch, set to Sketch. For Rodin Regular, set to Regular.',
    }),
  ),
  quality: z.optional(
    z.enum(['high', 'medium', 'low', 'extra-low']).register(z.globalRegistry, {
      description:
        'Generation quality. Possible values: high, medium, low, extra-low. Default is medium.',
    }),
  ),
  TAPose: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'When generating the human-like model, this parameter control the generation result to T/A Pose.',
      }),
    )
    .default(false),
  input_image_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'URL of images to use while generating the 3D model. Required for Image-to-3D mode. Optional for Text-to-3D mode.',
    }),
  ),
  geometry_file_format: z.optional(
    z.enum(['glb', 'usdz', 'fbx', 'obj', 'stl']).register(z.globalRegistry, {
      description:
        'Format of the geometry file. Possible values: glb, usdz, fbx, obj, stl. Default is glb.',
    }),
  ),
  use_hyper: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to export the model using hyper mode. Default is false.',
      }),
    )
    .default(false),
  addons: z.optional(
    z.enum(['HighPack']).register(z.globalRegistry, {
      description:
        'Generation add-on features. Default is []. Possible values are HighPack. The HighPack option will provide 4K resolution textures instead of the default 1K, as well as models with high-poly. It will cost triple the billable units.',
    }),
  ),
  seed: z.optional(
    z.int().gte(0).lte(65535).register(z.globalRegistry, {
      description:
        'Seed value for randomization, ranging from 0 to 65535. Optional.',
    }),
  ),
  material: z.optional(
    z.enum(['PBR', 'Shaded']).register(z.globalRegistry, {
      description:
        'Material type. Possible values: PBR, Shaded. Default is PBR.',
    }),
  ),
})

/**
 * ObjectOutput
 */
export const zSchemaHunyuan3dV2MiniTurboOutput = z.object({
  model_mesh: zSchemaFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
})

/**
 * Hunyuan3DInput
 */
export const zSchemaHunyuan3dV2MiniTurboInput = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: 'Octree resolution for the model.',
      }),
    )
    .default(256),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for the model.',
      }),
    )
    .default(7.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps to perform.',
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.',
      }),
    )
    .default(false),
})

/**
 * ObjectOutput
 */
export const zSchemaHunyuan3dV2TurboOutput = z.object({
  model_mesh: zSchemaFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
})

/**
 * Hunyuan3DInput
 */
export const zSchemaHunyuan3dV2TurboInput = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: 'Octree resolution for the model.',
      }),
    )
    .default(256),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for the model.',
      }),
    )
    .default(7.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps to perform.',
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.',
      }),
    )
    .default(false),
})

/**
 * MultiViewObjectOutput
 */
export const zSchemaHunyuan3dV2MultiViewOutput = z.object({
  model_mesh: zSchemaFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
})

/**
 * Hunyuan3DInputMultiView
 */
export const zSchemaHunyuan3dV2MultiViewInput = z.object({
  front_image_url: z.union([z.string(), z.string()]),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: 'Octree resolution for the model.',
      }),
    )
    .default(256),
  back_image_url: z.union([z.string(), z.string()]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for the model.',
      }),
    )
    .default(7.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps to perform.',
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.',
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  left_image_url: z.union([z.string(), z.string()]),
})

/**
 * ObjectOutput
 */
export const zSchemaHunyuan3dV2MiniOutput = z.object({
  model_mesh: zSchemaFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
})

/**
 * Hunyuan3DInput
 */
export const zSchemaHunyuan3dV2MiniInput = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: 'Octree resolution for the model.',
      }),
    )
    .default(256),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for the model.',
      }),
    )
    .default(7.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps to perform.',
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.',
      }),
    )
    .default(false),
})

/**
 * ObjectOutput
 */
export const zSchemaHunyuan3dV2Output = z.object({
  model_mesh: zSchemaFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
})

/**
 * Hunyuan3DInput
 */
export const zSchemaHunyuan3dV2Input = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: 'Octree resolution for the model.',
      }),
    )
    .default(256),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for the model.',
      }),
    )
    .default(7.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps to perform.',
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.',
      }),
    )
    .default(false),
})

/**
 * MultiViewObjectOutput
 */
export const zSchemaHunyuan3dV2MultiViewTurboOutput = z.object({
  model_mesh: zSchemaFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
})

/**
 * Hunyuan3DInputMultiView
 */
export const zSchemaHunyuan3dV2MultiViewTurboInput = z.object({
  front_image_url: z.union([z.string(), z.string()]),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: 'Octree resolution for the model.',
      }),
    )
    .default(256),
  back_image_url: z.union([z.string(), z.string()]),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for the model.',
      }),
    )
    .default(7.5),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps to perform.',
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.',
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  left_image_url: z.union([z.string(), z.string()]),
})

/**
 * Tripo3dOutput
 */
export const zSchemaTripoV25ImageTo3dOutput = z.object({
  base_model: z.optional(zSchemaFile),
  task_id: z.string().register(z.globalRegistry, {
    description: 'The task id of the 3D model generation.',
  }),
  rendered_image: z.optional(zSchemaFile),
  model_mesh: z.optional(zSchemaFile),
  pbr_model: z.optional(zSchemaFile),
})

/**
 * ImageTo3dInput
 */
export const zSchemaTripoV25ImageTo3dInput = z.object({
  face_limit: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Limits the number of faces on the output model. If this option is not set, the face limit will be adaptively determined.',
    }),
  ),
  style: z.optional(
    z
      .enum([
        'person:person2cartoon',
        'object:clay',
        'object:steampunk',
        'animal:venom',
        'object:barbie',
        'object:christmas',
        'gold',
        'ancient_bronze',
      ])
      .register(z.globalRegistry, {
        description:
          '[DEPRECATED] Defines the artistic style or transformation to be applied to the 3D model, altering its appearance according to preset options (extra $0.05 per generation). Omit this option to keep the original style and apperance.',
      }),
  ),
  pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'A boolean option to enable pbr. The default value is True, set False to get a model without pbr. If this option is set to True, texture will be ignored and used as True.',
      }),
    )
    .default(false),
  texture_alignment: z.optional(
    z.enum(['original_image', 'geometry']).register(z.globalRegistry, {
      description:
        'Determines the prioritization of texture alignment in the 3D model. The default value is original_image.',
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
  texture: z.optional(
    z.enum(['no', 'standard', 'HD']).register(z.globalRegistry, {
      description:
        "An option to enable texturing. Default is 'standard', set 'no' to get a model without any textures, and set 'HD' to get a model with hd quality textures.",
    }),
  ),
  auto_size: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Automatically scale the model to real-world dimensions, with the unit in meters. The default value is False.',
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'This is the random seed for model generation. The seed controls the geometry generation process, ensuring identical models when the same seed is used. This parameter is an integer and is randomly chosen if not set.',
    }),
  ),
  quad: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Set True to enable quad mesh output (extra $0.05 per generation). If quad=True and face_limit is not set, the default face_limit will be 10000. Note: Enabling this option will force the output to be an FBX model.',
      }),
    )
    .default(false),
  orientation: z.optional(
    z.enum(['default', 'align_image']).register(z.globalRegistry, {
      description:
        'Set orientation=align_image to automatically rotate the model to align the original image. The default value is default.',
    }),
  ),
  texture_seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'This is the random seed for texture generation. Using the same seed will produce identical textures. This parameter is an integer and is randomly chosen if not set. If you want a model with different textures, please use same seed and different texture_seed.',
    }),
  ),
})

/**
 * ObjectOutput
 */
export const zSchemaTrellisMultiOutput = z.object({
  model_mesh: zSchemaFile,
  timings: z.record(z.string(), z.number()).register(z.globalRegistry, {
    description: 'Processing timings',
  }),
})

/**
 * MultiImageInputModel
 */
export const zSchemaTrellisMultiInput = z.object({
  multiimage_algo: z.optional(
    z.enum(['stochastic', 'multidiffusion']).register(z.globalRegistry, {
      description: 'Algorithm for multi-image generation',
    }),
  ),
  slat_sampling_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Sampling steps for structured latent generation',
      }),
    )
    .default(12),
  ss_sampling_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Sampling steps for sparse structure generation',
      }),
    )
    .default(12),
  ss_guidance_strength: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Guidance strength for sparse structure generation',
      }),
    )
    .default(7.5),
  slat_guidance_strength: z
    .optional(
      z.number().gte(0).lte(10).register(z.globalRegistry, {
        description: 'Guidance strength for structured latent generation',
      }),
    )
    .default(3),
  mesh_simplify: z
    .optional(
      z.number().gte(0.9).lte(0.98).register(z.globalRegistry, {
        description: 'Mesh simplification factor',
      }),
    )
    .default(0.95),
  seed: z.optional(z.union([z.int(), z.unknown()])),
  texture_size: z.optional(
    z
      .union([z.literal(512), z.literal(1024), z.literal(2048)])
      .register(z.globalRegistry, {
        description: 'Texture resolution',
      }),
  ),
  image_urls: z.array(z.string()).register(z.globalRegistry, {
    description: 'List of URLs of input images to convert to 3D',
  }),
})

/**
 * ObjectOutput
 */
export const zSchemaHunyuan3dV21Output = z.object({
  model_glb_pbr: z.optional(zSchemaFile),
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
  model_mesh: zSchemaFile,
  model_glb: zSchemaFile,
})

/**
 * Hunyuan3DInput
 */
export const zSchemaHunyuan3dV21Input = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  octree_resolution: z
    .optional(
      z.int().gte(1).lte(1024).register(z.globalRegistry, {
        description: 'Octree resolution for the model.',
      }),
    )
    .default(256),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for the model.',
      }),
    )
    .default(7.5),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
    }),
  ),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Number of inference steps to perform.',
      }),
    )
    .default(50),
  textured_mesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If set true, textured mesh will be generated and the price charged would be 3 times that of white mesh.',
      }),
    )
    .default(false),
})

/**
 * Tripo3dOutput
 */
export const zSchemaTripoV25MultiviewTo3dOutput = z.object({
  base_model: z.optional(zSchemaFile),
  task_id: z.string().register(z.globalRegistry, {
    description: 'The task id of the 3D model generation.',
  }),
  rendered_image: z.optional(zSchemaFile),
  model_mesh: z.optional(zSchemaFile),
  pbr_model: z.optional(zSchemaFile),
})

/**
 * MultiviewTo3dInput
 */
export const zSchemaTripoV25MultiviewTo3dInput = z.object({
  face_limit: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Limits the number of faces on the output model. If this option is not set, the face limit will be adaptively determined.',
    }),
  ),
  right_image_url: z.optional(z.union([z.string(), z.string()])),
  style: z.optional(
    z
      .enum([
        'person:person2cartoon',
        'object:clay',
        'object:steampunk',
        'animal:venom',
        'object:barbie',
        'object:christmas',
        'gold',
        'ancient_bronze',
      ])
      .register(z.globalRegistry, {
        description:
          '[DEPRECATED] Defines the artistic style or transformation to be applied to the 3D model, altering its appearance according to preset options (extra $0.05 per generation). Omit this option to keep the original style and apperance.',
      }),
  ),
  quad: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Set True to enable quad mesh output (extra $0.05 per generation). If quad=True and face_limit is not set, the default face_limit will be 10000. Note: Enabling this option will force the output to be an FBX model.',
      }),
    )
    .default(false),
  front_image_url: z.union([z.string(), z.string()]),
  texture_seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'This is the random seed for texture generation. Using the same seed will produce identical textures. This parameter is an integer and is randomly chosen if not set. If you want a model with different textures, please use same seed and different texture_seed.',
    }),
  ),
  back_image_url: z.optional(z.union([z.string(), z.string()])),
  pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'A boolean option to enable pbr. The default value is True, set False to get a model without pbr. If this option is set to True, texture will be ignored and used as True.',
      }),
    )
    .default(false),
  texture_alignment: z.optional(
    z.enum(['original_image', 'geometry']).register(z.globalRegistry, {
      description:
        'Determines the prioritization of texture alignment in the 3D model. The default value is original_image.',
    }),
  ),
  texture: z.optional(
    z.enum(['no', 'standard', 'HD']).register(z.globalRegistry, {
      description:
        "An option to enable texturing. Default is 'standard', set 'no' to get a model without any textures, and set 'HD' to get a model with hd quality textures.",
    }),
  ),
  auto_size: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Automatically scale the model to real-world dimensions, with the unit in meters. The default value is False.',
      }),
    )
    .default(false),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'This is the random seed for model generation. The seed controls the geometry generation process, ensuring identical models when the same seed is used. This parameter is an integer and is randomly chosen if not set.',
    }),
  ),
  orientation: z.optional(
    z.enum(['default', 'align_image']).register(z.globalRegistry, {
      description:
        'Set orientation=align_image to automatically rotate the model to align the original image. The default value is default.',
    }),
  ),
  left_image_url: z.optional(z.union([z.string(), z.string()])),
})

/**
 * ImageToWorldResponse
 */
export const zSchemaHunyuanWorldImageToWorldOutput = z.object({
  world_file: zSchemaFile,
})

/**
 * ImageToWorldRequest
 */
export const zSchemaHunyuanWorldImageToWorldInput = z.object({
  classes: z.string().register(z.globalRegistry, {
    description: 'Classes to use for the world generation.',
  }),
  export_drc: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to export DRC (Dynamic Resource Configuration).',
      }),
    )
    .default(false),
  labels_fg1: z.string().register(z.globalRegistry, {
    description: 'Labels for the first foreground object.',
  }),
  labels_fg2: z.string().register(z.globalRegistry, {
    description: 'Labels for the second foreground object.',
  }),
  image_url: z.union([z.string(), z.string()]),
})

/**
 * PSHumanResponse
 */
export const zSchemaPshumanOutput = z.object({
  model_obj: zSchemaFile,
  preview_image: zSchemaFile,
})

/**
 * PSHumanRequest
 */
export const zSchemaPshumanInput = z.object({
  guidance_scale: z
    .optional(
      z.number().gte(1).lte(10).register(z.globalRegistry, {
        description:
          'Guidance scale for the diffusion process. Controls how much the output adheres to the generated views.',
      }),
    )
    .default(4),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Seed for reproducibility. If None, a random seed will be used.',
    }),
  ),
  image_url: z.union([z.string(), z.string()]),
})

/**
 * ObjectOutputv2
 */
export const zSchemaHyper3dRodinV2Output = z.object({
  model_mesh: zSchemaFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
  textures: z.array(zSchemaImage).register(z.globalRegistry, {
    description: 'Generated textures for the 3D object.',
  }),
})

/**
 * RodinGen2Input
 */
export const zSchemaHyper3dRodinV2Input = z.object({
  quality_mesh_option: z.optional(
    z
      .enum([
        '4K Quad',
        '8K Quad',
        '18K Quad',
        '50K Quad',
        '2K Triangle',
        '20K Triangle',
        '150K Triangle',
        '500K Triangle',
      ])
      .register(z.globalRegistry, {
        description:
          "Combined quality and mesh type selection. Quad = smooth surfaces, Triangle = detailed geometry. These corresponds to `mesh_mode` (if the option contains 'Triangle', mesh_mode is 'Raw', otherwise 'Quad') and `quality_override` (the numeric part of the option) parameters in Hyper3D API.",
      }),
  ),
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          'A textual prompt to guide model generation. Optional for Image-to-3D mode - if empty, AI will generate a prompt based on your images.',
      }),
    )
    .default(''),
  preview_render: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Generate a preview render image of the 3D model along with the model files.',
      }),
    )
    .default(false),
  bbox_condition: z.optional(
    z.array(z.int()).register(z.globalRegistry, {
      description:
        'An array that specifies the bounding box dimensions [width, height, length].',
    }),
  ),
  TAPose: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Generate characters in T-pose or A-pose format, making them easier to rig and animate in 3D software.',
      }),
    )
    .default(false),
  input_image_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'URL of images to use while generating the 3D model. Required for Image-to-3D mode. Up to 5 images allowed.',
    }),
  ),
  use_original_alpha: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'When enabled, preserves the transparency channel from input images during 3D generation.',
      }),
    )
    .default(false),
  geometry_file_format: z.optional(
    z.enum(['glb', 'usdz', 'fbx', 'obj', 'stl']).register(z.globalRegistry, {
      description:
        'Format of the geometry file. Possible values: glb, usdz, fbx, obj, stl. Default is glb.',
    }),
  ),
  addons: z.optional(
    z.enum(['HighPack']).register(z.globalRegistry, {
      description:
        'The HighPack option will provide 4K resolution textures instead of the default 1K, as well as models with high-poly. It will cost **triple the billable units**.',
    }),
  ),
  seed: z.optional(
    z.int().gte(0).lte(65535).register(z.globalRegistry, {
      description:
        'Seed value for randomization, ranging from 0 to 65535. Optional.',
    }),
  ),
  material: z.optional(
    z.enum(['PBR', 'Shaded', 'All']).register(z.globalRegistry, {
      description:
        'Material type. PBR: Physically-based materials with realistic lighting. Shaded: Simple materials with baked lighting. All: Both types included.',
    }),
  ),
})

/**
 * ImageTo3DOutput
 *
 * Output for Image to 3D conversion
 */
export const zSchemaMeshyV6PreviewImageTo3dOutput = z
  .object({
    model_urls: zSchemaModelUrls,
    texture_urls: z.optional(
      z.array(zSchemaTextureFiles).register(z.globalRegistry, {
        description:
          'Array of texture file objects, matching Meshy API structure',
      }),
    ),
    thumbnail: z.optional(zSchemaFile),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The seed used for generation (if available)',
      }),
    ),
    model_glb: zSchemaFile,
  })
  .register(z.globalRegistry, {
    description: 'Output for Image to 3D conversion',
  })

/**
 * ImageTo3DInput
 *
 * Input for Image to 3D conversion
 */
export const zSchemaMeshyV6PreviewImageTo3dInput = z
  .object({
    enable_pbr: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Generate PBR Maps (metallic, roughness, normal) in addition to base color',
        }),
      )
      .default(false),
    is_a_t_pose: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to generate the model in an A/T pose',
        }),
      )
      .default(false),
    target_polycount: z
      .optional(
        z.int().gte(100).lte(300000).register(z.globalRegistry, {
          description: 'Target number of polygons in the generated model',
        }),
      )
      .default(30000),
    should_texture: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to generate textures',
        }),
      )
      .default(true),
    texture_image_url: z.optional(z.union([z.string(), z.string()])),
    topology: z.optional(
      z.enum(['quad', 'triangle']).register(z.globalRegistry, {
        description:
          'Specify the topology of the generated model. Quad for smooth surfaces, Triangle for detailed geometry.',
      }),
    ),
    image_url: z.union([z.string(), z.string()]),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If set to true, input data will be checked for safety before processing.',
        }),
      )
      .default(true),
    symmetry_mode: z.optional(
      z.enum(['off', 'auto', 'on']).register(z.globalRegistry, {
        description:
          'Controls symmetry behavior during model generation. Off disables symmetry, Auto determines it automatically, On enforces symmetry.',
      }),
    ),
    texture_prompt: z.optional(
      z.string().max(600).register(z.globalRegistry, {
        description: 'Text prompt to guide the texturing process',
      }),
    ),
    should_remesh: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to enable the remesh phase',
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: 'Input for Image to 3D conversion',
  })

/**
 * MultiImageTo3DOutput
 *
 * Output for Multi-Image to 3D conversion
 */
export const zSchemaMeshyV5MultiImageTo3dOutput = z
  .object({
    model_urls: zSchemaModelUrls,
    texture_urls: z.optional(
      z.array(zSchemaTextureFiles).register(z.globalRegistry, {
        description: 'Array of texture file objects',
      }),
    ),
    thumbnail: z.optional(zSchemaFile),
    seed: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The seed used for generation (if available)',
      }),
    ),
    model_glb: zSchemaFile,
  })
  .register(z.globalRegistry, {
    description: 'Output for Multi-Image to 3D conversion',
  })

/**
 * MultiImageTo3DInput
 *
 * Input for Multi-Image to 3D conversion
 */
export const zSchemaMeshyV5MultiImageTo3dInput = z
  .object({
    enable_pbr: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Generate PBR Maps (metallic, roughness, normal) in addition to base color. Requires should_texture to be true.',
        }),
      )
      .default(false),
    should_texture: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to generate textures. False provides mesh without textures for 5 credits, True adds texture generation for additional 10 credits.',
        }),
      )
      .default(true),
    target_polycount: z
      .optional(
        z.int().gte(100).lte(300000).register(z.globalRegistry, {
          description: 'Target number of polygons in the generated model',
        }),
      )
      .default(30000),
    is_a_t_pose: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether to generate the model in an A/T pose',
        }),
      )
      .default(false),
    texture_image_url: z.optional(z.union([z.string(), z.string()])),
    topology: z.optional(
      z.enum(['quad', 'triangle']).register(z.globalRegistry, {
        description:
          'Specify the topology of the generated model. Quad for smooth surfaces, Triangle for detailed geometry.',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If set to true, input data will be checked for safety before processing.',
        }),
      )
      .default(true),
    symmetry_mode: z.optional(
      z.enum(['off', 'auto', 'on']).register(z.globalRegistry, {
        description: 'Controls symmetry behavior during model generation.',
      }),
    ),
    image_urls: z.array(z.string()).register(z.globalRegistry, {
      description:
        '1 to 4 images for 3D model creation. All images should depict the same object from different angles. Supports .jpg, .jpeg, .png formats, and AVIF/HEIF which will be automatically converted. If more than 4 images are provided, only the first 4 will be used.',
    }),
    texture_prompt: z.optional(
      z.string().max(600).register(z.globalRegistry, {
        description:
          'Text prompt to guide the texturing process. Requires should_texture to be true.',
      }),
    ),
    should_remesh: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Whether to enable the remesh phase. When false, returns triangular mesh ignoring topology and target_polycount.',
        }),
      )
      .default(true),
  })
  .register(z.globalRegistry, {
    description: 'Input for Multi-Image to 3D conversion',
  })

/**
 * Seed3DImageTo3DOutput
 */
export const zSchemaBytedanceSeed3dImageTo3dOutput = z.object({
  model: zSchemaFile,
  usage_tokens: z.int().register(z.globalRegistry, {
    description: 'The number of tokens used for the 3D model generation',
  }),
})

/**
 * Seed3DImageTo3DInput
 */
export const zSchemaBytedanceSeed3dImageTo3dInput = z.object({
  image_url: z.union([z.string(), z.string()]),
})

/**
 * MultiViewObjectOutput
 */
export const zSchemaOmnipartOutput = z.object({
  full_model_mesh: zSchemaFile,
  output_zip: zSchemaFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
  model_mesh: zSchemaFile,
})

/**
 * OmnipartInput
 */
export const zSchemaOmnipartInput = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  parts: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Specify which segments to merge (e.g., '0,1;3,4' merges segments 0&1 together and 3&4 together)",
      }),
    )
    .default(''),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description:
          '\n            The same seed and the same prompt given to the same version of the model\n            will output the same image every time.\n        ',
      }),
    )
    .default(765464),
  minimum_segment_size: z
    .optional(
      z.int().gte(1).lte(10000).register(z.globalRegistry, {
        description: 'Minimum segment size (pixels) for the model.',
      }),
    )
    .default(2000),
  guidance_scale: z
    .optional(
      z.number().gte(0).lte(20).register(z.globalRegistry, {
        description: 'Guidance scale for the model.',
      }),
    )
    .default(7.5),
})

/**
 * SAM3DObjectMetadata
 *
 * Per-object metadata for 3D reconstruction.
 */
export const zSchemaSam3dObjectMetadata = z
  .object({
    rotation: z.optional(
      z.array(z.array(z.number())).register(z.globalRegistry, {
        description: 'Rotation quaternion [x, y, z, w]',
      }),
    ),
    translation: z.optional(
      z.array(z.array(z.number())).register(z.globalRegistry, {
        description: 'Translation [tx, ty, tz]',
      }),
    ),
    object_index: z.int().register(z.globalRegistry, {
      description: 'Index of the object in the scene',
    }),
    scale: z.optional(
      z.array(z.array(z.number())).register(z.globalRegistry, {
        description: 'Scale factors [sx, sy, sz]',
      }),
    ),
    camera_pose: z.optional(
      z.array(z.array(z.number())).register(z.globalRegistry, {
        description: 'Camera pose matrix',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'Per-object metadata for 3D reconstruction.',
  })

/**
 * PointPromptBase
 */
export const zSchemaPointPromptBase = z.object({
  y: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Y Coordinate of the prompt',
    }),
  ),
  x: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'X Coordinate of the prompt',
    }),
  ),
  object_id: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Optional object identifier. Prompts sharing an object id refine the same object.',
    }),
  ),
  label: z.optional(
    z.union([z.literal(0), z.literal(1)]).register(z.globalRegistry, {
      description: '1 for foreground, 0 for background',
    }),
  ),
})

/**
 * BoxPromptBase
 */
export const zSchemaBoxPromptBase = z.object({
  y_min: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Y Min Coordinate of the box',
    }),
  ),
  object_id: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'Optional object identifier. Boxes sharing an object id refine the same object.',
    }),
  ),
  x_max: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'X Max Coordinate of the box',
    }),
  ),
  x_min: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'X Min Coordinate of the box',
    }),
  ),
  y_max: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Y Max Coordinate of the box',
    }),
  ),
})

/**
 * SAM3DObjectOutput
 */
export const zSchemaSam33dObjectsOutput = z.object({
  model_glb: z.optional(zSchemaFile),
  metadata: z.array(zSchemaSam3dObjectMetadata).register(z.globalRegistry, {
    description: 'Per-object metadata (rotation/translation/scale)',
  }),
  gaussian_splat: zSchemaFile,
  artifacts_zip: z.optional(zSchemaFile),
  individual_glbs: z.optional(
    z.array(zSchemaFile).register(z.globalRegistry, {
      description:
        'Individual GLB mesh files per object (only for multi-object scenes)',
    }),
  ),
  individual_splats: z.optional(
    z.array(zSchemaFile).register(z.globalRegistry, {
      description:
        'Individual Gaussian splat files per object (only for multi-object scenes)',
    }),
  ),
})

/**
 * SAM3DObjectInput
 */
export const zSchemaSam33dObjectsInput = z.object({
  pointmap_url: z.optional(z.union([z.string(), z.string()])),
  export_textured_glb: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'If True, exports GLB with baked texture and UVs instead of vertex colors.',
      }),
    )
    .default(false),
  prompt: z
    .optional(
      z.string().register(z.globalRegistry, {
        description:
          "Text prompt for auto-segmentation when no masks provided (e.g., 'chair', 'lamp')",
      }),
    )
    .default('car'),
  box_prompts: z
    .optional(
      z.array(zSchemaBoxPromptBase).register(z.globalRegistry, {
        description:
          'Box prompts for auto-segmentation when no masks provided. Multiple boxes supported - each produces a separate object mask for 3D reconstruction.',
      }),
    )
    .default([]),
  image_url: z.union([z.string(), z.string()]),
  mask_urls: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description:
        'Optional list of mask URLs (one per object). If not provided, use prompt/point_prompts/box_prompts to auto-segment, or entire image will be used.',
    }),
  ),
  point_prompts: z
    .optional(
      z.array(zSchemaPointPromptBase).register(z.globalRegistry, {
        description:
          'Point prompts for auto-segmentation when no masks provided',
      }),
    )
    .default([]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducibility',
    }),
  ),
})

/**
 * SAM3DBodyPersonMetadata
 *
 * Per-person metadata for body reconstruction.
 */
export const zSchemaSam3dBodyPersonMetadata = z
  .object({
    pred_cam_t: z.array(z.number()).register(z.globalRegistry, {
      description: 'Predicted camera translation [tx, ty, tz]',
    }),
    person_id: z.int().register(z.globalRegistry, {
      description: 'Index of the person in the scene',
    }),
    focal_length: z.number().register(z.globalRegistry, {
      description: 'Estimated focal length',
    }),
    keypoints_3d: z.optional(
      z.array(z.array(z.number())).register(z.globalRegistry, {
        description:
          '3D keypoints [[x, y, z], ...] - 70 body keypoints in camera space',
      }),
    ),
    keypoints_2d: z.array(z.array(z.number())).register(z.globalRegistry, {
      description: '2D keypoints [[x, y], ...] - 70 body keypoints',
    }),
    bbox: z.array(z.number()).register(z.globalRegistry, {
      description: 'Bounding box [x_min, y_min, x_max, y_max]',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Per-person metadata for body reconstruction.',
  })

/**
 * SAM3DBodyMetadata
 *
 * Metadata for body reconstruction output.
 */
export const zSchemaSam3dBodyMetadata = z
  .object({
    people: z.array(zSchemaSam3dBodyPersonMetadata).register(z.globalRegistry, {
      description: 'Per-person metadata',
    }),
    num_people: z.int().register(z.globalRegistry, {
      description: 'Number of people detected',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Metadata for body reconstruction output.',
  })

/**
 * SAM3DBodyOutput
 */
export const zSchemaSam33dBodyOutput = z.object({
  visualization: zSchemaFile,
  metadata: zSchemaSam3dBodyMetadata,
  meshes: z.optional(
    z.array(zSchemaFile).register(z.globalRegistry, {
      description:
        'Individual mesh files (.ply), one per detected person (when export_meshes=True)',
    }),
  ),
  model_glb: zSchemaFile,
})

/**
 * SAM3DBodyInput
 */
export const zSchemaSam33dBodyInput = z.object({
  include_3d_keypoints: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Include 3D keypoint markers (spheres) in the GLB mesh for visualization',
      }),
    )
    .default(true),
  export_meshes: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Export individual mesh files (.ply) per person',
      }),
    )
    .default(true),
  mask_url: z.optional(z.union([z.string(), z.string()])),
  image_url: z.union([z.string(), z.string()]),
})

/**
 * ImageTo3DOutput
 */
export const zSchemaHunyuan3dV3ImageTo3dOutput = z.object({
  model_urls: zSchemaModelUrls,
  thumbnail: z.optional(zSchemaFile),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
  ),
  model_glb: zSchemaFile,
})

/**
 * ImageTo3DInput
 */
export const zSchemaHunyuan3dV3ImageTo3dInput = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  polygon_type: z.optional(
    z.enum(['triangle', 'quadrilateral']).register(z.globalRegistry, {
      description:
        'Polygon type. Only takes effect when GenerateType is LowPoly.',
    }),
  ),
  face_count: z
    .optional(
      z.int().gte(40000).lte(1500000).register(z.globalRegistry, {
        description: 'Target face count. Range: 40000-1500000',
      }),
    )
    .default(500000),
  right_image_url: z.optional(z.union([z.string(), z.string()])),
  back_image_url: z.optional(z.union([z.string(), z.string()])),
  enable_pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description:
          'Whether to enable PBR material generation. Does not take effect when generate_type is Geometry.',
      }),
    )
    .default(false),
  generate_type: z.optional(
    z.enum(['Normal', 'LowPoly', 'Geometry']).register(z.globalRegistry, {
      description:
        'Generation type. Normal: textured model. LowPoly: polygon reduction. Geometry: white model without texture.',
    }),
  ),
  left_image_url: z.optional(z.union([z.string(), z.string()])),
})

/**
 * SketchTo3DOutput
 */
export const zSchemaHunyuan3dV3SketchTo3dOutput = z.object({
  model_urls: zSchemaModelUrls,
  thumbnail: z.optional(zSchemaFile),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The seed used for generation',
    }),
  ),
  model_glb: zSchemaFile,
})

/**
 * SketchTo3DInput
 */
export const zSchemaHunyuan3dV3SketchTo3dInput = z.object({
  input_image_url: z.union([z.string(), z.string()]),
  prompt: z.string().max(1024).register(z.globalRegistry, {
    description:
      'Text prompt describing the 3D content attributes such as color, category, and material.',
  }),
  face_count: z
    .optional(
      z.int().gte(40000).lte(1500000).register(z.globalRegistry, {
        description: 'Target face count. Range: 40000-1500000',
      }),
    )
    .default(500000),
  enable_pbr: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to enable PBR material generation.',
      }),
    )
    .default(false),
})

/**
 * ObjectOutput
 */
export const zSchemaTrellis2Output = z.object({
  model_glb: zSchemaFile,
})

/**
 * SingleImageInputModel
 */
export const zSchemaTrellis2Input = z.object({
  remesh_band: z.optional(z.number().gte(0).lte(4)).default(1),
  ss_guidance_rescale: z.optional(z.number().gte(0).lte(1)).default(0.7),
  ss_rescale_t: z.optional(z.number().gte(1).lte(6)).default(5),
  shape_slat_sampling_steps: z.optional(z.int().gte(1).lte(50)).default(12),
  tex_slat_rescale_t: z.optional(z.number().gte(1).lte(6)).default(3),
  ss_guidance_strength: z.optional(z.number().gte(0).lte(10)).default(7.5),
  ss_sampling_steps: z.optional(z.int().gte(1).lte(50)).default(12),
  tex_slat_sampling_steps: z.optional(z.int().gte(1).lte(50)).default(12),
  remesh_project: z.optional(z.number().gte(0).lte(1)).default(0),
  texture_size: z.optional(
    z
      .union([z.literal(1024), z.literal(2048), z.literal(4096)])
      .register(z.globalRegistry, {
        description: 'Texture resolution',
      }),
  ),
  shape_slat_rescale_t: z.optional(z.number().gte(1).lte(6)).default(3),
  resolution: z.optional(
    z
      .union([z.literal(512), z.literal(1024), z.literal(1536)])
      .register(z.globalRegistry, {
        description: 'Output resolution; higher is slower but more detailed',
      }),
  ),
  remesh: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Run remeshing (slower; often improves topology)',
      }),
    )
    .default(true),
  tex_slat_guidance_rescale: z.optional(z.number().gte(0).lte(1)).default(0),
  shape_slat_guidance_rescale: z
    .optional(z.number().gte(0).lte(1))
    .default(0.5),
  image_url: z.union([z.string(), z.string()]),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Random seed for reproducibility',
    }),
  ),
  shape_slat_guidance_strength: z
    .optional(z.number().gte(0).lte(10))
    .default(7.5),
  tex_slat_guidance_strength: z.optional(z.number().gte(0).lte(10)).default(1),
  decimation_target: z
    .optional(
      z.int().gte(100000).lte(2000000).register(z.globalRegistry, {
        description:
          'Target vertex count for mesh simplification during export',
      }),
    )
    .default(500000),
})

/**
 * HunyuanPartOutput
 */
export const zSchemaHunyuanPartOutput = z.object({
  iou_scores: z.array(z.number()).register(z.globalRegistry, {
    description: 'IoU scores for each of the three masks.',
  }),
  best_mask_index: z.int().register(z.globalRegistry, {
    description: 'Index of the best mask (1, 2, or 3) based on IoU score.',
  }),
  mask_2_mesh: zSchemaFile,
  mask_1_mesh: zSchemaFile,
  segmented_mesh: zSchemaFile,
  seed: z.int().register(z.globalRegistry, {
    description: 'Seed value used for generation.',
  }),
  mask_3_mesh: zSchemaFile,
})

/**
 * HunyuanPartInput
 */
export const zSchemaHunyuanPartInput = z.object({
  point_prompt_x: z
    .optional(
      z.number().gte(-1).lte(1).register(z.globalRegistry, {
        description:
          'X coordinate of the point prompt for segmentation (normalized space -1 to 1).',
      }),
    )
    .default(0),
  point_prompt_z: z
    .optional(
      z.number().gte(-1).lte(1).register(z.globalRegistry, {
        description:
          'Z coordinate of the point prompt for segmentation (normalized space -1 to 1).',
      }),
    )
    .default(0),
  use_normal: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether to use normal information for segmentation.',
      }),
    )
    .default(true),
  noise_std: z
    .optional(
      z.number().gte(0).lte(0.02).register(z.globalRegistry, {
        description: 'Standard deviation of noise to add to sampled points.',
      }),
    )
    .default(0),
  point_num: z
    .optional(
      z.int().gte(10000).lte(500000).register(z.globalRegistry, {
        description: 'Number of points to sample from the mesh.',
      }),
    )
    .default(100000),
  model_file_url: z.union([z.string(), z.string()]),
  point_prompt_y: z
    .optional(
      z.number().gte(-1).lte(1).register(z.globalRegistry, {
        description:
          'Y coordinate of the point prompt for segmentation (normalized space -1 to 1).',
      }),
    )
    .default(0),
  seed: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        '\n            The same seed and input will produce the same segmentation results.\n        ',
    }),
  ),
})

/**
 * RemeshOutput
 *
 * Output for 3D Model Remeshing
 */
export const zSchemaMeshyV5RemeshOutput = z
  .object({
    model_urls: zSchemaModelUrls,
    model_glb: z.optional(zSchemaFile),
  })
  .register(z.globalRegistry, {
    description: 'Output for 3D Model Remeshing',
  })

/**
 * RemeshInput
 *
 * Input for 3D Model Remeshing
 */
export const zSchemaMeshyV5RemeshInput = z
  .object({
    resize_height: z
      .optional(
        z.number().gte(0).register(z.globalRegistry, {
          description:
            'Resize the model to a certain height measured in meters. Set to 0 for no resizing.',
        }),
      )
      .default(0),
    topology: z.optional(
      z.enum(['quad', 'triangle']).register(z.globalRegistry, {
        description:
          'Specify the topology of the generated model. Quad for smooth surfaces, Triangle for detailed geometry.',
      }),
    ),
    target_polycount: z
      .optional(
        z.int().gte(100).lte(300000).register(z.globalRegistry, {
          description:
            'Target number of polygons in the generated model. Actual count may vary based on geometry complexity.',
        }),
      )
      .default(30000),
    model_url: z.union([z.string(), z.string()]),
    origin_at: z.optional(
      z.enum(['bottom', 'center']).register(z.globalRegistry, {
        description: 'Position of the origin. None means no effect.',
      }),
    ),
    target_formats: z
      .optional(
        z
          .array(z.enum(['glb', 'fbx', 'obj', 'usdz', 'blend', 'stl']))
          .register(z.globalRegistry, {
            description: 'List of target formats for the remeshed model.',
          }),
      )
      .default(['glb']),
  })
  .register(z.globalRegistry, {
    description: 'Input for 3D Model Remeshing',
  })

/**
 * RetextureOutput
 *
 * Output for 3D Model Retexturing
 */
export const zSchemaMeshyV5RetextureOutput = z
  .object({
    model_urls: zSchemaModelUrls,
    text_style_prompt: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The text prompt used for texturing (if provided)',
      }),
    ),
    texture_urls: z.optional(
      z.array(zSchemaTextureFiles).register(z.globalRegistry, {
        description: 'Array of texture file objects',
      }),
    ),
    thumbnail: z.optional(zSchemaFile),
    image_style_url: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The image URL used for texturing (if provided)',
      }),
    ),
    model_glb: zSchemaFile,
  })
  .register(z.globalRegistry, {
    description: 'Output for 3D Model Retexturing',
  })

/**
 * RetextureInput
 *
 * Input for 3D Model Retexturing
 */
export const zSchemaMeshyV5RetextureInput = z
  .object({
    enable_pbr: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Generate PBR Maps (metallic, roughness, normal) in addition to base color.',
        }),
      )
      .default(false),
    text_style_prompt: z.optional(
      z.string().max(600).register(z.globalRegistry, {
        description:
          'Describe your desired texture style using text. Maximum 600 characters. Required if image_style_url is not provided.',
      }),
    ),
    enable_safety_checker: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'If set to true, input data will be checked for safety before processing.',
        }),
      )
      .default(true),
    enable_original_uv: z
      .optional(
        z.boolean().register(z.globalRegistry, {
          description:
            'Use the original UV mapping of the model instead of generating new UVs. If the model has no original UV, output quality may be reduced.',
        }),
      )
      .default(true),
    model_url: z.union([z.string(), z.string()]),
    image_style_url: z.optional(z.union([z.string(), z.string()])),
  })
  .register(z.globalRegistry, {
    description: 'Input for 3D Model Retexturing',
  })

/**
 * SAM3DBodyAlignmentInfo
 *
 * Per-person alignment metadata.
 */
export const zSchemaSam3dBodyAlignmentInfo = z
  .object({
    translation: z.array(z.number()).register(z.globalRegistry, {
      description: 'Translation [tx, ty, tz]',
    }),
    cropped_vertices_count: z.int().register(z.globalRegistry, {
      description: 'Number of cropped vertices',
    }),
    person_id: z.int().register(z.globalRegistry, {
      description: 'Index of the person',
    }),
    target_points_count: z.int().register(z.globalRegistry, {
      description: 'Number of target points for alignment',
    }),
    scale_factor: z.number().register(z.globalRegistry, {
      description: 'Scale factor applied for alignment',
    }),
    focal_length: z.number().register(z.globalRegistry, {
      description: 'Focal length used',
    }),
  })
  .register(z.globalRegistry, {
    description: 'Per-person alignment metadata.',
  })

/**
 * SAM3DAlignmentOutput
 */
export const zSchemaSam33dAlignOutput = z.object({
  scene_glb: z.optional(zSchemaFile),
  visualization: zSchemaFile,
  metadata: zSchemaSam3dBodyAlignmentInfo,
  body_mesh_ply: zSchemaFile,
  model_glb: zSchemaFile,
})

/**
 * SAM3DAlignmentInput
 */
export const zSchemaSam33dAlignInput = z.object({
  image_url: z.union([z.string(), z.string()]),
  body_mesh_url: z.union([z.string(), z.string()]),
  object_mesh_url: z.optional(z.union([z.string(), z.string()])),
  focal_length: z.optional(
    z.number().register(z.globalRegistry, {
      description:
        'Focal length from SAM-3D Body metadata. If not provided, estimated from MoGe.',
    }),
  ),
  body_mask_url: z.optional(z.union([z.string(), z.string()])),
})

/**
 * UltraShapeResponse
 */
export const zSchemaUltrashapeOutput = z.object({
  model_glb: zSchemaFile,
})

/**
 * UltraShapeRequest
 */
export const zSchemaUltrashapeInput = z.object({
  octree_resolution: z
    .optional(
      z.int().gte(128).lte(1024).register(z.globalRegistry, {
        description: 'Marching cubes resolution.',
      }),
    )
    .default(1024),
  remove_background: z
    .optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Remove image background.',
      }),
    )
    .default(true),
  num_inference_steps: z
    .optional(
      z.int().gte(1).lte(50).register(z.globalRegistry, {
        description: 'Diffusion steps.',
      }),
    )
    .default(50),
  model_url: z.union([z.string(), z.string()]),
  seed: z
    .optional(
      z.int().register(z.globalRegistry, {
        description: 'Random seed.',
      }),
    )
    .default(42),
  image_url: z.union([z.string(), z.string()]),
})

export const zSchemaQueueStatus = z.object({
  status: z.enum(['IN_QUEUE', 'IN_PROGRESS', 'COMPLETED']),
  request_id: z.string().register(z.globalRegistry, {
    description: 'The request id.',
  }),
  response_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The response url.',
    }),
  ),
  status_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The status url.',
    }),
  ),
  cancel_url: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The cancel url.',
    }),
  ),
  logs: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The logs.',
    }),
  ),
  metrics: z.optional(
    z.record(z.string(), z.unknown()).register(z.globalRegistry, {
      description: 'The metrics.',
    }),
  ),
  queue_position: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The queue position.',
    }),
  ),
})

export const zGetFalAiUltrashapeRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiUltrashapeRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiUltrashapeRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiUltrashapeRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiUltrashapeData = z.object({
  body: zSchemaUltrashapeInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiUltrashapeResponse = zSchemaQueueStatus

export const zGetFalAiUltrashapeRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiUltrashapeRequestsByRequestIdResponse =
  zSchemaUltrashapeOutput

export const zGetFalAiSam33dAlignRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiSam33dAlignRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSam33dAlignRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiSam33dAlignRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSam33dAlignData = z.object({
  body: zSchemaSam33dAlignInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSam33dAlignResponse = zSchemaQueueStatus

export const zGetFalAiSam33dAlignRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSam33dAlignRequestsByRequestIdResponse =
  zSchemaSam33dAlignOutput

export const zGetFalAiMeshyV5RetextureRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiMeshyV5RetextureRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiMeshyV5RetextureRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiMeshyV5RetextureRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiMeshyV5RetextureData = z.object({
  body: zSchemaMeshyV5RetextureInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiMeshyV5RetextureResponse = zSchemaQueueStatus

export const zGetFalAiMeshyV5RetextureRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiMeshyV5RetextureRequestsByRequestIdResponse =
  zSchemaMeshyV5RetextureOutput

export const zGetFalAiMeshyV5RemeshRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiMeshyV5RemeshRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiMeshyV5RemeshRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiMeshyV5RemeshRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiMeshyV5RemeshData = z.object({
  body: zSchemaMeshyV5RemeshInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiMeshyV5RemeshResponse = zSchemaQueueStatus

export const zGetFalAiMeshyV5RemeshRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiMeshyV5RemeshRequestsByRequestIdResponse =
  zSchemaMeshyV5RemeshOutput

export const zGetFalAiHunyuanPartRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiHunyuanPartRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuanPartRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuanPartRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHunyuanPartData = z.object({
  body: zSchemaHunyuanPartInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuanPartResponse = zSchemaQueueStatus

export const zGetFalAiHunyuanPartRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHunyuanPartRequestsByRequestIdResponse =
  zSchemaHunyuanPartOutput

export const zGetFalAiTrellis2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiTrellis2RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiTrellis2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiTrellis2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiTrellis2Data = z.object({
  body: zSchemaTrellis2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiTrellis2Response = zSchemaQueueStatus

export const zGetFalAiTrellis2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiTrellis2RequestsByRequestIdResponse =
  zSchemaTrellis2Output

export const zGetFalAiHunyuan3dV3SketchTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV3SketchTo3dRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuan3dV3SketchTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV3SketchTo3dRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHunyuan3dV3SketchTo3dData = z.object({
  body: zSchemaHunyuan3dV3SketchTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV3SketchTo3dResponse = zSchemaQueueStatus

export const zGetFalAiHunyuan3dV3SketchTo3dRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV3SketchTo3dRequestsByRequestIdResponse =
  zSchemaHunyuan3dV3SketchTo3dOutput

export const zGetFalAiHunyuan3dV3ImageTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV3ImageTo3dRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuan3dV3ImageTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV3ImageTo3dRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHunyuan3dV3ImageTo3dData = z.object({
  body: zSchemaHunyuan3dV3ImageTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV3ImageTo3dResponse = zSchemaQueueStatus

export const zGetFalAiHunyuan3dV3ImageTo3dRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV3ImageTo3dRequestsByRequestIdResponse =
  zSchemaHunyuan3dV3ImageTo3dOutput

export const zGetFalAiSam33dBodyRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiSam33dBodyRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSam33dBodyRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiSam33dBodyRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSam33dBodyData = z.object({
  body: zSchemaSam33dBodyInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSam33dBodyResponse = zSchemaQueueStatus

export const zGetFalAiSam33dBodyRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSam33dBodyRequestsByRequestIdResponse =
  zSchemaSam33dBodyOutput

export const zGetFalAiSam33dObjectsRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiSam33dObjectsRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiSam33dObjectsRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiSam33dObjectsRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiSam33dObjectsData = z.object({
  body: zSchemaSam33dObjectsInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiSam33dObjectsResponse = zSchemaQueueStatus

export const zGetFalAiSam33dObjectsRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiSam33dObjectsRequestsByRequestIdResponse =
  zSchemaSam33dObjectsOutput

export const zGetFalAiOmnipartRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiOmnipartRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiOmnipartRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiOmnipartRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiOmnipartData = z.object({
  body: zSchemaOmnipartInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiOmnipartResponse = zSchemaQueueStatus

export const zGetFalAiOmnipartRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiOmnipartRequestsByRequestIdResponse =
  zSchemaOmnipartOutput

export const zGetFalAiBytedanceSeed3dImageTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiBytedanceSeed3dImageTo3dRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiBytedanceSeed3dImageTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiBytedanceSeed3dImageTo3dRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiBytedanceSeed3dImageTo3dData = z.object({
  body: zSchemaBytedanceSeed3dImageTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiBytedanceSeed3dImageTo3dResponse = zSchemaQueueStatus

export const zGetFalAiBytedanceSeed3dImageTo3dRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiBytedanceSeed3dImageTo3dRequestsByRequestIdResponse =
  zSchemaBytedanceSeed3dImageTo3dOutput

export const zGetFalAiMeshyV5MultiImageTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiMeshyV5MultiImageTo3dRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiMeshyV5MultiImageTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiMeshyV5MultiImageTo3dRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiMeshyV5MultiImageTo3dData = z.object({
  body: zSchemaMeshyV5MultiImageTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiMeshyV5MultiImageTo3dResponse = zSchemaQueueStatus

export const zGetFalAiMeshyV5MultiImageTo3dRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiMeshyV5MultiImageTo3dRequestsByRequestIdResponse =
  zSchemaMeshyV5MultiImageTo3dOutput

export const zGetFalAiMeshyV6PreviewImageTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiMeshyV6PreviewImageTo3dRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiMeshyV6PreviewImageTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiMeshyV6PreviewImageTo3dRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiMeshyV6PreviewImageTo3dData = z.object({
  body: zSchemaMeshyV6PreviewImageTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiMeshyV6PreviewImageTo3dResponse = zSchemaQueueStatus

export const zGetFalAiMeshyV6PreviewImageTo3dRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * Result of the request.
 */
export const zGetFalAiMeshyV6PreviewImageTo3dRequestsByRequestIdResponse =
  zSchemaMeshyV6PreviewImageTo3dOutput

export const zGetFalAiHyper3dRodinV2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiHyper3dRodinV2RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHyper3dRodinV2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiHyper3dRodinV2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHyper3dRodinV2Data = z.object({
  body: zSchemaHyper3dRodinV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHyper3dRodinV2Response = zSchemaQueueStatus

export const zGetFalAiHyper3dRodinV2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHyper3dRodinV2RequestsByRequestIdResponse =
  zSchemaHyper3dRodinV2Output

export const zGetFalAiPshumanRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiPshumanRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiPshumanRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiPshumanRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiPshumanData = z.object({
  body: zSchemaPshumanInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiPshumanResponse = zSchemaQueueStatus

export const zGetFalAiPshumanRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiPshumanRequestsByRequestIdResponse = zSchemaPshumanOutput

export const zGetFalAiHunyuanWorldImageToWorldRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiHunyuanWorldImageToWorldRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuanWorldImageToWorldRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuanWorldImageToWorldRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiHunyuanWorldImageToWorldData = z.object({
  body: zSchemaHunyuanWorldImageToWorldInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuanWorldImageToWorldResponse = zSchemaQueueStatus

export const zGetFalAiHunyuanWorldImageToWorldRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiHunyuanWorldImageToWorldRequestsByRequestIdResponse =
  zSchemaHunyuanWorldImageToWorldOutput

export const zGetTripo3dTripoV25MultiviewTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetTripo3dTripoV25MultiviewTo3dRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutTripo3dTripoV25MultiviewTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutTripo3dTripoV25MultiviewTo3dRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostTripo3dTripoV25MultiviewTo3dData = z.object({
  body: zSchemaTripoV25MultiviewTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostTripo3dTripoV25MultiviewTo3dResponse = zSchemaQueueStatus

export const zGetTripo3dTripoV25MultiviewTo3dRequestsByRequestIdData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * Result of the request.
 */
export const zGetTripo3dTripoV25MultiviewTo3dRequestsByRequestIdResponse =
  zSchemaTripoV25MultiviewTo3dOutput

export const zGetFalAiHunyuan3dV21RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV21RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuan3dV21RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV21RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHunyuan3dV21Data = z.object({
  body: zSchemaHunyuan3dV21Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV21Response = zSchemaQueueStatus

export const zGetFalAiHunyuan3dV21RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV21RequestsByRequestIdResponse =
  zSchemaHunyuan3dV21Output

export const zGetFalAiTrellisMultiRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiTrellisMultiRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiTrellisMultiRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiTrellisMultiRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiTrellisMultiData = z.object({
  body: zSchemaTrellisMultiInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiTrellisMultiResponse = zSchemaQueueStatus

export const zGetFalAiTrellisMultiRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiTrellisMultiRequestsByRequestIdResponse =
  zSchemaTrellisMultiOutput

export const zGetTripo3dTripoV25ImageTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetTripo3dTripoV25ImageTo3dRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutTripo3dTripoV25ImageTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutTripo3dTripoV25ImageTo3dRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostTripo3dTripoV25ImageTo3dData = z.object({
  body: zSchemaTripoV25ImageTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostTripo3dTripoV25ImageTo3dResponse = zSchemaQueueStatus

export const zGetTripo3dTripoV25ImageTo3dRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetTripo3dTripoV25ImageTo3dRequestsByRequestIdResponse =
  zSchemaTripoV25ImageTo3dOutput

export const zGetFalAiHunyuan3dV2MultiViewTurboRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV2MultiViewTurboRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuan3dV2MultiViewTurboRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV2MultiViewTurboRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiHunyuan3dV2MultiViewTurboData = z.object({
  body: zSchemaHunyuan3dV2MultiViewTurboInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV2MultiViewTurboResponse = zSchemaQueueStatus

export const zGetFalAiHunyuan3dV2MultiViewTurboRequestsByRequestIdData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV2MultiViewTurboRequestsByRequestIdResponse =
  zSchemaHunyuan3dV2MultiViewTurboOutput

export const zGetFalAiHunyuan3dV2RequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV2RequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuan3dV2RequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV2RequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHunyuan3dV2Data = z.object({
  body: zSchemaHunyuan3dV2Input,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV2Response = zSchemaQueueStatus

export const zGetFalAiHunyuan3dV2RequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV2RequestsByRequestIdResponse =
  zSchemaHunyuan3dV2Output

export const zGetFalAiHunyuan3dV2MiniRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV2MiniRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuan3dV2MiniRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV2MiniRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHunyuan3dV2MiniData = z.object({
  body: zSchemaHunyuan3dV2MiniInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV2MiniResponse = zSchemaQueueStatus

export const zGetFalAiHunyuan3dV2MiniRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV2MiniRequestsByRequestIdResponse =
  zSchemaHunyuan3dV2MiniOutput

export const zGetFalAiHunyuan3dV2MultiViewRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV2MultiViewRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuan3dV2MultiViewRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV2MultiViewRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHunyuan3dV2MultiViewData = z.object({
  body: zSchemaHunyuan3dV2MultiViewInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV2MultiViewResponse = zSchemaQueueStatus

export const zGetFalAiHunyuan3dV2MultiViewRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV2MultiViewRequestsByRequestIdResponse =
  zSchemaHunyuan3dV2MultiViewOutput

export const zGetFalAiHunyuan3dV2TurboRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV2TurboRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuan3dV2TurboRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV2TurboRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHunyuan3dV2TurboData = z.object({
  body: zSchemaHunyuan3dV2TurboInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV2TurboResponse = zSchemaQueueStatus

export const zGetFalAiHunyuan3dV2TurboRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV2TurboRequestsByRequestIdResponse =
  zSchemaHunyuan3dV2TurboOutput

export const zGetFalAiHunyuan3dV2MiniTurboRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV2MiniTurboRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuan3dV2MiniTurboRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV2MiniTurboRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHunyuan3dV2MiniTurboData = z.object({
  body: zSchemaHunyuan3dV2MiniTurboInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV2MiniTurboResponse = zSchemaQueueStatus

export const zGetFalAiHunyuan3dV2MiniTurboRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV2MiniTurboRequestsByRequestIdResponse =
  zSchemaHunyuan3dV2MiniTurboOutput

export const zGetFalAiHyper3dRodinRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiHyper3dRodinRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHyper3dRodinRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiHyper3dRodinRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHyper3dRodinData = z.object({
  body: zSchemaHyper3dRodinInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHyper3dRodinResponse = zSchemaQueueStatus

export const zGetFalAiHyper3dRodinRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHyper3dRodinRequestsByRequestIdResponse =
  zSchemaHyper3dRodinOutput

export const zGetFalAiTrellisRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiTrellisRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiTrellisRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiTrellisRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiTrellisData = z.object({
  body: zSchemaTrellisInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiTrellisResponse = zSchemaQueueStatus

export const zGetFalAiTrellisRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiTrellisRequestsByRequestIdResponse = zSchemaTrellisOutput

export const zGetFalAiTriposrRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiTriposrRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiTriposrRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiTriposrRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiTriposrData = z.object({
  body: zSchemaTriposrInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiTriposrResponse = zSchemaQueueStatus

export const zGetFalAiTriposrRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiTriposrRequestsByRequestIdResponse = zSchemaTriposrOutput

export const zGetFalAiHunyuanMotionFastRequestsByRequestIdStatusData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  },
)

/**
 * The request status.
 */
export const zGetFalAiHunyuanMotionFastRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuanMotionFastRequestsByRequestIdCancelData = z.object(
  {
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  },
)

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuanMotionFastRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHunyuanMotionFastData = z.object({
  body: zSchemaHunyuanMotionFastInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuanMotionFastResponse = zSchemaQueueStatus

export const zGetFalAiHunyuanMotionFastRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHunyuanMotionFastRequestsByRequestIdResponse =
  zSchemaHunyuanMotionFastOutput

export const zGetFalAiHunyuanMotionRequestsByRequestIdStatusData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(
    z.object({
      logs: z.optional(
        z.number().register(z.globalRegistry, {
          description:
            'Whether to include logs (`1`) in the response or not (`0`).',
        }),
      ),
    }),
  ),
})

/**
 * The request status.
 */
export const zGetFalAiHunyuanMotionRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuanMotionRequestsByRequestIdCancelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuanMotionRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHunyuanMotionData = z.object({
  body: zSchemaHunyuanMotionInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuanMotionResponse = zSchemaQueueStatus

export const zGetFalAiHunyuanMotionRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHunyuanMotionRequestsByRequestIdResponse =
  zSchemaHunyuanMotionOutput

export const zGetFalAiHunyuan3dV3TextTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiHunyuan3dV3TextTo3dRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiHunyuan3dV3TextTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiHunyuan3dV3TextTo3dRequestsByRequestIdCancelResponse = z
  .object({
    success: z.optional(
      z.boolean().register(z.globalRegistry, {
        description: 'Whether the request was cancelled successfully.',
      }),
    ),
  })
  .register(z.globalRegistry, {
    description: 'The request was cancelled.',
  })

export const zPostFalAiHunyuan3dV3TextTo3dData = z.object({
  body: zSchemaHunyuan3dV3TextTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiHunyuan3dV3TextTo3dResponse = zSchemaQueueStatus

export const zGetFalAiHunyuan3dV3TextTo3dRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiHunyuan3dV3TextTo3dRequestsByRequestIdResponse =
  zSchemaHunyuan3dV3TextTo3dOutput

export const zGetFalAiMeshyV6PreviewTextTo3dRequestsByRequestIdStatusData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(
      z.object({
        logs: z.optional(
          z.number().register(z.globalRegistry, {
            description:
              'Whether to include logs (`1`) in the response or not (`0`).',
          }),
        ),
      }),
    ),
  })

/**
 * The request status.
 */
export const zGetFalAiMeshyV6PreviewTextTo3dRequestsByRequestIdStatusResponse =
  zSchemaQueueStatus

export const zPutFalAiMeshyV6PreviewTextTo3dRequestsByRequestIdCancelData =
  z.object({
    body: z.optional(z.never()),
    path: z.object({
      request_id: z.string().register(z.globalRegistry, {
        description: 'Request ID',
      }),
    }),
    query: z.optional(z.never()),
  })

/**
 * The request was cancelled.
 */
export const zPutFalAiMeshyV6PreviewTextTo3dRequestsByRequestIdCancelResponse =
  z
    .object({
      success: z.optional(
        z.boolean().register(z.globalRegistry, {
          description: 'Whether the request was cancelled successfully.',
        }),
      ),
    })
    .register(z.globalRegistry, {
      description: 'The request was cancelled.',
    })

export const zPostFalAiMeshyV6PreviewTextTo3dData = z.object({
  body: zSchemaMeshyV6PreviewTextTo3dInput,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
})

/**
 * The request status.
 */
export const zPostFalAiMeshyV6PreviewTextTo3dResponse = zSchemaQueueStatus

export const zGetFalAiMeshyV6PreviewTextTo3dRequestsByRequestIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    request_id: z.string().register(z.globalRegistry, {
      description: 'Request ID',
    }),
  }),
  query: z.optional(z.never()),
})

/**
 * Result of the request.
 */
export const zGetFalAiMeshyV6PreviewTextTo3dRequestsByRequestIdResponse =
  zSchemaMeshyV6PreviewTextTo3dOutput
